<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="晕">
<meta property="og:type" content="article">
<meta property="og:title" content="file虚表函数学习">
<meta property="og:url" content="https://ixout.github.io/posts/1518/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="晕">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-10-19T11:26:18.000Z">
<meta property="article:modified_time" content="2023-11-28T07:20:29.461Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="_IO_FILE">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
        
      
    
    <!-- title -->
    <title>file虚表函数学习</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/posts/57317/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/33400/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/1518/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/1518/&text=file虚表函数学习"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/1518/&is_video=false&description=file虚表函数学习"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=file虚表函数学习&body=Check out this article: https://ixout.github.io/posts/1518/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/1518/&name=file虚表函数学习&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/1518/&t=file虚表函数学习"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">引*</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">相关系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lseek"><span class="toc-number">2.1.</span> <span class="toc-text">lseek</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync"><span class="toc-number">2.2.</span> <span class="toc-text">sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stat"><span class="toc-number">2.3.</span> <span class="toc-text">stat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E8%99%9A%E8%A1%A8%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">IO虚表函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#finish"><span class="toc-number">3.1.</span> <span class="toc-text">finish</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IO-new-file-finish"><span class="toc-number">3.1.1.</span> <span class="toc-text">1 _IO_new_file_finish</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-IO-do-flush"><span class="toc-number">3.1.2.</span> <span class="toc-text">2-1 _IO_do_flush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-IO-default-finish"><span class="toc-number">3.1.3.</span> <span class="toc-text">2-2 _IO_default_finish</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IO-un-link"><span class="toc-number">3.1.4.</span> <span class="toc-text">3 _IO_un_link</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overflow"><span class="toc-number">3.2.</span> <span class="toc-text">overflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write"><span class="toc-number">3.3.</span> <span class="toc-text">write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read"><span class="toc-number">3.4.</span> <span class="toc-text">read</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seek"><span class="toc-number">3.5.</span> <span class="toc-text">seek</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stat-1"><span class="toc-number">3.6.</span> <span class="toc-text">stat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#underflow"><span class="toc-number">3.7.</span> <span class="toc-text">underflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uflow"><span class="toc-number">3.8.</span> <span class="toc-text">uflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-1"><span class="toc-number">3.9.</span> <span class="toc-text">sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#imbue"><span class="toc-number">3.10.</span> <span class="toc-text">imbue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#showmanyc"><span class="toc-number">3.11.</span> <span class="toc-text">showmanyc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close"><span class="toc-number">3.12.</span> <span class="toc-text">close</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#doallocate"><span class="toc-number">3.13.</span> <span class="toc-text">doallocate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seekpos"><span class="toc-number">3.14.</span> <span class="toc-text">seekpos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seekoff"><span class="toc-number">3.15.</span> <span class="toc-text">seekoff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pbackfail"><span class="toc-number">3.16.</span> <span class="toc-text">pbackfail</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setbuf"><span class="toc-number">3.17.</span> <span class="toc-text">setbuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xsgetn"><span class="toc-number">3.18.</span> <span class="toc-text">xsgetn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xspuntn"><span class="toc-number">3.19.</span> <span class="toc-text">xspuntn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%BE%E9%81%97"><span class="toc-number">4.</span> <span class="toc-text">拾遗</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        file虚表函数学习
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ixout</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-19T11:26:18.000Z" class="dt-published" itemprop="datePublished">2023-10-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/pwn/">pwn</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/IO-FILE/" rel="tag">_IO_FILE</a>, <a class="p-category" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="引"><a href="#引" class="headerlink" title="引*"></a>引*</h1><p>glibc中有各种vtable,fileops,strops,wfileops等等</p>
<p>更多的的可以在glibc/libio/vtables.c查看,不同vtable中对应的函数实现也不同,不过都是为io服务,都与_IO_FILE有关</p>
<p>本文主要研究file虚表函数,其主要集中在fileops.c中</p>
<p>fileops.c文件开头这一段注释提供了不少信息</p>
<p>认真阅读能提供不少帮助</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An fstream can be in at most one of put mode, get mode, or putback mode.</span></span><br><span class="line"><span class="comment">   Putback mode is a variant of get mode.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In a filebuf, there is only one current position, instead of two</span></span><br><span class="line"><span class="comment">   separate get and put pointers.  In get mode, the current position</span></span><br><span class="line"><span class="comment">   is that of gptr(); in put mode that of pptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The position in the buffer that corresponds to the position</span></span><br><span class="line"><span class="comment">   in external file system is normally _IO_read_end, except in putback</span></span><br><span class="line"><span class="comment">   mode, when it is _IO_save_end and also when the file is in append mode,</span></span><br><span class="line"><span class="comment">   since switching from read to write mode automatically sends the position in</span></span><br><span class="line"><span class="comment">   the external file system to the end of file.</span></span><br><span class="line"><span class="comment">   If the field _fb._offset is &gt;= 0, it gives the offset in</span></span><br><span class="line"><span class="comment">   the file as a whole corresponding to eGptr(). (?)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PUT MODE:</span></span><br><span class="line"><span class="comment">   If a filebuf is in put mode, then all of _IO_read_ptr, _IO_read_end,</span></span><br><span class="line"><span class="comment">   and _IO_read_base are equal to each other.  These are usually equal</span></span><br><span class="line"><span class="comment">   to _IO_buf_base, though not necessarily if we have switched from</span></span><br><span class="line"><span class="comment">   get mode to put mode.  (The reason is to maintain the invariant</span></span><br><span class="line"><span class="comment">   that _IO_read_end corresponds to the external file position.)</span></span><br><span class="line"><span class="comment">   _IO_write_base is non-NULL and usually equal to _IO_buf_base.</span></span><br><span class="line"><span class="comment">   We also have _IO_write_end == _IO_buf_end, but only in fully buffered mode.</span></span><br><span class="line"><span class="comment">   The un-flushed character are those between _IO_write_base and _IO_write_ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   GET MODE:</span></span><br><span class="line"><span class="comment">   If a filebuf is in get or putback mode, eback() != egptr().</span></span><br><span class="line"><span class="comment">   In get mode, the unread characters are between gptr() and egptr().</span></span><br><span class="line"><span class="comment">   The OS file position corresponds to that of egptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PUTBACK MODE:</span></span><br><span class="line"><span class="comment">   Putback mode is used to remember &quot;excess&quot; characters that have</span></span><br><span class="line"><span class="comment">   been sputbackc&#x27;d in a separate putback buffer.</span></span><br><span class="line"><span class="comment">   In putback mode, the get buffer points to the special putback buffer.</span></span><br><span class="line"><span class="comment">   The unread characters are the characters between gptr() and egptr()</span></span><br><span class="line"><span class="comment">   in the putback buffer, as well as the area between save_gptr()</span></span><br><span class="line"><span class="comment">   and save_egptr(), which point into the original reserve buffer.</span></span><br><span class="line"><span class="comment">   (The pointers save_gptr() and save_egptr() are the values</span></span><br><span class="line"><span class="comment">   of gptr() and egptr() at the time putback mode was entered.)</span></span><br><span class="line"><span class="comment">   The OS position corresponds to that of save_egptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   LINE BUFFERED OUTPUT:</span></span><br><span class="line"><span class="comment">   During line buffered output, _IO_write_base==base() &amp;&amp; epptr()==base().</span></span><br><span class="line"><span class="comment">   However, ptr() may be anywhere between base() and ebuf().</span></span><br><span class="line"><span class="comment">   This forces a call to filebuf::overflow(int C) on every put.</span></span><br><span class="line"><span class="comment">   If there is more space in the buffer, and C is not a &#x27;\n&#x27;,</span></span><br><span class="line"><span class="comment">   then C is inserted, and pptr() incremented.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   UNBUFFERED STREAMS:</span></span><br><span class="line"><span class="comment">   If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>大致如下</p>
<ol>
<li><strong>文件流的模式</strong>：文件流可以处于put模式、get模式或putback模式中。Putback模式是get模式的一种变体。</li>
<li><strong>文件缓冲区中的当前位置</strong>：在文件缓冲区中，<strong>只有一个当前位置</strong>，而不是分别有get指针和put指针。在get模式中，当前位置是gptr()的位置；在put模式中，当前位置是pptr()的位置。</li>
<li><strong>缓冲区位置与外部文件系统位置的对应</strong>：通常情况下，缓冲区中与外部文件系统位置对应的位置是_IO_read_end，但在putback模式下，它是_IO_save_end，并且在文件处于附加模式时也是_IO_save_end。这是因为从读模式切换到写模式会自动将外部文件系统位置切换到文件的末尾。如果字段_fb._offset &gt;= 0，则它表示与eGptr()对应的文件整体偏移。</li>
<li><strong>PUT模式</strong>：在put模式下，_IO_read_ptr、_IO_read_end和_IO_read_base都相等。它们通常等于_IO_buf_base，但如果从get模式切换到put模式，它们不一定相等。_IO_write_base不为空，通常等于_IO_buf_base。_IO_write_end等于_IO_buf_end，但<strong>只在完全缓冲模式下成立</strong>。<u>未刷新的字符位于_IO_write_base和_IO_write_ptr之间。</u></li>
<li><strong>GET模式</strong>：在get或putback模式下，eback() != egptr()。在get模式中，<u>未读字符位于gptr()和egptr()之间</u>。操作系统文件位置对应于egptr()的位置。</li>
<li><strong>PUTBACK模式</strong>：putback模式用于记住已经通过sputbackc放回的“多余”字符，它们存储在特殊的putback缓冲区中。在putback模式中，get缓冲区指向特殊的putback缓冲区。未读字符包括putback缓冲区中gptr()和egptr()之间的字符，以及指向原始预留缓冲区的save_gptr()和save_egptr()之间的区域。操作系统位置对应于save_egptr()的位置。</li>
<li><strong>行缓冲输出</strong>：在行缓冲输出期间，_IO_write_base等于base()，<strong>并且epptr()也等于base()</strong>。但是，ptr()可能位于base()和ebuf()之间。这会导致在<strong>每次放入字符时调用</strong>filebuf::overflow(int C)。如果缓冲区中还有更多空间(pptr&lt;ebuf)，并且C不是’\n’，则会插入C，并增加pptr(),否则刷新写入。</li>
<li><strong>无缓冲流</strong>：如果文件缓冲区是unbuffered()，则_shortbuf[1]用作缓冲区。</li>
</ol>
<h1 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h1><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p><code>seek</code> 是一个用于文件操作的系统调用，它的主要功能是用于改变文件指针的位置，从而实现对文件的随机访问。具体来说，<code>seek</code> 的功能包括：</p>
<ol>
<li>定位文件指针：<code>seek</code> 允许你将文件指针（读/写位置）移动到文件中的任意位置。这是对文件进行随机访问的关键操作。你可以指定要移动到的位置，通常是相对于文件开头的偏移量。</li>
<li>读取和写入特定位置：通过改变文件指针的位置，你可以在文件中的任何位置进行读取和写入操作，而不必按照顺序逐个字节进行操作。这对于访问大型文件或数据库非常有用。</li>
<li>支持文件的随机访问：<code>seek</code> 是实现随机访问的关键，允许你在不必按照文件顺序读取数据的情况下，快速访问和处理文件的各个部分。</li>
<li>实现文件的截断和扩展：在某些情况下，<code>seek</code> 可以用于截断文件（减小文件大小）或扩展文件（增大文件大小）。通过移动文件指针并写入数据，你可以实现这些操作。</li>
</ol>
<p>其返回值表示成功执行操作后的文件偏移量，如果出现错误，返回值会是 <code>-1</code>。</p>
<p>具体来说，<code>lseek</code> 的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fd</code> 是文件描述符，用于指定要进行定位操作的文件。</li>
<li><code>offset</code> 是一个偏移量，用于指定要移动的相对位置。可以为正数、负数或零，具体取决于 <code>whence</code> 参数的值。</li>
<li><code>whence</code> 用于确定偏移量的基准位置，通常可以取以下值之一：<ul>
<li><code>SEEK_SET</code>：以文件开头为基准，<code>offset</code> 指定的位置。</li>
<li><code>SEEK_CUR</code>：以当前文件位置为基准，增加 <code>offset</code> 指定的位置。</li>
<li><code>SEEK_END</code>：以文件末尾为基准，增加 <code>offset</code> 指定的位置。</li>
</ul>
</li>
</ul>
<p><code>lseek</code> 函数会根据 <code>offset</code> 和 <code>whence</code> 的指定值来移动文件描述符 <code>fd</code> 的偏移位置，并返回新的文件偏移位置。如果操作成功，返回值是新的偏移位置。如果出现错误，返回值是 <code>-1</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_set 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_cur 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_end 2</span></span><br></pre></td></tr></table></figure>
<h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><p><code>sync</code> 是一个系统调用，它的主要功能是将操作系统内核中尚未写入磁盘的缓冲区数据强制刷新到磁盘上的存储设备，<strong>以确保数据持久性和文件系统的一致性</strong>。<code>sync</code> 的主要功能包括：</p>
<ol>
<li>数据持久性：通过执行 <code>sync</code>，操作系统会将所有尚未写入磁盘的数据写入到物理存储设备中。这可以确保即使系统崩溃或断电，尚未写入磁盘的数据也不会丢失。</li>
<li>文件系统一致性：<code>sync</code> 也有助于维护文件系统的一致性。在写入文件和目录信息时，文件系统通常会维护内部数据结构，这些数据结构需要及时写入磁盘以确保文件系统的一致性。<code>sync</code> 确保这些数据结构及其相关的数据被写入磁盘。</li>
<li>缓冲区刷新：<code>sync</code> 还用于刷新内核中的缓冲区，以确保缓冲区中的数据被写入磁盘。这对于正在进行的文件操作和文件系统操作非常重要，因为数据通常首先存储在内存中以提高性能，然后定期刷新到磁盘上。</li>
<li>数据完整性：<code>sync</code> 还有助于维护数据的完整性。它确保了所有写入的数据都已经被持久地存储在磁盘上，以免数据损坏或丢失。</li>
</ol>
<h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>系统调用 <code>stat</code> 用于获取关于文件或目录的信息，如文件的大小、访问权限、所属用户和组、文件类型等。它<strong>返回一个包含文件信息的结构体</strong>，通常被称为 <code>struct stat</code>。</p>
<p><code>stat</code> 系统调用的功能包括：</p>
<ol>
<li><p>获取文件的基本属性：<code>stat</code> 可以用来获取文件的基本属性，如文件大小、创建时间、修改时间、访问时间等。</p>
</li>
<li><p>获取文件的权限信息：<code>stat</code> 可以提供文件的权限信息，包括文件的拥有者、所属组以及其他用户的权限。</p>
</li>
<li><p>确定文件的类型：<code>stat</code> 可以告诉您文件是普通文件、目录、符号链接还是其他类型的文件。</p>
</li>
<li><p>获取文件的相关信息：<code>stat</code> 可以提供有关文件系统的信息，如文件系统的块大小、设备号等。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">stat64</span> &#123;</span></span><br><span class="line">  <span class="type">_dev_t</span> st_dev;<span class="comment">//文件所在的设备的标识符</span></span><br><span class="line">  <span class="type">_ino_t</span> st_ino;<span class="comment">//文件的 inode 号</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> st_mode;<span class="comment">//文件的权限和类型信息</span></span><br><span class="line">  <span class="type">short</span> st_nlink;<span class="comment">//文件的硬链接数目</span></span><br><span class="line">  <span class="type">short</span> st_uid;<span class="comment">//文件的用户标识符 (UID)</span></span><br><span class="line">  <span class="type">short</span> st_gid;<span class="comment">//文件的组标识符 (GID)</span></span><br><span class="line">  <span class="type">_dev_t</span> st_rdev;<span class="comment">//特殊文件的设备标识符</span></span><br><span class="line">  __MINGW_EXTENSION __int64 st_size;<span class="comment">//文件的大小，以字节为单位</span></span><br><span class="line">  <span class="type">__time64_t</span> st_atime;<span class="comment">//最后访问时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_mtime;<span class="comment">//最后修改时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_ctime;<span class="comment">//状态改变时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他还有用到read,write,open,close都较为熟悉就不记录了</p>
<h1 id="IO虚表函数"><a href="#IO虚表函数" class="headerlink" title="IO虚表函数"></a>IO虚表函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_file_jumps)</span><br></pre></td></tr></table></figure>
<h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>finish的主要功能是关闭缓冲区,解除文件流在_IO_list_all中的链接</p>
<h3 id="1-IO-new-file-finish"><a href="#1-IO-new-file-finish" class="headerlink" title="1 _IO_new_file_finish"></a>1 _IO_new_file_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">	_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)</span><br></pre></td></tr></table></figure>
<ol>
<li>先是检查文件是否打开,是则调用_IO_do_flush (fp)并根据 _IO_DELETE_DONT_CLOSE标志位决定是否调用close关闭文件流</li>
<li>_IO_default_finish (fp, 0);</li>
</ol>
<h3 id="2-1-IO-do-flush"><a href="#2-1-IO-do-flush" class="headerlink" title="2-1 _IO_do_flush"></a>2-1 _IO_do_flush</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0							      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">		  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)		      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,		      \</span></span><br><span class="line"><span class="meta">		   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr			      \</span></span><br><span class="line"><span class="meta">		    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure>
<p>根据是是否是宽字节有两个分支</p>
<p>目前先看非宽字节分支,调用的是另一个虚表函数write,这里先不写</p>
<h3 id="2-2-IO-default-finish"><a href="#2-2-IO-default-finish" class="headerlink" title="2-2 _IO_default_finish"></a>2-2 _IO_default_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_finish)</span><br></pre></td></tr></table></figure>
<ol>
<li>若buf不为空且_IO_USER_BUF标志为0,释放free缓冲区,并置空buf指针</li>
<li>将文件流的所有marker的_sbuf字段清空</li>
<li>若文件流的_IO_save_base不为空,则将其free释放并置空</li>
<li>调用unlink将文件流解除_IO_list_all链</li>
</ol>
<h3 id="3-IO-un-link"><a href="#3-IO-un-link" class="headerlink" title="3 _IO_un_link"></a>3 _IO_un_link</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">	;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">	_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	<span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">	  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">	    &#123;</span><br><span class="line">	      *f = fp-&gt;file._chain;</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>先确认文件流在_IO_list_all链中</li>
<li>寻找_IO_list_all链中的fp将其解链并清除_IO_LINKED标志位</li>
</ol>
<h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p><code>overflow</code> 主要负责将数据写入底层文件(或设备)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure>
<ol>
<li>判断文件流是否设置_IO_NO_WRITES,是则标记错误并返回</li>
<li><ul>
<li>如果文件不处于写入模式(_IO_CURRENTLY_PUTTING)或者_IO_write_base为空<ul>
<li>如果是_IO_write_base为空的情况,先通过_IO_doallocbuf申请buf缓冲区,并设置read指针</li>
<li>如果文件流正在备份(_IO_IN_BACKUP)<ul>
<li>调用_IO_free_backup_area (f)</li>
<li>f-&gt;_IO_read_base减去f-&gt;_IO_read_end - f-&gt;_IO_read_ptr和f-&gt;_IO_read_base - f-&gt;_IO_buf_base中更小的那个</li>
<li>f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</li>
</ul>
</li>
<li>如果f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end,将f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</li>
<li>将w-ptr和w-base设置为r-ptr,w-end设置为b-end,r-base和r-ptr设置为r-end(之后这些指针一般用简写)</li>
<li>设置_IO_CURRENTLY_PUTTING位</li>
<li>若文件流是行缓冲或无缓冲模式且非宽字符w-end=w-ptr</li>
</ul>
</li>
</ul>
</li>
<li>如果参数ch为EOF,调用_IO_do_write</li>
<li>如果w-ptr==b-end,调用_IO_do_flush如果返回EOF则直接return EOF</li>
<li>*f-&gt;_IO_write_ptr++=ch</li>
<li>如果文件是无缓冲或者是行缓冲且ch为’\n’,调用_IO_do_write如果返回EOF则直接return EOF</li>
<li>返回ch</li>
</ol>
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure>
<p>如果to_do==0直接返回1</p>
<p>否则调用new_do_write (fp, data, to_do)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);<span class="comment">//读写平衡</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)<span class="comment">//计算最后一行第几列</span></span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果_IO_IS_APPENDING被置位，说明文件对象是以追加方式打开的，所以将fp-&gt;_offset赋值为_IO_pos_BAD，即定位到文件末尾；</p>
</li>
<li><p>如果不是追加模式，就要考虑读写buffer块地址的信息了，读的尾指针不等于写的基指针，说明之前读写过程不一致，现在我们需要写入信息，所以需要调用_IO_SYSSEEK进行调整，基于当前的位置（1表示SEEK_CUR）将两者调整到一致。</p>
<ul>
<li>如果返回结果是异常的-1，那就直接返回0，表示写入字节数为0.</li>
<li>否则使用新的位置信息更新fp-&gt;_offset</li>
</ul>
</li>
<li>调用系统调用_IO_SYSWRITE (fp, data, to_do);</li>
<li>如果当前列参数不等于0(即第一列)，而且写入的字符数不等于0，此时需要更新列参数，调用_IO_adjust_column函数实现。</li>
<li>调用_IO<em>setg将读相关的base、ptr、end更新为_IO_buf_base；然后将写相关的base、ptr更新为_IO_buf_base。</em></li>
</ul>
<p>注意最后的w-end会根据当前的模式选择是等于_IO_buf_base还是_IO_buf_end：</p>
<ul>
<li>如果fp-&gt;_mode &lt;= 0，说明是标准字符，fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)说明是按行为buffer单位或没有缓存buffer，这种情况将写end置为_IO_buf_base，即无法使用buffer，否则则是可以使用buffer的情况，置为_IO_buf_end，可以使用base到end这块空间作为写缓存。</li>
</ul>
<p>看一下col调整函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="type">unsigned</span> start, <span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_adjust_column)</span><br></pre></td></tr></table></figure>
<p>就是更新最后一行的列</p>
<ul>
<li><p>首先ptr指向真正写入的最后一个字符；</p>
</li>
<li><p>当ptr大于line，即从后向前遍历字符，如果找到换行符，则结束，说明之前遍历的位于写入的最后一行，此时line + count - ptr - 1表示最后一行的字符数，返回该值即可；</p>
</li>
<li><p>如果没有找到换行符，那就返回start + count，即之前的列号加真正写入的字符数。</p>
</li>
</ul>
<p>最后在外层再加1得到当前行的列号，整体的逻辑就是要更新当前的列号。</p>
<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">	  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">	  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_read)</span><br></pre></td></tr></table></figure>
<p>就是调用系统调用</p>
<h2 id="seek"><a href="#seek" class="headerlink" title="seek"></a>seek</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_file_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __lseek64 (fp-&gt;_fileno, offset, dir);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_seek)</span><br></pre></td></tr></table></figure>
<p>seek就是调用lseek</p>
<p>返回成功后的偏移地址如果错误返回-1</p>
<h2 id="stat-1"><a href="#stat-1" class="headerlink" title="stat"></a>stat</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_stat (FILE *fp, <span class="type">void</span> *st)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fxstat64 (_STAT_VER, fp-&gt;_fileno, (<span class="keyword">struct</span> stat64 *) st);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_stat)</span><br></pre></td></tr></table></figure>
<p>调用stat系统调用</p>
<p>返回一个stat结构体</p>
<h2 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h2><p>underflow主要负责从文件中读取数据到缓冲区</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span class="comment">//注意读的大小是缓冲区的大小,这意味r-end可能会向后移动很多,从而导致读写不一致(_offset偏后)</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果已经到达文件末尾返回EOF</p>
</li>
<li><p>如果文件不允许读,设置错误并返回EOF</p>
</li>
<li><p>如果r-ptr&lt;r-end返回r-ptr指向的字符</p>
</li>
<li><p>如果buf为空</p>
<ul>
<li>如果_IO_save_base不为空先将其释放,并取消_IO_IN_BACKUP标志位</li>
<li>申请buf</li>
</ul>
</li>
<li><p>如果是行缓冲或无缓冲模式</p>
<ul>
<li>给stdout上锁</li>
<li>如果stdout是行缓冲且在_IO_list_all链上且不禁止写,对stdout调用overflow</li>
<li>将stdout解锁</li>
</ul>
</li>
<li><p>调用_IO_switch_to_get_mode (fp);</p>
</li>
<li><p>更新读写缓冲区所有指针为fp-&gt;_IO_buf_base</p>
</li>
<li><p>调用系统调用_IO_SYSREAD(fp, fp-&gt;_IO_buf_base,</p>
<p>​      fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</p>
</li>
<li><p>,返回值为count</p>
</li>
<li><p>如果count&lt;=0</p>
<ul>
<li>如果count为0,文件标志设置到达末尾</li>
<li>如果count小于0,设置错误标志,并将count置为0</li>
</ul>
</li>
<li><p>r-end向后移动count</p>
</li>
<li><p>如果count为0,将fp-&gt;_offset设置为-1(文件末尾)并返回EOF</p>
</li>
<li><p>如果fp-&gt;_offset不为-1,fp-&gt;_offset移动到当前位置向后count字节</p>
</li>
<li><p>返回r-ptr指向的字符</p>
</li>
</ol>
<p>看以下其中调用的_IO_switch_to_get_mode (fp);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_get_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">	fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_IO_read_ptr = fp-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_switch_to_get_mode)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果w-ptr&gt;w-base说明输出缓冲区还有数据尚未写入文件,调用_IO_OVERFLOW (fp, EOF)</li>
<li>如果处于备份模式fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;<ul>
<li>否则fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;<ul>
<li>如果w-ptr&gt;r-end,r-end=w-ptr</li>
</ul>
</li>
</ul>
</li>
<li>r-ptr被赋值为w-ptr,write的所有指针置为r-ptr</li>
<li>取消文件流的_IO_CURRENTLY_PUTTING标志位</li>
</ol>
<p>感觉有些指针操作有些多余了,underflow外层中都会统一更新赋值</p>
<h2 id="uflow"><a href="#uflow" class="headerlink" title="uflow"></a>uflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure>
<ol>
<li>调用underflow</li>
<li>如果underflow返回值为EOF,返回EOF</li>
<li>否则返回fp-&gt;_IO_read_ptr处的字符</li>
</ol>
<h2 id="sync-1"><a href="#sync-1" class="headerlink" title="sync"></a>sync</h2><p>sync负责平衡读写,将未写入的数据写入文件,将未读取的数据去除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;<span class="comment">//读平衡,真正只读到ptr,但实际读到end</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);<span class="comment">//将多余的去除</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">	fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;<span class="comment">//平衡</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">	; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果write缓冲区有未写入的,调用_IO_do_flush不成功写入或写入不完全则直接返回EOF</li>
<li>平衡read指针</li>
</ol>
<h2 id="imbue"><a href="#imbue" class="headerlink" title="imbue"></a>imbue</h2><p>在2.31中是个空函数</p>
<h2 id="showmanyc"><a href="#showmanyc" class="headerlink" title="showmanyc"></a>showmanyc</h2><p>在2.31中是个空函数</p>
<h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>关闭文件流</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">		      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">	_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  _IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  _IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果文件不处于打开状态,直接返回</li>
<li>如果文件不禁止写且正处于写入模式,调用_IO_do_flush,否则设置write_status = 0</li>
<li>调用_IO_unsave_markers (fp);</li>
<li>如果文件未设置_IO_FLAGS2_NOCLOSE,调用sysclose关闭文件描述符</li>
<li>如果文件为宽字符模式,对宽字符缓冲进行处理</li>
<li>设置缓冲区指针为null</li>
<li>调用_IO_un_link解链文件</li>
<li>设置标志位,设置偏移基址为末尾设置文件描述符</li>
<li>返回close_status ? close_status : write_status;</li>
</ol>
<h2 id="doallocate"><a href="#doallocate" class="headerlink" title="doallocate"></a>doallocate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">	      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      local_isatty (fp-&gt;_fileno))</span><br><span class="line">	    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">	size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果文件描述符大于等于0且文件返回的信息正常<ul>
<li>如果文件_IO_IS_FILEBUF标志被设置,设置 _IO_LINE_BUF标志位</li>
</ul>
</li>
<li>malloc申请chunk</li>
<li>设置buf指针并返回</li>
</ol>
<h2 id="seekpos"><a href="#seekpos" class="headerlink" title="seekpos"></a>seekpos</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_default_seekpos (FILE *fp, <span class="type">off64_t</span> pos, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _IO_SEEKOFF (fp, pos, <span class="number">0</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用_IO_SEEKOFF</p>
<h2 id="seekoff"><a href="#seekoff" class="headerlink" title="seekoff"></a>seekoff</h2><p>出现频率不高,暂时先略过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_new_file_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span></span><br><span class="line"><span class="comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span></span><br><span class="line"><span class="comment">     object. */</span></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span></span><br><span class="line"><span class="comment">     offset of the underlying file must be exact.  */</span></span><br><span class="line">  <span class="type">int</span> must_be_exact = (fp-&gt;_IO_read_base == fp-&gt;_IO_read_end</span><br><span class="line">		       &amp;&amp; fp-&gt;_IO_write_base == fp-&gt;_IO_write_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">		      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush unwritten characters.</span></span><br><span class="line"><span class="comment">     (This may do an unneeded write if we seek within the buffer.</span></span><br><span class="line"><span class="comment">     But to be able to switch to reading, we would need to set</span></span><br><span class="line"><span class="comment">     egptr to pptr.  That can&#x27;t be done in the current design,</span></span><br><span class="line"><span class="comment">     which assumes file_ptr() is eGptr.  Anyway, since we probably</span></span><br><span class="line"><span class="comment">     end up flushing when we close(), it doesn&#x27;t make much difference.)</span></span><br><span class="line"><span class="comment">     <span class="doctag">FIXME:</span> simulate mem-mapped files. */</span></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_get_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* It could be that we already have a pushback buffer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (dir)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_cur:</span><br><span class="line">      <span class="comment">/* Adjust for read-ahead (bytes is buffer). */</span></span><br><span class="line">      offset -= fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_offset == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">goto</span> dumb;</span><br><span class="line">      <span class="comment">/* Make offset absolute, assuming current pointer is file_ptr(). */</span></span><br><span class="line">      offset += fp-&gt;_offset;</span><br><span class="line">      <span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  __set_errno (EINVAL);</span><br><span class="line">	  <span class="keyword">return</span> EOF;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      dir = _IO_seek_set;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_set:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_end:</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (_IO_SYSSTAT (fp, &amp;st) == <span class="number">0</span> &amp;&amp; S_ISREG (st.st_mode))</span><br><span class="line">	  &#123;</span><br><span class="line">	    offset += st.st_size;</span><br><span class="line">	    dir = _IO_seek_set;</span><br><span class="line">	  &#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	  <span class="keyword">goto</span> dumb;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_free_backup_area (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* At this point, dir==_IO_seek_set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If destination is within current buffer, optimize: */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD &amp;&amp; fp-&gt;_IO_read_base != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; !_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> start_offset = (fp-&gt;_offset</span><br><span class="line">                              - (fp-&gt;_IO_read_end - fp-&gt;_IO_buf_base));</span><br><span class="line">      <span class="keyword">if</span> (offset &gt;= start_offset &amp;&amp; offset &lt; fp-&gt;_offset)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		    fp-&gt;_IO_buf_base + (offset - start_offset),</span><br><span class="line">		    fp-&gt;_IO_read_end);</span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">	  <span class="keyword">goto</span> resync;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    <span class="keyword">goto</span> dumb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to seek to a block boundary, to improve kernel page management. */</span></span><br><span class="line">  new_offset = offset &amp; ~(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base - <span class="number">1</span>);</span><br><span class="line">  delta = offset - new_offset;</span><br><span class="line">  <span class="keyword">if</span> (delta &gt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      new_offset = offset;</span><br><span class="line">      delta = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  result = _IO_SYSSEEK (fp, new_offset, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (delta == <span class="number">0</span>)</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">			   (must_be_exact</span><br><span class="line">			    ? delta : fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; delta)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* We weren&#x27;t allowed to read, but try to seek the remainder. */</span></span><br><span class="line">	  offset = count == EOF ? delta : delta-count;</span><br><span class="line">	  dir = _IO_seek_cur;</span><br><span class="line">	  <span class="keyword">goto</span> dumb;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base + delta,</span><br><span class="line">	    fp-&gt;_IO_buf_base + count);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_offset = result + count;</span><br><span class="line">  _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">  <span class="keyword">return</span> offset;</span><br><span class="line"> dumb:</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line">  result = _IO_SYSSEEK (fp, offset, dir);</span><br><span class="line">  <span class="keyword">if</span> (result != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">      fp-&gt;_offset = result;</span><br><span class="line">      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">resync:</span><br><span class="line">  <span class="comment">/* We need to do it since it is possible that the file offset in</span></span><br><span class="line"><span class="comment">     the kernel may be changed behind our back. It may happen when</span></span><br><span class="line"><span class="comment">     we fopen a file and then do a fork. One process may access the</span></span><br><span class="line"><span class="comment">     file and the kernel file offset will be changed. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    _IO_SYSSEEK (fp, fp-&gt;_offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_seekoff, _IO_file_seekoff)</span><br></pre></td></tr></table></figure>
<h2 id="pbackfail"><a href="#pbackfail" class="headerlink" title="pbackfail"></a>pbackfail</h2><p>出现频率不高,暂时先略过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_pbackfail (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; !_IO_in_backup (fp)</span><br><span class="line">      &amp;&amp; (<span class="type">unsigned</span> <span class="type">char</span>) fp-&gt;_IO_read_ptr[<span class="number">-1</span>] == c)</span><br><span class="line">    --fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/</span></span><br><span class="line">      <span class="keyword">if</span> (!_IO_in_backup (fp))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* We need to keep the invariant that the main get area</span></span><br><span class="line"><span class="comment">	     logically follows the backup area.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; _IO_have_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_ptr))</span><br><span class="line">		<span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (!_IO_have_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/* No backup buffer: allocate one. */</span></span><br><span class="line">	      <span class="comment">/* Use nshort buffer, if unused? (probably not)  FIXME */</span></span><br><span class="line">	      <span class="type">int</span> backup_size = <span class="number">128</span>;</span><br><span class="line">	      <span class="type">char</span> *bbuf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (backup_size);</span><br><span class="line">	      <span class="keyword">if</span> (bbuf == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> EOF;</span><br><span class="line">	      fp-&gt;_IO_save_base = bbuf;</span><br><span class="line">	      fp-&gt;_IO_save_end = fp-&gt;_IO_save_base + backup_size;</span><br><span class="line">	      fp-&gt;_IO_backup_base = fp-&gt;_IO_save_end;</span><br><span class="line">	    &#125;</span><br><span class="line">	  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_switch_to_backup_area (fp);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt;= fp-&gt;_IO_read_base)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Increase size of existing backup buffer. */</span></span><br><span class="line">	  <span class="type">size_t</span> new_size;</span><br><span class="line">	  <span class="type">size_t</span> old_size = fp-&gt;_IO_read_end - fp-&gt;_IO_read_base;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  new_size = <span class="number">2</span> * old_size;</span><br><span class="line">	  new_buf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  <span class="built_in">memcpy</span> (new_buf + (new_size - old_size), fp-&gt;_IO_read_base,</span><br><span class="line">		  old_size);</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">	  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),</span><br><span class="line">		    new_buf + new_size);</span><br><span class="line">	  fp-&gt;_IO_backup_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      *--fp-&gt;_IO_read_ptr = c;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_pbackfail)</span><br></pre></td></tr></table></figure>
<h2 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure>
<ol>
<li>调用_IO_default_setbuf (fp, p, len)</li>
<li>调整pptr和gptr为_IO_buf_base</li>
</ol>
<p>看_IO_default_setbuf (fp, p, len)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">	fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">	_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>sync平衡失败直接返回NULL</li>
<li>缓冲区未指定或长度为0,将文件流设置为无缓冲模式,并设置缓冲区指针为shorbuf</li>
<li>否则取消无缓冲标志并设置缓冲区为指定区域</li>
<li>更新pptr和gptr为null</li>
<li>返回fp</li>
</ol>
<h2 id="xsgetn"><a href="#xsgetn" class="headerlink" title="xsgetn"></a>xsgetn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_switch_to_main_get_area (fp);</span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">	      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  count = want;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">		count -= want % block_size;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">	  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  s += count;</span><br><span class="line">	  want -= count;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>如果buf为null</p>
<ul>
<li>如果savebase不为null,先将其释放并取消’在备份’标志位</li>
<li>调用doallocbuf申请缓冲区</li>
</ul>
</li>
<li><p>循环,条件为当需要的数据want大于0</p>
<ul>
<li><p>如果want不多于read缓冲区中拥有的数据,直接将缓冲区中的数据转移到内存,并调整gptr</p>
</li>
<li><p>否则如果want&gt;have</p>
<ul>
<li>如果have大于0,先将have中的数据转移到内存</li>
<li>如果处于备份模式,调用_IO_switch_to_main_get_area (fp);并结束当次循环</li>
<li>如果buf不为空且want小于缓冲区容量,调用underflow,若返回EOF则跳出循环,否则结束此次循环</li>
<li>如果缓冲区异常或者want大于缓冲区容量<ul>
<li>设置pptr和gptr</li>
<li>如果缓冲区存在且缓冲区大于128则count -= want % block_size;,即将超过缓冲区的部分直接调用系统调用读取,剩余部分则在下一次循环完成</li>
<li>调用系统调用read(fp, s, count),如果上一步没有修改count,那么这一步就可以直接调用系统调用read读取所有的内容,并且是直接读到目标区域不经过缓冲区,根据返回值有:<ul>
<li>如果返回为0,则设置文件标志为到达文件末尾,否则设置为发生错误,返回值小于0则设置错误标志位,两种情况下,都会跳出循环</li>
<li>返回值大于0,则继续向下执行</li>
</ul>
</li>
<li>s += count;want -= count;如果文件偏移不在末尾则调整offset</li>
<li>再次开始循环,进行前面的操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li>返回n-want(即读入的量)</li>
</ol>
<h2 id="xspuntn"><a href="#xspuntn" class="headerlink" title="xspuntn"></a>xspuntn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;<span class="comment">//绕过缓冲区</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果n小于等于0直接返回</li>
<li>如果文件时行缓冲且正处于写入模式<ul>
<li>如果b-end—w-ptr大于n,从要写入数据的末尾开始查找’\n’符,如果找到了设置count为’\n’字符前的数据长度,并将must_flush 置 1</li>
</ul>
</li>
<li>否则count=w_end - w_ptr</li>
<li>如果count大于0<ul>
<li>如果count&gt;todo,count=todo</li>
<li>将内存中的数据转移到缓冲区</li>
<li>s += count;to_do -= count;</li>
</ul>
</li>
<li>如果to_do + must_flush &gt; 0<ul>
<li>调用overflow,若返回EOF,则返回to_do == 0 ? EOF : n - to_do;</li>
<li>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</li>
<li>如果do_write大于0,调用new_do_write (f, s, do_write);写多余的<ul>
<li>如果写入数量小于do_write,返回n - to_do</li>
</ul>
</li>
<li>如果to_do还有剩,调用_IO_default_xsputn (f, s+do_write, to_do);</li>
</ul>
</li>
</ol>
<p>看_IO_default_xsputn (f, s+do_write, to_do);</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果more小于等于0直接返回0</li>
<li>循环<ul>
<li>如果f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end<ul>
<li>如果count&gt;more,count = more;</li>
<li>如果count&gt;20,将内存中的数据移动到缓冲区</li>
<li>否则如果count不为0但小于20,将内存中的数据逐个复制到缓冲区</li>
<li>如果more=0或者_IO_OVERFLOW (f, (unsigned char) *s++) == EOF结束循环,more!=0才会执行_IO_OVERFLOW,原因是因为前面已经填满了缓冲区需要刷新,其会单独往缓冲区写入一个字符(原本是处理行缓冲的机制),所以下面要more—</li>
<li>否则more—</li>
</ul>
</li>
</ul>
</li>
<li>返回n-more</li>
</ol>
<h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><ol>
<li>综上可以看出缓冲区模式,对读取过程并没有什么影响,对写入过程的影响则要更大,不过都受到上层函数影响</li>
</ol>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95"><span class="toc-number">1.</span> <span class="toc-text">引*</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">相关系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lseek"><span class="toc-number">2.1.</span> <span class="toc-text">lseek</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync"><span class="toc-number">2.2.</span> <span class="toc-text">sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stat"><span class="toc-number">2.3.</span> <span class="toc-text">stat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E8%99%9A%E8%A1%A8%E5%87%BD%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">IO虚表函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#finish"><span class="toc-number">3.1.</span> <span class="toc-text">finish</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IO-new-file-finish"><span class="toc-number">3.1.1.</span> <span class="toc-text">1 _IO_new_file_finish</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-IO-do-flush"><span class="toc-number">3.1.2.</span> <span class="toc-text">2-1 _IO_do_flush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-IO-default-finish"><span class="toc-number">3.1.3.</span> <span class="toc-text">2-2 _IO_default_finish</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IO-un-link"><span class="toc-number">3.1.4.</span> <span class="toc-text">3 _IO_un_link</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overflow"><span class="toc-number">3.2.</span> <span class="toc-text">overflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#write"><span class="toc-number">3.3.</span> <span class="toc-text">write</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#read"><span class="toc-number">3.4.</span> <span class="toc-text">read</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seek"><span class="toc-number">3.5.</span> <span class="toc-text">seek</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stat-1"><span class="toc-number">3.6.</span> <span class="toc-text">stat</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#underflow"><span class="toc-number">3.7.</span> <span class="toc-text">underflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uflow"><span class="toc-number">3.8.</span> <span class="toc-text">uflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-1"><span class="toc-number">3.9.</span> <span class="toc-text">sync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#imbue"><span class="toc-number">3.10.</span> <span class="toc-text">imbue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#showmanyc"><span class="toc-number">3.11.</span> <span class="toc-text">showmanyc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#close"><span class="toc-number">3.12.</span> <span class="toc-text">close</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#doallocate"><span class="toc-number">3.13.</span> <span class="toc-text">doallocate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seekpos"><span class="toc-number">3.14.</span> <span class="toc-text">seekpos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seekoff"><span class="toc-number">3.15.</span> <span class="toc-text">seekoff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pbackfail"><span class="toc-number">3.16.</span> <span class="toc-text">pbackfail</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setbuf"><span class="toc-number">3.17.</span> <span class="toc-text">setbuf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xsgetn"><span class="toc-number">3.18.</span> <span class="toc-text">xsgetn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xspuntn"><span class="toc-number">3.19.</span> <span class="toc-text">xspuntn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%BE%E9%81%97"><span class="toc-number">4.</span> <span class="toc-text">拾遗</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/1518/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/1518/&text=file虚表函数学习"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/1518/&is_video=false&description=file虚表函数学习"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=file虚表函数学习&body=Check out this article: https://ixout.github.io/posts/1518/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/1518/&title=file虚表函数学习"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/1518/&name=file虚表函数学习&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/1518/&t=file虚表函数学习"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>
        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ixout
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
