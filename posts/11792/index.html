<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="bin attack!!">
<meta property="og:type" content="article">
<meta property="og:title" content="堆利用-3">
<meta property="og:url" content="https://ixout.github.io/posts/11792/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="bin attack!!">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-03-31T13:19:04.000Z">
<meta property="article:modified_time" content="2024-11-20T14:11:46.228Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="学习记录">
<meta property="article:tag" content="堆">
<meta property="article:tag" content="堆利用">
<meta property="article:tag" content="fastbin">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
        
      
    
    <!-- title -->
    <title>堆利用-3</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/posts/11890/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/61137/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/11792/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/11792/&text=堆利用-3"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/11792/&is_video=false&description=堆利用-3"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=堆利用-3&body=Check out this article: https://ixout.github.io/posts/11792/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/11792/&name=堆利用-3&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/11792/&t=堆利用-3"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#fastbin-attack"><span class="toc-number">1.</span> <span class="toc-text">fastbin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-Double-Free"><span class="toc-number">1.1.</span> <span class="toc-text">Fastbin Double Free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alloc-to-Anywhere"><span class="toc-number">1.2.</span> <span class="toc-text">Alloc to Anywhere</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsortedbin-attack"><span class="toc-number">2.</span> <span class="toc-text">unsortedbin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-2"><span class="toc-number">2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">2.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E6%95%88"><span class="toc-number">2.4.</span> <span class="toc-text">失效</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#largebin-attack"><span class="toc-number">3.</span> <span class="toc-text">largebin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-3"><span class="toc-number">3.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="toc-number">3.2.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">3.3.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcache-attack"><span class="toc-number">4.</span> <span class="toc-text">tcache attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">4.1.</span> <span class="toc-text">tcache poisoning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-4"><span class="toc-number">4.1.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-dup"><span class="toc-number">4.2.</span> <span class="toc-text">tcache dup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-5"><span class="toc-number">4.2.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-perthread-corruption"><span class="toc-number">4.3.</span> <span class="toc-text">tcache perthread corruption</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-6"><span class="toc-number">4.3.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-house-of-spirit"><span class="toc-number">4.4.</span> <span class="toc-text">tcache house of spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-7"><span class="toc-number">4.4.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#smallbin-unlink"><span class="toc-number">4.5.</span> <span class="toc-text">smallbin unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-8"><span class="toc-number">4.5.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">4.5.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-stashing-unlink-attack"><span class="toc-number">4.6.</span> <span class="toc-text">tcache stashing unlink attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-9"><span class="toc-number">4.6.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">4.6.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.6.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-reverse-into-tcache"><span class="toc-number">4.7.</span> <span class="toc-text">Fastbin reverse into tcache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-10"><span class="toc-number">4.7.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">4.7.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        堆利用-3
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ixout</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-03-31T13:19:04.000Z" class="dt-published" itemprop="datePublished">2023-03-31</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/pwn/">pwn</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/fastbin/" rel="tag">fastbin</a>, <a class="p-category" href="/tags/%E5%A0%86/" rel="tag">堆</a>, <a class="p-category" href="/tags/%E5%A0%86%E5%88%A9%E7%94%A8/" rel="tag">堆利用</a>, <a class="p-category" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" rel="tag">学习记录</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <span class='p blue'>一些零碎的东西</span>
<h1 id="fastbin-attack"><a href="#fastbin-attack" class="headerlink" title="fastbin attack"></a>fastbin attack</h1><p>主要漏洞侧重于利用 <code>free</code> 函数释放<strong>真的 chunk 或伪造的 chunk</strong>，然后再次申请 chunk 进行攻击，或故意修改 <code>fd</code> 指针，直接利用 <code>malloc</code> 申请指定位置 chunk 进行攻击。</p>
<p><strong>直接改写freelist中的fd指针的话,不要求地址对齐</strong></p>
<p><strong>free释放假chunk需要地址对齐</strong></p>
<p><strong>fastbins取出时,会进行该chunk的大小所对应的索引和当前链索引是否相同</strong></p>
<h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> fastbin double free 我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。 如果更进一步修改 fd 指针，则能够实现任意地址分配堆块的效果 (首先要通过验证)，这就相当于任意地址写任意值的效果。</p>
<p><strong>利用条件:</strong>能多次free同一chunk</p>
<p><strong>利用效果:</strong>得到两个指向同一chunk的指针</p>
<p><strong>有效版本:</strong>ALL</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p>
<h2 id="Alloc-to-Anywhere"><a href="#Alloc-to-Anywhere" class="headerlink" title="Alloc to Anywhere"></a>Alloc to Anywhere</h2><h3 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong>该技术的核心点在于劫持 fastbin 链表中 chunk 的 fd 指针，把 fd 指针指向我们想要分配的栈上</p>
<p><strong>利用条件:</strong>能劫持chunk的fd指针</p>
<p><strong>利用效果:</strong>任意分配chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<p><strong>限制:</strong>2.32及以上版本fastbin加密,写fd指针需要能够泄露堆地址,并进行一些额外处理</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>利用了UAF,再free后又去改写该chunk的fd指针,使其指向内存中一个可以被视为fastbin_chunk的内存空间(size域合适等)</p>
<p>指向的chunk要绕过该检测,该chunk的大小计算出的idx要与该链的索引idx相匹配</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (victim));</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin attack"></a>unsortedbin attack</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong></p>
<p><strong>利用条件:</strong>uaf,能够劫持chunk的bk指针</p>
<p><strong>利用效果:</strong>任意地址写上unsorted+96(+88)</p>
<p><strong>有效版本:</strong>2.29以前</p>
<p><strong>失效原因:</strong>2.29新增unsortedbin取出时bk链完整性</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><strong>什么情况下会被放入unsortedbin</strong></p>
<ol>
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。(即last remainer)</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li>
<li>当进行 malloc_consolidate 时，若合并后不与top chunk相邻,则会将合并后的chunk放入unsortedbin。</li>
</ol>
<p><strong>使用情况</strong></p>
<ol>
<li>unsortedbin采用的是FIFO,<strong>即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取</strong>。加入的时候利用fd,取出的时候利用bk</li>
<li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，<strong>否则就会把这些 chunk 分别插入到对应的 bin 中</strong>。</li>
</ol>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。</p>
<p>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。</p>
<p>以及辅助泄露main_arena地址</p>
<p>其利用的函数片段为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>即将取出的chunk的上一个chunk的fd指针写为unsorted_chunks (av)</p>
<p>不难看出要攻击就要能修改某个chunk的bk指针,达到的效果是将&amp;bins[0]-2会被写入指定位置</p>
<p>这里可以看到 unsorted bin attack 确实可以修改任意地址的值，但是所修改成的值却不受我们控制，</p>
<ul>
<li>通过修改循环的次数来使得程序可以执行多次循环。</li>
<li>可以修改 heap 中的 <strong>global_max_fast 来使得更大的 chunk 可以被视为 fast bin</strong>，这样我们就可以去执行一些 fast bin attack 了。</li>
</ul>
<p><strong>注意:</strong></p>
<p>当进行完unsorted bin attack</p>
<p>unsortedbin都会损坏</p>
<p>但分两种情况:</p>
<ol>
<li>原本unsortedbin中只有一个chunk,利用完后unsorted的取出与放入都将被禁止</li>
<li>原本不止一个chunk,利用完后取出操作被禁止</li>
</ol>
<hr>
<p><strong>另一种利用方法</strong>:</p>
<p>修改bk,使其指向一个fakechunk,并且fakechunk</p>
<ol>
<li>size符合申请大小</li>
<li>fd字段可写</li>
<li>bk字段指向可写区域</li>
</ol>
<p>这样当被构造的unsortedbin被取出后下一次取出就会取出fakechunk,且大小合适的话就会直接退出</p>
<p>最好大小合适因为不合适的话就找不到出口了</p>
<h2 id="失效"><a href="#失效" class="headerlink" title="失效"></a>失效</h2><p>加了一个检测</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<h1 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>这种攻击方式主要利用的是 chunk 进入 bin 中的操作，在 malloc 的时候，遍历 unsorted bin 时，对每一个 chunk，若无法 exact-fit 分配或不满足切割分配的条件，就会将该 chunk 置入相应的 bin 中，而此过程中缺乏对 largebin 的跳表指针的检测。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>可以修改一个large bin chunk的data</li>
</ol>
<p><strong>利用效果:</strong>任意地址写上chunk地址,辅助 Tcache Stash Unlink+ 攻击,可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。是诸多house系列的重要前提</p>
<p><strong>有效版本:</strong>all/2.30以前</p>
<h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>在index相同的情况下：</p>
<ol>
<li><p>一般空闲的large chunk在fd的遍历顺序中，<strong>按照由大到小的顺序排列</strong>。这样可以避免在寻找合适chunk时挨个遍历</p>
</li>
<li><p>如果大小相同，chunk放置在处于nextsize链上的chunk的下一个</p>
</li>
<li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li>
<li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li>
</ol>
<p>空闲chunk的结构与unsorted和small的差别就在于多了fd_nextsize和bk_nextsize,分别指向下一个<strong>大小</strong>的chunk和上一个大小的chunk,且chunk在largebin free list中按从大到小排序是重要细节</p>
<h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p><strong>unsorted处理将chunk放入largebin中的操作</strong>(2.38)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         victim_index = largebin_index (size);</span><br><span class="line">         bck = bin_at (av, victim_index);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">         <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">             size |= PREV_INUSE;</span><br><span class="line">             <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">             assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">             <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">   &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">               &#123;</span><br><span class="line">                 fwd = bck;</span><br><span class="line">                 bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                 victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                 victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                 fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">                 <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                   malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">       &#125;</span><br><span class="line">     mark_bin (av, victim_index);</span><br><span class="line">     victim-&gt;bk = bck;</span><br><span class="line">     victim-&gt;fd = fwd;</span><br><span class="line">     fwd-&gt;bk = victim;</span><br><span class="line">     bck-&gt;fd = victim;</span><br></pre></td></tr></table></figure>
<p>largebin attack就是出现在这个提取chunk的过程中</p>
<p>由于两者大小相同的时候只会使用如下的方法插入，所以此时无法利用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long) size</span><br><span class="line">              == (unsigned long) chunksize_nomask (fwd))</span><br><span class="line">                        /* Always insert in the second position.  */</span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br></pre></td></tr></table></figure>
<p>两种利用方法</p>
<ul>
<li><strong>当unsorted chunk的size小于largebin链上最小的chunk时</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size)</span><br><span class="line">&lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = bck;</span><br><span class="line">              bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">              victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>如果修改nextsize链上最大的chunk的bk_nextsize字段为addr,那么<code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>就会将addr+0x20的位置写上victim</p>
<ul>
<li><strong>当unsorted chunk的size大于largebin链上最小的chunk时</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 assert (chunk_main_arena (fwd));</span><br><span class="line">                 <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                   &#123;</span><br><span class="line">                     fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">assert (chunk_main_arena (fwd));</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size</span><br><span class="line">== (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (fwd))<span class="comment">//!!no</span></span><br><span class="line">                   <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                   fwd = fwd-&gt;fd;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                   &#123;</span><br><span class="line">                     victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                     victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">                       malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class="line">                     fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                     victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                   &#125;</span><br><span class="line">                 bck = fwd-&gt;bk;</span><br><span class="line">                 <span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">                   malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>
<p><u>这两个在2.30中新增加的检查使得这种利用方法不再可行</u></p>
<p>但在此之前</p>
<ol>
<li>如果修改第一个小于unsorted chunk的size的chunk的bk_nextsize字段为addr,<code>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</code>会使得addr+0x20写为victim</li>
<li>如果修改第一个小于unsorted chunk的size的chunk的bk字段为addr,<code>bck = fwd-&gt;bk;</code>与之后的<code>bck-&gt;fd = victim;</code>会使得addr+0x10写为victim</li>
</ol>
<h1 id="tcache-attack"><a href="#tcache-attack" class="headerlink" title="tcache attack"></a>tcache attack</h1><p>tcache使得性能提高的同时,安全性大幅下降,操作优先级高且检查并不严谨,利用更为简单</p>
<h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><h3 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 通过覆盖 tcache 中的 next，不需要伪造任何 chunk 结构即可实现 malloc 到任何地址。任意地址作为chunk操作</p>
<p><strong>利用条件:</strong>能劫持chunk的next字段</p>
<p><strong>利用效果:</strong>任意地址分配chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<p><strong>限制:</strong>2.32及以上版本tcachebin加密,写next字段需要能够泄露堆地址,并进行一些额外处理</p>
<h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><h3 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 类似 <code>fastbin dup</code>，不过利用的是 <code>tcache_put()</code> 的不严谨,因为没有任何检查，所以我们可以对同一个 chunk 多次 free，可以连续释放同一个chunk,造成 cycliced list。也就是造成一个chunk可以被无数次取出利用</p>
<p><strong>利用条件:</strong>能多次free同一chunk</p>
<p><strong>利用效果:</strong>获得多个指向同一chunk的指针</p>
<p><strong>有效版本:</strong>2.29以前,2.29tcache引入key验证机制</p>
<p><strong>技巧:</strong>2.29及以后虽然tcache引入key验证机制,但如果能<strong>破坏chunk的key字段,就能绕过</strong></p>
<h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><h3 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 在开启tcache情况下,堆上第一个chunk就是结构体tcache_perthread_struct,大小为0x290,该技术就是通过tcache posioning将tcache链中的某个chunk指向tcache_perthread_struct本身,直接修改tcache_perthread_struct进行攻击</p>
<p><strong>利用条件:</strong>能劫持chunk的next字段</p>
<p><strong>利用效果:</strong>控制tcache_perthread_struct结构体</p>
<p><strong>有效版本:</strong>同tcache posioning</p>
<h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><h3 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 与fastbin的house of spirit一个原理,因为没有检查反而更简单,不需要伪造nextsize等,只要size字段符合tcache标准即可</p>
<p><strong>利用条件:</strong>能free指定地址</p>
<p><strong>利用效果:</strong>获得一个任意地址的chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<p>fakechunk须满足的条件</p>
<ol>
<li>地址对齐</li>
<li>ISMMAP 位不能为 1</li>
<li>大小对齐,大于MINSIZE小于system_mem,处在tcache范围内</li>
</ol>
<h2 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h2><h3 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 在smallbin中取出chunk后,如果在该 smallbin 链中还有剩余的空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。</p>
<p><strong>利用条件:</strong>能劫持chunk的bk字段</p>
<p><strong>利用效果:</strong></p>
<p><strong>有效版本:</strong>ALL</p>
<h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line"> <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">   &#123;</span><br><span class="line">     mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">     <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>修改victim的bk字段为目标地址,两个效果</p>
<ol>
<li>使得包含目标地址的chunk被放入tcache</li>
<li>目标地址的fd字段被写为该smallbin头</li>
</ol>
<p><strong>注意:</strong></p>
<p>其实最好需要控制tcache已有的数量尽量多(理论最好是6,这样能够在放入目标chunk后就退出循环,但实际上不行<strong>因为第一个chunk的完整性检查过不了</strong>,因此实际上最好为5)</p>
<p>否则可能会访问到错误地址,从而报错</p>
<p>但是tcache中有数量的话则申请的时候会直接从tcache中取出</p>
<p>因此除非能使目标地址的bk字段为其自身,不然都比较难使用,毕竟要一直保证每一次的bk字段都存放一个可写地址并不轻松</p>
<h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><h3 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 利用smallbin中的chunk转移到tcache的漏洞</p>
<p><strong>利用条件:</strong>能劫持chunk的bk字段</p>
<p><strong>利用效果:</strong></p>
<p><strong>有效版本:</strong>ALL</p>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种攻击利用的是 tcache bin 有剩余 (数量小于 <code>TCACHE_MAX_BINS</code> ) 时，同大小的 small bin 会放进 tcache 中</p>
<p> 这种情况可以用 <code>calloc</code> 分配同大小堆块触发，因为 <code>calloc</code> 分配堆块时不从 tcache bin 中选取。</p>
<p>在获取到一个 <code>smallbin</code> 中的一个 chunk 后会如果 tcache 仍有足够空闲位置，会将剩余的 small bin 链入 tcache ，在这个过程中只对第一个 bin 进行了完整性检查，<strong>后面的堆块的检查缺失</strong>。</p>
<p>当攻击者可以写一个 small bin 的 bk 指针时，其可以在任意地址上写一个 libc 地址 (类似 <code>unsorted bin attack</code> 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>同时还要在 <code>fake_chunk_addr-&gt;bk</code> 处提前写一个可写地址 <code>writable_addr</code> 。调用 <code>calloc(size-0x10)</code> 的时候会返回给用户 chunk0 (这是因为 smallbin 的 <code>FIFO</code> 分配机制)，假设 <code>tcache[sz]</code> 中有 5 个空闲堆块，则有足够的位置容纳 <code>chunk1</code> 以及 <code>fake_chunk</code> 。在源码的检查中，只对第一个 chunk 的链表完整性做了检测 <code>__glibc_unlikely (bck-&gt;fd != victim)</code> ，后续堆块在放入过程中并没有检测。</p>
<p>因为 tcache 的分配机制是 <code>LIFO</code> ，所以位于 <code>fake_chunk-&gt;bk</code> 指针处的 <code>fake_chunk</code> 在链入 tcache 的时候反而会放到链表表头。在下一次调用 <code>malloc(sz-0x10)</code> 时会返回 <code>fake_chunk+0x10</code> 给用户，同时，由于 <code>bin-&gt;bk = bck;bck-&gt;fd = bin;</code> 的 unlink 操作，会使得 <code>writable_addr+0x10</code> 处被写入一个 libc 地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack_var emulate the fake_chunk we want to alloc to</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="type">unsigned</span> <span class="type">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//put 7 tcache</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">//&gt;0x90</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此利用时,最好保证</p>
<ol>
<li>tcache的数量最好是5</li>
<li>smallbin链上至少要有两个正常的chunk以绕过第一个chunk的完整性检查</li>
<li>目标地址的fd字段要可写,bk字段应该指向一个可写的地方,确保<code>bck-&gt;fd = bin;</code>不报错</li>
</ol>
<h2 id="Fastbin-reverse-into-tcache"><a href="#Fastbin-reverse-into-tcache" class="headerlink" title="Fastbin reverse into tcache"></a>Fastbin reverse into tcache</h2><h3 id="概要-10"><a href="#概要-10" class="headerlink" title="概要"></a>概要</h3><p><strong>简介:</strong> 利用fastbin中的chunk转移到tcache的漏洞</p>
<p><strong>利用条件:</strong>能劫持chunk的bk字段</p>
<p><strong>利用效果:</strong></p>
<p><strong>有效版本:</strong>ALL</p>
<h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>原理于上述两个利用差不多,都是利用chunk转移到未满tcache链上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">     <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">     <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">	 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">	malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">	*fb = REVEAL_PTR (tc_victim-&gt;fd);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">	    <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到仅仅是检测了chunk的地址是否对齐,并没有对size进行检查</p>
<p>那么只要能够控制fast chunk的fd字段就能够做到任意写</p>
<p>但因为目标地址处的内容不完全可控</p>
<p>所以控制流程结束最稳妥的方式是通过将tcache加满,即加入fake chunk之后tcache刚好填满</p>
<p>个人觉得不是很实用,都能够做到控制fastbin的fd字段了,不如干脆直接控制tcachebin的next字段</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#fastbin-attack"><span class="toc-number">1.</span> <span class="toc-text">fastbin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-Double-Free"><span class="toc-number">1.1.</span> <span class="toc-text">Fastbin Double Free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alloc-to-Anywhere"><span class="toc-number">1.2.</span> <span class="toc-text">Alloc to Anywhere</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unsortedbin-attack"><span class="toc-number">2.</span> <span class="toc-text">unsortedbin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-2"><span class="toc-number">2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">2.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E6%95%88"><span class="toc-number">2.4.</span> <span class="toc-text">失效</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#largebin-attack"><span class="toc-number">3.</span> <span class="toc-text">largebin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-3"><span class="toc-number">3.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80-1"><span class="toc-number">3.2.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">3.3.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcache-attack"><span class="toc-number">4.</span> <span class="toc-text">tcache attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-poisoning"><span class="toc-number">4.1.</span> <span class="toc-text">tcache poisoning</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-4"><span class="toc-number">4.1.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-dup"><span class="toc-number">4.2.</span> <span class="toc-text">tcache dup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-5"><span class="toc-number">4.2.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-perthread-corruption"><span class="toc-number">4.3.</span> <span class="toc-text">tcache perthread corruption</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-6"><span class="toc-number">4.3.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-house-of-spirit"><span class="toc-number">4.4.</span> <span class="toc-text">tcache house of spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-7"><span class="toc-number">4.4.1.</span> <span class="toc-text">概要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#smallbin-unlink"><span class="toc-number">4.5.</span> <span class="toc-text">smallbin unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-8"><span class="toc-number">4.5.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">4.5.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcache-stashing-unlink-attack"><span class="toc-number">4.6.</span> <span class="toc-text">tcache stashing unlink attack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-9"><span class="toc-number">4.6.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">4.6.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.6.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fastbin-reverse-into-tcache"><span class="toc-number">4.7.</span> <span class="toc-text">Fastbin reverse into tcache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-10"><span class="toc-number">4.7.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">4.7.2.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/11792/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/11792/&text=堆利用-3"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/11792/&is_video=false&description=堆利用-3"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=堆利用-3&body=Check out this article: https://ixout.github.io/posts/11792/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/11792/&title=堆利用-3"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/11792/&name=堆利用-3&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/11792/&t=堆利用-3"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>
        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ixout
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
