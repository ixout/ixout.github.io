<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="exit函数初识">
<meta property="og:type" content="article">
<meta property="og:title" content="exit函数利用">
<meta property="og:url" content="https://ixout.github.io/posts/11890/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="exit函数初识">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2023-04-05_165633.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2023-04-05_170143.png">
<meta property="article:published_time" content="2023-04-05T03:00:01.000Z">
<meta property="article:modified_time" content="2024-11-20T14:11:46.265Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="exit">
<meta property="article:tag" content="pwn技巧">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2023-04-05_165633.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
        
      
    
    <!-- title -->
    <title>exit函数利用</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/posts/23411/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/11792/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/11890/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/11890/&text=exit函数利用"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/11890/&is_video=false&description=exit函数利用"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=exit函数利用&body=Check out this article: https://ixout.github.io/posts/11890/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/11890/&name=exit函数利用&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/11890/&t=exit函数利用"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%812-27"><span class="toc-number">1.</span> <span class="toc-text">源码2.27</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%831-%E8%83%BD%E5%90%A6%E5%8A%AB%E6%8C%81-exit-funcs%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">思考1:能否劫持__exit_funcs数组?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exit-funcs%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">__exit_funcs如何添加析构函数()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E5%86%8C%E2%80%94-libc-start-main"><span class="toc-number">1.3.</span> <span class="toc-text">析构函数的注册—__libc_start_main()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E7%9A%84fini"><span class="toc-number">1.3.1.</span> <span class="toc-text">ELF的fini()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E7%9A%84init"><span class="toc-number">1.3.2.</span> <span class="toc-text">ELF的init()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ld%E7%9A%84rtdl-fini"><span class="toc-number">1.3.3.</span> <span class="toc-text">ld的rtdl_fini()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rtld-global%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">rtld_global结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dl-fini-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">_dl_fini()源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%832-rtdl-fini-%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8F%AF%E5%88%A9%E7%94%A8%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">思考2:rtdl_fini()带来的可利用点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1%E5%8A%AB%E6%8C%81rtld-global%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">0x1劫持rtld_global中的函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2%E5%8A%AB%E6%8C%81l-info%E4%BC%AA%E9%80%A0fini-array%E8%8A%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">0x2劫持l_info伪造fini_array节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3fini-array%E4%B8%8EROP-SROP"><span class="toc-number">1.5.3.</span> <span class="toc-text">0x3fini_array与ROP(SROP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x4%E5%8A%AB%E6%8C%81fini"><span class="toc-number">1.5.4.</span> <span class="toc-text">0x4劫持fini</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x5exit-%E4%B8%8EFILE"><span class="toc-number">1.5.5.</span> <span class="toc-text">0x5exit()与FILE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2018hctf-the-end"><span class="toc-number">2.1.</span> <span class="toc-text">2018hctf-the_end</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        exit函数利用
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ixout</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-04-05T03:00:01.000Z" class="dt-published" itemprop="datePublished">2023-04-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/pwn/">pwn</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/exit/" rel="tag">exit</a>, <a class="p-category" href="/tags/pwn%E6%8A%80%E5%B7%A7/" rel="tag">pwn技巧</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="源码2-27"><a href="#源码2-27" class="headerlink" title="源码2.27"></a>源码2.27</h1><p>先看两个exit.h中的重要结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* `flavour&#x27; should be of type of the `enum&#x27; above but since we need</span></span><br><span class="line"><span class="comment">       this element in an atomic operation we have to use `long int&#x27;.  */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> flavor;</span><br><span class="line">    <span class="comment">/*函数类型, 可以是&#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;</span></span><br><span class="line"><span class="comment">       - ef_free表示此位置空闲</span></span><br><span class="line"><span class="comment">       - ef_us表示此位置被使用中, 但是函数类型不知道</span></span><br><span class="line"><span class="comment">       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异*/</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>         //一个联合体<span class="title">func</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="type">void</span> (*at) (<span class="type">void</span>);   <span class="comment">//ef_at类型 没有参数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">	  &#123;</span></span><br><span class="line">	    <span class="type">void</span> (*fn) (<span class="type">int</span> status, <span class="type">void</span> *arg);   <span class="comment">//ef_on类型</span></span><br><span class="line">	    <span class="type">void</span> *arg;</span><br><span class="line">	  &#125; on;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span>    </span></span><br><span class="line"><span class="class">	  &#123;</span></span><br><span class="line">	    <span class="type">void</span> (*fn) (<span class="type">void</span> *arg, <span class="type">int</span> status); <span class="comment">//ef_cxa类型</span></span><br><span class="line">	    <span class="type">void</span> *arg;</span><br><span class="line">	    <span class="type">void</span> *dso_handle;</span><br><span class="line">	  &#125; cxa;</span><br><span class="line">      &#125; func;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">next</span>;</span>  <span class="comment">//下一个exit_function_list,单链表</span></span><br><span class="line">    <span class="type">size_t</span> idx;   <span class="comment">//记录有多少个函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> <span class="title">fns</span>[32];</span>  <span class="comment">//exit_function数组,析构函数数组</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先是exit的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure>
<p>libc经典的套娃函数,可以看出exit的主体是__run_exit_handlers</p>
<p>run_exit_handlers()的主要工作就是<strong>调用exit_funcs中保存的各种函数指针</strong></p>
<p>看其工作流程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用atexit与on_exit注册的函数，顺序为注册的逆序</span></span><br><span class="line"><span class="type">void</span> attribute_hidden __run_exit_handlers(<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp, <span class="type">bool</span> run_list_atexit)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//首先释放线程局部储存, 即TLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line"><span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">__call_tls_dtors();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历exit_fundtion_list链表，链表种每个节点里又有一个函数指针数组，根据里面的函数类型进行调用</span></span><br><span class="line"><span class="keyword">while</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp; <span class="comment">//cur指向当前exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cur-&gt;idx表示cur-&gt;fns中有多少个函数，从后往前遍历</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>) <span class="comment">//遍历exit_function_list节点中 析构函数数组fns[32]中的函数指针</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx]; <span class="comment">//f指向对应析构函数的描述符</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor) <span class="comment">//选择析构函数类型</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//三种函数指针</span></span><br><span class="line">    <span class="type">void</span> (*atfct)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> (*onfct)(<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">    <span class="type">void</span> (*cxafct)(<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这两种类型不调用</span></span><br><span class="line">  <span class="keyword">case</span> ef_free:</span><br><span class="line">  <span class="keyword">case</span> ef_us:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//on类型的参数为注册时设定的参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_on:</span><br><span class="line">    onfct = f-&gt;func.on.fn; <span class="comment">//设置函数指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    onfct(status, f-&gt;func.on.arg); <span class="comment">//调用这个函数指针</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//at没有参数</span></span><br><span class="line">  <span class="keyword">case</span> ef_at:</span><br><span class="line">    atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    atfct();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//cxa类型则先为设定时的参数，再为状态码</span></span><br><span class="line">  <span class="keyword">case</span> ef_cxa:</span><br><span class="line">    cxafct = f-&gt;func.cxa.fn;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">    PTR_DEMANGLE(cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cxafct(f-&gt;func.cxa.arg, status); </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*listp = cur-&gt;next; <span class="comment">//listp指向下一个exit_function_list节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个链表节点为libc .data段中的initial，不需要释放</span></span><br><span class="line"><span class="comment">//除此以外的节点都是malloc申请得到的, 所以需要释放</span></span><br><span class="line"><span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="built_in">free</span>(cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">RUN_HOOK(__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">_exit(status); <span class="comment">//真正的exit系统调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思考1-能否劫持-exit-funcs数组"><a href="#思考1-能否劫持-exit-funcs数组" class="headerlink" title="思考1:能否劫持__exit_funcs数组?"></a>思考1:能否劫持__exit_funcs数组?</h2><p>在exit调用<strong>run_exit_handlers()时下断点, 找到</strong>exit_funcs指针</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2023-04-05_165633.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2023-04-05_170143.png" alt=""></p>
<p>可以看到其中最重要的fns[0]被加密成乱码了,要想利用的话还要获得存储在fs:0x30的密钥,难度高,几乎难以利用</p>
<h2 id="exit-funcs如何添加析构函数"><a href="#exit-funcs如何添加析构函数" class="headerlink" title="__exit_funcs如何添加析构函数()"></a>__exit_funcs如何添加析构函数()</h2><p>既然难以攻击<strong>exit_funcs, 那么尝试从</strong>exit_funcs中的函数入手</p>
<p>我们首先要弄明白, __exit_funcs中的函数是怎么添加的</p>
<p>libc提供了一个接口: atexit()用来注册exit()时调用的析构函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DSO由GCC定义，用来识别模块的*/</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> *__dso_handle __attribute__((__weak__));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册一个exit时调用的析构函数*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))func, <span class="literal">NULL</span>, &amp;__dso_handle == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : __dso_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cxa_atexit()是对internal_atexit()的封装</p>
<p>注意: __exit_funcs就是exit()时用的那个指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个exit/共享库被卸载时调用的函数，只会被C++编译器生产的代码调用，C会通过atexit调用</span></span><br><span class="line"><span class="type">int</span> __cxa_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __internal_atexit(func, arg, d, &amp;__exit_funcs);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def(__cxa_atexit)</span><br></pre></td></tr></table></figure>
<p><strong>internel_atexit()通过</strong>new_exitfn()找到一个在__exit_funcs链表上注册析构函数的位置, 然后进行写入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  参数:</span></span><br><span class="line"><span class="comment">    - func  析构函数指针</span></span><br><span class="line"><span class="comment">    - arg   参数指针</span></span><br><span class="line"><span class="comment">    - d     DSO</span></span><br><span class="line"><span class="comment">    - listp 析构函数数组链表指针</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> attribute_hidden __internal_atexit(<span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg, <span class="type">void</span> *d, <span class="keyword">struct</span> exit_function_list **listp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">new</span> =</span> __new_exitfn(listp); <span class="comment">//先在__exit_funcs链表上添加一个描述析构函数的结构体</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_MANGLE</span></span><br><span class="line">  PTR_MANGLE(func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//然后设置分配到的这个结构体</span></span><br><span class="line">  new-&gt;func.cxa.fn = (<span class="type">void</span> (*)(<span class="type">void</span> *, <span class="type">int</span>))func; <span class="comment">//函数指针</span></span><br><span class="line">  new-&gt;func.cxa.arg = arg;                        <span class="comment">//参数</span></span><br><span class="line">  new-&gt;func.cxa.dso_handle = d;</span><br><span class="line">  atomic_write_barrier();</span><br><span class="line">  new-&gt;flavor = ef_cxa;                         <span class="comment">//类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>__new_exitfn()的逻辑大致为</p>
<ul>
<li>先尝试在__exit_funcs中找到一个exit_function类型的ef_free的位置, ef_free代表着此位置空闲</li>
<li>如果没找到, 就新建一个exit_function节点, 使用头插法插入__exit_funcs链表, 使用新节点的第一个位置作为分配到的exit_function结构体</li>
<li>设置找到的exit_function的类型为ef_us, 表示正在使用中, 并返回</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从listp上返回一个新的exit_function结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *__<span class="title">new_exitfn</span>(<span class="keyword">struct</span> <span class="title">exit_function_list</span> **<span class="title">listp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">l</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">r</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock(lock); <span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//寻找一个析构函数类型为ef_free的位置</span></span><br><span class="line">  <span class="keyword">for</span> (l = *listp; l != <span class="literal">NULL</span>; p = l, l = l-&gt;next) <span class="comment">//遍历链表，l指向当前节点, p指向l的前一个节点</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = l-&gt;idx; i &gt; <span class="number">0</span>; --i)           <span class="comment">//搜索l中的函数指针数组fns[32]</span></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;fns[i - <span class="number">1</span>].flavor != ef_free) <span class="comment">//有一个不是ef_free的就停止</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="comment">//在l中找到了, 停止链表遍历</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只有全部都是ef_free才能走到这里 */</span></span><br><span class="line">    l-&gt;idx = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span> || i == <span class="keyword">sizeof</span>(l-&gt;fns) / <span class="keyword">sizeof</span>(l-&gt;fns[<span class="number">0</span>])) <span class="comment">//没有找到空闲位置</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    l==null 说明整个__exit_funcs中都没有ef_free</span></span><br><span class="line"><span class="comment">    i == sizeof(l-&gt;fns) / sizeof(l-&gt;fns[0]) 说明对于l节点, fns已经全部遍历了, 都没找到ef_free</span></span><br><span class="line"><span class="comment">    此时就需要插入一个新的exit_function_list节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(l != <span class="literal">NULL</span>);</span><br><span class="line">      p = (<span class="keyword">struct</span> exit_function_list *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> exit_function_list)); <span class="comment">//申请一个结构体, p指向新节点</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配失败</span></span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;next = *listp; <span class="comment">//头插法, 再__exit_funcs中插入一个节点</span></span><br><span class="line">        *listp = p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  <span class="comment">//分配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">      r = &amp;p-&gt;fns[<span class="number">0</span>]; <span class="comment">//r指向新节点的第一个析构函数描述结构体</span></span><br><span class="line">      p-&gt;idx = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">//找到空闲位置了, l节点中第i个为ef_free</span></span><br><span class="line">  &#123;</span><br><span class="line">    r = &amp;l-&gt;fns[i];</span><br><span class="line">    l-&gt;idx = i + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 此时这个函数位置的类型从空闲(ef_free)变为使用中(ef_us), 等待写入函数指针 */</span></span><br><span class="line">  <span class="keyword">if</span> (r != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    r-&gt;flavor = ef_us;</span><br><span class="line">    ++__new_exitfn_called;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock(lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="析构函数的注册—-libc-start-main"><a href="#析构函数的注册—-libc-start-main" class="headerlink" title="析构函数的注册—__libc_start_main()"></a>析构函数的注册—__libc_start_main()</h2><p><strong>__libc_start_main()</strong>函数初窥</p>
<ul>
<li>首先是其参数列表也就是_start()传递的参数, 我们中重点注意下面三个<ul>
<li>init: ELF文件 也就是main()的构造函数</li>
<li>fini: ELF文件 也就是main()的析构函数</li>
<li>rtld_fini: 动态链接器的析构函数</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(</span><br><span class="line">                <span class="type">int</span> (*main)(<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> **MAIN_AUXVEC_DECL), <span class="comment">//参数: main函数指针</span></span><br><span class="line">                <span class="type">int</span> argc, <span class="type">char</span> **argv,                              <span class="comment">//参数: argc argv</span></span><br><span class="line">                ElfW(<span class="type">auxv_t</span>) * auxvec,</span><br><span class="line">                __typeof(main) init,     <span class="comment">//参数: init ELF的构造函数</span></span><br><span class="line">                <span class="type">void</span> (*fini)(<span class="type">void</span>),      <span class="comment">//参数: fini ELF的析构函数</span></span><br><span class="line">                <span class="type">void</span> (*rtld_fini)(<span class="type">void</span>), <span class="comment">//参数: rtld_fini ld的析构函数</span></span><br><span class="line">                <span class="type">void</span> *stack_end         <span class="comment">//参数: 栈顶</span></span><br><span class="line">        )</span><br><span class="line">&#123;</span><br><span class="line">    ...函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入函数体, __libc_start_mian()主要做了以下几件事</p>
<ul>
<li>为libc保存一些关于main的参数, 比如__environ…</li>
<li>通过atexit()注册fini 与 rtld_fini 这两个参数</li>
<li>调用init为main()进行构造操作</li>
<li>然后调用main()函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __libc_start_main(...)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 保存main的返回地址 */</span></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取环境变量指针, 并保存到libc的.data中</span></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 保存下栈顶 */</span></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 初始化TLS */</span></span><br><span class="line">  __pthread_initialize_minimal();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置stack guard */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard(_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 设置pointer gurad */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard(_dl_random, stack_chk_guard);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册动态链接器(ld.so.2)的析构函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely(rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 进行一些简单的libc初始化工作: 在libc中保存argc argv env三个参数 */</span></span><br><span class="line">  __libc_init_first(argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 注册ELF的fini函数  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit((<span class="type">void</span> (*)(<span class="type">void</span> *))fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果ELF有构造函数的话, 那么先调用init() */</span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init)(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 调用main()  */</span></span><br><span class="line">  result = main(argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果main()返回后, __libc_start_main()回帮他调用exit()函数 */</span></span><br><span class="line">  <span class="built_in">exit</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们知道libc_start_mian()会在exit_funcs中放入下面两个函数</p>
<p><strong>ELF的fini函数</strong>和<strong>ld的rtld_fini函数</strong></p>
<p>然后会调用一个构造函数:</p>
<p><strong>init()</strong></p>
<h3 id="ELF的fini"><a href="#ELF的fini" class="headerlink" title="ELF的fini()"></a>ELF的fini()</h3><p>被编译在elf的text段中, 由_start()传递地址给__libc_start_main()</p>
<p>发现其是一个空函数,因为其只有在静态编译下才会起作用,故而动态编译该函数为空</p>
<p>静态编译时:该函数会逐一取出fini_array数组中的函数指针执行，该函数指针数组位于bss段上</p>
<h3 id="ELF的init"><a href="#ELF的init" class="headerlink" title="ELF的init()"></a><strong>ELF的init()</strong></h3><p>让我们思考一个问题: 如果只有fini与init的话, ELF只能有一个构造/ 析构函数</p>
<p>当具有多个构造析构函数时改怎么办呢?</p>
<p>ELF的解决方法是, 把所有的构造函数的指针放在一个段: .init_array中, 所有的析构函数的指针放在一个段 .fini_array中</p>
<p><strong>init()就负责遍历.init_array, 并调用其中的构造函数, 从而完成多个构造函数的调用</strong></p>
<h3 id="ld的rtdl-fini"><a href="#ld的rtdl-fini" class="headerlink" title="ld的rtdl_fini()"></a>ld的rtdl_fini()</h3><p>我们说完了.init_array, 那么对于.fini_array呢?</p>
<p>很明显不是ELF的fini()负责 , 因为他就是一个空函数, 那么就只能<u>由rtdl_fini来负责</u></p>
<p><strong><em>rtdl_fini实际指向_dl_fini()函数</em></strong>, 源码在dl-fini.c文件中, 会被编译到ld.so.2中</p>
<p>我们把进程空间中的一个单独文件, 称之为模块</p>
<p>ld.so.2会通过dl_open()把所需文件到进程空间中, 他会把所有映射的文件都记录在结构体_rtld_global中</p>
<p>当一个进程终止, ld.so.2自然需要卸载所映射的模块, 这需要调用每一个非共享模块的fini_arrary段中的析构函数</p>
<p><strong>一言以蔽之: _dl_fini()的功能就是调用进程空间中所有模块的析构函数</strong></p>
<h3 id="rtld-global结构体"><a href="#rtld-global结构体" class="headerlink" title="rtld_global结构体"></a>rtld_global结构体</h3><p>接着来看_rtld_global结构体, 这个结构体很复杂, 我们只看与本文相关的</p>
<p>_rtld_global一般通过宏GL来引用, 这个结构体定义在ld.so.2的data段中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span> _<span class="title">rtld_global</span> __<span class="title">rtld_global_attribute__</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>再看其结构体struct rtld_global的定义<ul>
<li>一些缩写的含义:<ul>
<li>ns代表着NameSpace</li>
<li>nns代表着Num of NameSpace</li>
</ul>
</li>
<li>struct rtld_global先以命名空间为单位建立了一个数组 _dl_ns[DL_NNS]</li>
<li>在每个命名空间内部加载的模块以双向链表组织, 通过_ns_loaded索引</li>
<li>同时每个命名空间内部又有一个符号表_ns_unique_sym_table, 记录着所有模块导出的符号集合</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_namespaces</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="comment">//每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *_<span class="title">ns_loaded</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* _ns_loaded中有多少模块 */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 映射模块的搜索表 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> *_<span class="title">ns_main_searchlist</span>;</span></span><br><span class="line">        <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">        <span class="type">size_t</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 这个命名空间中的符号表, 单个命名空间中的符号不允许重复 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym_table</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            __rtld_lock_define_recursive(, lock) <span class="class"><span class="keyword">struct</span> <span class="title">unique_sym</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="type">uint32_t</span> hashval;           <span class="comment">//符号hash值</span></span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *name;           <span class="comment">//名称</span></span><br><span class="line">                <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> * sym;      <span class="comment">//符号</span></span><br><span class="line">                <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span> <span class="comment">//所属模块</span></span><br><span class="line">            &#125; * entries;                   <span class="comment">//entries可以理解为struct unique_sym数组的指针, 通过entries[idx]就可找到第idx个符号</span></span><br><span class="line">            <span class="type">size_t</span> size;                   <span class="comment">//有多少个元素</span></span><br><span class="line">            <span class="type">size_t</span> n_elements;</span><br><span class="line">            <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *); <span class="comment">//析构函数</span></span><br><span class="line">        &#125; _ns_unique_sym_table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录命名空间变化的, debug用 */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">r_debug</span> _<span class="title">ns_debug</span>;</span></span><br><span class="line">    &#125; _dl_ns[DL_NNS]; <span class="comment">//一个命名空间一个link_namespace结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* _dl_nns表示使用了多少个命名空间: Dynamic Link Num of NameSpace */</span></span><br><span class="line">    <span class="type">size_t</span> _dl_nns;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们分析下struct link_map, 来看看ld是怎么描述每一个模块的</p>
<ul>
<li>ELF文件都是通过节的组织的, ld自然也延续了这样的思路,</li>
<li>l_info中的指针都指向ELF中Dyn节中的描述符, Dyn中节描述符类型是ElfW(Dyn)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElfW(Addr) l_addr;                <span class="comment">/* 模块在内存中的的基地址 */</span></span><br><span class="line">   <span class="type">char</span> *l_name;                     <span class="comment">/* 模块的文件名  */</span></span><br><span class="line">   ElfW(Dyn) * l_ld;                 <span class="comment">/* 指向ELF中的Dynamic节 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* 双向链表指针 */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 这个模块所属NameSapce的idx  */</span></span><br><span class="line">   Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* </span></span><br><span class="line"><span class="comment">      l_info是ELF节描述符组成的的数组</span></span><br><span class="line"><span class="comment">      ELF中一个节, 使用一个ElfW(Dyn)描述</span></span><br><span class="line"><span class="comment">      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line"></span><br><span class="line">   <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> * l_phdr; <span class="comment">/* ELF的头表  */</span></span><br><span class="line">   ElfW(Addr) l_entry;        <span class="comment">/* ELF入口点  */</span></span><br><span class="line">   ElfW(Half) l_phnum;        <span class="comment">/* 头表中有多少节  */</span></span><br><span class="line">   ElfW(Half) l_ldnum;        <span class="comment">/* dynamic节中有多少描述符  */</span></span><br><span class="line"></span><br><span class="line">    ...;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ElfW(Dyn)是一个节描述符类型(也就是一个宏), 宏展开结果为<strong>Elf64_Dyn</strong>, 这个类型被定义在elf.h文件中, 与ELF中的节描述对应</p>
<p>这个结构体在elf的学习中很重要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Elf64_Sxword    d_tag;            <span class="comment">/* 便签, 用于标注描述符类型,每一个描述符类型都对应一个类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>        </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Xword d_val;        <span class="comment">/* 内容可以是一个值 */</span></span><br><span class="line">  Elf64_Addr d_ptr;            <span class="comment">/* 也可以是一个指针 */</span></span><br><span class="line">&#125; d_un;</span><br><span class="line">&#125; Elf64_Dyn;</span><br></pre></td></tr></table></figure>
<p>至此rtld_global的结构就清楚了, 他自顶向下按照: <strong>命名空间-&gt;模块-&gt;节</strong> 的形式<u>描述所有的模块,</u> 通过_ns_unique_sym_table描述命名空间中所有的可见符号</p>
<h2 id="dl-fini-源码分析"><a href="#dl-fini-源码分析" class="headerlink" title="_dl_fini()源码分析"></a>_dl_fini()源码分析</h2><p>理解了模块是如何组织的之后, _dl_fini的任务就显而易见了:</p>
<ul>
<li>遍历rtld_global中所有的命名空间</li>
<li>遍历命名空间中所有的模块</li>
<li><strong>找到这个模块的fini_array段, 并调用其中的所有函数指针</strong></li>
<li><strong>找到这个模块的fini段, 调用fini()</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> internal_function _dl_fini(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">    <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line">again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns) <span class="comment">//遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]</span></span><br><span class="line">    &#123;</span><br><span class="line">        __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">        <span class="comment">/* 如果这个NameSapce没加载模块, 或者不需要释放, 就不需要做任何事, 就直接调用rtld中的函数指针释放锁 */</span></span><br><span class="line">        <span class="keyword">if</span> (nloaded == <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit)</span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则遍历模块</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 把这个命名空间中的所有模块指针, 都复制到maps数组中  */</span></span><br><span class="line">            <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">            assert(nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next) <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (l == l-&gt;l_real)                                                <span class="comment">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    assert(i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">                    maps[i] = l;</span><br><span class="line">                    l-&gt;l_idx = i;</span><br><span class="line">                    ++i;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Bump l_direct_opencount of all objects so that they are not dlclose()ed from underneath us.  */</span></span><br><span class="line">                    ++l-&gt;l_direct_opencount;</span><br><span class="line">                &#125;</span><br><span class="line">            ...;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;    <span class="comment">//多少个模块</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 对maps进行排序, 确定析构顺序 */</span></span><br><span class="line">            _dl_sort_fini(maps, nmaps, <span class="literal">NULL</span>, ns);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            __rtld_lock_unlock_recursive(GL(dl_load_lock));    </span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 从前往后, 析构maps中的每一个模块 */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (l-&gt;l_init_called)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">                    l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 是否包含fini_array节, 或者fini节 */</span></span><br><span class="line">                    <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span> || l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/* debug时打印下相关信息 */</span></span><br><span class="line">                        <span class="keyword">if</span> (__builtin_expect(GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">                            _dl_debug_printf(<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,DSO_FILENAME(l-&gt;l_name),ns);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 如果有fini_array节的话 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                l-&gt;l_addr: 模块l的加载基地址</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移</span></span><br><span class="line"><span class="comment">                                array: 为模块l的fini_array节的内存地址</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *)(l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">/* </span></span><br><span class="line"><span class="comment">                                ELF中 fini_arraysz节用来记录fini_array节的大小</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符</span></span><br><span class="line"><span class="comment">                                l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位</span></span><br><span class="line"><span class="comment">                                i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / <span class="keyword">sizeof</span>(ElfW(Addr)));</span><br><span class="line">                            <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)    <span class="comment">//从后往前, 调用fini_array中的每一个析构函数</span></span><br><span class="line">                                ((<span class="type">fini_t</span>)<span class="built_in">array</span>[i])();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/* 调用fini段中的函数 */</span></span><br><span class="line">                        <span class="keyword">if</span> (l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>)</span><br><span class="line">                            DL_CALL_DT_FINI(l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ...;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Correct the previous increment.  */</span></span><br><span class="line">                --l-&gt;l_direct_opencount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思考2-rtdl-fini-带来的可利用点"><a href="#思考2-rtdl-fini-带来的可利用点" class="headerlink" title="思考2:rtdl_fini()带来的可利用点"></a>思考2:rtdl_fini()带来的可利用点</h2><p><strong>rtdl_fini()十分依赖与rtld_global这一数据结构, 并且rtld_global中的数据并没有被加密</strong>, 这就带来了两个攻击面</p>
<ul>
<li><strong>劫持rtld_global中的锁相关函数指针</strong></li>
<li><strong>修改rtld_global中的l_info, 伪造fini_array/ fini的节描述符, 从而劫持fini_array/ fini到任意位置, 执行任意函数</strong></li>
</ul>
<h3 id="0x1劫持rtld-global中的函数指针"><a href="#0x1劫持rtld-global中的函数指针" class="headerlink" title="0x1劫持rtld_global中的函数指针"></a>0x1劫持rtld_global中的函数指针</h3><p>ld相关函数在使用rtld_global时都需要先上锁, 以避免多进程下的条件竞争问题</p>
<p>相关函数包括但不限于:</p>
<ul>
<li>_dl_open()</li>
<li>_dl_fini()</li>
<li>….</li>
</ul>
<p>上锁操作是通过宏进行的, 宏定义:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> __rtld_lock_lock_recursive(NAME) GL(dl_rtld_lock_recursive) (&amp;(NAME).mutex)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br></pre></td></tr></table></figure>
<p>查看宏<code>GL</code>的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> IS_IN (rtld)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_local._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> GL(name) _rtld_global._##name</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>宏展开:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    __rtld_lock_lock_recursive(GL(dl_load_lock)); <span class="comment">//对rtld_global上锁</span></span><br><span class="line">=&gt;    GL(dl_rtld_lock_recursive) (&amp; GL(dl_load_lock).mutex)</span><br><span class="line">=&gt;    _rtld_global.dl_rtld_lock_recursive(&amp;_rtld_global.dl_load_lock.mutex)</span><br></pre></td></tr></table></figure>
<p>可以看到实际调用的是dl_rtld_lock_recursive函数指针</p>
<p>释放锁的操作也是类似的, 调用的是_dl_rtld_unlock_recursive函数指针, 这两个函数指针再rtld_global中定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtld_global</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...;</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_lock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    <span class="type">void</span> (*_dl_rtld_unlock_recursive)(<span class="type">void</span> *);</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ld作为mmap的文件, 与libc地址固定</strong></p>
<p><strong>也就是说, 当有了任意写+libc地址后, 我们可以通过覆盖_rtld_global中的lock/ unlock函数指针来getshell</strong></p>
<h3 id="0x2劫持l-info伪造fini-array节"><a href="#0x2劫持l-info伪造fini-array节" class="headerlink" title="0x2劫持l_info伪造fini_array节"></a>0x2劫持l_info伪造fini_array节</h3><p>我们的目标是伪造rtld_global中关于fini_array节与fini_arraysize节的描述</p>
<p>将fini_array节迁移到一个可控位置, 比如堆区, 然后在这个可控位置中写入函数指针, 那么在exit()时就会依次调用其中的函数指针</p>
<p><strong>l_info中关于fini_array节的描述符下标为26, 关于fini_arraysz节的下标是28,l_info中的指针正好指向的就是Dynamic段中相关段描述符</strong></p>
<p>此时我们就可以回答ELF中fini_array中的析构函数是怎么被调用的这个问题了:</p>
<p><strong>exit()调用__exit_funcs链表中的_rtdl_fini()函数, 由_rtdl_fini()函数寻找到ELF的fini_array节并调用</strong></p>
<p>假设我们修改rtld_global中的l_info[0x1a]为addrA, 修改l_info[0x1c]为addrB</p>
<p>那么首先在addrA addrB中伪造好描述符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0x1a, addrC)</span><br><span class="line">addrB: flat(0x1b, N)</span><br></pre></td></tr></table></figure>
<p><strong>然后在addrC中写入函数指针就可以在exit时执行了</strong></p>
<h3 id="0x3fini-array与ROP-SROP"><a href="#0x3fini-array与ROP-SROP" class="headerlink" title="0x3fini_array与ROP(SROP)"></a>0x3fini_array与ROP(SROP)</h3><p>当我们可以劫持fini_array之后, 我们就具备了连续调用多个函数的能力, 那么有无可能像ROP一样, 让多个函数进行组合, 完成复杂的工作?</p>
<p>多个fini_array函数调用之间, 寄存器环境十分稳定, 只有: rdx r13会被破坏, 这是一个好消息</p>
<p>考察执行call时的栈环境, 我们发现rdi总是指向一个可读可写区域, 可以当做我们函数的缓冲区</p>
<p>那么就已经有了大致的利用思路,</p>
<ol>
<li>让fini_array先调用gets()函数, 在rdi中读入SigreturnFrame</li>
<li>然后再调用setcontext+53, 即可进行SROP, 劫持所有寄存器</li>
<li>如果高版本libc, setcontext使用rdx作为参数, 那么在gets(rdi)后还需要一个gadget, 能通过rdi设置rdx,<br>再执行setcontext</li>
</ol>
<h3 id="0x4劫持fini"><a href="#0x4劫持fini" class="headerlink" title="0x4劫持fini"></a>0x4劫持fini</h3><p>fini段在l_info中下标为13,这个描述符中直接放的就是fini函数指针(前面有提到动态链接下这是个空函数，由_dl_fini调用), 利用手法较为简单, 但是只能执行一个函数, 通常设置为onegadget</p>
<p>例如我们可以<strong>修改rtld_global中l_info[0xd]为addrA, 然后再addrA中写入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addrA: flat(0xd, onegadget)</span><br></pre></td></tr></table></figure>
<p>就可以在exit()时触发</p>
<h3 id="0x5exit-与FILE"><a href="#0x5exit-与FILE" class="headerlink" title="0x5exit()与FILE"></a>0x5exit()与FILE</h3><p>一开始的run_exit_handlers么, 在遍历完exit_funcs链表后, 还有最后一句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (run_list_atexit) <span class="comment">//调用_atexit</span></span><br><span class="line">  RUN_HOOK(__libc_atexit, ());</span><br></pre></td></tr></table></figure>
<p>__libc_atexit其实<strong>是libc中的一个段</strong></p>
<p><strong>这个段中就是libc退出时的析构函数</strong></p>
<p><strong>其中默认只有一个函数fcloseall()</strong></p>
<p>这个函数会调用<strong>_IO_cleanup()</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fcloseall (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 关闭所有流.  */</span></span><br><span class="line"><span class="keyword">return</span> _IO_cleanup ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>_IO_cleanup()会调用两个函数</strong></p>
<ul>
<li><strong>_IO_flush_all_lockp()会通过_IO_list_all遍历所有流, 对每个流调用_IO_OVERFLOW(fp), 保证关闭前缓冲器中没有数据残留</strong></li>
<li><strong>_IO_unbuffer_all()会通过_IO_list_all遍历所有流, 对每个流调用_IO_SETBUF(fp, NULL, 0)即无缓冲模式, 来释放流的缓冲区</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_cleanup(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 刷新所有流 */</span></span><br><span class="line">  <span class="type">int</span> result = _IO_flush_all_lockp(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 关闭所有流的缓冲区 */</span></span><br><span class="line">  _IO_unbuffer_all();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">	_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_IO_unbuffer_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (_IO_FILE *) _IO_list_all; fp; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (! (fp-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">	  <span class="comment">/* Iff stream is un-orientated, it wasn&#x27;t used. */</span></span><br><span class="line">	  &amp;&amp; fp-&gt;_mode != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="type">int</span> cnt;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTRIES 2</span></span><br><span class="line">	  <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt &lt; MAXTRIES; ++cnt)</span><br><span class="line">	    <span class="keyword">if</span> (fp-&gt;_lock == <span class="literal">NULL</span> || _IO_lock_trylock (*fp-&gt;_lock) == <span class="number">0</span>)</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	      <span class="comment">/* Give the other thread time to finish up its use of the</span></span><br><span class="line"><span class="comment">		 stream.  */</span></span><br><span class="line">	      __sched_yield ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (! dealloc_buffers &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">	    &#123;</span><br><span class="line">	      fp-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line"></span><br><span class="line">	      fp-&gt;_freeres_list = freeres_list;</span><br><span class="line">	      freeres_list = fp;</span><br><span class="line">	      fp-&gt;_freeres_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  _IO_SETBUF (fp, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">	    _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">	  <span class="keyword">if</span> (cnt &lt; MAXTRIES &amp;&amp; fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">	    _IO_lock_unlock (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure that never again the wide char functions can be</span></span><br><span class="line"><span class="comment">	 used.  */</span></span><br><span class="line">      fp-&gt;_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现攻击点:</p>
<ol>
<li><p>libc2.23以前三个标准流的vtable是可写的,可以修改函数指针</p>
</li>
<li><p>之后的版本因为位于libc段中的vtable是无法写入的,故可以选择伪造vtable中的setbuf或overflow(其中overflow需要达到一些条件)函数,来达到getshell</p>
</li>
</ol>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2018hctf-the-end"><a href="#2018hctf-the-end" class="headerlink" title="2018hctf-the_end"></a>2018hctf-the_end</h2><p>这道题有两种解法，但都是利用exit函数</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BA%90%E7%A0%812-27"><span class="toc-number">1.</span> <span class="toc-text">源码2.27</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%831-%E8%83%BD%E5%90%A6%E5%8A%AB%E6%8C%81-exit-funcs%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">思考1:能否劫持__exit_funcs数组?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exit-funcs%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">__exit_funcs如何添加析构函数()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E5%86%8C%E2%80%94-libc-start-main"><span class="toc-number">1.3.</span> <span class="toc-text">析构函数的注册—__libc_start_main()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E7%9A%84fini"><span class="toc-number">1.3.1.</span> <span class="toc-text">ELF的fini()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ELF%E7%9A%84init"><span class="toc-number">1.3.2.</span> <span class="toc-text">ELF的init()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ld%E7%9A%84rtdl-fini"><span class="toc-number">1.3.3.</span> <span class="toc-text">ld的rtdl_fini()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rtld-global%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">rtld_global结构体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dl-fini-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">_dl_fini()源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%832-rtdl-fini-%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8F%AF%E5%88%A9%E7%94%A8%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">思考2:rtdl_fini()带来的可利用点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1%E5%8A%AB%E6%8C%81rtld-global%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.5.1.</span> <span class="toc-text">0x1劫持rtld_global中的函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2%E5%8A%AB%E6%8C%81l-info%E4%BC%AA%E9%80%A0fini-array%E8%8A%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">0x2劫持l_info伪造fini_array节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3fini-array%E4%B8%8EROP-SROP"><span class="toc-number">1.5.3.</span> <span class="toc-text">0x3fini_array与ROP(SROP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x4%E5%8A%AB%E6%8C%81fini"><span class="toc-number">1.5.4.</span> <span class="toc-text">0x4劫持fini</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x5exit-%E4%B8%8EFILE"><span class="toc-number">1.5.5.</span> <span class="toc-text">0x5exit()与FILE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2018hctf-the-end"><span class="toc-number">2.1.</span> <span class="toc-text">2018hctf-the_end</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/11890/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/11890/&text=exit函数利用"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/11890/&is_video=false&description=exit函数利用"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=exit函数利用&body=Check out this article: https://ixout.github.io/posts/11890/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/11890/&title=exit函数利用"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/11890/&name=exit函数利用&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/11890/&t=exit函数利用"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>
        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ixout
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
